# 异步代码

# 异步代码

异步代码是在调用时不立即完成的代码。

```
setTimeout(() => {
  console.log('do stuff');
}, 3000 ) 
```

3 秒后，超时结束，`做一些事情`被回显到屏幕上。我们可以看到，我们提供的匿名函数在时间过去后被触发。现在来看另一个更具启发性的例子：

```
doWork( () => {
  console.log('call me when done');
}) 
```

```
function doWork(cb){
   setTimeout( () => {
     cb();
   }, 3000)
} 
```

回调代码的另一个示例是事件，这里通过一个`jQuery`示例演示

```
input.on('click', () => {

}) 
```

回调和异步的要点是，将来的某个时候会调用一个或多个方法，但不知道何时。

## 问题

所以我们确定了回调可以是一个定时器，ajax 代码，甚至是一个事件，但所有这些都有什么问题？

一个词 **可读性**

想象一下执行以下代码

```
syncCode()  // emit 1
syncCode2()  // emit 2
asyncCode()  // emit 3
syncCode4()  // emit 4 
```

输出很可能是

```
1,2,4,3 
```

因为异步方法可能需要很长时间才能完成。没有办法通过查看它来知道什么时候完成。问题是如果我们关心顺序，这样我们就得到了 1,2,3,4

我们可能会使用回调，使其看起来像

```
syncCode()
syncCode()2
asyncCode(()= > {
   syncCode4()
}) 
```

到目前为止，它是可读的，但是想象一下如果我们只有异步代码，那么它可能看起来像：

```
asyncCode(() => {
   asyncCode2(() => {
     asyncCode3() => {

     }
   })
}) 
```

也被称为`回调地狱`，请暂停一下作用 :)

由于这个原因，承诺开始存在，所以我们得到了看起来像这样的代码

```
 getData()
    .then(getMoreData)
    .then(getEvenMoreData) 
```

这对于`请求/响应`模式非常有用，但对于更高级的异步场景，我敢说只有 Rxjs 符合要求。
