["```js\nlet simpleLevelPlan = `\n......................\n..#................#..\n..#..............=.#..\n..#.........o.o....#..\n..#.@......#####...#..\n..#####............#..\n......#++++++++++++#..\n......##############..\n......................`;\n```", "```js\nclass Level {\n  constructor(plan) {\n    let rows = plan.trim().split(\"\\n\").map(l => [...l]);\n    this.height = rows.length;\n    this.width = rows[0].length;\n    this.startActors = [];\n\n this.rows = rows.map((row, y) => {\n      return row.map((ch, x) => {\n        let type = levelChars[ch];\n        if (typeof type != \"string\") {\n          let pos = new Vec(x, y);\n          this.startActors.push(type.create(pos, ch));\n          type = \"empty\";\n        }\n        return type;\n      });\n    });\n  }\n}\n```", "```js\nclass State {\n  constructor(level, actors, status) {\n    this.level = level;\n    this.actors = actors;\n    this.status = status;\n  }\n static start(level) {\n    return new State(level, level.startActors, \"playing\");\n  }\n\n  get player() {\n    return this.actors.find(a => a.type == \"player\");\n  }\n}\n```", "```js\nclass Vec {\n  constructor(x, y) {\n    this.x = x; this.y = y;\n  }\n  plus(other) {\n    return new Vec(this.x + other.x, this.y + other.y);\n  }\n  times(factor) {\n    return new Vec(this.x * factor, this.y * factor);\n  }\n}\n```", "```js\nclass Player {\n  constructor(pos, speed) {\n    this.pos = pos;\n    this.speed = speed;\n  }\n\n  get type() { return \"player\"; }\n\n  static create(pos) {\n    return new Player(pos.plus(new Vec(0, -0.5)),\n                      new Vec(0, 0));\n  }\n}\n\nPlayer.prototype.size = new Vec(0.8, 1.5);\n```", "```js\nclass Lava {\n  constructor(pos, speed, reset) {\n    this.pos = pos;\n    this.speed = speed;\n    this.reset = reset;\n  }\n\n get type() { return \"lava\"; }\n\n  static create(pos, ch) {\n    if (ch == \"=\") {\n      return new Lava(pos, new Vec(2, 0));\n    } else if (ch == \"|\") {\n      return new Lava(pos, new Vec(0, 2));\n    } else if (ch == \"v\") {\n      return new Lava(pos, new Vec(0, 3), pos);\n    }\n  }\n}\n\nLava.prototype.size = new Vec(1, 1);\n```", "```js\nclass Coin {\n  constructor(pos, basePos, wobble) {\n    this.pos = pos;\n    this.basePos = basePos;\n    this.wobble = wobble;\n  }\n\n  get type() { return \"coin\"; }\n\n  static create(pos) {\n    let basePos = pos.plus(new Vec(0.2, 0.1));\n    return new Coin(basePos, basePos,\n                    Math.random() * Math.PI * 2);\n  }\n}\n\nCoin.prototype.size = new Vec(0.6, 0.6);\n```", "```js\nconst levelChars = {\n  \".\": \"empty\", \"#\": \"wall\", \"+\": \"lava\",\n  \"@\": Player, \"o\": Coin,\n  \"=\": Lava, \"|\": Lava, \"v\": Lava\n};\n```", "```js\nlet simpleLevel = new Level(simpleLevelPlan);\nconsole.log(`${simpleLevel.width} by ${simpleLevel.height}`);\n// â†’ 22 by 9\n```", "```js\nfunction elt(name, attrs, ...children) {\n  let dom = document.createElement(name);\n  for (let attr of Object.keys(attrs)) {\n    dom.setAttribute(attr, attrs[attr]);\n  }\n  for (let child of children) {\n    dom.appendChild(child);\n  }\n  return dom;\n}\n```", "```js\nclass DOMDisplay {\n  constructor(parent, level) {\n    this.dom = elt(\"div\", {class: \"game\"}, drawGrid(level));\n    this.actorLayer = null;\n    parent.appendChild(this.dom);\n  }\n\n  clear() { this.dom.remove(); }\n}\n```", "```js\nconst scale = 20;\n\nfunction drawGrid(level) {\n  return elt(\"table\", {\n    class: \"background\",\n    style: `width: ${level.width * scale}px`\n  }, ...level.rows.map(row =>\n    elt(\"tr\", {style: `height: ${scale}px`},\n        ...row.map(type => elt(\"td\", {class: type})))\n  ));\n}\n```", "```js\n.background    { background: rgb(52, 166, 251);\n                 table-layout: fixed;\n                 border-spacing: 0;              }\n.background td { padding: 0;                     }\n.lava          { background: rgb(255, 100, 100); }\n.wall          { background: white;              }\n```", "```js\nfunction drawActors(actors) {\n  return elt(\"div\", {}, ...actors.map(actor => {\n    let rect = elt(\"div\", {class: `actor ${actor.type}`});\n    rect.style.width = `${actor.size.x * scale}px`;\n    rect.style.height = `${actor.size.y * scale}px`;\n    rect.style.left = `${actor.pos.x * scale}px`;\n    rect.style.top = `${actor.pos.y * scale}px`;\n    return rect;\n  }));\n}\n```", "```js\n.actor  { position: absolute;            }\n.coin   { background: rgb(241, 229, 89); }\n.player { background: rgb(64, 64, 64);   }\n```", "```js\nDOMDisplay.prototype.syncState = function(state) {\n  if (this.actorLayer) this.actorLayer.remove();\n  this.actorLayer = drawActors(state.actors);\n  this.dom.appendChild(this.actorLayer);\n  this.dom.className = `game ${state.status}`;\n  this.scrollPlayerIntoView(state);\n};\n```", "```js\n.lost .player {\n  background: rgb(160, 64, 64);\n}\n.won .player {\n  box-shadow: -4px -7px 8px white, 4px -7px 8px white;\n}\n```", "```js\n.game {\n  overflow: hidden;\n  max-width: 600px;\n  max-height: 450px;\n  position: relative;\n}\n```", "```js\nDOMDisplay.prototype.scrollPlayerIntoView = function(state) {\n  let width = this.dom.clientWidth;\n  let height = this.dom.clientHeight;\n  let margin = width / 3;\n\n  // The viewport\n  let left = this.dom.scrollLeft, right = left + width;\n  let top = this.dom.scrollTop, bottom = top + height;\n\n  let player = state.player;\n  let center = player.pos.plus(player.size.times(0.5))\n                         .times(scale);\n if (center.x < left + margin) {\n    this.dom.scrollLeft = center.x - margin;\n  } else if (center.x > right - margin) {\n    this.dom.scrollLeft = center.x + margin - width;\n  }\n  if (center.y < top + margin) {\n    this.dom.scrollTop = center.y - margin;\n  } else if (center.y > bottom - margin) {\n    this.dom.scrollTop = center.y + margin - height;\n  }\n};\n```", "```js\n<link rel=\"stylesheet\" href=\"css/game.css\">\n\n<script>\n  let simpleLevel = new Level(simpleLevelPlan);\n  let display = new DOMDisplay(document.body, simpleLevel);\n  display.syncState(State.start(simpleLevel));\n</script>\n```", "```js\nLevel.prototype.touches = function(pos, size, type) {\n  let xStart = Math.floor(pos.x);\n  let xEnd = Math.ceil(pos.x + size.x);\n  let yStart = Math.floor(pos.y);\n  let yEnd = Math.ceil(pos.y + size.y);\n\n  for (let y = yStart; y < yEnd; y++) {\n    for (let x = xStart; x < xEnd; x++) {\n      let isOutside = x < 0 || x >= this.width ||\n                      y < 0 || y >= this.height;\n      let here = isOutside ? \"wall\" : this.rows[y][x];\n      if (here == type) return true;\n    }\n  }\n  return false;\n};\n```", "```js\nState.prototype.update = function(time, keys) {\n  let actors = this.actors\n    .map(actor => actor.update(time, this, keys));\n  let newState = new State(this.level, actors, this.status);\n\n  if (newState.status != \"playing\") return newState;\n\n  let player = newState.player;\n  if (this.level.touches(player.pos, player.size, \"lava\")) {\n    return new State(this.level, actors, \"lost\");\n  }\n\n  for (let actor of actors) {\n    if (actor != player && overlap(actor, player)) {\n      newState = actor.collide(newState);\n    }\n  }\n  return newState;\n};\n```", "```js\nfunction overlap(actor1, actor2) {\n  return actor1.pos.x + actor1.size.x > actor2.pos.x &&\n         actor1.pos.x < actor2.pos.x + actor2.size.x &&\n         actor1.pos.y + actor1.size.y > actor2.pos.y &&\n         actor1.pos.y < actor2.pos.y + actor2.size.y;\n}\n```", "```js\nLava.prototype.collide = function(state) {\n  return new State(state.level, state.actors, \"lost\");\n};\n\nCoin.prototype.collide = function(state) {\n  let filtered = state.actors.filter(a => a != this);\n  let status = state.status;\n  if (!filtered.some(a => a.type == \"coin\")) status = \"won\";\n  return new State(state.level, filtered, status);\n};\n```", "```js\nLava.prototype.update = function(time, state) {\n  let newPos = this.pos.plus(this.speed.times(time));\n  if (!state.level.touches(newPos, this.size, \"wall\")) {\n    return new Lava(newPos, this.speed, this.reset);\n  } else if (this.reset) {\n    return new Lava(this.reset, this.speed, this.reset);\n  } else {\n    return new Lava(this.pos, this.speed.times(-1));\n  }\n};\n```", "```js\nconst wobbleSpeed = 8, wobbleDist = 0.07;\n\nCoin.prototype.update = function(time) {\n  let wobble = this.wobble + time * wobbleSpeed;\n  let wobblePos = Math.sin(wobble) * wobbleDist;\n  return new Coin(this.basePos.plus(new Vec(0, wobblePos)),\n                  this.basePos, wobble);\n};\n```", "```js\nconst playerXSpeed = 7;\nconst gravity = 30;\nconst jumpSpeed = 17;\n\nPlayer.prototype.update = function(time, state, keys) {\n  let xSpeed = 0;\n  if (keys.ArrowLeft) xSpeed -= playerXSpeed;\n  if (keys.ArrowRight) xSpeed += playerXSpeed;\n  let pos = this.pos;\n  let movedX = pos.plus(new Vec(xSpeed * time, 0));\n  if (!state.level.touches(movedX, this.size, \"wall\")) {\n    pos = movedX;\n  }\n\n  let ySpeed = this.speed.y + time * gravity;\n  let movedY = pos.plus(new Vec(0, ySpeed * time));\n  if (!state.level.touches(movedY, this.size, \"wall\")) {\n    pos = movedY;\n  } else if (keys.ArrowUp && ySpeed > 0) {\n    ySpeed = -jumpSpeed;\n  } else {\n    ySpeed = 0;\n }\n  return new Player(pos, new Vec(xSpeed, ySpeed));\n};\n```", "```js\nfunction trackKeys(keys) {\n  let down = Object.create(null);\n  function track(event) {\n    if (keys.includes(event.key)) {\n      down[event.key] = event.type == \"keydown\";\n      event.preventDefault();\n    }\n  }\n  window.addEventListener(\"keydown\", track);\n  window.addEventListener(\"keyup\", track);\n  return down;\n}\n\nconst arrowKeys =\n  trackKeys([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\"]);\n```", "```js\nfunction runAnimation(frameFunc) {\n  let lastTime = null;\n  function frame(time) {\n    if (lastTime != null) {\n      let timeStep = Math.min(time - lastTime, 100) / 1000;\n      if (frameFunc(timeStep) === false) return;\n    }\n    lastTime = time;\n    requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n}\n```", "```js\nfunction runLevel(level, Display) {\n  let display = new Display(document.body, level);\n  let state = State.start(level);\n  let ending = 1;\n  return new Promise(resolve => {\n runAnimation(time => {\n      state = state.update(time, arrowKeys);\n      display.syncState(state);\n      if (state.status == \"playing\") {\n        return true;\n      } else if (ending > 0) {\n        ending -= time;\n        return true;\n      } else {\n        display.clear();\n        resolve(state.status);\n        return false;\n      }\n    });\n  });\n}\n```", "```js\nasync function runGame(plans, Display) {\n  for (let level = 0; level < plans.length;) {\n    let status = await runLevel(new Level(plans[level]),\n                                Display);\n    if (status == \"won\") level++;\n  }\n  console.log(\"You've won!\");\n}\n```", "```js\n<link rel=\"stylesheet\" href=\"css/game.css\">\n\n<body>\n  <script>\n    runGame(GAME_LEVELS, DOMDisplay);\n  </script>\n</body>\n```"]