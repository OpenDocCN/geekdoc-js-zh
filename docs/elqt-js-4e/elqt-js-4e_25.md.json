["```js\nclass Graph {\n  #nodes = [];\n\n  get size() {\n    return this.#nodes.length;\n  }\n\n  addNode() {\n    let id = this.#nodes.length;\n    this.#nodes.push(new Set());\n    return id;\n  }\n\n  addEdge(nodeA, nodeB) {\n    this.#nodes[nodeA].add(nodeB);\n    this.#nodes[nodeB].add(nodeA);\n  }\n\n  neighbors(node) {\n    return this.#nodes[node];\n  }\n}\n```", "```js\nfunction randomLayout(graph) {\n  let layout = [];\n  for (let i = 0; i < graph.size; i++) {\n    layout.push(new Vec(Math.random() * 1000,\n                        Math.random() * 1000));\n  }\n  return layout;\n}\n```", "```js\nfunction gridGraph(size) {\n  let grid = new Graph();\n  for (let y = 0; y < size; y++) {\n    for (let x = 0; x < size; x++) {\n      let id = grid.addNode();\n      if (x > 0) grid.addEdge(id, id - 1);\n      if (y > 0) grid.addEdge(id, id - size);\n    }\n  }\n  return grid;\n}\n```", "```js\nconst springLength = 20;\nconst springStrength = 0.1;\nconst repulsionStrength = 1500;\n\nfunction forceSize(distance, connected) {\n  let repulse = -repulsionStrength / (distance * distance);\n  let spring = 0;\n  if (connected) {\n    spring = (distance - springLength) * springStrength;\n  }\n  return spring + repulse;\n}\n```", "```js\nfunction forceDirected_simple(layout, graph) {\n  for (let a = 0; a < graph.size; a++) {\n    for (let b = 0; b < graph.size; b++) {\n      if (a == b) continue;\n      let apart = layout[b].minus(layout[a]);\n      let distance = Math.max(1, apart.length);\n let connected = graph.neighbors(a).has(b);\n      let size = forceSize(distance, connected);\n      let force = apart.times(1 / distance).times(size);\n      layout[a] = layout[a].plus(force);\n    }\n  }\n}\n```", "```js\nfunction pause() {\n  return new Promise(done => setTimeout(done, 0))\n}\n\nasync function runLayout(implementation, graph) {\n  let time = 0, iterations = 0;\n  let layout = randomLayout(graph);\n  while (time < 3000) {\n    let start = Date.now();\n    for (let i = 0; i < 100; i++) {\n      implementation(layout, graph);\n      iterations++;\n    }\n    time += Date.now() - start;\n    drawGraph(graph, layout);\n    await pause();\n  }\n  let perSecond = Math.round(iterations / (time / 1000));\n  console.log(`${perSecond} iterations per second`);\n}\n```", "```js\nrunLayout(forceDirected_simple, gridGraph(12));\n```", "```js\nfunction forceDirected_noRepeat(layout, graph) {\n  for (let a = 0; a < graph.size; a++) {\n    for (let b = a + 1; b < graph.size; b++) {\n      let apart = layout[b].minus(layout[a]);\n      let distance = Math.max(1, apart.length);\n      let connected = graph.neighbors(a).has(b);\n      let size = forceSize(distance, connected);\n      let force = apart.times(1 / distance).times(size);\n      layout[a] = layout[a].plus(force);\n      layout[b] = layout[b].minus(force);\n    }\n  }\n}\n```", "```js\nconst skipDistance = 175;\n\nfunction forceDirected_skip(layout, graph) {\n  for (let a = 0; a < graph.size; a++) {\n    for (let b = a + 1; b < graph.size; b++) {\n      let apart = layout[b].minus(layout[a]);\n      let distance = Math.max(1, apart.length);\n      let connected = graph.neighbors(a).has(b);\n      if (distance > skipDistance && !connected) continue;\n      let size = forceSize(distance, connected);\n      let force = apart.times(1 / distance).times(size);\n      layout[a] = layout[a].plus(force);\n      layout[b] = layout[b].minus(force);\n    }\n  }\n}\n```", "```js\nActivity             Self Time        Total Time\nforceDirected_skip   74.0ms  82.4%    769.5ms  94.1%\nMinor GC             48.2ms   5.9%     48.2ms   5.9%\nVec                  44.8ms   5.5%     46.9ms   5.7%\nplus                  4.6ms   0.6%      5.5ms   0.7%\nOptimize Code         0.1ms   0.0%      0.1ms   0.0%\n```", "```js\nfunction forceDirected_noVector(layout, graph) {\n  for (let a = 0; a < graph.size; a++) {\n    let posA = layout[a];\n    for (let b = a + 1; b < graph.size; b++) {\n      let posB = layout[b];\n      let apartX = posB.x - posA.x\n      let apartY = posB.y - posA.y;\n      let distance = Math.sqrt(apartX * apartX +\n                               apartY * apartY);\n      let connected = graph.neighbors(a).has(b);\n      if (distance > skipDistance && !connected) continue;\n      let size = forceSize(distance, connected);\n      let forceX = (apartX / distance) * size;\n      let forceY = (apartY / distance) * size;\n      posA.x += forceX;\n      posA.y += forceY;\n      posB.x -= forceX;\n      posB.y -= forceY;\n }\n  }\n}\n```", "```js\npos.plus(normalized.times(forceSize))\n```", "```js\nfunction randomLayout(graph) {\n  let layout = [];\n  for (let i = 0; i < graph.size; i++) {\n    let vector = new Vec(Math.random() * 1000,\n                         Math.random() * 1000);\n    vector[`p${Math.floor(Math.random() * 999)}`] = true;\n    layout.push(vector);\n  }\n  return layout;\n}\n\nrunLayout(forceDirected_noVector, gridGraph(12));\n```"]