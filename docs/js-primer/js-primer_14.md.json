["```\n// 関数宣言\nfunction 関数名(仮引数 1, 仮引数 2) {\n    // 関数が呼び出されたときの処理\n    // ...\n    return 関数の返り値;\n}\n// 関数呼び出し\nconst 関数の結果 = 関数名(引数 1, 引数 2);\nconsole.log(関数の結果); // => 関数の返り値 \n```", "```\nfunction double(num) {\n    return num * 2;\n}\n// `double`関数の返り値は、`num`に`10`を入れて`return`文で返した値\nconsole.log(double(10)); // => 20 \n```", "```\nfunction fn() {\n    // 何も返り値を指定してない場合は`undefined`を返す\n    return;\n    // すでにreturnされているため、この行は実行されません\n}\nconsole.log(fn()); // => undefined \n```", "```\nfunction fn() {\n}\n\nconsole.log(fn()); // => undefined \n```", "```\nfunction echo(x) {\n    return x;\n}\n\nconsole.log(echo(1)); // => 1\nconsole.log(echo()); // => undefined \n```", "```\nfunction argumentsToArray(x, y) {\n    return [x, y];\n}\n\nconsole.log(argumentsToArray(1, 2)); // => [1, 2]\n// 仮引数のxには1、yにはundefinedが入る\nconsole.log(argumentsToArray(1)); // => [1, undefined] \n```", "```\nfunction 関数名(仮引数 1 = デフォルト値 1, 仮引数 2 = デフォルト値 2) {\n\n} \n```", "```\nfunction echo(x = \"デフォルト値\") {\n    return x;\n}\n\nconsole.log(echo(1)); // => 1\nconsole.log(echo()); // => \"デフォルト値\" \n```", "```\nfunction addPrefix(text, prefix) {\n    const pre = prefix || \"デフォルト:\";\n    return pre + text;\n}\n\nconsole.log(addPrefix(\"文字列\")); // => \"デフォルト:文字列\"\nconsole.log(addPrefix(\"文字列\", \"カスタム:\")); // => \"カスタム:文字列\" \n```", "```\nfunction addPrefix(text, prefix) {\n    const pre = prefix || \"デフォルト:\";\n    return pre + text;\n}\n\n// falsyな値を渡すとデフォルト値が入ってしまう\nconsole.log(addPrefix(\"文字列\")); // => \"デフォルト:文字列\"\nconsole.log(addPrefix(\"文字列\", \"\")); // => \"デフォルト:文字列\"\nconsole.log(addPrefix(\"文字列\", \"カスタム:\")); // => \"カスタム:文字列\" \n```", "```\nfunction addPrefix(text, prefix = \"デフォルト:\") {\n    return prefix + text;\n}\n// falsyな値を渡してもデフォルト値は代入されない\nconsole.log(addPrefix(\"文字列\")); // => \"デフォルト:文字列\"\nconsole.log(addPrefix(\"文字列\", \"\")); // => \"文字列\"\nconsole.log(addPrefix(\"文字列\", \"カスタム:\")); // => \"カスタム:文字列\" \n```", "```\nfunction addPrefix(text, prefix) {\n    // prefixがnullまたはundefinedの時、デフォルト値を返す\n    const pre = prefix ?? \"デフォルト:\";\n    return pre + text;\n}\n\nconsole.log(addPrefix(\"文字列\")); // => \"デフォルト:文字列\"\n// falsyな値でも意図通りに動作する\nconsole.log(addPrefix(\"文字列\", \"\")); // => \"文字列\"\nconsole.log(addPrefix(\"文字列\", \"カスタム:\")); // => \"カスタム:文字列\" \n```", "```\nfunction add(x, y) {\n    return x + y;\n}\nadd(1, 3); // => 4\nadd(1, 3, 5); // => 4 \n```", "```\n// Math.maxは可変長引数を受け取る関数\nconst max = Math.max(1, 5, 10, 20);\nconsole.log(max); // => 20 \n```", "```\nfunction fn(...args) {\n    // argsは、渡された引数が入った配列\n    console.log(args); // => [\"a\", \"b\", \"c\"]\n}\nfn(\"a\", \"b\", \"c\"); \n```", "```\nfunction fn(arg1, ...restArgs) {\n    console.log(arg1); // => \"a\"\n    console.log(restArgs); // => [\"b\", \"c\"]\n}\nfn(\"a\", \"b\", \"c\"); \n```", "```\nfunction fn(x, y, z) {\n    console.log(x); // => 1\n    console.log(y); // => 2\n    console.log(z); // => 3\n}\nconst array = [1, 2, 3];\n// Spread 構文で配列を引数に展開して関数を呼び出す\nfn(...array);\n// 次のように書いたのと同じ意味\nfn(array[0], array[1], array[2]); \n```", "```\nfunction fn() {\n    // `arguments`はインデックスを指定して各要素にアクセスできる\n    console.log(arguments[0]); // => \"a\"\n    console.log(arguments[1]); // => \"b\"\n    console.log(arguments[2]); // => \"c\"\n}\nfn(\"a\", \"b\", \"c\"); \n```", "```\nfunction printUserId(user) {\n    console.log(user.id); // => 42\n}\nconst user = {\n    id: 42\n};\nprintUserId(user); \n```", "```\n// 第 1 引数のオブジェクトから`id`プロパティを変数`id`として定義する\nfunction printUserId({ id }) {\n    console.log(id); // => 42\n}\nconst user = {\n    id: 42\n};\nprintUserId(user); \n```", "```\nconst user = {\n    id: 42\n};\n// オブジェクトの分割代入\nconst { id } = user;\nconsole.log(id); // => 42\n// 関数の引数の分割代入\nfunction printUserId({ id }) {\n    console.log(id); // => 42\n}\nprintUserId(user); \n```", "```\nfunction print([first, second]) {\n    console.log(first); // => 1\n    console.log(second); // => 2\n}\nconst array = [1, 2];\nprint(array); \n```", "```\nfunction fn() {\n    console.log(\"fnが呼び出されました\");\n}\n// 関数`fn`を`myFunc`変数に代入している\nconst myFunc = fn;\nmyFunc(); \n```", "```\n// 関数式\nconst 変数名 = function() {\n    // 関数を呼び出したときの処理\n    // ...\n    return 関数の返り値;\n}; \n```", "```\n// 関数式は変数名で参照できるため、\"関数名\"を省略できる\nconst 変数名 = function() {\n};\n// 関数宣言では\"関数名\"は省略できない\nfunction 関数名() {\n} \n```", "```\n// factorialは関数の外から呼び出せる名前\n// innerFactは関数の外から呼び出せない名前\nconst factorial = function innerFact(n) {\n    if (n === 0) {\n        return 1;\n    }\n    // innerFactを再帰的に呼び出している\n    return n * innerFact(n - 1);\n};\nconsole.log(factorial(3)); // => 6 \n```", "```\n// Arrow Functionを使った関数定義\nconst 変数名 = () => {\n    // 関数を呼び出したときの処理\n    // ...\n    return 関数の返す値;\n}; \n```", "```\n// 仮引数の数と定義\nconst fnA = () => { /* 仮引数がないとき */ };\nconst fnB = (x) => { /* 仮引数が1つのみのとき */ };\nconst fnC = x => { /* 仮引数が1つのみのときは()を省略可能 */ };\nconst fnD = (x, y) => { /* 仮引数が複数のとき */ };\n// 値の返し方\n// 次の２つの定義は同じ意味となる\nconst mulA = x => { return x * x; }; // ブロックの中でreturn\nconst mulB = x => x * x;            // 1 行のみの場合はreturnとブロックを省略できる \n```", "```\nconst array = [1, 2, 3];\n// 1,2,3と順番に値が渡されコールバック関数（無名関数）が処理する\nconst doubleArray = array.map(function(value) {\n    return value * 2; // 返した値をまとめた配列ができる\n});\nconsole.log(doubleArray); // => [2, 4, 6] \n```", "```\nconst array = [1, 2, 3];\n// 仮引数が1つなので`()`を省略できる\n// 関数の処理が1つの式なので`return`文を省略できる\nconst doubleArray = array.map(value => value * 2);\nconsole.log(doubleArray); // => [2, 4, 6] \n```", "```\nfunction fn(x) {\n    return `最初の関数 x: ${x}`;\n}\nfunction fn(x, y) {\n    return `最後の関数 x: ${x}, y: ${y}`;\n}\nconsole.log(fn(2, 10)); // => \"最後の関数 x: 2, y: 10\" \n```", "```\nconst fn = (x) => {\n    return `最初の関数 x: ${x}`;\n};\n// constは同じ変数名を定義できないため、構文エラーとなる\nconst fn = (x, y) => {\n    return `最後の関数 x: ${x}, y: ${y}`;\n}; \n```", "```\nfunction 高階関数(コールバック関数) {\n    コールバック関数();\n} \n```", "```\nconst array = [1, 2, 3];\nconst output = (value) => {\n    console.log(value);\n};\narray.forEach(output);\n// 次のように実行しているのと同じ\n// output(1); => 1\n// output(2); => 2\n// output(3); => 3 \n```", "```\nconst array = [1, 2, 3];\narray.forEach((value) => {\n    console.log(value);\n}); \n```", "```\nconst obj = {\n    method1: function() {\n        // `function`キーワードでのメソッド\n    },\n    method2: () => {\n        // Arrow Functionでのメソッド\n    }\n}; \n```", "```\nconst obj = {};\nobj.method = function() {\n}; \n```", "```\nconst obj = {\n    method: function() {\n        return \"this is method\";\n    }\n};\nconsole.log(obj.method()); // => \"this is method\" \n```", "```\nconst obj = {\n    method() {\n        return \"this is method\";\n    }\n};\nconsole.log(obj.method()); // => \"this is method\" \n```"]