- en: 字符串和 Unicode
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和 Unicode
- en: 原文：[`jsprimer.net/basic/string-unicode/`](https://jsprimer.net/basic/string-unicode/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/string-unicode/`](https://jsprimer.net/basic/string-unicode/)
- en: 「文字列」的章节介绍了，JavaScript 采用 Unicode 作为字符编码，并采用 UTF-16 作为编码方式。 采用 UTF-16 仅仅是为了在
    JavaScript 内部处理字符串时使用的字符编码（内部编码）。 因此，文件本身的字符编码（外部编码）可以是 UTF-8 等 UTF-16 以外的字符编码。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 「字符串」的章节介绍了，JavaScript 采用 Unicode 作为字符编码，并采用 UTF-16 作为编码方式。采用 UTF-16 仅仅是为了在
    JavaScript 内部处理字符串时使用的字符编码（内部编码）。因此，文件本身的字符编码（外部编码）可以是 UTF-8 等非 UTF-16 的字符编码。
- en: 在「字符串」章节中，我们并没有意识到这些字符编码，可以在不意识到内部使用的字符编码是什么的情况下进行字符串处理。 但是，JavaScript 的 String
    对象也有针对这个字符编码（Unicode）的 API。 此外，在处理特定包含表情符号的字符或计算“字符数”时，必须意识到 UTF-16 作为内部编码。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在「字符串」章节中，我们并没有意识到这些字符编码，可以在不意识到内部使用的字符编码是什么的情况下进行字符串处理。但是，JavaScript 的 String
    对象也有针对这个字符编码（Unicode）的 API。此外，在处理特定包含表情符号的字符或计算“字符数”时，必须意识到 UTF-16 作为内部编码。
- en: 本章将讨论需要意识到字符串中的 Unicode 的情况。 此外，Unicode 本身与 ECMAScript 一样具有历史悠久的规范，要介绍 Unicode
    的所有内容需要大量的字符串。 因此，本章将限定讨论 JavaScript 中的 Unicode 和 UTF-16。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论需要意识到字符串中的 Unicode 的情况。此外，Unicode 本身与 ECMAScript 一样具有悠久的历史规范，要介绍 Unicode
    的所有内容需要大量的字符串。因此，本章将限定讨论 JavaScript 中的 Unicode 和 UTF-16。
- en: 如果想要了解 Unicode 的历史以及字符编码本身的更多信息，请参考“[プログラマのための文字コード技術入門](https://gihyo.jp/book/2019/978-4-297-10291-3)”或“[文字コード「超」研究](https://www.rutles.net/products/detail.php?product_id=298)”等。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想要了解 Unicode 的历史以及字符编码本身的更多信息，请参考“[程序员必备的文字编码技术入门](https://gihyo.jp/book/2019/978-4-297-10291-3)”或“[文字编码「超」研究](https://www.rutles.net/products/detail.php?product_id=298)”等。
- en: '[](#code-point)*Code Point*'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#code-point)*代码点*'
- en: '*Unicode 是为所有字符（包括不可见字符等）定义 ID 的规范。 对于这些“字符”的“唯一 ID”，我们称之为**Code Point**（代码点）。'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*Unicode 规范为所有字符（包括不可见字符等）定义了 ID。对于这些“字符”的“唯一 ID”，我们称之为**代码点**（代码点）。'
- en: 处理 Code Point 的方法大多是在 ECMAScript 2015 中添加的。 通过使用 ES2015 中添加的 String 的`codePointAt`方法和`String.fromCodePoint`静态方法，可以相互转换字符串和
    Code Point。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 处理代码点的方法大多是在 ECMAScript 2015 中添加的。通过使用 ES2015 中添加的 String 的 `codePointAt` 方法和
    `String.fromCodePoint` 静态方法，可以相互转换字符串和代码点。
- en: String 的`codePointAt`方法^([ES2015])会返回字符串中指定索引处字符的 Code Point 值。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: String 的 `codePointAt` 方法^([ES2015])会返回字符串中指定索引处字符的代码点值。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 另一方面，`String.fromCodePoint`方法^([ES2015])会返回与指定 Code Point 对应的字符。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`String.fromCodePoint` 方法^([ES2015])会返回与指定代码点对应的字符。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 此外，在字符串文字中，可以使用 Unicode 转义序列直接写入 Code Point。 Code Point 可以以`\u{Code Point 的
    16 进制值}`的形式作为转义序列进行编写。 在 Unicode 转义序列中，需要提供 Code Point 的 16 进制值。 通过将 Number 的`toString`方法的基数参数设置为`16`，可以获取
    16 进制字符串。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在字符串文字中，可以使用 Unicode 转义序列直接写入代码点。代码点可以以`\u{Code Point 的 16 进制值}`的形式作为转义序列进行编写。在
    Unicode 转义序列中，需要提供代码点的 16 进制值。通过将 Number 的 `toString` 方法的基数参数设置为 `16`，可以获取 16
    进制字符串。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[](#code-point-is-not-code-unit)*Code Point 和 Code Unit 的区别*'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#code-point-is-not-code-unit)*代码点与代码单元的区别*'
- en: '*我们介绍了 Code Point（代码点），但 JavaScript 字符串的构成元素是经过 UTF-16 转换的 Code Unit（代码单元）（详细信息请参考“字符串”章节）。
    对于某些范围的字符串，Code Point（代码点）和 Code Unit（代码单元）的值最终会相同。'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们介绍了代码点，但 JavaScript 字符串的构成元素是经过 UTF-16 转换的代码单元（详细信息请参考“字符串”章节）。对于某些范围的字符串，代码点和代码单元的值最终会相同。'
- en: 在下面的代码中，我们展示了名为`アオイ`的字符串的每个元素作为 Code Point 和 Code Unit 的表示。 `convertCodeUnits`函数将字符串转换为
    Code Unit 数组，`convertCodePoints`函数将字符串转换为 Code Point 数组。 暂时不需要理解这两个函数的具体实现。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们展示了名为`アオイ`的字符串的每个元素作为代码点和代码单元的表示。`convertCodeUnits` 函数将字符串转换为代码单元数组，`convertCodePoints`
    函数将字符串转换为代码点数组。暂时不需要理解这两个函数的具体实现。
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 总结执行结果后，可以看出在这个字符串中，Code Point 和 Code Unit 的值是相同的。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 总结执行结果后，可以看出在这个字符串中，代码点和代码单元的值是相同的。
- en: '![字符串中的 Code Unit 和 Code Point 表](img/d509219aa230c9091994e155711f62f1.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![字符串中的代码单元和代码点表](img/d509219aa230c9091994e155711f62f1.png)'
- en: 然而，有些字符串的 Code Point 和 Code Unit 可能会有不同的值。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些字符串的代码点和代码单元可能会有不同的值。
- en: 使用相同的函数，我们将比较`リンゴ🍎`（苹果表情符号）这个字符串的 Code Unit 和 Code Point。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的函数，我们将比较`リンゴ🍎`（苹果表情符号）这个字符串的代码单元和代码点。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 总结执行结果后，可以看出在包含表情符号的字符串中，Code Point 和 Code Unit 的值是不同的。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 总结执行结果后，可以看出在包含表情符号的字符串中，代码点和代码单元的值是不同的。
- en: '![包含表情符号的字符串中的 Code Unit 和 Code Point 表](img/d20cf51e0c1e366dbe3477309403da4a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![包含表情符号的字符串中的代码单元和代码点表](img/d20cf51e0c1e366dbe3477309403da4a.png)'
- en: 具体来说，Code Point 的元素数为 4，而 Code Unit 的元素数为 5。 此外，虽然一个 Code Point 对应于`🍎`，但在 Code
    Unit 中，`🍎`对应于两个 Code Unit。 在 JavaScript 中，字符串被视为按顺序排列的 Code Unit，因此该字符串的元素数（长度）为
    Code Unit 的个数，即 5。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，代码点的元素数为4，而代码单元的元素数为5。此外，虽然一个代码点对应于`🍎`，但在代码单元中，`🍎`对应于两个代码单元。在 JavaScript
    中，字符串被视为按顺序排列的代码单元，因此该字符串的元素数（长度）为代码单元的个数，即5。
- en: UTF-16 是一种编码方式，用 16 位（2 字节）的 Code Unit 来表示一个对应于 Code Point 的字符。 然而，16 位（2 字节）可以表示的范围只有
    65536 种（2 的 16 次方）。 目前，Unicode 注册的 Code Point 已经超过 10 万种，因此无法将所有字符与 Code Unit
    进行一对一的映射。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16 是一种编码方式，用 16 位（2 字节）的代码单元来表示一个对应于代码点的字符。然而，16 位（2 字节）可以表示的范围只有 65536
    种（2 的 16 次方）。目前，Unicode 注册的代码点已经超过 10 万种，因此无法将所有字符与代码单元进行一对一的映射。
- en: 在这种情况下，UTF-16 使用两个 Code Unit 的组合（总共 4 个字节）来表示一个字符（一个 Code Point）。 这种机制被称为**代理对**。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，UTF-16 使用两个代码单元的组合（总计4个字节）来表示一个字符（一个代码点）。这种机制被称为**代理对**。
- en: '[](#surrogate-pair)*代理对*'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#surrogate-pair)*代理对*'
- en: '*サロゲートペアでは、2つのCode Unitの組み合わせ（合計 4バイト）で1つの文字（1つのCode Point）を表現します。UTF-16では、次の範囲をサロゲートペアに利用する領域としています。'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*代理对中，由2个代码单元的组合（总计4个字节）来表示一个字符（一个代码点）。UTF-16中，使用以下范围作为代理对的利用区域。'
- en: '`\uD800`～`\uDBFF`：上位サロゲートの範囲'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\uD800`～`\uDBFF`：高位代理的范围'
- en: '`\uDC00`～`\uDFFF`：下位サロゲートの範囲'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\uDC00`～`\uDFFF`：低位代理的范围'
- en: 文字列中に上位サロゲートと下位サロゲートのCode Unitが並んだ場合に、2つのCode Unitを組み合わせて1 文字（Code Point）として扱います。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当文字列中包含高位代理和低位代理的代码单元时，将两个代码单元组合成一个文字（代码点）进行处理。
- en: 次のコードでは、サロゲートペアの文字である「𩸽（ほっけ）」を次の2つのCode Unitで表現しています。Code Unitのエスケープシーケンス（`\uXXXX`）を2つ並べることで`𩸽`という文字を表現できます。一方で、ES2015からはCode
    Pointのエスケープシーケンス（`\u{XXXX}`）も書けるため、1つのCode Pointで`𩸽`という文字を表現できることもわかります。しかし、Code
    Pointのエスケープシーケンスで書いた場合でも、内部的にCode Unitに変換された値で保持されることは変わりません。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中，展示了由代理对表示的字符「𩸽（ほっけ）」使用两个代码单元进行表达。通过将两个代码单元的转义序列（`\uXXXX`）并列，可以表示字符「𩸽」。另一方面，从
    ES2015 开始，也可以使用代码点的转义序列（`\u{XXXX}`）来表示，因此可以使用一个代码点来表示字符「𩸽」。然而，即使使用代码点的转义序列，内部仍然会将其转换为代码单元的值。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 先ほどの例で登場した`🍎`（リンゴの絵文字）もサロゲートペアで表現される文字です。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中出现的`🍎`（苹果表情符号）也是用替代对表示的文字。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: このようにサロゲートペアでは、2つのCode Unitで1つのCode Pointを表現します。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在替代对中，两个Code Unit表示一个Code Point。
- en: 基本的には、文字列はCode Unitが順番に並んでいるものとして扱われるため、多くの`String`のメソッドはCode Unitごとに作用します。また、インデックスアクセスもCode
    Unitごととなります。そのため、サロゲートペアで表現している文字列では、上位サロゲート（0 番目）と下位サロゲート（1 番目）へのインデックスアクセスになります。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，字符串被视为按顺序排列的Code Unit，因此许多`String`方法都是按Code Unit操作的。此外，索引访问也是按Code Unit进行的。因此，用替代对表示的字符串中，索引访问是针对上位替代符（0号）和下位替代符（1号）的。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 絵文字や「𩸽（ほっけ）」などのサロゲートペアで表現される文字が文字列中に含まれると、Code Unitごとに扱う文字列処理は複雑になります。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串中包含表情符号或“𩸽（ほっけ）”等用替代对表示的文字时，按Code Unit处理的字符串处理会变得复杂。
- en: たとえば、Stringの`length`プロパティは文字列におけるCode Unitの要素数を数えるため、`"🍎".length`の結果は`2`となります。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，String的`length`属性计算的是字符串中的Code Unit元素数，因此`"🍎".length`的结果是`2`。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: このような場合には、文字列をCode Pointごとに処理することを考える必要があります。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，需要考虑按Code Point处理字符串。
- en: '[](#handle-code-point)*Code Pointを扱う*'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#handle-code-point)*处理Code Point*'
- en: '*文字列をCode Pointが順番に並んだものとして扱うには、Code Pointに対応したメソッドなどを利用する必要があります。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*要按Code Point顺序排列字符串，需要使用与Code Point对应的函数等方法。'
- en: ES2015から文字列をCode Pointごとに扱うメソッドや構文が追加されています。次に紹介するものは、文字列をCode Pointごとに扱います。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES2015开始，增加了处理字符串为Code Point的方法或语法。接下来要介绍的是，这些方法将处理字符串为Code Point。
- en: '`CodePoint`を名前に含むメソッド'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`CodePoint`名称的方法
- en: '`u`（Unicode）フラグが有効化されている正規表現'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`（Unicode）标志已启用的正则表达式'
- en: 文字列のIteratorを扱うもの（Destructuring、`for...of`、`Array.from`メソッドなど）
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理字符串的Iterator（解构、`for...of`、`Array.from`方法等）
- en: これらのCode Pointを扱う処理と具体的な使い方を見ていきます。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看处理这些Code Point的具体方法和用法。
- en: '[](#regexp-unicode)*正規表現の`.`とUnicode*'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#regexp-unicode)*正则表达式的`.`和Unicode*'
- en: '*ES2015では、正規表現に`u`（Unicode）フラグが追加されました。この`u`フラグをつけた正規表現は、文字列をCode Pointが順番に並んだものと���て扱います。'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*ES2015中，正则表达式添加了`u`（Unicode）标志。添加了`u`标志的正则表达式将按Code Point顺序排列的字符串进行处理。'
- en: 具体的に`u`フラグの有無による`.`（改行文字以外のどの1 文字にもマッチする特殊文字）の動作の違いを見ていきます。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将查看添加或未添加`u`标志的`.`（除了换行符以外的任意一个字符）的行为差异。
- en: '`/（.）のひらき/`というパターンで`.`にマッチする部分を取り出すことを例に見ていきます。'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以`/（.）のひらき/`这种模式为例，看看如何提取匹配`.`的部分。
- en: まずは、`u`フラグをつけていない正規表現とStringの`match`メソッドでマッチした範囲を取り出してみます。`match`メソッドの返す値は`[マッチした全体の文字列,
    キャプチャされた文字列]`です（詳細は「文字列」の章を参照）。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过添加`u`标志的正则表达式和String的`match`方法来提取匹配的范围内。`match`方法返回的值是`[匹配的整个字符串, 被捕获的字符串]`（详细信息请参考“字符串”章节）。
- en: 実際にマッチした結果を見��みると、`.`は`𩸽`の下位サロゲートである`\ude3d`にマッチしていることがわかります（`\ude3d`は単独では表示できないため、文字化けのように表示されます）。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际匹配的结果显示，`.`与`𩸽`的下位替代符`\ude3d`相匹配（`\ude3d`单独无法显示，因此会以乱码的形式显示）。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: つまり、`u`フラグをつけていない正規表現は、文字列をCode Unitが順番に並んだものとして扱っています。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，没有添加`u`标志的正则表达式将字符串视为按顺序排列的Code Unit。
- en: このような意図しない結果を避けるには、正規表現に`u`フラグをつけます。`u`フラグがついた正規表現は、文字列をCode Pointごとに扱います。そのため、任意の1
    文字にマッチする`.`が`𩸽`という文字（Code Point）にマッチします。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免这种意外的结果，可以在正则表达式中添加`u`标志。添加了`u`标志的正则表达式将按Code Point处理字符串。因此，任意一个字符匹配的`.`将匹配`𩸽`这个字符（Code
    Point）。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 基本的には正規表現に`u`フラグをつけて問題となるケースは少ないはずです。なぜなら、サロゲートペアの片方だけにマッチしたい正規表現を書くケースはまれであるためです。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，添加了`u`标志的正则表达式应该很少出现问题。这是因为很少需要编写只匹配替代对中一个部分的正则表达式。
- en: '[](#count-of-code-points)*Code Pointの数を数える*'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#count-of-code-points)*计算Code Point的数量*'
- en: '*Stringの`length`プロパティは、文字列を構成するCode Unitの個数を表すプロパティです。そのためサロゲートペアを含む文字列では、`length`の結果が見た目より大きな値となる場合があります。'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*String的`length`属性表示的是构成字符串的Code Unit的个数。因此，包含替代对的字符串中，`length`的结果可能会比预期的要大。'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: JavaScriptには、文字列におけるCode Pointの個数を数えるメソッドは用意されていません。これを行うには、文字列をCode Pointごとに区切った配列へ変換して、配列の長さを数えるのが簡潔です。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有提供计算字符串中Code Point个数的内置方法。为此，需要将字符串转换为按Code Point分隔的数组，然后计算数组的长度。
- en: '`Array.from`メソッド^([ES2015])は、引数にiterableなオブジェクトを受け取り、それを元にした新しい配列を返します。iterableオブジェクトとは`Symbol.iterator`という特別な名前のメソッドを実装したオブジェクトの総称で、`for...of`文などで反復処理が可能なオブジェクトです（詳細は「ループと反復処理のfor...of
    文」を参照）。'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from`方法^([ES2015])接受一个可迭代的对象作为参数，并返回一个新的数组。可迭代的对象是指实现了`Symbol.iterator`这个特殊名称的方法的对象的总称，`for...of`语句等可以对其进行迭代处理（详细信息请参考“循环与重复处理的for...of语句”章节）。'
- en: 文字列もiterableオブジェクトであるため、`Array.from`メソッドによって1 文字（厳密にはCode Point）ごとに区切った配列へと変換できます。先ほども紹介したように、文字列をiterableとして扱う場合はCode
    Pointごとに処理を行います。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也是可迭代的对象，因此可以使用`Array.from`方法将其转换为按1个字符（严格来说是一个Code Point）分隔的数组。正如之前所介绍的，当将字符串作为可迭代对象处理时，应按Code
    Point进行处理。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: しかし、Code Pointの数を数えた場合でも、直感的な結果にならない場合もあります。なぜなら、Code Pointには制御文字などの視覚的に見えないものも定義されているためです。そのため、文字として数えたくないものは無視するなど、視覚的な**文字列の長さ**を数えるにはさらなる工夫が必要になります。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在计算Code Point的数量时，有时也可能得到不直观的结果。这是因为Code Point中定义了诸如控制字符等视觉上不可见的字符。因此，在需要计算视觉上的**字符串长度**时，需要额外的技巧。
- en: '[](#loop-each-code-point)*Code Pointごとに反復処理をする*'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#loop-each-code-point)*按Code Point进行循环处理*'
- en: '*先ほど紹介した`Array.from`メソッドを使えば、文字列をCode Pointで区切った文字の配列へと変換できます。配列にすれば、あとは「ループと反復処理」の章で学んだ方法を使って、Code
    Pointごとに反復処理ができます。'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用之前介绍的`Array.from`方法，可以将字符串转换为按Code Point分隔的字符数组。然后，可以使用“循环与重复处理”章节中学到的技术，对Code
    Point进行循环处理。'
- en: 下面的代码计算了字符串中出现`🍎`的次数。`countOfCodePoints`函数将使用`Array.from`将字符串转换为 Code Point
    数组，并返回由数组过滤器`codePoint`产生的数组的元素数。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码计算了字符串中出现`🍎`的次数。`countOfCodePoints`函数将使用`Array.from`将字符串转换为Code Point数组，并返回由数组过滤器`codePoint`产生的数组的元素数。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`for...of`循环也可以按 Code Point 处理字符串。这是因为`for...of`语句会枚举目标作为迭代器。'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...of`循环也可以按Code Point处理字符串。这是因为`for...of`语句会枚举目标作为迭代器。'
- en: 我们将使用与之前相同的`countOfCodePoints`函数，但这次使用`for...of`来实现。
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前相同的`countOfCodePoints`函数，但这次使用`for...of`来实现。
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[](#conclusion)*结论*'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#conclusion)*结论*'
- en: '*本章简要介绍了字符串和 Unicode 之间的关系。Unicode 还有一些未在本章介绍的方面。此外，JavaScript 并非总是提供处理 Unicode
    的完美 API。'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章简要介绍了字符串和Unicode之间的关系。Unicode还有一些未在本章介绍的方面。此外，JavaScript并非总是提供处理Unicode的完美API。'
- en: 另一方面，正如在“字符串”章节中介绍的那样，即使不考虑 Code Unit 或 Code Point，也可以进行灵活而强大的字符串处理。然而，由于近年来使用表情符号的情况越来越多，因此也越来越需要意识到
    Code Point 进行编程的情况。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，正如在“字符串”章节中介绍的那样，即使不考虑Code Unit或Code Point，也可以进行灵活而强大的字符串处理。然而，由于近年来使用表情符号的情况越来越多，因此也越来越需要意识到按Code
    Point编程的情况。
- en: Unicode 是独立于 ECMAScript 的规范，因此，处理字符串的问题是所有编程语言都会遇到的共同问题。特别是 Java 采用了与 JavaScript
    相同的 UTF-16 编码方式，因此存在类似的问题。因此，在遇到 JavaScript 中的字符串处理问题时，了解其他语言的处理方式也是很重要的。********
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 是一个独立于 ECMAScript 的规范，因此，处理字符串的问题成为了所有编程语言都会遇到的共同问题。特别是 Java 采用了与 JavaScript
    相同的 UTF-16 编码方式，因此存在类似的问题。因此，在遇到 JavaScript 中的字符串处理问题时，了解其他语言的处理方式也是很重要的。********
