- en: データ型とリテラル
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型与字面量
- en: 原文：[`jsprimer.net/basic/data-type/`](https://jsprimer.net/basic/data-type/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/data-type/`](https://jsprimer.net/basic/data-type/)
- en: '[](#data-type)*データ型*'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#data-type)*数据类型*'
- en: '*JavaScriptは動的型付け言語に分類される言語であるため、静的型付け言語のような**変数の型**はありません。 しかし、文字列、数値、真偽値といった**値の型**は存在します。
    これらの値の型のことを**データ型**と呼びます。'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 被归类为动态类型语言，因此没有像静态类型语言那样的**变量类型**。然而，存在诸如字符串、数值、真值等**值类型**。这些值类型被称为**数据类型**。'
- en: データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類されます。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型大致分为**原始类型**和**对象**两种。
- en: プリミティブ型（基本型）は、真偽値や数値などの基本的な値の型のことです。 プリミティブ型の値は、一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性を持ちます。
    JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われます。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型（基本类型）是指诸如真值或数值等基本值的类型。原始类型的值一旦创建就不能更改，具有不可变（immutable）的特性。在 JavaScript
    中，字符串也具有不可变的特性，一旦创建就不能更改，被视为原始类型之一。
- en: 一方、プリミティブ型ではないものをオブジェクト（複合型）と呼び、 オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合です。 オブジェクトは、一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持ちます。
    オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言います。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不是原始类型的被称为对象（复合类型），对象是由多个原始类型的值或对象组成的集合。对象在创建后可以改变其值，因此具有可变（mutable）的特性。由于对象是通过引用值来操作的，因此也被称为引用类型的数据。
- en: データ型を細かく見ていくと、7つのプリミティブ型とオブジェクトからなります。
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型细分后，由7个原始类型和对象组成。
- en: プリミティブ型（基本型）
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型（基本类型）
- en: '真偽値（Boolean）: `true`または`false`のデータ型'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '真值（Boolean）: `true` 或 `false` 的数据类型'
- en: '数値（Number）: `42` や `3.14159` などの数値のデータ型'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '数值（Number）: `42` 或 `3.14159` 等数值的数据类型'
- en: '巨大な整数（BigInt）: ES2020から追加された`9007199254740992n`などの任意精度の整数のデータ型'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '大整数（BigInt）: 从 ES2020 开始添加的 `9007199254740992n` 等任意精度的整数的数据类型'
- en: '文字列（String）: `"JavaScript"` などの文字列のデータ型'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '字符串（String）: `"JavaScript"` 等字符串的数据类型'
- en: 'undefined: 値が未定義であることを意味するデータ型'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: undefined：表示值未定义的数据类型
- en: 'null: 値が存在しないことを意味するデータ型'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: null：表示值不存在的数据类型
- en: 'シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '符号（Symbol）: 从 ES2015 开始添加的唯一且不可变的值的数据类型'
- en: オブジェクト（複合型）
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象（复合类型）
- en: プリミティブ型以外のデータ
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非原始类型的数据
- en: オブジェクト、配列、関数、クラス、正規表現、Dateなど
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象、数组、函数、类、正则表达式、Date 等
- en: プリミティブ型でないものは、オブジェクトであると覚えていれば問題ありません。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 非原始类型的是对象，记住这一点就不会有问题。
- en: '`typeof`演算子を使うことで、次のようにデータ型を調べることができます。'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typeof` 操作符可以像这样检查数据类型。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: プリミティブ型の値は、それぞれ`typeof`演算子の評価結果として、その値のデータ型を返します。 一方で、オブジェクトに分類される値は`"object"`となります。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型的值分别通过 `typeof` 操作符的评估结果返回其值的类型。另一方面，被归类为对象的值是 `"object"`。
- en: 配列(`[]`)とオブジェクト(`{}`)は、どちらも`"object"`という判定結果になります。 そのため、`typeof`演算子ではオブジェクトの詳細な種類を正しく判定することはできません。
    ただし、関数はオブジェクトの中でも特別扱いされているため、`typeof`演算子の評価結果は`"function"`となります。 また、`typeof null`が`"object"`となるのは、歴史的経緯のある仕様のバグ^(1)です。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数组（`[]`）和对象（`{}`）都返回 `"object"` 这个判定结果。因此，`typeof` 操作符不能正确地判定对象的详细类型。但是，函数在对象中是特殊处理的，因此
    `typeof` 操作符的评估结果是 `"function"`。另外，`typeof null` 返回 `"object"` 是由于历史原因的规范错误^(1)。
- en: このことからもわかるように`typeof`演算子は、プリミティブ型またはオブジェクトかを判別するものです。 `typeof`演算子では、オブジェクトの詳細な種類を判定できないことは、覚えておくとよいでしょう。
    各オブジェクトの判定方法については、それぞれのオブジェクトの章で見ていきます。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，`typeof` 操作符用于区分原始类型或对象。记住，`typeof` 操作符不能确定对象的详细类型。关于每个对象的判定方法，将在各自的章节中介绍。
- en: '[](#literal)*リテラル*'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#literal)*字面量*'
- en: '*プリミティブ型の値や一部のオブジェクトは、**リテラル**を使うことで簡単に定義できるようになっています。'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始类型的值或一些对象可以通过**字面量**轻松定义。'
- en: リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたものです。 たとえば、`"`と`"`で囲んだ範囲が文字列リテラルで、これは文字列型のデータを表現しています。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是在程序中直接以语法形式定义的数值或字符串等数据类型值。例如，用引号 `"` 和 `"` 包围的范围是字符串字面量，它表示字符串类型的值。
- en: 次のコードでは、`"こんにちは"`という文字列型のデータを初期値に持つ変数`str`を定義しています。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，定义了一个名为 `str` 的变量，其初始值为具有字符串类型的 `"こんにちは"` 数据。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: リテラル表現がない場合は、その値を作る関数に引数を渡して作成する形になります。 そのような冗長な表現を避ける方法として、よく利用される主要なデータ型にはリテラルが用意されています。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有字面量表示，则通过将值作为参数传递给创建该值的函数来创建该值。为了避免这种冗长的表示，为常用的主要数据类型提供了字面量。
- en: 次の5つのプリミティブ型は、それぞれリテラル表現を持っています。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的5个原始类型各自都有字面量表示。
- en: 真偽値
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真值
- en: 数値
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值
- en: BigInt
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BigInt
- en: 文字列
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: 'null'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'null'
- en: また、オブジェクトの中でもよく利用されるものに関してはリテラル表現が用意されています。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于在对象中经常使用的，也提供了字面量表示。
- en: オブジェクト
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: 配列
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: 正規表現
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: これらのリテラルについて、まずはプリミティブ型から順番に見ていきます。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些字面量，首先从原始类型开始依次介绍。
- en: '[](#boolean)*真偽値（Boolean）*'
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#boolean)*真值（Boolean）*'
- en: '*真偽値には`true`と`false`のリテラルがあります。 それぞれは`true`と`false`の値を返すリテラルで、見た目どおりの意味となります。'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*真值有 `true` 和 `false` 的字面量。它们分别返回 `true` 和 `false` 的值，具有直观的含义。'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[](#number)*数値（Number）*'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#number)*数值（Number）*'
- en: '*数値には`42`のような整数リテラルと`3.14159`のような浮動小数点数リテラルがあります。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*数值包括像 `42` 这样的整数字面量以及像 `3.14159` 这样的浮点数字面量。'
- en: これらのリテラルで表現できる数値は[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)の倍精度浮動小数として扱われます。
    倍精度浮動小数では64ビットで数値を表現します。 64ビットのうち52ビットを数字の格納のために使い、11ビットを小数点の位置に使い、残りの1ビットはプラスとマイナスの符号です。
    そのため、正確に扱える数値の最大値は`2⁵³-1`（2の53 乗から1 引いた値）となります。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字面量表示的数值被视为 IEEE 754 的双精度浮点数。双精度浮点数使用64位来表示数值。在64位中，52位用于存储数字，11位用于小数点的位置，剩下的1位是正负符号。因此，可以精确处理的数值的最大值是
    `2⁵³-1`（2的53次方减1）。
- en: '[](#integer-literal)*整数リテラル*'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#integer-literal)*整数字面量*'
- en: '*整数リテラルには次の4 種類があります。'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数字面量有以下4种。'
- en: '10 進数: 数字の組み合わせ'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制：数字的组合
- en: ただし、複数の数字を組み合わせた際に、先頭を`0`から開始すると8 進数として扱われる場合があります
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，当组合多个数字时，如果以 `0` 开头，则可能被视为八进制。
- en: 例）`0`、`2`、`10`
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例）`0`、`2`、`10`
- en: '2 進数: `0b`（または`0B`）の後ろに、`0`または`1`の数字の組み合わせ'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制：紧跟在 `0b`（或 `0B`）之后的是由 `0` 或 `1` 组成的数字组合
- en: 例）`0b0`、`0b10`、`0b1010`
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例）`0b0`、`0b10`、`0b1010`
- en: '8 進数: `0o`（または`0O`）の後ろに、`0`から`7`までの数字の組み合わせ'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制：紧跟在 `0o`（或 `0O`）之后的是由 `0` 到 `7` 组成的数字组合
- en: '`0o` は数字のゼロと小文字アルファベットの`o`'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0o` 是数字的零和小写字母 `o`'
- en: 例）`0o644`、`0o777`
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例）`0o644`、`0o777`
- en: '16 進数: `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制：紧跟在 `0x`（或 `0X`）之后的是由 `0` 到 `9` 的数字和 `a` 到 `f` 或 `A` 到 `F` 的字母组成的组合
- en: アルファベットの大文字・小文字の違いは値には影響しません
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母的大小写对值没有影响
- en: 例）`0x30A2`、`0xEEFF`
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例）`0x30A2`、`0xEEFF`
- en: 0から9の数字のみで書かれた数値は、10 進数として扱われます。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仅由0到9的数字组成的数值被视为十进制。
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`0b`からはじまる2 進数リテラルは、ビットを表現するのによく利用されています。 `b`は2 進数を表すbinaryを意味しています。'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `0b` 开头的二进制数字面量常用于表示位。`b` 代表二进制（binary）。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`0o`からはじまる8 進数リテラルは、ファイルのパーミッションを表現するのによく利用されています。 `o`は8 進数を表すoctalを意味しています。'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `0o` 开头的八进制数字面量常用于表示文件权限。`o` 代表八进制（octal）。
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 次のように、`0`からはじまり、`0`から`7`の数字を組み合わせた場合も8 進数として扱われます。 しかし、この表記は10 進数と紛らわしいものであったため、ES2015で`0o`の8
    進数リテラルが新たに導入されました。 また、strict modeではこの書き方は例外が発生するため、次のような8 進数の書き方は避けるべきです（詳細は「JavaScriptとは」のstrict
    modeを参照）。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように、`0`からはじまり、`0`から`7`の数字を組み合わせた場合も8進数として扱われます。 しかし、この表記は10進数と紛らわしいものであったため、ES2015で`0o`の8進数リテラルが新たに導入されました。
    また、strict modeではこの書き方は例外が発生するため、次のような8進数の書き方は避けるべきです（詳細は「JavaScriptとは」のstrict
    modeを参照）。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`0x`からはじまる16 進数リテラルは、文字のコードポイントやRGB 値の表現などに利用されています。 `x`は16 進数を表すhexを意味しています。'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`0x`からはじまる16 進数リテラルは、文字のコードポイントやRGB 値の表現などに利用されています。 `x`は16 進数を表すhexを意味しています。'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| 名前 | 表記例 | 用途 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 名前 | 表記例 | 用途 |'
- en: '| --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 10 進数 | 42 | 数値 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 10進数 | 42 | 数値 |'
- en: '| 2 進数 | 0b0001 | ビット演算など |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 2進数 | 0b0001 | ビット演算など |'
- en: '| 8 進数 | 0o777 | ファイルのパーミッションなど |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 8進数 | 0o777 | ファイルのパーミッションなど |'
- en: '| 16 進数 | 0xEEFF | 文字のコードポイント、RGB 値など |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 16進数 | 0xEEFF | 文字のコードポイント、RGB値など |'
- en: '[](#floating-point-number-literal)*浮動小数点数リテラル*'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#floating-point-number-literal)*浮動小数点数リテラル*'
- en: '*浮動小数点数をリテラルとして書く場合には、次の2 種類の表記が利用できます。'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*When writing a floating-point number as a literal, the following two types
    of notation can be used.'
- en: '`3.14159` のような `.`（ドット）を含んだ数値'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3.14159` のような `.`（ドット）を含んだ数値'
- en: '`2e8` のような `e` または `E` を含んだ数値'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2e8`のような`e`または`E`を含んだ数値'
- en: '`0`からはじまる浮動小数点数は、`0`を省略して書くことができます。'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`からはじまる浮動小数点数は、`0`を省略して書くことができます。'
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: しかし、JavaScriptでは`.`をオブジェクトにおいて利用する機会が多いため、 `0`からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせるでしょう。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: しかし、JavaScriptでは`.`をオブジェクトにおいて利用する機会が多いため、 `0`からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせるでしょう。
- en: '**Note** 変数名を数字からはじめることができないのは、数値リテラルと衝突してしまうからです。'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Note** 変数名を数字からはじめることができないのは、数値リテラルと衝突してしまうからです。'
- en: '`e`は指数（exponent）を意味する記号で、`e`のあとには指数部の値を書きます。 たとえば、`2e8`は2×10の8 乗となるので、10 進数で表すと`200000000`となります。'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`e`は指数（exponent）を意味する記号で、`e`のあとには指数部の値を書きます。 たとえば、`2e8`は2×10の8乗となるので、10進数で表すと`200000000`となります。'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[](#bigint-literal)*[ES2020] BigInt*'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#bigint-literal)*[ES2020] BigInt*'
- en: '*JavaScriptでは、`1`や`3.14159`などの数値リテラルは[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)で定義された倍精度浮動小数となります。
    倍精度浮動小数で正確に扱える数値の最大値は`2⁵³-1`（2の53 乗から1 引いた値である`9007199254740991`）です。 この数値リテラルで安全に表せる最大の数値は`Number.MAX_SAFE_INTEGER`として定義されています。'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScriptでは、`1`や`3.14159`などの数値リテラルは[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)で定義された倍精度浮動小数となります。
    倍精度浮動小数で正確に扱える数値の最大値は`2⁵³-1`（2の53乗から1引いた値である`9007199254740991`）です。 この数値リテラルで安全に表せる最大の数値は`Number.MAX_SAFE_INTEGER`として定義されています。'
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 数値リテラルで`2⁵³-1`（`9007199254740991`）よりも大きな値を表現したり計算すると間違った結果となる場合があります。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: When expressing or calculating a value larger than `2⁵³-1` (`9007199254740991`)
    with a number literal, there may be cases where incorrect results occur.
- en: この問題を解決するために、ES2020では`BigInt`という新しい整数型のデータ型とリテラルが追加されました。 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の精度の整数を扱えます。
    そのため、BigIntでは`2⁵³-1`（`9007199254740991`）よりも大きな整数を正しく表現できます。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: この問題を解決するために、ES2020では`BigInt`という新しい整数型のデータ型とリテラルが追加されました。 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の精度の整数を扱えます。
    そのため、BigIntでは`2⁵³-1`（`9007199254740991`）よりも大きな整数を正しく表現できます。
- en: BigIntリテラルは、数値の後ろに`n`をつけます。
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: BigIntリテラルは、数値の後ろに`n`をつけます。
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: BigIntは整数を扱うデータ型であるため、次のように小数点を含めた場合は構文エラーとなります。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: BigInt is a data type that handles integers, so if it contains a decimal point,
    a syntax error occurs.
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[](#numeric-separators)*[ES2021] Numeric Separators*'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#numeric-separators)*[ES2021] Numeric Separators*'
- en: '*数値が大きくなるほど、桁数の見間違いなどが発生しやすくなります。 次のコードは、1 兆を数値リテラルで書いていますが、桁数を読み取りにくいです。'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*The more the number becomes large, the more likely it is to make mistakes
    in the number of digits. The following code is to write 1 billion as a number
    literal, but it is difficult to read the number of digits.'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ES2021から、数値リテラル内の区切り文字として`_`を追加できるNumeric Separatorsがサポートされています。 Numeric Separatorsは、数値リテラル内では区切り文字として`_`が追加できます。
    次のコードも、1 兆を数値リテラルで書いています。数値リテラルを評価する際に`_`は単純に無視されるため同じ意味となります。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ES2021から、数値リテラル内の区切り文字として`_`を追加できるNumeric Separatorsがサポートされています。 Numeric Separatorsは、数値リテラル内では区切り文字として`_`が追加できます。
    次のコードも、1億を数値リテラルで書いています。数値リテラルを評価する際に`_`は単純に無視されるため同じ意味となります。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Numeric Separatorsは数値リテラルである整数、浮動小数点、BigIntのリテラル内でのみ利用できます。 また、`_`はリテラルの先頭や数値の最後に追加することはできません。
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Numeric Separators can only be used in the literals of integers, floating-point
    numbers, and BigInt. Additionally, `_` cannot be added at the beginning or end
    of the literal.
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[](#string)*文字列（String）*'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#string)*文字列（String）*'
- en: '*文字列リテラル共通のルールとして、同じ記号で囲んだ内容を文字列として扱います。 文字列リテラルとして次の3 種類のリテラルがありますが、その評価結果はすべて同じ`"文字列"`になります。'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*As a common rule for string literals, the content enclosed with the same symbol
    is treated as a string. There are three types of literals as string literals,
    but their evaluation results are all the same `"string"`.'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[](#double-quote-and-single-quote)*ダブルクォートとシングルクォート*'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#double-quote-and-single-quote)*ダブルクォートとシングルクォート*'
- en: '*`"`（ダブルクォート）と`''`（シングルクォート）はまったく同じ意味となります。 PHPやRubyなどとは違い、どちらのリテラルでも評価結果は同じとなります。'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*`"`（ダブルクォート）と`''`（シングルクォート）はまったく同じ意味となります。 PHPやRubyなどとは違い、どちらのリテラルでも評価結果は同じとなります。'
- en: 文字列リテラルは同じ記号で囲む必要があるため、次のように文字列の中に同じ記号が出現した場合は、 `\'`のように`\`（バックスラッシュ）を使ってエスケープしなければなりません。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文字列リテラルは同じ記号で囲む必要があるため、次のように文字列の中に同じ記号が出現した場合は、 `\'`のように`\`（バックスラッシュ）を使ってエスケープしなければなりません。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: また、文字列内部に出現しない別のクォート記号を使うことで、エスケープをせずに書くこともできます。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: また、文字列内部に出現しない別のクォート記号を使うことで、エスケープをせずに書くこともできます。
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できません。 次のように改行を含んだ文字列は定義できないため、構文エラー（`SyntaxError`）となります。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できません。 次のように改行を含んだ文字列は定義できないため、構文エラー（`SyntaxError`）となります。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 改行の代わりに改行記号のエスケープシーケンス（`\n`）を使うことで複数行の文字列を書くことができます。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 改行の代わりに改行記号のエスケープシーケンス（`\n`）を使うことで複数行の文字列を書くことができます。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: シングルクォートとダブルクォートの文字列リテラルに改行を入れるには、エスケープシーケンスを使わないといけません。 これに対してES2015から導入されたテンプレートリテラルでは、複数行の文字列を直感的に書くことができます。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: シングルクォートとダブルクォートの文字列リテラルに改行を入れるには、エスケープシーケンスを使わないといけません。 これに対してES2015から導入されたテンプレートリテラルでは、複数行の文字列を直感的に書くことができます。
- en: '[](#template-literal)*[ES2015] テンプレートリテラル*'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#template-literal)*[ES2015] Template Literals*'
- en: '*テンプレートリテラルは、[PRE21]で囲めば、そのまま書くことができます。'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*テンプレートリテラルは、[PRE21]で囲めば、そのまま書くことができます。'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: また、名前のとおりテンプレートのような機能も持っています。 テンプレートリテラル内で`${変数名}`と書いた場合に、その変数の値を埋め込むことができます。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: また、名前のとおりテンプレートのような機能も持っています。 テンプレートリテラル内で`${変数名}`と書いた場合に、その変数の値を埋め込むことができます。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、`\`を使ってエスケープする必要があります。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、`\`を使ってエスケープする必要があります。
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[](#null-literal)*nullリテラル*'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#null-literal)*nullリテラル*'
- en: '*nullリテラルは`null`値を返すリテラルです。 `null`は「値がない」ということを表現する値です。'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*nullリテラルは`null`値を返すリテラルです。 `null`は「値がない」ということを表現する値です。'
- en: 次のように、未定義の変数を参照した場合は、 参照できないため`ReferenceError`の例外が投げられます。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 次のように、未定義の変数を参照した場合は、参照できないため`ReferenceError`の例外が投げられます。
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 如果想表示`foo`没有值，可以通过赋值`null`来定义一个具有`null`值的`foo`变量。 这样，就可以定义`foo`为一个没有值的变量，并且可以对其进行引用。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果想表示 `foo` has no value, you can define a `foo` variable with a `null` value
    by assignment. In this way, you can define `foo` as a variable without a value
    and reference it.
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[](#undefined-is-not-literal)*[专栏] undefined 不是字面量*'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#undefined-is-not-literal)*[专栏] undefined is not a literal* '
- en: '*作为原始类型介绍的`undefined`并不是字面量。 `undefined`只是一个全局变量，它只有一个名为`undefined`的值。'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为原始类型介绍的`undefined`并不是字面量。 `undefined`只是一个全局变量，它只有一个名为`undefined`的值。'
- en: 可以声明具有相同名称的局部变量，因为`undefined`只是一个全局变量。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以声明具有相同名称的局部变量，因为`undefined`只是一个全局变量。
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 相比之下，像`true`、`false`、`null`等则不是全局变量，而是字面量，因此无法定义具有相同名称的变量。 字面量类似于保留字，因此如果尝试重新定义它们，将会产生语法错误（SyntaxError）。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，像`true`、`false`、`null`等则不是全局变量，而是字面量，因此无法定义具有相同名称的变量。 字面量类似于保留字，因此如果尝试重新定义它们，将会产生语法错误（SyntaxError）。
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 在这里，我们声明了名为`undefined`的局部变量用于解释，但是不推荐重新定义`undefined`。 因为这样只会带来不必要的混乱，所以应该避免。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了名为`undefined`的局部变量用于解释，但是不推荐重新定义`undefined`。 因为这样只会带来不必要的混乱，所以应该避免。
- en: '[](#object)*对象字面量*'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#object)*对象字面量*'
- en: '*在 JavaScript 中，对象是一切的基础。 创建这些对象的方法之一是使用对象字面量。 通过编写`{}`（大括号），可以创建新对象。'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 JavaScript 中，对象是一切的基础。 创建这些对象的方法之一是使用对象字面量。 通过编写`{}`（大括号），可以创建新对象。'
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 对象字面量允许在创建对象的同时定义其内容。 使用`{}`内的键和值以`:`分隔，即可创建并初始化对象。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量允许在创建对象的同时定义其内容。 使用`{}`内的键和值以`:`分隔，即可创建并初始化对象。
- en: 下面的代码创建了一个具有`key`键和值为`"value"`字符串的对象。 键名可以是字符串或 Symbol，值可以是从原始类型到对象的任何内容。
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码创建了一个具有`key`键和值为`"value"`字符串的对象。 键名可以是字符串或 Symbol，值可以是从原始类型到对象的任何内容。
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 在这种情况下，对象具有的键称为属性名。 在这种情况下，`obj`对象具有一个名为`key`的属性。
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对象具有的键称为属性名。 在这种情况下，`obj`对象具有一个名为`key`的属性。
- en: 要引用`obj`的`key`属性，可以使用`.`（点）连接或`[]`（方括号）引用的方式。
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用`obj`的`key`属性，可以使用`.`（点）连接或`[]`（方括号）引用的方式。
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 在点表示法中，属性名必须是标识符。 因此，无法使用类似下面的无法作为标识符的属性名来使用点表示法。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在点表示法中，属性名必须是标识符。 因此，无法使用类似下面的无法作为标识符的属性名来使用点表示法。
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 对象非常重要，因为接下来将介绍的数组和正则表达式都是基于此对象。 详细信息请参见“对象”章节。 在这里，当出现对象字面量（`{`和`}`）时，请理解为正在创建新对象。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对象非常重要，因为接下来将介绍的数组和正则表达式都是基于此对象。 详细信息请参见“对象”章节。 在这里，当出现对象字面量（`{`和`}`）时，请理解为正在创建新对象。
- en: '[](#array)*数组字面量*'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#array)*数组字面量*'
- en: '*除了对象字面量之外，数组字面量也是一种常用的字面量。 数组字面量使用`[`和`]`将值括起来，用逗号分隔，创建一个具有这些值的 Array 对象。
    数组（Array 对象）是一种可以存储多个值并且具有顺序的对象。'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*除了对象字面量之外，数组字面量也是一种常用的字面量。 数组字面量使用`[`和`]`将值括起来，用逗号分隔，创建一个具有这些值的 Array 对象。
    数组（Array 对象）是一种可以存储多个值并且具有顺序的对象。'
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 数组从`0`开始的索引（下标）保持与相应值的关系。 要获取创建的数组的元素，请使用`array[index]`语法指定的索引。
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 数组从`0`开始的索引（下标）保持与相应值的关系。 要获取创建的数组的元素，请使用`array[index]`语法指定的索引。
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 关于数组的详细信息将在“数组”章节中进行解释。
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的详细信息将在“数组”章节中进行解释。
- en: '[](#regexp-literal)*正则表达式字面量*'
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#regexp-literal)*正则表达式字面量*'
- en: '*JavaScript 允许使用字面量编写正则表达式。 正则表达式字面量使用`/`（斜杠）将正则表达式模式字符串括起来。 在正则表达式模式中，特定字符和以`\`（反斜杠）开头的特殊字符具有特殊含义。'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 允许使用字面量编写正则表达式。 正则表达式字面量使用`/`（斜杠）将正则表达式模式字符串括起来。 在正则表达式模式中，特定字符和以`\`（反斜杠）开头的特殊字符具有特殊含义。'
- en: 在下面的代码中，我们使用匹配数字的特殊字符`\d`，并且使用正则表达式字面量表示匹配一个或多个数字的正则表达式。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用匹配数字的特殊字符`\d`，并且使用正则表达式字面量表示匹配一个或多个数字的正则表达式。
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 通过使用`RegExp`构造函数，可以从字符串创建正则表达式对象。 但是，这样做会导致特殊字符的双重转义，使得编写起来不够直观。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`RegExp`构造函数，可以从字符串创建正则表达式对象。 但是，这样做会导致特殊字符的双重转义，使得编写起来不够直观。
- en: 关于正则表达式对象的详细信息将在“字符串”章节中介绍。
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正则表达式对象的详细信息将在“字符串”章节中介绍。
- en: '[](#primitive-and-wrapper-object)*原始类型和包装对象*'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#primitive-and-wrapper-object)*原始类型和包装对象*'
- en: '*原始类型通常以字面量形式表示，但是布尔值（Boolean）、数值（Number）、字符串（String）也可以作为对象来表示。 这些对象称为**包装对象**，它们包装了原始类型的值。'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*原始类型通常以字面量形式表示，但是布尔值（Boolean）、数值（Number）、字符串（String）也可以作为对象来表示。 这些对象称为**包装对象**，它们包装了原始类型的值。'
- en: 使用`new`操作符和相应的构造函数可以创建包装对象。 例如，用于原始字符串的构造函数是`String`。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`操作符和相应的构造函数可以创建包装对象。 例如，用于原始字符串的构造函数是`String`。
- en: 下面的代码创建了`String`的包装对象。 由于包装对象本质上也是对象，因此`typeof`运算符的结果也是`"object"`。 此外，由于它是对象，因此可以访问对象具有的属性，例如`length`属性。
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码创建了`String`的包装对象。 由于包装对象本质上也是对象，因此`typeof`运算符的结果也是`"object"`。 此外，由于它是对象，因此可以访问对象具有的属性，例如`length`属性。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 但是，没有明确使用包装对象的理由。 因为 JavaScript 允许像对象一样引用原始类型的数据，这是因为存在隐式类型转换到包装对象的机制。 在下面的代码中，我们可以访问原始类型的字符串数据的`length`属性。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，没有明确使用包装对象的理由。 因为 JavaScript 允许像对象一样引用原始类型的数据，这是因为存在隐式类型转换到包装对象的机制。 在下面的代码中，我们可以访问原始类型的字符串数据的`length`属性。
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 这是因为在访
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在访问
- en: 关于这种隐式类型转换到包装对象的机制将在“包装对象”章节中进行解释。 目前，只需知道即使是原始类型的数据也可以像对象一样访问属性（包括方法）即可。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种隐式类型转换到包装对象的机制将在“包装对象”章节中进行解释。 目前，只需知道即使是原始类型的数据也可以像对象一样访问属性（包括方法）即可。
- en: '[](#data-type-summary)*摘要*'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#data-type-summary)*摘要*'
- en: '*在本章中，我们学习了有关数据类型和字面量的知识。'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们学习了有关数据类型和字面量的知识。'
- en: 有 7 种原始类型和对象
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有 7 种原始类型和对象
- en: 字面量是一种可以直接描述数据类型值的语法。
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量是一种可以直接描述数据类型值的语法。
- en: プリミティブ型的布尔值、数字、BigInt、字符串、null 都有字面量表示。
  id: totrans-174
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: プリミティブ型的布尔值、数字、BigInt、字符串、null 都有字面量表示。
- en: 对象类型的对象、数组、正则表达式都有字面量表示。
  id: totrans-175
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象类型的对象、数组、正则表达式都有字面量表示。
- en: 即使是原始数据类型也可以访问属性。
  id: totrans-176
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使是原始数据类型也可以访问属性。
- en: ¹. JavaScript 最初在 Netscape 上实现时有一个 bug，`typeof null === "object"`。 由于修复此 bug
    会破坏已经依赖此行为的代码，因此修复被推迟，当前行为成为规范。 有关详细信息，请参阅[`2ality.com/2013/10/typeof-null.html`](https://2ality.com/2013/10/typeof-null.html)。
    ↩******************
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ¹. JavaScript 最初在 Netscape 上实现时有一个 bug，`typeof null === "object"`。 由于修复此 bug
    会破坏已经依赖此行为的代码，因此修复被推迟，当前行为成为规范。 有关详细信息，请参阅[`2ality.com/2013/10/typeof-null.html`](https://2ality.com/2013/10/typeof-null.html)。
    ↩******************
