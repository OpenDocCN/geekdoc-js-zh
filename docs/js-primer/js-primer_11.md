# データ型とリテラル

> 原文：[`jsprimer.net/basic/data-type/`](https://jsprimer.net/basic/data-type/)

## [](#data-type)*データ型*

*JavaScriptは動的型付け言語に分類される言語であるため、静的型付け言語のような**変数の型**はありません。 しかし、文字列、数値、真偽値といった**値の型**は存在します。 これらの値の型のことを**データ型**と呼びます。

データ型を大きく分けると、**プリミティブ型**と**オブジェクト**の2つに分類されます。

プリミティブ型（基本型）は、真偽値や数値などの基本的な値の型のことです。 プリミティブ型の値は、一度作成したらその値自体を変更できないというイミュータブル（immutable）の特性を持ちます。 JavaScriptでは、文字列も一度作成したら変更できないイミュータブルの特性を持ち、プリミティブ型の一種として扱われます。

一方、プリミティブ型ではないものをオブジェクト（複合型）と呼び、 オブジェクトは複数のプリミティブ型の値またはオブジェクトからなる集合です。 オブジェクトは、一度作成した後もその値自体を変更できるためミュータブル（mutable）の特性を持ちます。 オブジェクトは、値そのものではなく値への参照を経由して操作されるため、参照型のデータとも言います。

データ型を細かく見ていくと、7つのプリミティブ型とオブジェクトからなります。

+   プリミティブ型（基本型）

    +   真偽値（Boolean）: `true`または`false`のデータ型

    +   数値（Number）: `42` や `3.14159` などの数値のデータ型

    +   巨大な整数（BigInt）: ES2020から追加された`9007199254740992n`などの任意精度の整数のデータ型

    +   文字列（String）: `"JavaScript"` などの文字列のデータ型

    +   undefined: 値が未定義であることを意味するデータ型

    +   null: 値が存在しないことを意味するデータ型

    +   シンボル（Symbol）: ES2015から追加された一意で不変な値のデータ型

+   オブジェクト（複合型）

    +   プリミティブ型以外のデータ

    +   オブジェクト、配列、関数、クラス、正規表現、Dateなど

プリミティブ型でないものは、オブジェクトであると覚えていれば問題ありません。

`typeof`演算子を使うことで、次のようにデータ型を調べることができます。

```
console.log(typeof true);// => "boolean"
console.log(typeof 42); // => "number"
console.log(typeof 9007199254740992n); // => "bigint"
console.log(typeof "JavaScript"); // => "string"
console.log(typeof Symbol("シンボル"));// => "symbol"
console.log(typeof undefined); // => "undefined"
console.log(typeof null); // => "object"
console.log(typeof ["配列"]); // => "object"
console.log(typeof { "key": "value" }); // => "object"
console.log(typeof function() {}); // => "function" 
```

プリミティブ型の値は、それぞれ`typeof`演算子の評価結果として、その値のデータ型を返します。 一方で、オブジェクトに分類される値は`"object"`となります。

配列(`[]`)とオブジェクト(`{}`)は、どちらも`"object"`という判定結果になります。 そのため、`typeof`演算子ではオブジェクトの詳細な種類を正しく判定することはできません。 ただし、関数はオブジェクトの中でも特別扱いされているため、`typeof`演算子の評価結果は`"function"`となります。 また、`typeof null`が`"object"`となるのは、歴史的経緯のある仕様のバグ^(1)です。

このことからもわかるように`typeof`演算子は、プリミティブ型またはオブジェクトかを判別するものです。 `typeof`演算子では、オブジェクトの詳細な種類を判定できないことは、覚えておくとよいでしょう。 各オブジェクトの判定方法については、それぞれのオブジェクトの章で見ていきます。

## [](#literal)*リテラル*

*プリミティブ型の値や一部のオブジェクトは、**リテラル**を使うことで簡単に定義できるようになっています。

リテラルとはプログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたものです。 たとえば、`"`と`"`で囲んだ範囲が文字列リテラルで、これは文字列型のデータを表現しています。

次のコードでは、`"こんにちは"`という文字列型のデータを初期値に持つ変数`str`を定義しています。

```
// "と"で囲んだ範囲が文字列リテラル
const str = "こんにちは"; 
```

リテラル表現がない場合は、その値を作る関数に引数を渡して作成する形になります。 そのような冗長な表現を避ける方法として、よく利用される主要なデータ型にはリテラルが用意されています。

次の5つのプリミティブ型は、それぞれリテラル表現を持っています。

+   真偽値

+   数値

+   BigInt

+   文字列

+   null

また、オブジェクトの中でもよく利用されるものに関してはリテラル表現が用意されています。

+   オブジェクト

+   配列

+   正規表現

これらのリテラルについて、まずはプリミティブ型から順番に見ていきます。

### [](#boolean)*真偽値（Boolean）*

*真偽値には`true`と`false`のリテラルがあります。 それぞれは`true`と`false`の値を返すリテラルで、見た目どおりの意味となります。

```
true; // => true
false; // => false 
```

### [](#number)*数値（Number）*

*数値には`42`のような整数リテラルと`3.14159`のような浮動小数点数リテラルがあります。

これらのリテラルで表現できる数値は[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)の倍精度浮動小数として扱われます。 倍精度浮動小数では64ビットで数値を表現します。 64ビットのうち52ビットを数字の格納のために使い、11ビットを小数点の位置に使い、残りの1ビットはプラスとマイナスの符号です。 そのため、正確に扱える数値の最大値は`2⁵³-1`（2の53 乗から1 引いた値）となります。

#### [](#integer-literal)*整数リテラル*

*整数リテラルには次の4 種類があります。

+   10 進数: 数字の組み合わせ

    +   ただし、複数の数字を組み合わせた際に、先頭を`0`から開始すると8 進数として扱われる場合があります

    +   例）`0`、`2`、`10`

+   2 進数: `0b`（または`0B`）の後ろに、`0`または`1`の数字の組み合わせ

    +   例）`0b0`、`0b10`、`0b1010`

+   8 進数: `0o`（または`0O`）の後ろに、`0`から`7`までの数字の組み合わせ

    +   `0o` は数字のゼロと小文字アルファベットの`o`

    +   例）`0o644`、`0o777`

+   16 進数: `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ

    +   アルファベットの大文字・小文字の違いは値には影響しません

    +   例）`0x30A2`、`0xEEFF`

0から9の数字のみで書かれた数値は、10 進数として扱われます。

```
console.log(1); // => 1
console.log(10); // => 10
console.log(255); // => 255 
```

`0b`からはじまる2 進数リテラルは、ビットを表現するのによく利用されています。 `b`は2 進数を表すbinaryを意味しています。

```
console.log(0b1111); // => 15
console.log(0b10000000000); // => 1024 
```

`0o`からはじまる8 進数リテラルは、ファイルのパーミッションを表現するのによく利用されています。 `o`は8 進数を表すoctalを意味しています。

```
console.log(0o644);  // => 420
console.log(0o777);  // => 511 
```

次のように、`0`からはじまり、`0`から`7`の数字を組み合わせた場合も8 進数として扱われます。 しかし、この表記は10 進数と紛らわしいものであったため、ES2015で`0o`の8 進数リテラルが新たに導入されました。 また、strict modeではこの書き方は例外が発生するため、次のような8 進数の書き方は避けるべきです（詳細は「JavaScriptとは」のstrict modeを参照）。

```
// 非推奨な8 進数の書き方
// strict modeは例外が発生
console.log(0644);  // => 420
console.log(0777);  // => 511 
```

`0x`からはじまる16 進数リテラルは、文字のコードポイントやRGB 値の表現などに利用されています。 `x`は16 進数を表すhexを意味しています。

```
console.log(0xFF); // => 255
// 小文字で書いても意味は同じ
console.log(0xff); // => 255
console.log(0x30A2); // => 12450 
```

| 名前 | 表記例 | 用途 |
| --- | --- | --- |
| 10 進数 | 42 | 数値 |
| 2 進数 | 0b0001 | ビット演算など |
| 8 進数 | 0o777 | ファイルのパーミッションなど |
| 16 進数 | 0xEEFF | 文字のコードポイント、RGB 値など |

#### [](#floating-point-number-literal)*浮動小数点数リテラル*

*浮動小数点数をリテラルとして書く場合には、次の2 種類の表記が利用できます。

+   `3.14159` のような `.`（ドット）を含んだ数値

+   `2e8` のような `e` または `E` を含んだ数値

`0`からはじまる浮動小数点数は、`0`を省略して書くことができます。

```
.123; // => 0.123 
```

しかし、JavaScriptでは`.`をオブジェクトにおいて利用する機会が多いため、 `0`からはじまる場合でも省略せずに書いたほうが意図しない挙動を減らせるでしょう。

> **Note** 変数名を数字からはじめることができないのは、数値リテラルと衝突してしまうからです。

`e`は指数（exponent）を意味する記号で、`e`のあとには指数部の値を書きます。 たとえば、`2e8`は2×10の8 乗となるので、10 進数で表すと`200000000`となります。

```
2e8; // => 200000000 
```

### [](#bigint-literal)*[ES2020] BigInt*

*JavaScriptでは、`1`や`3.14159`などの数値リテラルは[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)で定義された倍精度浮動小数となります。 倍精度浮動小数で正確に扱える数値の最大値は`2⁵³-1`（2の53 乗から1 引いた値である`9007199254740991`）です。 この数値リテラルで安全に表せる最大の数値は`Number.MAX_SAFE_INTEGER`として定義されています。

```
console.log(Number.MAX_SAFE_INTEGER); // => 9007199254740991 
```

数値リテラルで`2⁵³-1`（`9007199254740991`）よりも大きな値を表現したり計算すると間違った結果となる場合があります。

この問題を解決するために、ES2020では`BigInt`という新しい整数型のデータ型とリテラルが追加されました。 数値リテラルは倍精度浮動小数（64ビット）で数値を扱うのに対して、BigIntでは任意の精度の整数を扱えます。 そのため、BigIntでは`2⁵³-1`（`9007199254740991`）よりも大きな整数を正しく表現できます。

BigIntリテラルは、数値の後ろに`n`をつけます。

```
console.log(1n); // => 1n
// 2⁵³-1より大きな値も扱える
console.log(9007199254740992n); // => 9007199254740992n 
```

BigIntは整数を扱うデータ型であるため、次のように小数点を含めた場合は構文エラーとなります。

```
1.2n; // => SyntaxError 
```

### [](#numeric-separators)*[ES2021] Numeric Separators*

*数値が大きくなるほど、桁数の見間違いなどが発生しやすくなります。 次のコードは、1 兆を数値リテラルで書いていますが、桁数を読み取りにくいです。

```
1000000000000; 
```

ES2021から、数値リテラル内の区切り文字として`_`を追加できるNumeric Separatorsがサポートされています。 Numeric Separatorsは、数値リテラル内では区切り文字として`_`が追加できます。 次のコードも、1 兆を数値リテラルで書いています。数値リテラルを評価する際に`_`は単純に無視されるため同じ意味となります。

```
1_000_000_000_000; 
```

Numeric Separatorsは数値リテラルである整数、浮動小数点、BigIntのリテラル内でのみ利用できます。 また、`_`はリテラルの先頭や数値の最後に追加することはできません。

```
_123; // 変数として評価される
3._14; // => SyntaxError
0x52_; // => SyntaxError
1234n_; // => SyntaxError 
```

### [](#string)*文字列（String）*

*文字列リテラル共通のルールとして、同じ記号で囲んだ内容を文字列として扱います。 文字列リテラルとして次の3 種類のリテラルがありますが、その評価結果はすべて同じ`"文字列"`になります。

```
console.log("文字列"); // => "文字列"
console.log('文字列'); // => "文字列"
console.log(`文字列`); // => "文字列" 
```

#### [](#double-quote-and-single-quote)*ダブルクォートとシングルクォート*

*`"`（ダブルクォート）と`'`（シングルクォート）はまったく同じ意味となります。 PHPやRubyなどとは違い、どちらのリテラルでも評価結果は同じとなります。

文字列リテラルは同じ記号で囲む必要があるため、次のように文字列の中に同じ記号が出現した場合は、 `\'`のように`\`（バックスラッシュ）を使ってエスケープしなければなりません。

```
'8 o\'clock'; // => "8 o'clock" 
```

また、文字列内部に出現しない別のクォート記号を使うことで、エスケープをせずに書くこともできます。

```
"8 o'clock"; // => "8 o'clock" 
```

ダブルクォートとシングルクォートどちらも、改行をそのままでは入力できません。 次のように改行を含んだ文字列は定義できないため、構文エラー（`SyntaxError`）となります。

```
"複数行の
文字列を
入れたい"; // => SyntaxError: "" string literal contains an unescaped line break 
```

改行の代わりに改行記号のエスケープシーケンス（`\n`）を使うことで複数行の文字列を書くことができます。

```
"複数行の\n 文字列を\n 入れたい"; 
```

シングルクォートとダブルクォートの文字列リテラルに改行を入れるには、エスケープシーケンスを使わないといけません。 これに対してES2015から導入されたテンプレートリテラルでは、複数行の文字列を直感的に書くことができます。

#### [](#template-literal)*[ES2015] テンプレートリテラル*

*テンプレートリテラルは、```（バッククォート）で囲んだ範囲を文字列とするリテラルです。 テンプレートリテラルでは、複数行の文字列を改行記号のエスケープシーケンス（`\n`）を使わずにそのまま書くことができます。

複数行の文字列も```で囲めば、そのまま書くことができます。

```
`複数行の
文字列を
入れたい`; // => "複数行の\n 文字列を\n 入れたい" 
```

また、名前のとおりテンプレートのような機能も持っています。 テンプレートリテラル内で`${変数名}`と書いた場合に、その変数の値を埋め込むことができます。

```
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です" 
```

テンプレートリテラルも他の文字列リテラルと同様に同じリテラル記号を内包したい場合は、`\`を使ってエスケープする必要があります。

```
`This is \`code\``;// => "This is `code`" 
```

### [](#null-literal)*nullリテラル*

*nullリテラルは`null`値を返すリテラルです。 `null`は「値がない」ということを表現する値です。

次のように、未定義の変数を参照した場合は、 参照できないため`ReferenceError`の例外が投げられます。

```
foo;// "ReferenceError: foo is not defined" 
```

如果想表示`foo`没有值，可以通过赋值`null`来定义一个具有`null`值的`foo`变量。 这样，就可以定义`foo`为一个没有值的变量，并且可以对其进行引用。

```
const foo = null;
console.log(foo); // => null 
```

## [](#undefined-is-not-literal)*[专栏] undefined 不是字面量*

*作为原始类型介绍的`undefined`并不是字面量。 `undefined`只是一个全局变量，它只有一个名为`undefined`的值。

可以声明具有相同名称的局部变量，因为`undefined`只是一个全局变量。

```
function fn(){
    const undefined = "独自の未定義値"; // undefinedという名前の変数をエラーなく定義できる
    console.log(undefined); // => "独自の未定義値"
}
fn(); 
```

相比之下，像`true`、`false`、`null`等则不是全局变量，而是字面量，因此无法定义具有相同名称的变量。 字面量类似于保留字，因此如果尝试重新定义它们，将会产生语法错误（SyntaxError）。

```
let null; // => SyntaxError 
```

在这里，我们声明了名为`undefined`的局部变量用于解释，但是不推荐重新定义`undefined`。 因为这样只会带来不必要的混乱，所以应该避免。

### [](#object)*对象字面量*

*在 JavaScript 中，对象是一切的基础。 创建这些对象的方法之一是使用对象字面量。 通过编写`{}`（大括号），可以创建新对象。

```
const obj = {}; // 中身が空のオブジェクトを作成 
```

对象字面量允许在创建对象的同时定义其内容。 使用`{}`内的键和值以`:`分隔，即可创建并初始化对象。

下面的代码创建了一个具有`key`键和值为`"value"`字符串的对象。 键名可以是字符串或 Symbol，值可以是从原始类型到对象的任何内容。

```
const obj = {
    "key": "value"
}; 
```

在这种情况下，对象具有的键称为属性名。 在这种情况下，`obj`对象具有一个名为`key`的属性。

要引用`obj`的`key`属性，可以使用`.`（点）连接或`[]`（方括号）引用的方式。

```
const obj = {
    "key": "value"
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value" 
```

在点表示法中，属性名必须是标识符。 因此，无法使用类似下面的无法作为标识符的属性名来使用点表示法。

```
// プロパティ名は文字列の"123"
const object = {
    "123": "value"
};
// OK: ブラケット記法では、文字列として書くことができる
console.log(object["123"]); // => "value"
// NG: ドット記法では、数値からはじまる識別子は利用できない
object.123 
```

对象非常重要，因为接下来将介绍的数组和正则表达式都是基于此对象。 详细信息请参见“对象”章节。 在这里，当出现对象字面量（`{`和`}`）时，请理解为正在创建新对象。

### [](#array)*数组字面量*

*除了对象字面量之外，数组字面量也是一种常用的字面量。 数组字面量使用`[`和`]`将值括起来，用逗号分隔，创建一个具有这些值的 Array 对象。 数组（Array 对象）是一种可以存储多个值并且具有顺序的对象。

```
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成 
```

数组从`0`开始的索引（下标）保持与相应值的关系。 要获取创建的数组的元素，请使用`array[index]`语法指定的索引。

```
const array = ["index:0", "index:1", "index:2"];
// 0 番目の要素を参照
console.log(array[0]); // => "index:0"
// 1 番目の要素を参照
console.log(array[1]); // => "index:1" 
```

关于数组的详细信息将在“数组”章节中进行解释。

### [](#regexp-literal)*正则表达式字面量*

*JavaScript 允许使用字面量编写正则表达式。 正则表达式字面量使用`/`（斜杠）将正则表达式模式字符串括起来。 在正则表达式模式中，特定字符和以`\`（反斜杠）开头的特殊字符具有特殊含义。

在下面的代码中，我们使用匹配数字的特殊字符`\d`，并且使用正则表达式字面量表示匹配一个或多个数字的正则表达式。

```
const numberRegExp = /\d+/; // 1 文字以上の数字にマッチする正規表現
// `numberRegExp`の正規表現が文字列"123"にマッチするかをテストする
console.log(numberRegExp.test("123")); // => true 
```

通过使用`RegExp`构造函数，可以从字符串创建正则表达式对象。 但是，这样做会导致特殊字符的双重转义，使得编写起来不够直观。

关于正则表达式对象的详细信息将在“字符串”章节中介绍。

## [](#primitive-and-wrapper-object)*原始类型和包装对象*

*原始类型通常以字面量形式表示，但是布尔值（Boolean）、数值（Number）、字符串（String）也可以作为对象来表示。 这些对象称为**包装对象**，它们包装了原始类型的值。

使用`new`操作符和相应的构造函数可以创建包装对象。 例如，用于原始字符串的构造函数是`String`。

下面的代码创建了`String`的包装对象。 由于包装对象本质上也是对象，因此`typeof`运算符的结果也是`"object"`。 此外，由于它是对象，因此可以访问对象具有的属性，例如`length`属性。

```
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3 
```

但是，没有明确使用包装对象的理由。 因为 JavaScript 允许像对象一样引用原始类型的数据，这是因为存在隐式类型转换到包装对象的机制。 在下面的代码中，我们可以访问原始类型的字符串数据的`length`属性。

```
// プリミティブ型の文字列データ
const str = "文字列";
// プリミティブ型の文字列は"string"型のデータ
console.log(typeof str); // => "string"
// プリミティブ型の文字列も`length`プロパティを参照できる
console.log(str.length); // => 3 
```

这是因为在访

关于这种隐式类型转换到包装对象的机制将在“包装对象”章节中进行解释。 目前，只需知道即使是原始类型的数据也可以像对象一样访问属性（包括方法）即可。

## [](#data-type-summary)*摘要*

*在本章中，我们学习了有关数据类型和字面量的知识。

+   有 7 种原始类型和对象

+   字面量是一种可以直接描述数据类型值的语法。

+   -   プリミティブ型的布尔值、数字、BigInt、字符串、null 都有字面量表示。

+   -   对象类型的对象、数组、正则表达式都有字面量表示。

+   -   即使是原始数据类型也可以访问属性。

> -   ¹. JavaScript 最初在 Netscape 上实现时有一个 bug，`typeof null === "object"`。 由于修复此 bug 会破坏已经依赖此行为的代码，因此修复被推迟，当前行为成为规范。 有关详细信息，请参阅[`2ality.com/2013/10/typeof-null.html`](https://2ality.com/2013/10/typeof-null.html)。 ↩******************
