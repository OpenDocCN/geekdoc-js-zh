["```（バッククォート）の3 種類があります。\n\nまずは`\"`（ダブルクォート）と`'`（シングルクォート）について見ていきます。\n\n`\"`（ダブルクォート）と`'`（シングルクォート）に意味的な違いはありません。 そのため、どちらを使うかは好みやプロジェクトごとのコーディング規約によって異なります。 この書籍では、`\"`（ダブルクォート）を主な文字列リテラルとして利用します。\n\n```", "```\n\nES2015では、テンプレートリテラル ```", "```（バッククォート）を利用することで文字列を作成できる点は、他の文字列リテラルと同じです。\n\nこれに加えてテンプレートリテラルでは、文字列中に改行を入力できます。 次のコードでは、テンプレートリテラルを使って複数行の文字列を見た目どおりに定義しています。\n\n```", "```\n\nどの文字列リテラルでも共通ですが、文字列リテラルは同じ記号が対になります。 そのため、文字列の中にリテラルと同じ記号が出現した場合は、`\\`（バックスラッシュ）を使いエスケープする必要があります。 次のコードでは、文字列中の`\"`を`\\\"`のようにエスケープしています。\n\n```", "```\n\n## [](#escape-sequence)*エスケープシーケンス*\n\n *文字列リテラル中にはそのままでは入力できない特殊な文字もあります。 改行もそのひとつで、`\"`（ダブルクォート）と`'`（シングルクォート）の文字列リテラルには改行をそのまま入力できません （テンプレートリテラル中には例外的に改行をそのまま入力できます）。\n\n次のコードは、JavaScriptの構文として正しくないため、構文エラー（SyntaxError）となります。\n\n```", "```\n\nこの問題を回避するためには、改行のような特殊な文字をエスケープシーケンスとして書く必要があります。 エスケープシーケンスは、`\\`と特定の文字を組み合わせることで、特殊文字を表現します。\n\n次の表では、代表的な[エスケープシーケンス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/String#%E3%82%A8%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%97%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B9)を紹介しています。 エスケープシーケンスは、`\"`（ダブルクォート）、`'`（シングルクォート）、```", "```\n// 改行を\\nのエスケープシーケンスとして入力している\nconst multiline = \"1 行目\\n2 行目\\n3 行目\";\nconsole.log(multiline); \n/* 改行した結果が出力される\n1 行目\n2 行目\n3 行目\n*/ \n```", "```\nconsole.log(\"¯\\_(ツ)_/¯\");\n// ¯_(ツ)_/¯ のように\\が無視されて表示される \n```", "```\nconsole.log(\"¯\\\\_(ツ)_/¯\");\n//　¯\\_(ツ)_/¯ と表示される \n```", "```\nconst str = \"a\" + \"b\";\nconsole.log(str); // => \"ab\" \n```", "```\nconst name = \"JavaScript\";\nconsole.log(\"Hello \" + name + \"!\");// => \"Hello JavaScript!\" \n```", "```\nconst name = \"JavaScript\";\nconsole.log(`Hello ${name}!`);// => \"Hello JavaScript!\" \n```", "```\nconst str = \"文字列\";\n// 配列と同じようにインデックスでアクセスできる\nconsole.log(str[0]); // => \"文\"\nconsole.log(str[1]); // => \"字\"\nconsole.log(str[2]); // => \"列\" \n```", "```\nconst str = \"文字列\";\n// 42 番目の要素は存在しない\nconsole.log(str[42]); // => undefined \n```", "```\nconst str = \"文字列\";\nconsole.log(str.at(0)); // => \"文\"\nconsole.log(str.at(1)); // => \"字\"\nconsole.log(str.at(2)); // => \"列\"\nconsole.log(str.at(-1)); // => \"列\" \n```", "```\nconst str = \"アオイ\";\n// それぞれの文字をCode Unitのhex 値（16 進数）に変換する\n// toStringの引数に16を渡すと16 進数に変換される\nconsole.log(str.charCodeAt(0).toString(16)); // => \"30a2\"\nconsole.log(str.charCodeAt(1).toString(16)); // => \"30aa\"\nconsole.log(str.charCodeAt(2).toString(16));  // => \"30a4\" \n```", "```\nconst str = String.fromCharCode(\n    0x30a2, // アのCode Unit\n    0x30aa, // オのCode Unit\n    0x30a4  // イのCode Unit\n);\nconsole.log(str); // => \"アオイ\" \n```", "```\nconst strings = \"赤・青・緑\".split(\"・\");\nconsole.log(strings); // => [\"赤\", \"青\", \"緑\"] \n```", "```\nconst str = \"赤・青・緑\".split(\"・\").join(\"、\");\nconsole.log(str); // => \"赤、青、緑\" \n```", "```\n// 文字間に1つ以上のスペースがある\nconst str = \"a     b    c      d\";\n// 1つ以上のスペースにマッチして分解する\nconst strings = str.split(/\\s+/);\nconsole.log(strings); // => [\"a\", \"b\", \"c\", \"d\"] \n```", "```\nconsole.log(\"文字列\".length); // => 3 \n```", "```\nconsole.log(\"\".length); // => 0 \n```", "```\nconsole.log(\"文字列\" === \"文字列\"); // => true\n// 一致しなければfalseとなる\nconsole.log(\"JS\" === \"ES\"); // => false\n// 文字列の長さが異なるのでfalseとなる\nconsole.log(\"文字列\" === \"文字\"); // => false \n```", "```\n// \"A\"と\"B\"のCode Unitは65と66\nconsole.log(\"A\".charCodeAt(0)); // => 65\nconsole.log(\"B\".charCodeAt(0)); // => 66\n// \"A\"（65）は\"B\"（66）よりCode Unitの値が小さい\nconsole.log(\"A\" > \"B\"); // => false\n// 先頭から順番に比較し C > D が falseであるため\nconsole.log(\"ABC\" > \"ABD\"); // => false \n```", "```\nconst str = \"ABCDE\";\nconsole.log(str.slice(1)); // => \"BCDE\"\nconsole.log(str.slice(1, 5)); // => \"BCDE\"\n// マイナスを指定すると後ろからの位置となる\nconsole.log(str.slice(-1)); // => \"E\"\n// インデックスが1から4の範囲を取り出す\nconsole.log(str.slice(1, 4)); // => \"BCD\"\n// 第一引数 > 第二引数の場合、常に空文字列を返す\nconsole.log(str.slice(4, 1)); // => \"\" \n```", "```\nconst str = \"ABCDE\";\nconsole.log(str.substring(1)); // => \"BCDE\"\nconsole.log(str.substring(1, 5)); // => \"BCDE\"\n// マイナスを指定すると0として扱われる\nconsole.log(str.substring(-1)); // => \"ABCDE\"\n// 位置:1から4の範囲を取り出す\nconsole.log(str.substring(1, 4)); // => \"BCD\"\n// 第一引数 > 第二引数の場合、引数が入れ替わる\n// str.substring(1, 4)と同じ結果になる\nconsole.log(str.substring(4, 1)); // => \"BCD\" \n```", "```\nconst url = \"https://example.com?param=1\";\nconst indexOfQuery = url.indexOf(\"?\");\nconst queryString = url.slice(indexOfQuery);\nconsole.log(queryString); // => \"?param=1\" \n```", "```\n// 検索対象となる文字列\nconst str = \"にわにはにわにわとりがいる\";\n// indexOfは先頭から検索しインデックスを返す - \"**にわ**にはにわにわとりがいる\"\n// \"にわ\"の先頭のインデックスを返すため 0 となる\nconsole.log(str.indexOf(\"にわ\")); // => 0\n// lastIndexOfは末尾から検索しインデックスを返す- \"にわにはにわ**にわ**とりがいる\"\nconsole.log(str.lastIndexOf(\"にわ\")); // => 6\n// 指定した文字列が見つからない場合は -1 を返す\nconsole.log(str.indexOf(\"未知のキーワード\")); // => -1 \n```", "```\nconst str = \"JavaScript\";\nconst searchWord = \"Script\";\nconst index = str.indexOf(searchWord);\nif (index !== -1) {\n    console.log(`${searchWord}が見つかりました`);\n} else {\n    console.log(`${searchWord}は見つかりませんでした`);\n} \n```", "```\n// 検索対象となる文字列\nconst str = \"にわにはにわにわとりがいる\";\n// startsWith - 検索文字列が先頭ならtrue\nconsole.log(str.startsWith(\"にわ\")); // => true\nconsole.log(str.startsWith(\"いる\")); // => false\n// endsWith - 検索文字列が末尾ならtrue\nconsole.log(str.endsWith(\"にわ\")); // => false\nconsole.log(str.endsWith(\"いる\")); // => true\n// includes - 検索文字列が含まれるならtrue\nconsole.log(str.includes(\"にわ\")); // => true\nconsole.log(str.includes(\"いる\")); // => true \n```", "```\n\\ ^ $ . * + ? ( ) [ ] { } | \n```", "```\n// 正規表現リテラルで正規表現オブジェクトを作成\nconst patternA = /パターン/フラグ;\n// `RegExp`コンストラクタで正規表現オブジェクトを作成\nconst patternB = new RegExp(\"パターン文字列\", \"フラグ\"); \n```", "```\nconst pattern = /a+/; \n```", "```\nconst pattern = new RegExp(\"a+\"); \n```", "```\n// 正規表現リテラルはロード時にパターンが評価され、例外が発生する\nfunction main() {\n    // `[`は対となる`]`を組み合わせる特殊文字であるため、単独で書けない\n    const invalidPattern = /[/;\n}\n\n// `main`関数を呼び出さなくても例外が発生する \n```", "```\n// `RegExp`コンストラクタは実行時にパターンが評価され、例外が発生する\nfunction main() {\n    // `[`は対となる`]`を組み合わせる特殊文字であるため、単独で書けない\n    const invalidPattern = new RegExp(\"\");\n}\n\n// `main`関数を呼び出すことで初めて例外が発生する\nmain(); \n```", "```\n// 3つの連続するスペースなどにマッチする正規表現\nconst pattern = /\\s{3}/; \n```", "```\nconst spaceCount = 3;\n// `/\\s{3}/`の正規表現を文字列から作成する\n// \"\\\"がエスケープ文字であるため、\"\\\"自身を文字列として書くには、\"\\\\\"のように2つ書く\nconst pattern = new RegExp(`\\\\s{${spaceCount}}`); \n```", "```\nconst str = \"ABC123EFG\";\nconst searchPattern = /\\d{3}/;\nconsole.log(str.search(searchPattern)); // => 3 \n```", "```\nconst str = \"abc123def\";\n// 連続した数字にマッチする正規表現\nconst searchPattern = /\\d+/;\nconst index = str.search(searchPattern); // => 3\n// `index` だけではマッチした文字列の長さがわからない\nstr.slice(index, index + マッチした文字列の長さ); // マッチした文字列は取得できない \n```", "```\n\"文字列\".match(/パターン/); \n```", "```\nconsole.log(\"文字列\".match(/マッチしないパターン/)); // => null \n```", "```\nconst str = \"ABC あいう DE えお\";\nconst alphabetsPattern = /[a-zA-Z]+/;\n// gフラグなしでは、最初の結果のみを含んだ特殊な配列を返す\nconst results = str.match(alphabetsPattern);\nconsole.log(results.length); // => 1\n// マッチした文字列はインデックスでアクセスできる\nconsole.log(results[0]); // => \"ABC\"\n// マッチした文字列の先頭のインデックス\nconsole.log(results.index); // => 0\n// 検索対象となった文字列全体\nconsole.log(results.input); // => \"ABC あいう DE えお\" \n```", "```\nconst str = \"ABC あいう DE えお\";\nconst alphabetsPattern = /[a-zA-Z]+/g;\n// gフラグありでは、すべての検索結果を含む配列を返す\nconst resultsWithG = str.match(alphabetsPattern);\nconsole.log(resultsWithG.length); // => 2\nconsole.log(resultsWithG[0]); // => \"ABC\"\nconsole.log(resultsWithG[1]); // => \"DE\"\n// indexとinputはgフラグありの場合は追加されない\nconsole.log(resultsWithG.index); // => undefined\nconsole.log(resultsWithG.input); // => undefined \n```", "```\nconst str = \"ABC あいう DE えお\";\nconst alphabetsPattern = /[a-zA-Z]+/g;\n// matchAllはIteratorを返す\nconst matchesIterator = str.matchAll(alphabetsPattern);\nfor (const match of matchesIterator) {\n    // マッチした要素ごとの情報を含んでいる\n    console.log(`match: \"${match[0]}\", index: ${match.index}, input: \"${match.input}\"`);\n}\n// 次の順番でコンソールに出力される\n// match: \"ABC\", index: 0, input: \"ABC あいう DE えお\"\n// match: \"DE\", index: 8, input: \"ABC あいう DE えお\" \n```", "```\nconst [マッチした全体の文字列, キャプチャ1, キャプチャ2] = 文字列.match(/パターン(キャプチャ1)と(キャプチャ2)/); \n```", "```\n// \"ECMAScript (数字+)\"にマッチするが、欲しい文字列は数字の部分のみ\nconst pattern = /ECMAScript (\\d+)/;\n// 返り値は0 番目がマッチした全体、1 番目がキャプチャの1 番目というように対応している\n// [マッチした全部の文字列, キャプチャの1 番目, キャプチャの2 番目 ....]\nconst [all, capture1] = \"ECMAScript 6\".match(pattern);\nconsole.log(all); // => \"ECMAScript 6\"\nconsole.log(capture1); // => \"6\" \n```", "```\n// \"ES(数字+)\"にマッチするが、欲しい文字列は数字の部分のみ\nconst pattern = /ES(\\d+)/g;\n// iteratorを返す\nconst matchesIterator = \"ES2015、ES2016、ES2017\".matchAll(pattern);\nfor (const match of matchesIterator) {\n    // マッチした要素ごとの情報を含んでいる\n    // 0 番目はマッチした文字列全体、1 番目がキャプチャの1 番目である数字\n    console.log(`match: \"${match[0]}\", capture1: ${match[1]}, index: ${match.index}, input: \"${match.input}\"`);\n}\n// 次の順番でコンソールに出力される\n// match: \"ES2015\", capture1: 2015, index: 0, input: \"ES2015、ES2016、ES2017\"\n// match: \"ES2016\", capture1: 2016, index: 7, input: \"ES2015、ES2016、ES2017\"\n// match: \"ES2017\", capture1: 2017, index: 14, input: \"ES2015、ES2016、ES2017\" \n```", "```\n/pattern/.exec(\"文字列\"); \n```", "```\nconst str = \"ABC あいう DE えお\";\nconst alphabetsPattern = /[a-zA-Z]+/;\n// gフラグなしでは、最初の結果のみを持つ配列を返す\nconst results = alphabetsPattern.exec(str);\nconsole.log(results.length); // => 1\nconsole.log(results[0]); // => \"ABC\"\n// マッチした文字列の先頭のインデックス\nconsole.log(results.index); // => 0\n// 検索対象となった文字列全体\nconsole.log(results.input); // => \"ABC あいう DE えお\" \n```", "```\nconst str = \"ABC あいう DE えお\";\nconst alphabetsPattern = /[a-zA-Z]+/g;\n// まだ一度も検索していないので、lastIndexは0となり先頭から検索が開始される\nconsole.log(alphabetsPattern.lastIndex); // => 0\n// gフラグありでも、一回目の結果は同じだが、`lastIndex`プロパティが更新される\nconst result1 = alphabetsPattern.exec(str);\nconsole.log(result1[0]); // => \"ABC\"\nconsole.log(alphabetsPattern.lastIndex); // => 3\n// 2 回目の検索が、`lastIndex`の値のインデックスから開始される\nconst result2 = alphabetsPattern.exec(str);\nconsole.log(result2[0]); // => \"DE\"\nconsole.log(alphabetsPattern.lastIndex); // => 10\n// 検索結果が見つからない場合はnullを返し、`lastIndex`プロパティは0にリセットされる\nconst result3 = alphabetsPattern.exec(str);\nconsole.log(result3); // => null\nconsole.log(alphabetsPattern.lastIndex); // => 0 \n```", "```\nconst str = \"ABC あいう DE えお\";\nconst alphabetsPattern = /[a-zA-Z]+/g;\nlet matches;\nwhile (matches = alphabetsPattern.exec(str)) {\n    // RegExpの`exec`メソッドの返り値は`index`プロパティなどを含む特殊な配列\n    console.log(`match: ${matches[0]}, index: ${matches.index}, lastIndex: ${alphabetsPattern.lastIndex}`);\n}\n// 次の順番でコンソールに出力される\n// match: ABC, index: 0, lastIndex: 3\n// match: DE, index: 8, lastIndex: 10 \n```", "```\n// 検索対象となる文字列\nconst str = \"にわにはにわにわとりがいる\";\n// ^ - 検索文字列が先頭ならtrue\nconsole.log(/^にわ/.test(str)); // => true\nconsole.log(/^いる/.test(str)); // => false\n// $ - 検索文字列が末尾ならtrue\nconsole.log(/にわ$/.test(str)); // => false\nconsole.log(/いる$/.test(str)); // => true\n// 検索文字列が含まれるならtrue\nconsole.log(/にわ/.test(str)); // => true\nconsole.log(/いる/.test(str)); // => true \n```", "```\nconst str = \"/正規表現のような文字列/\";\n// 正規表現で`/`からはじまり`/`で終わる文字列のパターン\nconst regExpLikePattern = /^\\/.*\\/$/;\n// RegExpの`test`メソッドでパターンにマッチするかを判定\nconsole.log(regExpLikePattern.test(str)); // => true\n// Stringメソッドで、`/`からはじまり`/`で終わる文字列かを判定する関数\nconst isRegExpLikeString = (str) => {\n    return str.startsWith(\"/\") && str.endsWith(\"/\");\n};\nconsole.log(isRegExpLikeString(str)); // => true \n```", "```\n\"use strict\";\nconst str = \"文字列\";\n// 文字列の0 番目の削除を試みるがStrict modeでは例外が発生する\ndelete str[0]; // => TypeError: property 0 is non-configurable and can't be deleted \n```", "```\n文字列.replace(\"検索文字列\", \"置換文字列\");\n文字列.replace(/パターン/, \"置換文字列\"); \n```", "```\nconst str = \"文字列\";\n// \"文字\"を\"\"（空文字列）へ置換することで\"削除\"を表現\nconst newStr = str.replace(\"文字\", \"\");\nconsole.log(newStr); // => \"列\" \n```", "```\n// 検索対象となる文字列\nconst str = \"にわにはにわにわとりがいる\";\n// 文字列を指定した場合は、最初に一致したものだけが置換される\nconsole.log(str.replace(\"にわ\", \"niwa\")); // => \"niwaにはにわにわとりがいる\"\n// `g`フラグなし正規表現の場合は、最初に一致したものだけが置換される\nconsole.log(str.replace(/にわ/, \"niwa\")); // => \"niwaにはにわにわとりがいる\"\n// `g`フラグあり正規表現の場合は、繰り返し置換を行う\nconsole.log(str.replace(/にわ/g, \"niwa\")); // => \"niwaにはniwaniwaとりがいる\" \n```", "```\n// 検索対象となる文字列\nconst str = \"???\";\n// replaceメソッドに文字列を指定した場合は、最初に一致したものだけが置換される\nconsole.log(str.replace(\"?\", \"!\")); // => \"!??\"\n// replaceAllメソッドに文字列を指定した場合は、一致したものがすべて置換される\nconsole.log(str.replaceAll(\"?\", \"!\")); // => \"!!!\"\n// replaceメソッドの場合は、正規表現の特殊文字はエスケープが必要となる\nconsole.log(str.replace(/\\?/g, \"!\")); // => \"!!!\"\n// replaceAllメソッドにも正規表現を渡せるが、この場合はエスケープが必要となるためreplaceと同じ\nconsole.log(str.replaceAll(/\\?/g, \"!\")); // => \"!!!\" \n```", "```\nconst 置換した結果の文字列 = 文字列.replace(/(パターン)/, (all, ...captures) => {\n    return 置換したい文字列;\n}); \n```", "```\nfunction toDateJa(dateString) {\n    // パターンにマッチしたときのみ、コールバック関数で置換処理が行われる\n    return dateString.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g, (all, year, month, day) => {\n        // `all`には、マッチした文字列全体が入っているが今回は利用しない\n        // `all`が次の返す値で置換されるイメージ\n        return `${year}年${month}月${day}日`;\n    });\n}\n// マッチしない文字列の場合は、そのままの文字列が返る\nconsole.log(toDateJa(\"本日ハ晴天ナリ\")); // => \"本日ハ晴天ナリ\"\n// マッチした場合は置換した結果を返す\nconsole.log(toDateJa(\"今日は2017-03-01です\")); // => \"今日は2017 年 03 月 01 日です\" \n```", "```\n\"https://example.com/index.html\"\n ^^^^^   ^^^^^^^^^^^ ^^^^^^^^^^\n   |          |     　　　|\n scheme      host     pathname \n```", "```\n// `baseURL`と`pathname`にあるリソースを取得する\nfunction getResource(baseURL, pathname) {\n    const url = baseURL + pathname;\n    console.log(url); // => \"http://example.com/resouces/example.js\"\n    // 省略) リソースを取得する処理...\n}\nconst baseURL = \"http://example.com/resouces\";\nconst pathname = \"/example.js\";\ngetResource(baseURL, pathname); \n```", "```\n// `baseURL`と`pathname`にあるリソースを取得する\nfunction getResource(baseURL, pathname) {\n    const url = baseURL + pathname;\n    // `/` と `/` が２つ重なってしまっている\n    console.log(url); // => \"http://example.com/resouces//example.js\"\n    // 省略) リソースを取得する処理...\n}\nconst baseURL = \"http://example.com/resouces/\";\nconst pathname = \"/example.js\";\ngetResource(baseURL, pathname); \n```", "```\n// ベースURLとパスを結合した文字列を返す\nfunction baseJoin(baseURL, pathname) {\n    // 末尾に / がある場合は、/ を削除してから結合する\n    const stripSlashBaseURL = baseURL.replace(/\\/$/, \"\");\n    return stripSlashBaseURL + pathname;\n}\n// `baseURL`と`pathname`にあるリソースを取得する\nfunction getResource(baseURL, pathname) {\n    const url = baseJoin(baseURL, pathname);\n    // baseURLの末尾に / があってもなくても同じ結果となる\n    console.log(url); // => \"http://example.com/resouces/example.js\"\n    // 省略) リソースを取得する処理...\n}\nconst baseURL = \"http://example.com/resouces/\";\nconst pathname = \"/example.js\";\ngetResource(baseURL, pathname); \n```", "```\nfunction tag(str) {\n    // 引数`str`にはただの文字列が渡ってくる\n    console.log(str); // => \"template 0 literal 1\"\n}\n// ()をつけて関数を呼び出す\ntag(`template ${0} literal ${1}`); \n```", "```\n// 呼び出し方によって受け取る引数の形式が変わる\nfunction tag(strings, ...values) {\n    // stringsは文字列のパーツが${}で区切られた配列となる\n    console.log(strings); // => [\"template \",\" literal \",\"\"]\n    // valuesには${}の評価値が順番に入る\n    console.log(values); // => [0, 1]\n}\n// ()をつけずにテンプレートを呼び出す\ntag`template ${0} literal ${1}`; \n```", "```\n// テンプレートを順番どおりに結合した文字列を返すタグ関数\nfunction stringRaw(strings, ...values) {\n    // 配列から文字列を返すためにreduceメソッドを利用する\n    // resultの初期値はstrings[0]の値となる\n    return strings.reduce((result, str, i) => {\n        console.log([result, values[i - 1], str]);\n        // それぞれループで次のような出力となる\n        // 1 度目: [\"template \", 0, \" literal \"]\n        // 2 度目: [\"template 0 literal \", 1, \"\"]\n        return result + values[i - 1] + str;\n    });\n}\n// 関数`テンプレートリテラル` という形で呼び出す\nconsole.log(stringRaw`template ${0} literal ${1}`); // => \"template 0 literal 1\" \n```", "```\nconsole.log(String.raw`template ${0} literal ${1}`); // => \"template 0 literal 1\" \n```", "```\n// 変数をURLエスケープするタグ関数\nfunction escapeURL(strings, ...values) {\n    return strings.reduce((result, str, i) => {\n        return result + encodeURIComponent(values[i - 1]) + str;\n    });\n}\n\nconst input = \"A&B\";\n// escapeURLタグ関数を使ったタグつきテンプレート\nconst escapedURL = escapeURL`https://example.com/search?q=${input}&sort=desc`;\nconsole.log(escapedURL); // => \"https://example.com/search?q=A%26B&sort=desc\" \n```"]