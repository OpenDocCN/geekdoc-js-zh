["```\nconst map = new Map();\nconsole.log(map.size); // => 0 \n```", "```\nconst map = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);\n// 2つのエントリーで初期化されている\nconsole.log(map.size); // => 2 \n```", "```\nconst map = new Map();\n// 新しい要素の追加\nmap.set(\"key\", \"value1\");\nconsole.log(map.size); // => 1\nconsole.log(map.get(\"key\")); // => \"value1\"\n// 要素の上書き\nmap.set(\"key\", \"value2\");\nconsole.log(map.get(\"key\")); // => \"value2\"\n// キーの存在確認\nconsole.log(map.has(\"key\")); // => true\nconsole.log(map.has(\"foo\")); // => false \n```", "```\nconst map = new Map();\nmap.set(\"key1\", \"value1\");\nmap.set(\"key2\", \"value2\");\nconsole.log(map.size); // => 2\nmap.delete(\"key1\");\nconsole.log(map.size); // => 1\nmap.clear();\nconsole.log(map.size); // => 0 \n```", "```\nconst map = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);\nconst results = [];\nmap.forEach((value, key) => {\n    results.push(`${key}:${value}`);\n});\nconsole.log(results); // => [\"key1:value1\",\"key2:value2\"] \n```", "```\nconst map = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);\nconst keys = [];\n// keysメソッドの返り値(Iterator)を反復処理する\nfor (const key of map.keys()) {\n    keys.push(key);\n}\nconsole.log(keys); // => [\"key1\",\"key2\"]\n// keysメソッドの返り値(Iterator)から配列を作成する\nconst keysArray = Array.from(map.keys());\nconsole.log(keysArray); // => [\"key1\",\"key2\"] \n```", "```\nconst map = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);\nconst entries = [];\nfor (const [key, value] of map.entries()) {\n    entries.push(`${key}:${value}`);\n}\nconsole.log(entries); // => [\"key1:value1\",\"key2:value2\"] \n```", "```\nconst map = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);\nconst results = [];\nfor (const [key, value] of map) {\n    results.push(`${key}:${value}`);\n}\nconsole.log(results); // => [\"key1:value1\",\"key2:value2\"] \n```", "```\nconst map = {};\n// マップがキーを持つことを確認する\nfunction has(key) {\n    return typeof map[key] !== \"undefined\";\n}\nconsole.log(has(\"foo\")); // => false\n// Objectのプロパティが存在する\nconsole.log(has(\"constructor\")); // => true \n```", "```\n// ショッピングカートを表現するクラス\nclass ShoppingCart {\n    constructor() {\n        // 商品とその数を持つマップ\n        this.items = new Map();\n    }\n    // カートに商品を追加する\n    addItem(item) {\n        // `item`がない場合は`undefined`を返すため、Nullish coalescing 演算子(`??`)を使いデフォルト値として`0`を設定する\n        const count = this.items.get(item) ?? 0;\n        this.items.set(item, count + 1);\n    }\n    // カート内の合計金額を返す\n    getTotalPrice() {\n        return Array.from(this.items).reduce((total, [item, count]) => {\n            return total + item.price * count;\n        }, 0);\n    }\n    // カートの中身を文字列にして返す\n    toString() {\n        return Array.from(this.items).map(([item, count]) => {\n            return `${item.name}:${count}`;\n        }).join(\",\");\n    }\n}\nconst shoppingCart = new ShoppingCart();\n// 商品一覧\nconst shopItems = [\n    { name: \"みかん\", price: 100 },\n    { name: \"リンゴ\", price: 200 },\n];\n\n// カートに商品を追加する\nshoppingCart.addItem(shopItems[0]);\nshoppingCart.addItem(shopItems[0]);\nshoppingCart.addItem(shopItems[1]);\n\n// 合計金額を表示する\nconsole.log(shoppingCart.getTotalPrice()); // => 400\n// カートの中身を表示する\nconsole.log(shoppingCart.toString()); // => \"みかん:2,リンゴ:1\" \n```", "```\n// URLとObjectのマップを受け取ってPOSTリクエストを送る関数\nfunction sendPOSTRequest(url, data) {\n    // fetchを使ってPOSTリクエストを送る\n    fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify(data),\n    }).catch((error) => {\n        console.error(error);\n    });\n}\n\n// formのsubmitイベントを受け取る関数\nfunction onLoginFormSubmit(event) {\n    const form = event.target;\n    const data = {\n        userName: form.elements.userName,\n        password: form.elements.password,\n    };\n    sendPOSTRequest(\"/api/login\", data);\n} \n```", "```\nconst map = new WeakMap();\n// キーとなるオブジェクト\nlet obj = {};\n// {} への参照をキーに値をセットする\nmap.set(obj, \"value\");\n// {} への参照を破棄する\nobj = null;\n// GCが発生するタイミングでWeakMapから値が破棄される \n```", "```\n// イベントリスナーを管理するマップ\nconst listenersMap = new WeakMap();\n\nclass EventEmitter {\n    addListener(listener) {\n        // this(インスタンス)にひもづいたリスナーの配列を取得する\n        const listeners = listenersMap.get(this) ?? [];\n        const newListeners = listeners.concat(listener);\n        // this をキーにして、新しいリスナーの配列をセットする\n        listenersMap.set(this, newListeners);\n    }\n    // ...EventEmitterには他にもメソッドがあるが省略...\n}\n\n// `event`は`EventEmitter`のインスタンスへの参照をもつ\nlet event = new EventEmitter();\n// `EventEmitter`のインスタンスへイベントリスナーを追加する\nevent.addListener(() => {\n    // `EventEmitter`のインスタンスに紐づくイベントリスナーの処理\n});\n// `event`へ`null`を代入することで、`EventEmitter`のインスタンスへの参照がなくなる\n// インスタンスがどこからも参照されなくなったため、紐づいていたイベントリスナーが自動的に解放される\nevent = null; \n```", "```\nconst cache = new WeakMap();\n\nfunction getHeight(element) {\n    if (cache.has(element)) {\n        return cache.get(element);\n    }\n    const height = element.getBoundingClientRect().height;\n    // elementオブジェクトに対して高さをひもづけて保存している\n    cache.set(element, height);\n    return height;\n} \n```", "```\nconst map = new Map();\nmap.set(NaN, \"value\");\n// NaNは===で比較した場合は常にfalse\nconsole.log(NaN === NaN); // => false\n// MapはNaN 同士を比較できる\nconsole.log(map.has(NaN)); // => true\nconsole.log(map.get(NaN)); // => \"value\" \n```", "```\nconst set = new Set();\nconsole.log(set.size); // => 0 \n```", "```\n// \"value2\"が重複するため、片方は無視される\nconst set = new Set([\"value1\", \"value2\", \"value2\"]);\n// セットのサイズは2になる\nconsole.log(set.size); // => 2 \n```", "```\nconst set = new Set();\n// 値の追加\nset.add(\"a\");\nconsole.log(set.size); // => 1\n// 重複する値は追加されない\nset.add(\"a\");\nconsole.log(set.size); // => 1\n// 値の存在確認\nconsole.log(set.has(\"a\")); // => true\nconsole.log(set.has(\"b\")); // => false \n```", "```\nconst set = new Set();\nset.add(\"a\");\nset.add(\"b\");\nconsole.log(set.size); // => 2\nset.delete(\"a\");\nconsole.log(set.size); // => 1\nset.clear();\nconsole.log(set.size); // => 0 \n```", "```\nconst set = new Set([\"a\", \"b\"]);\nconst results = [];\nset.forEach((value) => {\n    results.push(value);\n});\nconsole.log(results); // => [\"a\",\"b\"] \n```", "```\nconst set = new Set([\"a\", \"b\"]);\n// keysで列挙\nconst keysResults = [];\nfor (const value of set.keys()) {\n    keysResults.push(value);\n}\nconsole.log(keysResults); // => [\"a\",\"b\"]\n// entriesで列挙\nconst entryResults = [];\nfor (const entry of set.entries()) {\n    // entryは[値, 値]という配列\n    entryResults.push(entry);\n}\nconsole.log(entryResults); // => [[\"a\",\"a\"], [\"b\", \"b\"]] \n```", "```\nconst set = new Set([\"a\", \"b\"]);\nconst results = [];\nfor (const value of set) {\n    results.push(value);\n}\nconsole.log(results); // => [\"a\",\"b\"] \n```"]