- en: 変数と宣言
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量与声明
- en: 原文：[`jsprimer.net/basic/variables/`](https://jsprimer.net/basic/variables/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/variables/`](https://jsprimer.net/basic/variables/)
- en: プログラミング言語には、文字列や数値などのデータに名前をつけることで、繰り返し利用できるようにする**変数**という機能があります。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言中，通过给数据（如字符串、数值等）命名，使其可以重复使用，这种功能称为**变量**。
- en: JavaScriptには「これは変数です」という宣言をするキーワードとして、 `const`、`let`、`var`の3つがあります。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有`const`、`let`、`var`三个关键字用于声明“这是变量”。
- en: '`var`はもっとも古くからある変数宣言のキーワードですが、意図しない動作を作りやすい問題が知られています。 そのためECMAScript 2015で、`var`の問題を改善するために`const`と`let`という新しいキーワードが導入されました。'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`是最早的变量声明关键字之一，但存在容易引起意外行为的问题。因此，在ECMAScript 2015中，为了改善`var`的问题，引入了新的关键字`const`和`let`。'
- en: この章では`const`、`let`、`var`の順に、それぞれの方法で宣言した変数の違いについて見ていきます。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将按顺序介绍`const`、`let`、`var`，分别探讨使用这些方法声明的变量的不同之处。
- en: '[](#const)*[ES2015] `const`*'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#const)*[ES2015] `const`*'
- en: '*`const`キーワードでは、再代入できない変数の宣言とその変数が参照する値（初期値）を定義できます。'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用`const`关键字可以声明不能重赋的变量，并定义该变量所引用的值（初始值）。'
- en: 次のように、`const`キーワードに続いて`変数名`を書き、代入演算子（`=`）の右辺に変数の`初期値`を書いて変数を定義できます。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像以下这样，在`const`关键字后面写上`变量名`，在赋值运算符（`=`）的右边写上变量的`初始值`来定义变量。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 次のコードでは`bookTitle`という変数を宣言し、初期値が`"JavaScript Primer"`という文字列であることを定義しています。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，声明了变量`bookTitle`，并定义了其初始值为字符串`"JavaScript Primer"`。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`const`、`let`、`var`どのキーワードも共通の仕組みですが、変数同士を`,`（カンマ）で区切ることにより、同時に複数の変数を定義できます。'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`、`let`、`var`这三个关键字具有共同的机制，但可以通过`,`（逗号）来分隔变量，从而同时定义多个变量。'
- en: 次のコードでは、`bookTitle`と`bookCategory`という変数を順番に定義しています。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，依次定义了变量`bookTitle`和`bookCategory`。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: これは次のように書いた場合と同じ意味になります。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下写法具有相同的意义。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: また、`const`は再代入できない変数を宣言するキーワードです。 そのため、`const`キーワードで宣言した変数に対して、後から値を代入することはできません。
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`const`是用于声明不能重赋的变量的关键字。因此，使用`const`关键字声明的变量，之后不能对其进行值赋。
- en: 次のコードでは、`const`で宣言した変数`bookTitle`に対して値を再代入しているため、次のようなエラー（`TypeError`）が発生します。
    エラーが発生するとそれ以降の処理は実行されなくなります。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，由于使用`const`声明了变量`bookTitle`并对其进行了值的重赋，因此发生了以下错误（`TypeError`）。错误发生会导致后续的处理无法执行。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、バグを発生させやすい要因として知られています。そのため、変数に対して値を再代入する必要がない場合は、`const`キーワードで変数宣言することを推奨しています。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，变量到值的重赋会破坏所谓的“变量引用透明性”规则，这是导致bug容易发生的原因之一。因此，如果不需要对变量进行值的重赋，建议使用`const`关键字进行变量声明。
- en: 変数に値を再代入したいケースとして、ループなどの反復処理の途中で特定の変数が参照する値を変化させたい場合があります。 そのような場合には、変数への再代入が可能な`let`キーワードを利用します。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要值重赋的变量场景中，例如在循环等重复处理过程中，可能需要改变特定变量所引用的值。在这种情况下，可以使用可以值重赋的`let`关键字。
- en: '[](#let)*[ES2015] `let`*'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#let)*[ES2015] `let`*'
- en: '*`let`キーワードでは、値の再代入が可能な変数を宣言できます。 `let`の使い方は`const`とほとんど同じです。'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用`let`关键字可以声明可以值重赋的变量。`let`的使用方法与`const`几乎相同。'
- en: 次のコードでは、`bookTitle`という変数を宣言し、初期値が`"JavaScript Primer"`という文字列であることを定義しています。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，声明了变量`bookTitle`，并定义了其初始值为字符串`"JavaScript Primer"`。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`let`は`const`とは異なり、初期値を指定しない変数も定義できます。 初期値が指定されなかった変数はデフォルト値として`undefined`という値で初期化されます（`undefined`は値が未定義ということを表す値です）。'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`与`const`不同，也可以定义没有初始值的变量。没有指定初始值的变量将使用默认值`undefined`进行初始化（`undefined`表示值未定义）。'
- en: 次のコードでは、`bookTitle`という変数を宣言しています。 このとき`bookTitle`には初期値が指定されていないため、デフォルト値として`undefined`で初期化されます。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，声明了变量`bookTitle`。此时，由于没有指定初始值，因此默认使用`undefined`进行初始化。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: この`let`で宣言された`bookTitle`という変数には、代入演算子（`=`）を使うことで値を代入できます。 代入演算子（`=`）の右側には変数へ代入する値を書きますが、ここでは`"JavaScript
    Primer"`という文字列を代入しています。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`声明的变量`bookTitle`可以通过使用赋值运算符（`=`）来赋值。赋值运算符（`=`）的右边写上要赋给变量的值，这里写的是字符串`"JavaScript
    Primer"`。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`let`で宣言した変数に対しては何度でも値の代入が可能です。'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`声明的变量可以进行多次值赋。
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[](#var)*`var`*'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#var)*`var`*'
- en: '*`var`キーワードでは、値の再代入が可能な変数を宣言できます。 `var`の使い方は`let`とほとんど同じです。'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用`var`关键字可以声明可以值重赋的变量。`var`的使用方法与`let`几乎相同。'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`var`では、`let`と同じように初期値がない変数を宣言でき、変数に対して値の再代入もできます。'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`var`中，可以像`let`一样声明没有初始值的变量，并且可以对变量进行值的重赋。
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[](#var-issues)*`var`の問題*'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#var-issues)*`var`的问题*'
- en: '*`var`は`let`とよく似ていますが、`var`キーワードには同じ名前の変数を再定義できてしまう問題があります。'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*`var`与`let`很相似，但`var`关键字可以重新定义同名变量。'
- en: '`let`や`const`では、同じ名前の変数を再定義しようとすると、次のような構文エラー（`SyntaxError`）が発生します。 そのため、間違えて変数を二重に定義してしまうというミスを防ぐことができます。'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`或`const`中，如果尝试重新定义同名变量，则会发生以下语法错误（`SyntaxError`）。这可以防止错误地重复定义变量。'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 一方、`var`は同じ名前の変数を再定義できます。 これは意図せずに同じ変数名で定義してもエラーとならずに、値を上書きしてしまいます。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`var`可以重新定义同名变量。这可能导致在不经意间使用相同的变量名进行定义，而不会产生错误，并覆盖原有的值。
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: また`var`には変数の巻き上げと呼ばれる意図しない挙動があり、`let`や`const`ではこの問題が解消されています。 `var`による変数の巻き上げの問題については「関数とスコープ」の章で解説します。
    そのため、現時点では「`let`は`var`を改善したバージョン」ということだけ覚えておくとよいです。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`var`存在所谓的“变量提升”的意外行为，而`let`或`const`则解决了这个问题。关于`var`引起的变量提升问题，将在“函数与作用域”章节中解释。因此，目前只需记住“`let`是改进版的`var`”即可。
- en: このように、`var`にはさまざまな問題があります。 また、ほとんどすべてのケースで`var`は`const`か`let`に置き換えが可能です。 そのため、これから書くコードに対して`var`を利用することは避けたほうがよいでしょう。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`var`存在许多问题。而且，在几乎所有情况下，都可以用`const`或`let`替换`var`。因此，对于将要编写的代码，最好避免使用`var`。
- en: '[](#why-add-let-and-const)*[コラム] なぜ`let`や`const`は追加されたのか？*'
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#why-add-let-and-const)*[专栏] 为什么会添加`let`和`const`？*'
- en: '*ECMAScript 2015では、`var`そのものを改善するのではなく、新しく`const`と`let`というキーワードを追加することで、`var`の問題を回避できるようにしました。`var`自体の動作を変更しなかったのは、後方互換性のためです。'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*在ECMAScript 2015中，不是通过改善`var`本身，而是通过添加新的关键字`const`和`let`来避免`var`的问题。没有改变`var`本身的动作是为了保持向后兼容性。'
- en: なぜなら、`var`の挙動自体を変更してしまうと、すでに`var`で書かれたコードの動作が変わってしまい、動かなくなるアプリケーションが出てくるためです。
    新しく`const`や`let`などのキーワードをECMAScript 仕様に追加しても、そのキーワードを使っているソースコードは追加時点では存在しません。^(1)
    そのため、`const`や`let`が追加されても後方互換性には影響がありません。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为如果改变`var`的行为，那么已经用`var`编写的代码的行为也会改变，可能导致应用程序无法运行。因此，新添加的`const`或`let`等关键字虽然被添加到ECMAScript规范中，但使用这些关键字的源代码在添加时并不存在。^(1)
    因此，即使添加了`const`或`let`，也不会影响向后兼容性。
- en: このように、ECMAScriptでは機能を追加する際にも後方互換性を重視しているため、`var`自体の挙動は変更されませんでした。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，ECMAScript在添加新功能时也重视向后兼容性，因此没有改变`var`本身的动作。
- en: '[](#variable-name)*変数名に使える名前のルール*'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#variable-name)*变量名可以使用规则*'
- en: '*到目前为止，我们已经了解了`const`、`let`、`var`关键字以及它们各自的变量声明特性。 在任何关键字中，可用于声明变量的名称规则都是相同的。
    此外，此规则适用于 JavaScript 标识符，如变量名和函数名。'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们已经了解了`const`、`let`、`var`关键字以及它们各自的变量声明特性。 在任何关键字中，可用于声明变量的名称规则都是相同的。
    此外，此规则适用于 JavaScript 标识符，如变量名和函数名。'
- en: 变量名（标识符）有以下规则：
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名（标识符）有以下规则：
- en: 将变量名设为由半角字母、`_`（下划线）、`$`（美元符号）和数字`0`至`9`组成的名称
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量名设为由半角字母、`_`（下划线）、`$`（美元符号）和数字`0`至`9`组成的名称
- en: 变量名不能以数字开头
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量名不能以数字开头
- en: 不能使用保留字作为名称
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不能使用保留字作为名称
- en: 变量名应为由半角字母`A`至`Z`（大写）和`a`至`z`（小写）、`_`（下划线）、`$`（美元符号）、数字`0`至`9`组成的名称。 在 JavaScript
    中，区分大小写。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名应为由半角字母`A`至`Z`（大写）和`a`至`z`（小写）、`_`（下划线）、`$`（美元符号）、数字`0`至`9`组成的名称。 在 JavaScript
    中，区分大小写。
- en: 除此之外，虽然可以在变量名中使用平假名和部分汉字等，但是如果混合全角字符，则可能会因环境问题而难以处理，因此不建议使用。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，虽然可以在变量名中使用平假名和部分汉字等，但是如果混合全角字符，则可能会因环境问题而难以处理，因此不建议使用。
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 可以在变量名中包含数字，但是变量名不能以数字开头。 这是因为会导致无法区分变量名和数字。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在变量名中包含数字，但是变量名不能以数字开头。 这是因为会导致无法区分变量名和数字。
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 此外，无法将保留字用作变量名。 保留字是指具有语法意义的关键字，例如`let`。 可以在[保留字 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar)上找到保留字列表，但基本上是保留用于语法的名称。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无法将保留字用作变量名。 保留字是指具有语法意义的关键字，例如`let`。 可以在[保留字 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar)上找到保留字列表，但基本上是保留用于语法的名称。
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[](#const-is-not-constant)*[专栏] `const`并非常量*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#const-is-not-constant)*[专栏] `const`并非常量*'
- en: '*`const`是定义“不能重新赋值的变量”的变量声明，并不一定定义常量。常量是指一旦定义的名称（变量名）始终表示相同值的东西。'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*`const`是定义“不能重新赋值的变量”的变量声明，并不一定定义常量。常量是指一旦定义的名称（变量名）始终表示相同值的东西。'
- en: 在 JavaScript 中，也可以使用`const`声明接近常量的变量。如果使用`const`声明的变量初始化为无法更改的原始值，则实际上就是常量。原始值是指除对象之外的数据，例如数字和字符串（有关详细信息，请参阅“数据类型和字面量”章节）。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，也可以使用`const`声明接近常量的变量。如果使用`const`声明的变量初始化为无法更改的原始值，则实际上就是常量。原始值是指除对象之外的数据，例如数字和字符串（有关详细信息，请参阅“数据类型和字面量”章节）。
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 但是，在 JavaScript 中，也可以使用`const`声明对象等。 例如，对象值本身在初始化后也可以更改。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在 JavaScript 中，也可以使用`const`声明对象等。 例如，对象值本身在初始化后也可以更改。
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 因此，由于使用`const`声明的变量不一定始终表示相同的值，因此不能称之为常量（有关详细信息，请参见“对象”章节）。
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于使用`const`声明的变量不一定始终表示相同的值，因此不能称之为常量（有关详细信息，请参见“对象”章节）。
- en: 此外，`const`没有变量命名规则，也没有赋值限制。因此，最好理解`const`声明的特性是定义“不能重新赋值的变量”。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`const`没有变量命名规则，也没有赋值限制。因此，最好理解`const`声明的特性是定义“不能重新赋值的变量”。
- en: '[](#summary)*总结*'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#summary)*总结*'
- en: '*本章介绍了 JavaScript 中用于声明变量的关键字`const`、`let`、`var`。'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章介绍了 JavaScript 中用于声明变量的关键字`const`、`let`、`var`。'
- en: '`const`可以声明不能重新赋值的变量'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`可以声明不能重新赋值的变量'
- en: '`let`可以声明可以重新赋值的变量'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`let`可以声明可以重新赋值的变量'
- en: '`var`可以声明可以重新赋值的变量，但已知存在一些问题'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`可以声明可以重新赋值的变量，但已知存在一些问题'
- en: 变量名（标识符）有一些可用的名称规则
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名（标识符）有一些可用的名称规则
- en: '`var`在大多数情况下都可以用`let`或`const`来替代。`const`定义了不能重新赋值的变量。通过禁止重新赋值，可以减少因错误而引起的 bug。因此，在声明变量时，首先考虑是否可以用`const`定义，如果不行，则建议使用`let`。'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`在大多数情况下都可以用`let`或`const`来替代。`const`定义了不能重新赋值的变量。通过禁止重新赋值，可以减少因错误而引起的 bug。因此，在声明变量时，首先考虑是否可以用`const`定义，如果不行，则建议使用`let`。'
- en: ¹. 由于`let`和`const`在 ECMAScript 2015 之前被定义为保留字，所以不会与现有代码冲突。 ↩********
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. 由于`let`和`const`在 ECMAScript 2015 之前被定义为保留字，所以不会与现有代码冲突。 ↩********
