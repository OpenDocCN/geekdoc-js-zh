- en: 暗黙的な���変換
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式类型转换
- en: 原文：[`jsprimer.net/basic/implicit-coercion/`](https://jsprimer.net/basic/implicit-coercion/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/implicit-coercion/`](https://jsprimer.net/basic/implicit-coercion/)
- en: この章では、明示的な型変換と暗黙的な型変換について学んでいきます。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将学习显式类型转换和隐式类型转换。
- en: 「演算子」の章にて、 等価演算子（`==`）ではなく厳密等価演算子（`===`）の利用を推奨していました。 これは厳密等価演算子（`===`）が**暗黙的な型変換**をせずに、値同士を比較できるためです。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在“运算符”章节中，我推荐使用严格的等价运算符（`===`）而不是等价运算符（`==`），因为严格的等价运算符（`===`）不会进行隐式类型转换，可以直接比较值。
- en: 厳密等価演算子（`===`）では異なるデータ型を比較した場合に、その比較結果は必ず`false`となります。 次のコードは、数値の`1`と文字列の`"1"`という異なるデータ型を比較しているので、結果は`false`となります。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的等价运算符（`===`）在比较不同数据类型时，其比较结果始终为`false`。以下代码正在比较数值的`1`和字符串的`"1"`这两种不同的数据类型，因此结果为`false`。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: しかし、等価演算子（`==`）では異なるデータ型を比較した場合に、同じ型となるように**暗黙的な型変換**をしてから比較します。 次のコードでは、数値の`1`と文字列の`"1"`の比較結果が`true`となっています。
    これは、等価演算子（`==`）は右辺の文字列`"1"`を数値の`1`へと暗黙的な型変換をしてから、比較するためです。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，等价运算符（`==`）在比较不同数据类型时，会先进行隐式类型转换，使其具有相同的类型后再进行比较。以下代码中，数值的`1`和字符串的`"1"`的比较结果为`true`。这是因为等价运算符（`==`）将右边的字符串`"1"`隐式地转换为数值的`1`，然后进行比较。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: このように、暗黙的な型変換によって意図しない結果となるため、比較には厳密等価演算子（`===`）を使うべきです。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，由于隐式类型转换可能导致意外结果，因此在比较时应使用严格的等价运算符（`===`）。
- en: 別の暗黙的な型変換の例として、数値と真偽値の加算を見てみましょう。 多くの言語では、数値と真偽値の加算のような異なるデータ型同士の加算はエラーとなります。
    しかし、JavaScriptでは暗黙的な型変換が行われてから加算されるため、エラーなく処理されます。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个隐式类型转换的例子，让我们看看数值和布尔值的加法。在许多语言中，数值和布尔值的加法等不同数据类型的加法会导致错误。然而，在JavaScript中，由于隐式类型转换，加法操作可以无错误地处理。
- en: 次のコードでは、真偽値の`true`が数値の`1`へと暗黙的に変換されてから加算処理が行われます。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，布尔值的`true`被隐式地转换为数值的`1`，然后进行加法处理。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JavaScriptでは、エラーが発生するのではなく、暗黙的な型変換が行われてしまうケースが多くあります。 暗黙的に変換が行われた場合、プログラムは例外を投げずに処理が進むため、バグの発見が難しくなります。
    このように、暗黙的な型変換はできる限り避けるべき挙動です。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中，不会发生错误，而是进行隐式类型转换。当隐式转换发生时，程序不会抛出异常，处理会继续进行，这使得错误难以发现。因此，应尽可能避免隐式类型转换。
- en: この章では、次のことについて学んでいきます。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将学习以下内容。
- en: 暗黙的な型変換とはどのようなものなのか
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式类型转换是什么样的？
- en: 暗黙的ではない明示的な型変換の方法
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非隐式的显式类型转换方法
- en: 明示的な変換だけでは解決しないこと
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅显式转换无法解决问题
- en: '[](#what-is-implicit-coercion)*暗黙的な型変換とは*'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#what-is-implicit-coercion)*隐式类型转换是什么*'
- en: '*暗黙的な型変換とは次のことを言います。'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐式类型转换是指以下内容。'
- en: ある処理において、その処理過程で行われる明示的ではない型変換のこと
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某个处理过程中，指在处理过程中进行的非显式类型转换
- en: 暗黙的な型変換は、演算子による演算や関数の処理過程で行われます。 ここでは、演算子における暗黙的な型変換を中心に見ていきます。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式类型转换是在运算符的运算或函数的处理过程中进行的。在这里，我们将主要关注运算符中的隐式类型转换。
- en: '[](#implicit-coercion-of-equal-operator)*等価演算子の暗黙的な型変換*'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#implicit-coercion-of-equal-operator)*等价运算符的隐式类型转换*'
- en: '*もっとも有名な暗黙的な型変換は、先ほども出てきた等価演算子（`==`）です。 等価演算子は、オペランド同士が同じ型となるように暗黙的な型変換をしてから、比較します。'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*最著名的隐式类型转换是之前提到的等价运算符（`==`）。等价运算符在比较操作数之前，会进行隐式类型转换，使其具有相同的类型。'
- en: 次のように等価演算子（`==`）による比較は、驚くような結果を作り出します。
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用等价运算符（`==`）进行的比较会产生令人惊讶的结果。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: このほかにも等価演算子による予想できない結果は、比較する値と型の組み合わせの数だけあります。 そのため、等価演算子の比較結果がどうなるかを覚えるのは現実的でありません。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于等价运算符导致的不可预测的结果数量与比较值和类型的组合数量相同，因此记住等价运算符的比较结果在现实中是不切实际的。
- en: '![等価演算子による比較結果をまとめた表。緑はtrueとなる組み合わせ](https://dorey.github.io/JavaScript-Equality-Table/)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![等价运算符比较结果汇总表。绿色表示为true的组合](https://dorey.github.io/JavaScript-Equality-Table/)'
- en: しかし、等価演算子の暗黙的な型変換を避ける簡単な方法があります。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，避免等价运算符的隐式类型转换有一个简单的方法。
- en: それは、常に厳密等価演算子（`===`）を使うことです。 値を比較する際は、常に厳密等価演算子を使うことで、暗黙的な型変換をせずに値を比較できます。
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是始终使用严格的等价运算符（`===`）。在比较值时，始终使用严格的等价运算符可以避免隐式类型转换，从而直接比较值。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 厳密等価演算子（`===`）を使うことで、意図しない比較結果を避けることができます。 そのため、比較には等価演算子（`==`）ではなく厳密等価演算子（`===`）を使うことを推奨します。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用严格的等价运算符（`===`）可以避免意外的比较结果。因此，建议在比较时使用严格的等价运算符（`===`）而不是等价运算符（`==`）。
- en: '[](#various-implicit-coercion)*さまざまな暗黙的な型変換*'
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#various-implicit-coercion)*各种隐式类型转换*'
- en: '*他の演算子についても、具体的な例を見てみましょう。'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*其他运算符的具体例子也让我们看看。'
- en: 次のコードでは、数値の`1`と文字列の`"2"`をプラス演算子で処理しています。 プラス演算子（`+`）は、数値の加算と文字列の結合を両方実行できるように多重定義されています。
    このケースでは、JavaScriptは文字列の結合を優先する仕様となっています。 そのため、数値の`1`を文字列の`"1"`へ暗黙的に変換してから、文字列結合します。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，使用加号运算符处理数值的`1`和字符串的`"2"`。加号运算符（`+`）被双重定义，既可以执行数值的加法，也可以执行字符串的连接。在这种情况下，JavaScript优先执行字符串连接。因此，数值的`1`被隐式地转换为字符串的`"1"`，然后进行字符串连接。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: もうひとつ、数値と文字列での暗黙的な型変換を見てみましょう。 次のコードでは、数値の`1`から文字列の`"2"`を減算しています。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，让我们看看数值和字符串之间的隐式类型转换。以下代码中，从数值的`1`减去字符串的`"2"`。
- en: JavaScriptには、文字列に対するマイナス演算子（`-`）の定義はありません。 そのため、マイナス演算子の対象となる数値への暗黙的な型変換が行われます。
    これにより、文字列の`"2"`を数値の`2`へ暗黙的に変換してから、減算します。
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中没有对字符串的减号运算符（`-`）的定义。因此，对减号运算符的目标数值进行隐式类型转换。因此，将字符串的`"2"`隐式地转换为数值的`2`，然后进行减法。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 2つの値までは、まだ結果の型を予想できます。 しかし、3つ以上の値を扱う場合に結果を予測するのが難しくなります。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个值，还可以预测结果的类型。但是，当处理三个以上的值时，预测结果变得困难。
- en: 次のように3つ以上の値を`+`演算子で演算する場合に、値の型が混ざっていると、 演算する順番によっても結果が異なります。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`+`运算符进行三个以上值的运算时，如果值的数据类型混合，则结果会因运算顺序而异。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: このように、処理の過程でオペランドの型によって、 自動的に変換されることを**暗黙的な型変換**と呼んでいます。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在处理过程中，根据操作数的类型，会自动进行转换，这被称为**隐式类型转换**。
- en: 暗黙的な型変換では、結果の値の型はオペランドの型に依存しています。 それを避けるには、暗黙的ではない変換 ーー つまり明示的な型変換をする必要があります。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐式类型转换中，结果的类型依赖于操作数的类型。为了避免这种情况，需要使用非隐式转换，即显式类型转换。
- en: '[](#explicit-coercion)*明示的な型変換*'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#explicit-coercion)*显式类型转换*'
- en: '*プリミティブ型へ明示的な型変換をする方法を見ていきます。'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看将原始类型转换为显式类型的方法。'
- en: '[](#any-to-boolean)*任意の値 → 真偽値*'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#any-to-boolean)*任意值 → 布尔值*'
- en: '*JavaScriptでは`Boolean`コンストラクタ関数を使うことで、任意の値を`true`または`false`の真偽値に変換できます。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*在JavaScript中，可以使用`Boolean`构造函数将任意值转换为`true`或`false`的布尔值。'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: JavaScriptでは、次の値は`false`へ変換されます。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，以下值会被转换为`false`。
- en: '`false`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`'
- en: '`undefined`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`'
- en: '`null`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`0`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`'
- en: '`0n`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0n`'
- en: '`NaN`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`'
- en: '`""`（空文字列）'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）'
- en: 暗黙的な型変換によって`false`に変換されるこれらの値をまとめて**falsy**な値と呼びます。 falsyではない値は、`true`へと変換されます。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于隐式类型转换，以下这些值会被汇总为**falsy**值。非falsy值会被转换为`true`。
- en: この変換ルールはif 文の条件式の評価と同様です。 次のようにif 文に対して、真偽値以外の値を渡したときに、真偽値へと暗黙的に変換されてから判定されます。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换规则与if语句的条件表达式评估相同。当向if语句传递非布尔值时，会将其隐式地转换为布尔值进行判断。
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 真偽値については、暗黙的な型変換のルールが少ないため、明示的に変換せずに扱われることも多いです。 しかし、より正確な判定をして真偽値を得るには、次のように厳密等価演算子（`===`）を使って比較します。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于布尔值，由于隐式类型转换的规则较少，因此经常直接处理而不进行显式转换。但是，为了更精确地判断布尔值，可以使用如下严格的等价运算符（`===`）进行比较。
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[](#number-to-string)*数値 → 文字列*'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#number-to-string)*数值 → 字符串*'
- en: '*要明确从数字转换为字符串，可以使用`String`构造函数。'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*要明确从数字转换为字符串，可以使用`String`构造函数。'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`String`构造函数还可以将除了数字之外的各种值转换为字符串。'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`构造函数还可以将除了数字之外的各种值转换为字符串。'
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 正如上面的结果所示，`String`构造函数的明确转换并不是一种万能方法。 对于布尔值、数字、字符串、未定义、null、符号等原始类型的值，转换结果可能不尽人意。
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上面的结果所示，`String`构造函数的明确转换并不是一种万能方法。 对于布尔值、数字、字符串、未定义、null、符号等原始类型的值，转换结果可能不尽人意。
- en: 另一方面，对于对象，返回的字符串通常没有太多意义。 这是因为对于对象，存在比`String`构造函数更适合的方法。 对于数组，有`join`方法，对于对象，有`JSON.stringify`方法等。
    因此，`String`构造函数的转换应仅限于原始类型。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于对象，返回的字符串通常没有太多意义。 这是因为对于对象，存在比`String`构造函数更适合的方法。 对于数组，有`join`方法，对于对象，有`JSON.stringify`方法等。
    因此，`String`构造函数的转换应仅限于原始类型。
- en: '[](#symbol-to-string)*符号 → 字符串*'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#symbol-to-string)*符号 → 字符串*'
- en: '*当将加法运算符用于字符串时，优先考虑字符串连接。 您可能会想：“如果其中一个是字符串，那么结果就是字符串，而不管另一个操作数是什么？”。'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*当将加法运算符用于字符串时，优先考虑字符串连接。 您可能会想：“如果其中一个是字符串，那么结果就是字符串，而不管另一个操作数是什么？”。'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 然而，在 ES2015 中添加的原始类型 Symbol 无法进行隐式类型转换。 对符号使用字符串连接运算符会抛出异常。 因此，即使一个是字符串，加法运算符的结果也不一定是字符串。
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ES2015 中添加的原始类型 Symbol 无法进行隐式类型转换。 对符号使用字符串连接运算符会抛出异常。 因此，即使一个是字符串，加法运算符的结果也不一定是字符串。
- en: 下面的代码示例中，使用字符串连接运算符(`+`)无法将符号转换为字符串，因此会引发`TypeError`异常。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例中，使用字符串连接运算符(`+`)无法将符号转换为字符串，因此会引发`TypeError`异常。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 通过使用`String`构造函数，可以解决这个问题，将符号明确转换为字符串。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`String`构造函数，可以解决这个问题，将符号明确转换为字符串。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[](#string-to-number)*字符串 → 数值*'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#string-to-number)*字符串 → 数值*'
- en: '*将字符串转换为数字的典型案例是接收用户输入的数字。 用户输入始终以字符串形式接收，因此必须先将其转换为数字才能使用。'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*将字符串转换为数字的典型案例是接收用户输入的数字。 用户输入始终以字符串形式接收，因此必须先将其转换为数字才能使用。'
- en: 若要明确从字符串转换为数字，可以使用`Number`构造函数。
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 若要明确从字符串转换为数字，可以使用`Number`构造函数。
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 此外，还可以使用`Number.parseInt`、`Number.parseFloat`等函数从字符串中提取并转换数字。 `Number.parseInt`从字符串中提取整数，`Number.parseFloat`从字符串中提取浮点数。
    `Number.parseInt(字符串, 基数)`的第二个参数指定基数。 例如，如果要解析字符串以获取十进制数值，则将`10`作为第二个参数。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以使用`Number.parseInt`、`Number.parseFloat`等函数从字符串中提取并转换数字。 `Number.parseInt`从字符串中提取整数，`Number.parseFloat`从字符串中提取浮点数。
    `Number.parseInt(字符串, 基数)`的第二个参数指定基数。 例如，如果要解析字符串以获取十进制数值，则将`10`作为第二个参数。
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 然而，用户并不总是输入数字。 `Number`构造函数、
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户并不总是输入数字。 `Number`构造函数、
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 因此，如果从任意值转换为数字后结果为`NaN`，则需要编写相应的处理。 可以使用`Number.isNaN(x)`方法来检查转换结果是否为`NaN`。
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果从任意值转换为数字后结果为`NaN`，则需要编写相应的处理。 可以使用`Number.isNaN(x)`方法来检查转换结果是否为`NaN`。
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[](#nan-is-number-type)*`NaN`是非数字但是属于 Number 类型*'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#nan-is-number-type)*`NaN`是非数字但是属于 Number 类型*'
- en: '*在这里，我们将更详细地了解频繁出现的值`NaN`的情况。 `NaN`是 Not a Number 的缩写，是一种具有特殊性质的 Number 类型的数据。'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这里，我们将更详细地了解频繁出现的值`NaN`的情况。 `NaN`是 Not a Number 的缩写，是一种具有特殊性质的 Number 类型的数据。'
- en: 关于这种名为`NaN`的数据的性质在[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)中有规定，并不仅限于
    JavaScript。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种名为`NaN`的数据的性质在[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)中有规定，并不仅限于
    JavaScript。
- en: 创建`NaN`值的方法很简单，即将不兼容 Number 类型的数据转换为 Number 类型，结果将为`NaN`。 例如，对象是与数字不兼容的数据。 因此，即使明确转换对象，结果也将为`NaN`。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`NaN`值的方法很简单，即将不兼容 Number 类型的数据转换为 Number 类型，结果将为`NaN`。 例如，对象是与数字不兼容的数据。 因此，即使明确转换对象，结果也将为`NaN`。
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: また、`NaN`是一种特殊的值，无论如何进行运算，结果都将是`NaN`。 下面的例子展示了当在计算过程中出现`NaN`值时，最终结果也会是`NaN`。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: また、`NaN`是一种特殊的值，无论如何进行运算，结果都将是`NaN`。 下面的例子展示了当在计算过程中出现`NaN`值时，最终结果也会是`NaN`。
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`NaN`看起来像是与其名字“Not a Number”相矛盾的数据。'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`看起来像是与其名字“Not a Number”相矛盾的数据。'
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`NaN`具有一个特殊的属性，即它与自身不匹配。 通过利用这一特性，可以判断一个值是否为`NaN`。'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`具有一个特殊的属性，即它与自身不匹配。 通过利用这一特性，可以判断一个值是否为`NaN`。'
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 作为相似处理方式，可以使用`Number.isNaN(x)`方法。 在实际判断值是否为`NaN`时，最好使用`Number.isNaN(x)`方法。^(1)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为相似处理方式，可以使用`Number.isNaN(x)`方法。 在实际判断值是否为`NaN`时，最好使用`Number.isNaN(x)`方法。^(1)
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`NaN`是在隐式类型转换中最应该避免的值之一。 原因是，正如前面介绍的那样，无论进行何种运算，`NaN`的结果都是`NaN`。 这会使得计算中出现`NaN`的位置不清晰，从而导致调试困难。'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`NaN`是在隐式类型转换中最应该避免的值之一。 原因是，正如前面介绍的那样，无论进行何种运算，`NaN`的结果都是`NaN`。 这会使得计算中出现`NaN`的位置不清晰，从而导致调试困难。'
- en: 例如，下面的`sum`函数接受可变数量的参数，并返回它们的总和。 但是，当调用`sum(x, y, z)`时，结果变为`NaN`。 这是因为参数中包含了`undefined`（未定义值）。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的`sum`函数接受可变数量的参数，并返回它们的总和。 但是，当调用`sum(x, y, z)`时，结果变为`NaN`。 这是因为参数中包含了`undefined`（未定义值）。
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 因此，`sum(x, y, z);`将产生与下面相同的结果。 将数值加到`undefined`上会得到`NaN`。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`sum(x, y, z);`将产生与下面相同的结果。 将数值加到`undefined`上会得到`NaN`。
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 这意味着，即使在`sum`函数中明确将参数转换为 Number 类型，问题也无法避免。 换句话说，可以看出明确的类型转换也无法解决这个问题。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，即使在`sum`函数中明确将参数转换为 Number 类型，问题也无法避免。 换句话说，可以看出明确的类型转换也无法解决这个问题。
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 避免意外的`NaN`转换的方法大致分为两种。
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 避免意外的`NaN`转换的方法大致分为两种。
- en: 在`sum`函数的一侧（被调用方）中，仅接受 Number 类型的值
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`sum`函数的一侧（被调用方）中，仅接受 Number 类型的值
- en: 在调用`sum`函数时，仅传递 Number 类型的值
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`sum`函数时，仅传递 Number 类型的值
- en: 换句话说，这是由调用方或被调用方处理的，两者都会导致更安全的代码。
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这是由调用方或被调用方处理的，两者都会导致更安全的代码。
- en: 因此，需要明确指定`sum`函数仅接受数字。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要明确指定`sum`函数仅接受数字。
- en: 明确的方法包括在`sum`函数的文档（注释）中描述，或者在参数中添加处理以抛出异常，表示除了数值以外的值。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的方法包括在`sum`函数的文档（注释）中描述，或者在参数中添加处理以抛出异常，表示除了数值以外的值。
- en: 在 JavaScript 中，用于描述参数类型的注释格式[JSDoc](https://jsdoc.app/)很有名。此外，通过在运行时检查值是否为 Number
    类型并通过`throw`语句抛出异常，可以明确`sum`函数的使用方式（关于`throw`语句的解释将在“错误处理”章节中说明）。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，用于描述参数类型的注释格式[JSDoc](https://jsdoc.app/)很有名。此外，通过在运行时检查值是否为 Number
    类型并通过`throw`语句抛出异常，可以明确`sum`函数的使用方式（关于`throw`语句的解释将在“错误处理”章节中说明）。
- en: 通过这两个方面详细实现了`sum`函数的前提条件如下：
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个方面详细实现了`sum`函数的前提条件如下：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 通过明确说明`sum`函数的使用方式，当发生错误时，调用方和被调用方可以清楚地知道问题出在哪里。在这种情况下，问题出在将`undefined`值传递给`sum`函数的调用方。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明确说明`sum`函数的使用方式，当发生错误时，调用方和被调用方可以清楚地知道问题出在哪里。在这种情况下，问题出在将`undefined`值传递给`sum`函数的调用方。
- en: JavaScript 对于类型错误非常宽容，例如会进行隐式类型转换，因此，在编写大型应用程序时，编写能够发现这些难以检测到的错误的代码非常重要。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对于类型错误非常宽容，例如会进行隐式类型转换，因此，在编写大型应用程序时，编写能够发现这些难以检测到的错误的代码非常重要。
- en: '[](#unsolved-problem)*即使是显式转换也无法解决的问题*'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#unsolved-problem)*即使是显式转换也无法解决的问题*'
- en: '*正如前面的例子所示，不是所有情况都可以通过显式转换来解决。将不兼容于 Number 类型的值转换为数字，结果将会是`NaN`。一旦出现`NaN`，就只能通过`Number.isNaN(x)`来判断并结束处理。'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如前面的例子所示，不是所有情况都可以通过显式转换来解决。将不兼容于 Number 类型的值转换为数字，结果将会是`NaN`。一旦出现`NaN`，就只能通过`Number.isNaN(x)`来判断并结束处理。'
- en: JavaScript 的类型转换基本上是向信息减少的方向进行的。因此，在进行显式转换之前，首先需要考虑是否需要转换。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的类型转换基本上是向信息减少的方向进行的。因此，在进行显式转换之前，首先需要考虑是否需要转换。
- en: '[](#judge-empty-string)*判断是否为空字符串*'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#judge-empty-string)*判断是否为空字符串*'
- en: '*例如，假设我们想要判断字符串是否为空字符串。 `""`（空字符串）是 falsy 值，因此可以通过显式使用`Boolean`构造函数将其转换为布尔值。
    但是，虽然 falsy 值不仅限于空字符串，但通过显式转换并不意味着只能判断空字符串。'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*例如，假设我们想要判断字符串是否为空字符串。 `""`（空字符串）是 falsy 值，因此可以通过显式使用`Boolean`构造函数将其转换为布尔值。
    但是，虽然 falsy 值不仅限于空字符串，但通过显式转换并不意味着只能判断空字符串。'
- en: 在下面的代码中，虽然进行了显式类型转换，但`0`也会变成**空字符串**，导致意外行为。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，虽然进行了显式类型转换，但`0`也会变成**空字符串**，导致意外行为。
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 在大多数情况下，获取布尔值的方法不是通过类型转换，而是通过其他方式。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，获取布尔值的方法不是通过类型转换，而是通过其他方式。
- en: 在这种情况下，空字符串被定义为“String 类型且长度为 0 的值”，这样一来，我们可以更准确地编写`isEmptyString`函数。通过以下实现，我们现在能够正确判断值是否为空字符串。
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，空字符串被定义为“String 类型且长度为 0 的值”，这样一来，我们可以更准确地编写`isEmptyString`函数。通过以下实现，我们现在能够正确判断值是否为空字符串。
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 使用`Boolean`进行类型转换是为了方便，但并不是获取准确布尔值的方法。因此，在进行类型转换之前，首先考虑是否可以通过其他方式解决问题也很重要。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Boolean`进行类型转换是为了方便，但并不是获取准确布尔值的方法。因此，在进行类型转换之前，首先考虑是否可以通过其他方式解决问题也很重要。
- en: '[](#conclusion)*总结*'
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#conclusion)*总结*'
- en: '*本章我们学习了隐式类型转换和显式类型转换。'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章我们学习了隐式类型转换和显式类型转换。'
- en: 避免使用隐式类型转换，因为它容易导致意外结果。
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用隐式类型转换，因为它容易导致意外结果。
- en: 在比较时应使用严格等于运算符（`===`）而不是等于运算符（`==`）
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较时应使用严格等于运算符（`===`）而不是等于运算符（`==`）
- en: 使用函数进行显式类型转换而不是运算符进行隐式类型转换
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数进行显式类型转换而不是运算符进行隐式类型转换
- en: 除了显式类型转换外，还有其他方法可以获得布尔值。
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了显式类型转换外，还有其他方法可以获得布尔值。
- en: ¹. 虽然有名为`isNaN`的函数类似，但由于它无法正确判断`NaN`，因此建议使用`Number.isNaN`方法。 ↩************
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. 虽然有名为`isNaN`的函数类似，但由于它无法正确判断`NaN`，因此建议使用`Number.isNaN`方法。 ↩************
