- en: ラッパーオブジェクト
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装对象
- en: 原文：[`jsprimer.net/basic/wrapper-object/`](https://jsprimer.net/basic/wrapper-object/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/wrapper-object/`](https://jsprimer.net/basic/wrapper-object/)
- en: JavaScriptのデータ型はプリミティブ型とオブジェクトに分けられます（詳細は「データ型とリテラル」を参照）。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的数据类型可以分为原始类型和对象（详细信息请参考“数据类型与字面量”）。
- en: 次のコードでは文字列リテラルでプリミティブ型の値である文字列を定義しています。 プリミティブ型の値である文字列は`String`オブジェクトのインスタンスではありません。
    しかし、プリミティブ型の文字列においても、`String`オブジェクトのインスタンスメソッドである`toUpperCase`メソッドを呼び出せます。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，使用字符串字面量定义了原始类型的字符串值。原始类型的字符串不是`String`对象的实例。然而，即使是在原始类型的字符串中，也可以调用`String`对象的实例方法`toUpperCase`。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: プリミティブ型である文字列が`String`のインスタンスメソッドを呼び出せるのは一見不思議です。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型的字符串可以调用`String`的实例方法，这看起来有些不可思议。
- en: この章では、プリミティブ型の値がなぜオブジェクトのメソッドを呼び出せるのかについて解説します。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释为什么原始类型的值可以调用对象的函数。
- en: '*プリミティブ型とラッパーオブジェクト*'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*原始类型与包装对象*'
- en: '*プリミティブ型のデータのうち、真偽値（Boolean）、数値（Number） 、BigInt、文字列（String）、シンボル（Symbol）にはそれぞれ対応するオブジェクトが存在します。たとえば、文字列に対応するオブジェクトとして、`String`オブジェクトがあります。'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*在原始类型数据中，真值（Boolean）、数值（Number）、BigInt、字符串（String）和符号（Symbol）各自都有对应的对象。例如，对于字符串，有`String`对象。'
- en: この`String`オブジェクトを`new`することで`String`オブジェクトのインスタンスを作れます。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`new`创建这个`String`对象，可以创建`String`对象的实例。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: このようにインスタンス化されたものは、プリミティブ型の値を包んだ（ラップした）オブジェクトと言えます。 そのため、このようなオブジェクトをプリミティブ型の値に対しての**ラッパーオブジェクト**と呼びます。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这样实例化的对象可以看作是包裹了原始类型值的对象。因此，这种对象被称为针对原始类型值的**包装对象**。
- en: ラッパーオブジェクトとプリミティブ型の対応は次のとおりです。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 包装对象与原始类型的对应关系如下。
- en: '| ラッパーオブジェクト | プリミティブ型 | 例 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 包装对象 | 原始类型 | 例如 |'
- en: '| --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Boolean` | 真偽値 | `true`や`false` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `Boolean` | 真值 | `true`或`false` |'
- en: '| `Number` | 数値 | `1`や`2` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `Number` | 数值 | `1`或`2` |'
- en: '| `BigInt` | 大整数 | `1n`や`2n` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `BigInt` | 大整数 | `1n`或`2n` |'
- en: '| `String` | 文字列 | `"文字列"` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 文字串 | `"字符串"` |'
- en: '| `Symbol` | シンボル | `Symbol("説明")` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `Symbol` | 符号 | `Symbol("说明")` |'
- en: '注記: `undefined`と`null`に対応するラッパーオブジェクトはありません。'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注记：没有为`undefined`和`null`提供对应的包装对象。
- en: 注意点として、ラッパーオブジェクトは名前のとおりオブジェクトです。 そのため、次のように`typeof`演算子でラッパーオブジェクトを見ると`"object"`です。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：包装对象正如其名，是对象。因此，使用`typeof`运算符查看包装对象时，结果会是`"object"`。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*プリミティブ型の値からラッパーオブジェクトへの自動変換*'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*从原始类型值到包装对象的自动转换*'
- en: '*JavaScriptでは、プリミティブ型の値に対してプロパティアクセスするとき、自動で対応するラッパーオブジェクトに変換されます。 たとえば`"string"`という文字列は、自動的に`new
    String("string")`のようなラッパーオブジェクトへ変換されています。 これにより、プリミティブ型の値である文字列が`String`のインスタンスメソッドを呼び出せるようになります。'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*在JavaScript中，当对原始类型的值进行属性访问时，会自动将其转换为对应的包装对象。例如，字符串`"string"`会自动转换为类似`new
    String("string")`的包装对象。这使得原始类型的字符串可以调用`String`的实例方法。'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: このように、プリミティブ型の値からラッパーオブジェクト���の変換は自動的に行われます。^(1)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，从原始类型值到包装对象的转换是自动进行的。^(1)
- en: 一方、明示的に作成したラッパーオブジェクトからプリミティブ型の値を取り出すこともできます。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也可以从显式创建的包装对象中提取原始类型的值。
- en: '`ラッパーオブジェクト.valueOf`メソッドを呼び出すことで、ラッパーオブジェクトから値を取り出せます。 たとえば、次のように文字列のラッパーオブジェクトから`valueOf`メソッドで文字列を取り出せます。'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`valueOf`方法可以从包装对象中提取值。例如，可以从以下字符串的包装对象中通过`valueOf`方法提取字符串。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: JavaScriptには、リテラルを使ったプリミティブ型の文字列とラッパーオブジェクトを使った文字列オブジェクトがあります（真偽値や数値についても同様です）。
    この2つを明示的に使い分ける利点はないため、常にリテラルを使うことを推奨します。 理由として次の3つが挙げられます。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中，有使用字面量表示的原始类型字符串和用包装对象表示的字符串对象（真值和数值也是如此）。这两者之间没有明确的区分优势，因此推荐始终使用字面量。以下列举三个理由。
- en: 必要に応じて、プリミティブ型の文字列は自動的にラッパーオブジェクトに変換されるため
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要时，原始类型的字符串会自动转换为包装对象
- en: '`new String("string")`のようにラッパーオブジェクトのインスタンスを扱う利点がないため'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new String("string")`这样的包装对象实例的处理优势不存在'
- en: ラッパーオブジェクトを`typeof`演算子で評価した結果が、プリミティブ型ではなく`"object"`となり混乱を生むため
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`typeof`运算符评估包装对象的结果是`"object"`而不是原始类型，这可能会引起混淆
- en: これらの理由などから、プリミティブ型のデータにはリテラルを使います。 常にリテラルを使うことでラッパーオブジェクトを意識する必要がなくなります。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，建议对原始类型的数据始终使用字面量。这样就不需要关注包装对象。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*まとめ*'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*总结*'
- en: '*この章では、プリミティブ型の値がなぜメソッド呼び出しできるのかについて解説しました。 その仕組みの背景にはプリミティブ型に対応したラッパーオブジェクトの存在があります。
    プリミティブ型の値のプロパティへアクセスする際に、自動的にラッパーオブジェクトへ変換されることでメソッド呼び出しなどが可能となっています。'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章解释了为什么原始类型的值可以调用方法。其背后的机制是存在针对原始类型的包装对象。在访问原始类型的属性时，会自动转换为包装对象，从而使得方法调用等操作成为可能。'
- en: 「JavaScriptはすべてがオブジェクトである」と言われることがあります。 プリミティブ型はオブジェクトではありませんが、プリミティブ型に対応したラッパーオブジェクトが用意されています（`null`と`undefined`を除く）。
    そのため、「すべてがオブジェクトのように見える」というのが正しい認識となるでしょう。
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候会说“JavaScript中一切都是对象”，虽然原始类型不是对象，但为原始类型提供了对应的包装对象（除了`null`和`undefined`）。因此，“看起来一切都是对象”这种认识是正确的。
- en: ¹. このようなプリミティブ型からオブジェクト型への変換はボックス化（ボクシング）、逆にオブジェクト型からプリミティブ型への変換はボックス化解除（アンボクシング）と呼ばれます。
    ↩***
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. 这种从原始类型到对象类型的转换称为装箱（boxing），反之，从对象类型到原始类型的转换称为拆箱（unboxing）。 ↩***
