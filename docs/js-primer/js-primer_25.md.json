["```\n<script> // 実行コンテキストは\"Script\"\nconsole.log(this); // => window </script> \n```", "```\n<script type=\"module\"> // 実行コンテキストは\"Module\"\nconsole.log(this); // => undefined </script> \n```", "```\n// ブラウザでは`window`オブジェクト、Node.jsでは`global`オブジェクトを参照する\nconsole.log(globalThis); \n```", "```\n// `function`キーワードからはじめる関数宣言\nfunction fn1() {}\n// `function`を式として扱う関数式\nconst fn2 = function() {};\n// Arrow Functionを使った関数式\nconst fn3 = () => {}; \n```", "```\n// 関数宣言\nfunction fn() {}\n// 関数呼び出し\nfn(); \n```", "```\nconst obj = {\n    // `function`キーワードを使ったメソッド\n    method1: function() {\n    },\n    // Arrow Functionを使ったメソッド\n    method2: () => {\n    }\n}; \n```", "```\nconst obj = {\n    // メソッドの短縮記法で定義したメソッド\n    method() {\n    }\n}; \n```", "```\nconst obj = {\n    // メソッドの定義\n    method() {\n    }\n};\n// メソッド呼び出し\nobj.method(); \n```", "```\n// 疑似的な`this`の値の仕組み\n// 関数は引数として暗黙的に`this`の値を受け取るイメージ\nfunction fn(暗黙的に渡されるthisの値, 仮引数) {\n    console.log(this); // => 暗黙的に渡されるthisの値\n}\n// 暗黙的に`this`の値を引数として渡しているイメージ\nfn(暗黙的に渡すthisの値, 引数); \n```", "```\n// `fn`関数はメソッドではないのでベースオブジェクトはない\nfn();\n// `obj.method`メソッドのベースオブジェクトは`obj`\nobj.method();\n// `obj1.obj2.method`メソッドのベースオブジェクトは`obj2`\n// ドット演算子、ブラケット演算子どちらも結果は同じ\nobj1.obj2.method();\nobj1[\"obj2\"][\"method\"](); \n```", "```\n\"use strict\";\nfunction fn1() {\n    return this;\n}\nconst fn2 = function() {\n    return this;\n};\n// 関数の中の`this`が参照する値は呼び出し方によって決まる\n// `fn1`と`fn2`どちらもただの関数として呼び出している\n// メソッドとして呼び出していないためベースオブジェクトはない\n// ベースオブジェクトがない場合、`this`は`undefined`となる\nconsole.log(fn1()); // => undefined\nconsole.log(fn2()); // => undefined \n```", "```\n\"use strict\";\nfunction outer() {\n    console.log(this); // => undefined\n    function inner() {\n        console.log(this); // => undefined\n    }\n    // `inner`関数呼び出しのベースオブジェクトはない\n    inner();\n}\n// `outer`関数呼び出しのベースオブジェクトはない\nouter(); \n```", "```\nconst obj = {\n    // 関数式をプロパティの値にしたメソッド\n    method1: function() {\n        return this;\n    },\n    // 短縮記法で定義したメソッド\n    method2() {\n        return this;\n    }\n};\n// メソッド呼び出しの場合、それぞれの`this`はベースオブジェクト(`obj`)を参照する\n// メソッド呼び出しの`.`の左にあるオブジェクトがベースオブジェクト\nconsole.log(obj.method1()); // => obj\nconsole.log(obj.method2()); // => obj \n```", "```\nconst person = {\n    fullName: \"Brendan Eich\",\n    sayName: function() {\n        // `person.fullName`と書いているのと同じ\n        return this.fullName;\n    }\n};\n// `person.fullName`を出力する\nconsole.log(person.sayName()); // => \"Brendan Eich\" \n```", "```\nconst obj1 = {\n    obj2: {\n        obj3: {\n            method() {\n                return this;\n            }\n        }\n    }\n};\n// `obj1.obj2.obj3.method`メソッドの`this`は`obj3`を参照\nconsole.log(obj1.obj2.obj3.method() === obj1.obj2.obj3); // => true \n```", "```\n\"use strict\";\nconst person = {\n    fullName: \"Brendan Eich\",\n    sayName: function() {\n        // `this`は呼び出し元によって異なる\n        return this.fullName;\n    }\n};\n// `sayName`メソッドは`person`オブジェクトに所属する\n// `this`は`person`オブジェクトとなる\nconsole.log(person.sayName()); // => \"Brendan Eich\"\n// `person.sayName`を`say`変数に代入する\nconst say = person.sayName;\n// 代入したメソッドを関数として呼ぶ\n// この`say`関数はどのオブジェクトにも所属していない\n// `this`はundefinedとなるため例外を投げる\nsay(); // => TypeError: Cannot read property 'fullName' of undefined \n```", "```\n\"use strict\";\n// const say = person.sayName; は次のようなイメージ\nconst say = function() {\n    return this.fullName;\n};\n// `this`は`undefined`となるため例外を投げる\nsay(); // => TypeError: Cannot read property 'fullName' of undefined \n```", "```\n関数.call(thisの値, ...関数の引数); \n```", "```\n\"use strict\";\nfunction say(message) {\n    return `${message} ${this.fullName}！`;\n}\nconst person = {\n    fullName: \"Brendan Eich\"\n};\n// `this`を`person`にして`say`関数を呼びだす\nconsole.log(say.call(person, \"こんにちは\")); // => \"こんにちは Brendan Eich！\"\n// `say`関数をそのまま呼び出すと`this`は`undefined`となるため例外が発生\nsay(\"こんにちは\"); // => TypeError: Cannot read property 'fullName' of undefined \n```", "```\n関数.apply(thisの値, [関数の引数 1, 関数の引数 2]); \n```", "```\n\"use strict\";\nfunction say(message) {\n    return `${message} ${this.fullName}！`;\n}\nconst person = {\n    fullName: \"Brendan Eich\"\n};\n// `this`を`person`にして`say`関数を呼びだす\n// callとは異なり引数を配列として渡す\nconsole.log(say.apply(person, [\"こんにちは\"])); // => \"こんにちは Brendan Eich！\"\n// `say`関数をそのまま呼び出すと`this`は`undefined`となるため例外が発生\nsay(\"こんにちは\"); // => TypeError: Cannot read property 'fullName' of undefined \n```", "```\nfunction add(x, y) {\n    return x + y;\n}\n// `this`が不要な場合は、nullを渡す\nconsole.log(add.call(null, 1, 2)); // => 3\nconsole.log(add.apply(null, [1, 2])); // => 3 \n```", "```\n関数.bind(thisの値, ...関数の引数); // => thisや引数がbindされた関数 \n```", "```\nfunction say(message) {\n    return `${message} ${this.fullName}！`;\n}\nconst person = {\n    fullName: \"Brendan Eich\"\n};\n// `this`を`person`に束縛した`say`関数をラップした関数を作る\nconst sayPerson = say.bind(person, \"こんにちは\");\nconsole.log(sayPerson()); // => \"こんにちは Brendan Eich！\" \n```", "```\nfunction say(message) {\n    return `${message} ${this.fullName}！`;\n}\nconst person = {\n    fullName: \"Brendan Eich\"\n};\n// `this`を`person`に束縛した`say`関数をラップした関数を作る\n//  say.bind(person, \"こんにちは\"); は次のようなラップ関数を作る\nconst sayPerson = () => {\n    return say.call(person, \"こんにちは\");\n};\nconsole.log(sayPerson()); // => \"こんにちは Brendan Eich！\" \n```", "```\n\"use strict\";\n// strict modeを明示しているのは、thisがグローバルオブジェクトに暗黙的に変換されるのを防止するため\nconst Prefixer = {\n    prefix: \"pre\",\n    /**\n     * `strings`配列の各要素にprefixをつける\n     */\n    prefixArray(strings) {\n        return strings.map(function(str) {\n            // コールバック関数における`this`は`undefined`となる(strict mode)\n            // そのため`this.prefix`は`undefined.prefix`となり例外が発生する\n            return this.prefix + \"-\" + str;\n        });\n    }\n};\n// `prefixArray`メソッドにおける`this`は`Prefixer`\nPrefixer.prefixArray([\"a\", \"b\", \"c\"]); // => TypeError: Cannot read property 'prefix' of undefined \n```", "```\n// ...\n    prefixArray(strings) {\n        // 無名関数をコールバック関数として渡している\n        return strings.map(function(str) {\n            return this.prefix + \"-\" + str;\n        });\n    }\n// ... \n```", "```\n\"use strict\";\n// strict modeを明示しているのは、thisがグローバルオブジェクトに暗黙的に変換されるのを防止するため\nconst Prefixer = {\n    prefix: \"pre\",\n    prefixArray(strings) {\n        // コールバック関数は`callback()`のように呼び出される\n        // そのためコールバック関数における`this`は`undefined`となる(strict mode)\n        const callback = function(str) {\n            return this.prefix + \"-\" + str;\n        };\n        return strings.map(callback);\n    }\n};\n// `prefixArray`メソッドにおける`this`は`Prefixer`\nPrefixer.prefixArray([\"a\", \"b\", \"c\"]); // => TypeError: Cannot read property 'prefix' of undefined \n```", "```\n\"use strict\";\nconst Prefixer = {\n    prefix: \"pre\",\n    prefixArray(strings) {\n        // `that`は`prefixArray`メソッド呼び出しにおける`this`となる\n        // つまり`that`は`Prefixer`オブジェクトを参照する\n        const that = this;\n        return strings.map(function(str) {\n            // `this`ではなく`that`を参照する\n            return that.prefix + \"-\" + str;\n        });\n    }\n};\n// `prefixArray`メソッドにおける`this`は`Prefixer`\nconst prefixedStrings = Prefixer.prefixArray([\"a\", \"b\", \"c\"]);\nconsole.log(prefixedStrings); // => [\"pre-a\", \"pre-b\", \"pre-c\"] \n```", "```\n\"use strict\";\nconst Prefixer = {\n    prefix: \"pre\",\n    prefixArray(strings) {\n        // Arrayの`map`メソッドは第二引数に`this`となる値を渡せる\n        return strings.map(function(str) {\n            // `this`が第二引数の値と同じになる\n            // つまり`prefixArray`メソッドと同じ`this`となる\n            return this.prefix + \"-\" + str;\n        }, this);\n    }\n};\n// `prefixArray`メソッドにおける`this`は`Prefixer`\nconst prefixedStrings = Prefixer.prefixArray([\"a\", \"b\", \"c\"]);\nconsole.log(prefixedStrings); // => [\"pre-a\", \"pre-b\", \"pre-c\"] \n```", "```\n\"use strict\";\nconst Prefixer = {\n    prefix: \"pre\",\n    prefixArray(strings) {\n        return strings.map((str) => {\n            // Arrow Function 自体は`this`を持たない\n            // `this`は外側の`prefixArray`関数が持つ`this`を参照する\n            // そのため`this.prefix`は\"pre\"となる\n            return this.prefix + \"-\" + str;\n        });\n    }\n};\n// このとき、`prefixArray`のベースオブジェクトは`Prefixer`となる\n// つまり、`prefixArray`メソッド内の`this`は`Prefixer`を参照する\nconst prefixedStrings = Prefixer.prefixArray([\"a\", \"b\", \"c\"]);\nconsole.log(prefixedStrings); // => [\"pre-a\", \"pre-b\", \"pre-c\"] \n```", "```\n// thisはキーワードであるため、ユーザーは`this`という名前の変数を定義できない\nconst this = \"thisは読み取り専用\"; // => SyntaxError: Unexpected token this \n```", "```\n// Arrow Functionで定義した関数\nconst fn = () => {\n    // この関数の外側には関数は存在しない\n    // トップレベルの`this`と同じ値\n    return this;\n};\nconsole.log(fn() === this); // => true \n```", "```\n\"use strict\";\nfunction outer() {\n    // Arrow Functionで定義した関数を返す\n    return () => {\n        // この関数の外側には`outer`関数が存在する\n        // `outer`関数に`this`を書いた場合と同じ\n        return this;\n    };\n}\n// `outer`関数の返り値はArrow Functionにて定義された関数\nconst innerArrowFunction = outer();\nconsole.log(innerArrowFunction()); // => undefined \n```", "```\n\"use strict\";\nfunction outer() {\n    // `outer`関数直下の`this`\n    const that = this;\n    // Arrow Functionで定義した関数を返す\n    return () => {\n        // Arrow Function 自身は`this`を持たない\n        // `outer`関数に`this`を書いた場合と同じ\n        return that;\n    };\n}\n// `outer()`と呼び出したときの`this`は`undefined`(strict mode)\nconst innerArrowFunction = outer();\nconsole.log(innerArrowFunction()); // => undefined \n```", "```\n// `callback`関数を受け取り呼び出す関数\nconst callCallback = (callback) => {\n    // `callback`を呼び出す実装\n};\n\nconst obj = {\n    method() {\n        callCallback(function() {\n            // ここでの `this` は`callCallback`の実装に依存する\n            // `callback()`のように単純に呼び出されるなら`this`は`undefined`になる\n            // Functionの`call`メソッドなどを使って特定のオブジェクトを指定するかもしれない\n            // この問題を回避するために`const that = this`のような一時変数を使う\n        });\n    }\n}; \n```", "```\n// `callback`関数を受け取り呼び出す関数\nconst callCallback = (callback) => {\n    // `callback`を呼び出す実装\n};\n\nconst obj = {\n    method() {\n        callCallback(() => {\n            // ここでの`this`は1つ外側の関数における`this`と同じ\n        });\n    }\n}; \n```", "```\nconst Prefixer = {\n    prefix: \"pre\",\n    prefixArray(strings) {\n        return strings.map((str) => {\n            // `Prefixer.prefixArray()` と呼び出されたとき\n            // `this`は常に`Prefixer`を参照する\n            return this.prefix + \"-\" + str;\n        });\n    }\n};\nconst prefixedStrings = Prefixer.prefixArray([\"a\", \"b\", \"c\"]);\nconsole.log(prefixedStrings); // => [\"pre-a\", \"pre-b\", \"pre-c\"] \n```", "```\nconst fn = () => {\n    return this;\n};\n// Scriptコンテキストの場合、スクリプト直下のArrow Functionの`this`はグローバルオブジェクト\nconsole.log(fn()); // グローバルオブジェクト\n// callで`this`を`{}`にしようとしても、`this`は変わらない\nconsole.log(fn.call({})); // グローバルオブジェクト \n```", "```\nconst obj = {\n    method() {\n        const arrowFunction = () => {\n            return this;\n        };\n        return arrowFunction();\n    }\n};\n// 通常の`this`は`obj.method`の`this`と同じ\nconsole.log(obj.method()); // => obj\n// `obj.method`の`this`を変更すれば、Arrow Functionの`this`も変更される\nconsole.log(obj.method.call(\"THAT\")); // => \"THAT\" \n```"]