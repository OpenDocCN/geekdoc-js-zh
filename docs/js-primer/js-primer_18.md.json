["```\n// プロパティを持たない空のオブジェクトを作成\nconst obj = {}; \n```", "```\n// プロパティを持つオブジェクトを定義する\nconst obj = {\n    // キー: 値\n    \"key\": \"value\"\n}; \n```", "```\n// プロパティ名（キー）はクォートを省略することが可能\nconst obj = {\n    // キー: 値\n    key: \"value\"\n}; \n```", "```\nconst object = {\n    // キー: 値\n    my-prop: \"value\" // NG\n}; \n```", "```\nconst obj = {\n    // キー: 値\n    \"my-prop\": \"value\" // OK\n}; \n```", "```\nconst color = {\n    // それぞれのプロパティは`,`で区切る\n    red: \"red\",\n    green: \"green\",\n    blue: \"blue\"\n}; \n```", "```\nconst name = \"名前\";\n// `name`というプロパティ名で`name`の変数を値に設定したオブジェクト\nconst obj = {\n    name: name\n};\nconsole.log(obj); // => { name: \"名前\" } \n```", "```\nconst name = \"名前\";\n// `name`というプロパティ名で`name`の変数を値に設定したオブジェクト\nconst obj = {\n    name\n};\nconsole.log(obj); // => { name: \"名前\" } \n```", "```\n// プロパティを持たない空のオブジェクトを作成\n// = `Object`からインスタンスオブジェクトを作成\nconst obj = new Object();\nconsole.log(obj); // => {} \n```", "```\nconst obj = {\n    key: \"value\"\n};\n// ドット記法で参照\nconsole.log(obj.key); // => \"value\"\n// ブラケット記法で参照\nconsole.log(obj[\"key\"]); // => \"value\" \n```", "```\nobj.key; // OK\n// プロパティ名が数字から始まる識別子は利用できない\nobj.123; // NG\n// プロパティ名にハイフンを含む識別子は利用できない\nobj.my-prop; // NG \n```", "```\nconst obj = {\n    key: \"value\",\n    123: 456,\n    \"my-key\": \"my-value\"\n};\n\nconsole.log(obj[\"key\"]); // => \"value\"\n// プロパティ名が数字からはじまる識別子も利用できる\nconsole.log(obj[123]); // => 456\n// プロパティ名は暗黙的に文字列に変換されているため、次も同じプロパティを参照している\nconsole.log(obj[\"123\"]); // => 456\n// プロパティ名にハイフンを含む識別子も利用できる\nconsole.log(obj[\"my-key\"]); // => \"my-value\" \n```", "```\nconst languages = {\n    ja: \"日本語\",\n    en: \"英語\"\n};\nconst myLang = \"ja\";\nconsole.log(languages[myLang]); // => \"日本語\" \n```", "```\nconst languages = {\n    ja: \"日本語\",\n    en: \"英語\"\n};\nconst ja = languages.ja;\nconst en = languages.en;\nconsole.log(ja); // => \"日本語\"\nconsole.log(en); // => \"英語\" \n```", "```\nconst languages = {\n    ja: \"日本語\",\n    en: \"英語\"\n};\nconst { ja, en } = languages;\nconsole.log(ja); // => \"日本語\"\nconsole.log(en); // => \"英語\" \n```", "```\n// 空のオブジェクト\nconst obj = {};\n// `key`プロパティを追加して値を代入\nobj.key = \"value\";\nconsole.log(obj.key); // => \"value\" \n```", "```\nconst key = \"key-string\";\nconst obj = {};\n// `key`の評価結果 \"key-string\" をプロパティ名に利用\nobj[key] = \"value of key\";\n// 取り出すときも同じく`key`変数を利用\nconsole.log(obj[key]); // => \"value of key\" \n```", "```\nconst key = \"key-string\";\n// Computed Propertyで`key`の評価結果 \"key-string\" をプロパティ名に利用\nconst obj = {\n    [key]: \"value\"\n};\nconsole.log(obj[key]); // => \"value\" \n```", "```\nfunction changeProperty(obj) {\n    obj.key = \"value\";\n    // いろいろな処理...\n}\nconst obj = {};\nchangeProperty(obj); // objのプロパティを変更している\nconsole.log(obj.key); // => \"value\" \n```", "```\nconst obj = {\n    key1: \"value1\",\n    key2: \"value2\"\n};\n// key1プロパティを削除\ndelete obj.key1;\n// key1プロパティが削除されている\nconsole.log(obj); // => { \"key2\": \"value2\" } \n```", "```\nconst obj = { key: \"value\" };\nobj.key = \"Hi!\"; // constで定義したオブジェクト(`obj`)が変更できる\nconsole.log(obj.key); // => \"Hi!\" \n```", "```\nconst obj = { key: \"value\" };\nobj = {}; // => TypeError \n```", "```\n\"use strict\";\nconst object = Object.freeze({ key: \"value\" });\n// freezeしたオブジェクトにプロパティを追加や変更できない\nobject.key = \"value\"; // => TypeError: \"key\" is read-only \n```", "```\nconst obj = {};\nconsole.log(obj.notFound); // => undefined \n```", "```\nconst widget = {\n    window: {\n        title: \"ウィジェットのタイトル\"\n    }\n};\n// `window`を`windw`と間違えているが、例外は発生しない\nconsole.log(widget.windw); // => undefined\n// さらにネストした場合に、例外が発生する\n// `undefined.title`と書いたのと同じ意味となるため\nconsole.log(widget.windw.title); // => TypeError: widget.windw is undefined\n// 例外が発生した文以降は実行されません \n```", "```\nconst obj = {\n    key: \"value\"\n};\n// `key`プロパティが`undefined`ではないなら、プロパティが存在する?\nif (obj.key !== undefined) {\n    // `key`プロパティが存在する?ときの処理\n    console.log(\"`key`プロパティの値は`undefined`ではない\");\n} \n```", "```\nconst obj = {\n    key: undefined\n};\n// `key`プロパティの値が`undefined`である場合\nif (obj.key !== undefined) {\n    // この行は実行されません\n} \n```", "```\n\"プロパティ名\" in オブジェクト; // true or false \n```", "```\nconst obj = { key: undefined };\n// `key`プロパティを持っているならtrue\nif (\"key\" in obj) {\n    console.log(\"`key`プロパティは存在する\");\n} \n```", "```\nconst obj = {};\n// objが\"プロパティ名\"を持っているかを確認する\nObject.hasOwn(obj, \"プロパティ名\"); // true or false \n```", "```\nconst obj = { key: undefined };\n// `obj`が`key`プロパティを持っているならtrueとなる\nif (Object.hasOwn(obj, \"key\")) {\n    console.log(\"`obj`は`key`プロパティを持っている\");\n} \n```", "```\nconst obj = { key: undefined };\n// `obj`が`key`プロパティを持っているならtrueとなる\nif (obj.hasOwnProperty(\"key\")) {\n    console.log(\"`obj`は`key`プロパティを持っている\");\n} \n```", "```\nfunction printWidgetTitle(widget) {\n    // 例外を避けるために`widget`のプロパティの存在を順番に確認してから、値を表示している\n    if (widget.window !== undefined && widget.window.title !== undefined) {\n        console.log(`ウィジェットのタイトルは${widget.window.title}です`);\n    } else {\n        console.log(\"ウィジェットのタイトルは未定義です\");\n    }\n}\n// タイトルが定義されているwidget\nprintWidgetTitle({\n    window: {\n        title: \"Book Viewer\"\n    }\n});\n// タイトルが未定義のwidget\nprintWidgetTitle({\n    // タイトルが定義されてない空のオブジェクト\n}); \n```", "```\nconst obj = {\n    a: {\n        b: \"objのaプロパティのbプロパティ\"\n    }\n};\n// obj.a.b は存在するので、その評価結果を返す\nconsole.log(obj?.a?.b); // => \"objのaプロパティのbプロパティ\"\n// 存在しないプロパティのネストも`undefined`を返す\n// ドット記法の場合は例外が発生してしまう\nconsole.log(obj?.notFound?.notFound); // => undefined\n// undefinedやnullはnullishなので、`undefined`を返す\nconsole.log(undefined?.notFound?.notFound); // => undefined\nconsole.log(null?.notFound?.notFound); // => undefined \n```", "```\nfunction printWidgetTitle(widget) {\n    const title = widget?.window?.title ?? \"未定義\";\n    console.log(`ウィジェットのタイトルは${title}です`);\n}\nprintWidgetTitle({\n    window: {\n        title: \"Book Viewer\"\n    }\n}); // \"ウィジェットのタイトルはBook Viewerです\" と出力される\nprintWidgetTitle({\n    // タイトルが定義されてない空のオブジェクト\n}); // \"ウィジェットのタイトルは未定義です\" と出力される \n```", "```\nconst languages = {\n    ja: {\n        hello: \"こんにちは！\"\n    },\n    en: {\n        hello: \"Hello!\"\n    }\n};\nconst langJapanese = \"ja\";\nconst langKorean = \"ko\";\nconst messageKey = \"hello\";\n// Optional chaining 演算子（`?.`）とブラケット記法を組みわせた書き方\nconsole.log(languages?.[langJapanese]?.[messageKey]); // => \"こんにちは！\"\n// `languages`に`ko`プロパティが定義されていないため、`undefined`を返す\nconsole.log(languages?.[langKorean]?.[messageKey]); // => undefined \n```", "```\nconst obj = { key: \"value\" };\nconsole.log(obj.toString()); // => \"[object Object]\"\n// `String`コンストラクタ関数は`toString`メソッドを呼んでいる\nconsole.log(String(obj)); // => \"[object Object]\" \n```", "```\n// 独自のtoStringメソッドを定義\nconst customObject = {\n    toString() {\n        return \"custom value\";\n    }\n};\nconsole.log(String(customObject)); // => \"custom value\" \n```", "```\nconst obj = {};\nconst keyObject1 = { a: 1 };\nconst keyObject2 = { b: 2 };\n// どちらも同じプロパティ名（\"[object Object]\"）に代入している\nobj[keyObject1] = \"1\";\nobj[keyObject2] = \"2\";\nconsole.log(obj); //  { \"[object Object]\": \"2\" } \n```", "```\nconst obj = {};\n// Symbolは例外的に文字列化されず扱える\nconst symbolKey1 = Symbol(\"シンボル1\");\nconst symbolKey2 = Symbol(\"シンボル2\");\nobj[symbolKey1] = \"1\";\nobj[symbolKey2] = \"2\";\nconsole.log(obj[symbolKey1]); // => \"1\"\nconsole.log(obj[symbolKey2]); // => \"2\" \n```", "```\nconst obj = {\n    \"one\": 1,\n    \"two\": 2,\n    \"three\": 3\n};\n// `Object.keys`はキーを列挙した配列を返す\nconsole.log(Object.keys(obj)); // => [\"one\", \"two\", \"three\"]\n// `Object.values`は値を列挙した配列を返す\nconsole.log(Object.values(obj)); // => [1, 2, 3]\n// `Object.entries`は[キー, 値]の配列を返す\nconsole.log(Object.entries(obj)); // => [[\"one\", 1], [\"two\", 2], [\"three\", 3]] \n```", "```\nconst obj = {\n    \"one\": 1,\n    \"two\": 2,\n    \"three\": 3\n};\nconst keys = Object.keys(obj);\nkeys.forEach(key => {\n    console.log(key);\n});\n// 次の値が順番に出力される\n// \"one\"\n// \"two\"\n// \"three\" \n```", "```\nconst obj = Object.assign(target, ...sources); \n```", "```\nconst objectA = { a: \"a\" };\nconst objectB = { b: \"b\" };\nconst merged = Object.assign({}, objectA, objectB);\nconsole.log(merged); // => { a: \"a\", b: \"b\" } \n```", "```\nconst objectA = { a: \"a\" };\nconst objectB = { b: \"b\" };\nconst merged = Object.assign(objectA, objectB);\nconsole.log(merged); // => { a: \"a\", b: \"b\" }\n// `objectA`が変更されている\nconsole.log(objectA); // => { a: \"a\", b: \"b\" }\nconsole.log(merged === objectA); // => true \n```", "```\n// `version`のプロパティ名が被っている\nconst objectA = { version: \"a\" };\nconst objectB = { version: \"b\" };\nconst merged = Object.assign({}, objectA, objectB);\n// 後ろにある`objectB`のプロパティで上書きされる\nconsole.log(merged); // => { version: \"b\" } \n```", "```\nconst objectA = { a: \"a\" };\nconst objectB = { b: \"b\" };\nconst merged = {\n    ...objectA,\n    ...objectB\n};\nconsole.log(merged); // => { a: \"a\", b: \"b\" } \n```", "```\n// `version`のプロパティ名が被っている\nconst objectA = { version: \"a\" };\nconst objectB = { version: \"b\" };\nconst merged = {\n    ...objectA,\n    ...objectB,\n    other: \"other\"\n};\n// 後ろにある`objectB`のプロパティで上書きされる\nconsole.log(merged); // => { version: \"b\", other: \"other\" } \n```", "```\n// 引数の`obj`を浅く複製したオブジェクトを返す\nconst shallowClone = (obj) => {\n    return Object.assign({}, obj);\n};\nconst obj = { a: \"a\" };\nconst cloneObj = shallowClone(obj);\nconsole.log(cloneObj); // => { a: \"a\" }\n// オブジェクトを複製しているので、異なるオブジェクトとなる\nconsole.log(obj === cloneObj); // => false \n```", "```\nconst shallowClone = (obj) => {\n    return Object.assign({}, obj);\n};\nconst obj = {\n    level: 1,\n    nest: {\n        level: 2\n    },\n};\nconst cloneObj = shallowClone(obj);\n// `nest`プロパティのオブジェクトは同じオブジェクトのままになる \nconsole.log(cloneObj.nest === obj.nest); // => true \n```", "```\n// 引数の`obj`を浅く複製したオブジェクトを返す\nconst shallowClone = (obj) => {\n    return Object.assign({}, obj);\n};\n// 引数の`obj`を深く複製したオブジェクトを返す\nfunction deepClone(obj) {\n    const newObj = shallowClone(obj);\n    // プロパティがオブジェクト型であるなら、再帰的に複製する\n    Object.keys(newObj)\n        .filter(k => typeof newObj[k] === \"object\")\n        .forEach(k => newObj[k] = deepClone(newObj[k]));\n    return newObj;\n}\nconst obj = {\n    level: 1,\n    nest: {\n        level: 2\n    }\n};\nconst cloneObj = deepClone(obj);\n// `nest`オブジェクトも再帰的に複製されている\nconsole.log(cloneObj.nest === obj.nest); // => false \n```"]