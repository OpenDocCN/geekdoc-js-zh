# 函数和作用域

> 原文：[`jsprimer.net/basic/function-scope/`](https://jsprimer.net/basic/function-scope/)

每个定义的函数都有自己的作用域。作用域决定了变量或函数参数等的可引用范围。在 JavaScript 中，定义新函数会创建一个与该函数相关联的新作用域。定义函数不仅仅是将处理内容组合在一起，还创建了一个新的作用域来确定变量的有效范围。

理解作用��的机制有助于更深入地理解函数。因为函数和作用域之间有着密切的关系。本章将重点介绍函数和作用域之间的关系，以及作用域的作用以及作用域内变量的取值方式。

JavaScript 的作用域在 ES2015 中得到了直观易懂的改进。基本上，只要理解了 ES2015 及以后的机制，编写代码就不会有问题。

然而，为了理解现有代码，您还需要了解 ES2015 之前确定的旧机制。因为现有代码有时会使用旧机制编写。此外，在 JavaScript 中，可以混合使用旧机制和新机制编写代码。由于旧机制的作用域存在许多不直观的行为，因此我们也会补充介绍旧机制。

## [](#what-is-scope)*作用域是什么*

*作用域决定了变量名或函数等可被引用的范围。在作用域中定义的变量只能在该作用域内部引用，外部无法引用。

以函数作用域为例，看看身边的作用域示例。

在下面的代码中，我们在`fn`函数的块（`{`和`}`）内定义了变量`x`。这个变量`x`是在`fn`函数的作用域中定义的，因此在`fn`函数内部可以引用。然而，在`fn`函数外部无法引用变量`x`，因此会导致`ReferenceError`异常。

```
function fn() {
    const x = 1;
    // fn 関数のスコープ内から`x`は参照できる
    console.log(x); // => 1
}
fn();
// fn 関数のスコープ外から`x`は参照できないためエラー
console.log(x); // => ReferenceError: x is not defined 
```

如下代码所示，变量`x`是在`fn`函数的作用域中定义的。因此，变量`x`只能在`fn`函数的作用域内部引用。

函数可以拥有**形参**，但形参是在函数作用域中定义的。因此，形参只能在该函数内部引用，外部无法引用。

```
function fn(arg) {
    // fn 関数のスコープ内から仮引数`arg`は参照できる
    console.log(arg); // => 1
}
fn(1);
// fn 関数のスコープ外から`arg`は参照できないためエラー
console.log(arg); // => ReferenceError: arg is not defined 
```

这种通过函数确定作用域的概念被称为**函数作用域**。

在“变量和声明”章节中，我们讨论了`let`和`const`不能在同一作用域内重复定义相同名称变量的问题。这是因为每个作用域只能声明一个同名变量（使用`var`声明的变量和使用`function`声明的函数是例外）。 

```
// スコープ内に同じ"a"を定義すると SyntaxError となる
let a;
let a; 
```

在不同作用域中，可以使用相同名称来声明变量。在下面的代码中，我们可以看到在不同作用域中的`fnA`函数和`fnB`函数中分别定义了变量`x`。

```
// 異なる関数のスコープには同じ"x"を定義できる
function fnA() {
    let x;
}
function fnB() {
    let x;
} 
```

由于作用域不同，因此可以在不同作用域中定义相同名称的变量。作用域的存在使得可以在每个作用域中定义相同名称的变量，因此作用域的作用非常重要。

## [](#block-scope)*块级作用域*

*用`{`和`}`括起来的范围称为块（请参阅“语句和表达式”章节）。块也会创建作用域。在块内声明的变量只能在作用域内部引用，外部无法引用。

```
// ブロック内で定義した変数はスコープ内でのみ参照できる
{
    const x = 1;
    console.log(x); // => 1
}
// スコープの外から`x`を参照できないためエラー
console.log(x); // => ReferenceError: x is not defined 
```

通过块来创建作用域的概念被称为**块级作用域**。

if 语句或 while 语句也会创建块级作用域。与单独的块级作用域一样，在块内声明的变量无法从外部引用。

```
// if 文のブロック内で定義した変数はブロックスコープの中でのみ参照できる
if (true) {
    const x = "inner";
    console.log(x); // => "inner"
}
console.log(x); // => ReferenceError: x is not defined 
```

for 循环会为每个循环创建一个新的块级作用域。考虑到“每个作用域只能声明一个同名变量”的规则，这一点就很容易理解了。在下面的代码中，我们使用`const`在每次循环中定义`element`变量，但却可以无错误地定义。这是因为每次循环都会创建一个独立的块级作用域，变量声明也会在各自独立的作用域中进行。

```
const array = [1, 2, 3, 4, 5];
// ループごとに新しいブロックスコープを作成する
for (const element of array) {
    // forのブロックスコープの中でのみ`element`を参照できる
    console.log(element);
}
// ループの外からはブロックスコープ内の変数は参照できない
console.log(element); // => ReferenceError: element is not defined 
```

## [](#scope-chain)*作用域链*

*函数和块可以嵌套编写，同样，作用域也可以嵌套。在下面的代码中，我们在一个块内部编写了另一个块。在这种情况下，我们将外部块级作用域称为`OUTER`，内部块级作用域称为`INNER`。

```
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
    }
} 
```

当作用域嵌套时，内部作用域可以引用外部作用域中的变量。在下面的代码中，内部的 INNER 块级作用域可以引用外部的 OUTER 块级作用域中定义的变量`x`。这种情况不仅限于块级作用域，函数作用域也是如此。

```
{
    // OUTERブロックスコープ
    const x = "x";
    {
        // INNERブロックスコープからOUTERブロックスコープの変数を参照できる
        console.log(x); // => "x"
    }
} 
```

在引用变量时，会逐级检查当前作用域（包含引用变量的表达式的作用域）向外部作用域逐级定义变量的情况。在上述代码中，虽然内部的 INNER 块级作用域中不存在变量`x`，但外部的 OUTER 块级作用域中定义了变量`x`，因此可以引用。换句话说，我们正在按照以下步骤搜索要引用的变量。

1.  检查 INNER 块级作用域中是否存在变量`x` => 不存在

1.  检查一级外部 OUTER 块级作用域中是否存在变量`x` => 存在

另一方面，如果在当前作用域以及外部任何作用域中都没有定义相应的变量，则会导致`ReferenceError`异常。在下面的例子中，由于引用了任何作用域中都不存在的`xyz`，因此会导致`ReferenceError`异常。

```
{
    // OUTERブロックスコープ
    {
        // INNERブロックスコープ
        console.log(xyz); // => ReferenceError: xyz is not defined
    }
} 
```

在这种情况下，我们正在检查从当前作用域（包含引用变量的表达式的作用域）向外部作用域逐级定义变量的情况。然而，由于任何作用域中都没有定义变量`xyz`，因此会导致`ReferenceError`异常。换句话说，我们正在按照以下步骤搜索要引用的变量。

1.  检查 INNER 块级作用域中是否存在变量`xyz` => 不存在

1.  检查一级外部 OUTER 块级作用域中是否存在变量`xyz` => 不存在

1.  最外层作用域中也没有定义变量`xyz` => 导致`ReferenceError`

这种按照内外作用域顺序查找变量定义的机制称为**作用域链**。

即使在内外作用域中都定义了相同名称的变量，作用域链的机制也可以解决。在下面的代码中，内部的 INNER 块作用域和外部的 OUTER 块作用域都定义了相同名称的变量`x`。通过作用域链的机制，优先引用当前作用域中定义的变量`x`。

```
{
    // OUTERブロックスコープ
    const x = "outer";
    {
        // INNERブロックスコープ
        const x = "inner";
        // 現在のスコープ(INNERブロックスコープ)にある`x`を参照する
        console.log(x); // => "inner"
    }
    // 現在のスコープ(OUTERブロックスコープ)にある`x`を参照する
    console.log(x); // => "outer"
} 
```

作用域是层级结构的，当引用变量时，可以通过作用域链来解决哪些变量是可访问的。

## [](#global-scope)*全局作用域*

*以前我们将代码写在程序的顶层，但是这里也存在一个称为**全局作用域**的隐式作用域。全局作用域就像其名称一样，是最外层的作用域，在程序执行时会隐式创建。

```
// プログラム直下はグローバルスコープ
const x = "x";
console.log(x); // => "x" 
```

在全局作用域中定义的变量被称为**全局变量**，全局变量可以从任何作用域中访问。这是因为作用域链的机制允许最终访问最外层的全局作用域中定义的变量。

```
// グローバル変数はどのスコープからも参照できる
const globalVariable = "グローバル";
// ブロックスコープ
{
    // ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
// 関数スコープ
function fn() {
    // 関数ブロックスコープ内には該当する変数が定義されてない -> 外側のスコープへ
    console.log(globalVariable); // => "グローバル"
}
fn(); 
```

全局作用域中除了自定义的全局变量外，还有在程序执行时自动定义的**内置对象**。

内置对象大致分为两种。第一种是由 ECMAScript 规范定义的变量（参见“undefined 不是文字”）如`undefined`、`isNaN`等函数，以及`Array`、`RegExp`等构造函数。第二种是由执行环境（如浏览器或 Node.js 等）定义的对象，如`document`、`module`等。由于两者都会自动定义在全局作用域中，因此在本章中我们将它们都称为**内置对象**。

内置对象在程序启动时会自动定义在全局作用域中，因此可以从任何作用域中访问。

```
// ビルトインオブジェクトは実行環境が自動的に定義している
// どこのスコープから参照してもReferenceErrorにはならない
console.log(isNaN); // => isNaN
console.log(Array); // => Array 
```

自定义的全局变量和内置对象之间，全局变量优先被引用。也就是说，如果定义与内置对象相同名称的变量，那么定义的变量将被引用。

```
// "Array"という名前の変数を定義
const Array = 1;
// 自分で定義した変数がビルトインオブジェクトより優先される
console.log(Array); // => 1 
```

通过定义与内置对象相同名称的变量，将无法访问内置对象。通过在内部作用域中定义与外部作用域相同名称的变量，外部变量将无法访问，这种情况被称为**变量的遮蔽**（shadowing）。

避免这个问题的方法之一是不要随意在全局作用域中定义变量。如果在全局作用域中定义的变量与内置对象发生冲突，将影响所有作用域，但在函数作用域内，影响范围仅限于该函数内。

避免与内置对象相同的名称是困难的。这是因为内置对象在每个执行环境（如浏览器或 Node.js 等）中都有许多独立定义的对象。通过利用函数等将程序重点放在小范围的作用域中编写，即使存在与内置对象相同名称的变量，也可以限定影响范围。

## [](#reduce-scope)*[专栏] 减小变量的作用域*

*不仅仅是全局变量，减小特定变量的作用域是一件好事。因为有时候会意外地引用全局变量而不是当前作用域的变量，反之亦然。如果所有变量都在全局作用域中，那么就无法了解变量在哪里被引用。避免这种情况的简单方法是尽可能在使用的作用域内定义变量。

在下面的代码中，我们试图测量`doHeavyTask`函数的执行时间。`Date.now`方法返回当前时间的毫秒数。通过从**执行后的时间**减去**执行前的时间**，可以得到中间处理的执行时间。

```
function doHeavyTask() {
    // 計測したい処理
}
const startTime = Date.now();
doHeavyTask();
const endTime = Date.now();
console.log(`実行時間は${endTime - startTime}ミリ秒`); 
```

在这段代码中，定义了在计算过程中不会使用的`startTime`和`endTime`两个变量在全局作用域中。如果程序很短，这可能不是问题，但随着程序变得越来越长，影响范围也会扩大。将这两个变量的作用域减小的简单方法是将计时处理过程封装为一个函数。

```
// 実行時間を計測したい関数をコールバック関数として引数に渡す
const measureTask = (taskFn) => {
    const startTime = Date.now();
    taskFn();
    const endTime = Date.now();
    console.log(`実行時間は${endTime - startTime}ミリ秒`);
};
function doHeavyTask() {
    // 計測したい処理
}
measureTask(doHeavyTask); 
```

通过这种方式，我们消除了从全局作用域中删除`startTime`和`endTime`这两个变量。此外，将计时处理过程封装为`measureTask`函数，以便重复使用。

随着代码量的增加，人们一次能够理解的量也有限制。因此，有必要将处理组织到人们一次能够理解的范围内。为了减小变量的作用域，将处理封装为函数是一种常用的方法来解决这个问题。

## [](#hoisting-var)*函数作用域和 var 的提升*

*变量声明可以使用`var`、`let`、`const`。正如在“变量和声明”章节中所介绍的，“`let`是改进版的`var`”，`let`是为了改进`var`而引入的语法。`const`除了不能重新赋值之外，与`let`的行为相同。因此，在可以使用`let`的情况下，没有理由使用`var`，但是由于现有代码或现有库中仍然使用`var`，因此需要理解`var`的行为。

首先，让我们一起看看`let`和`var`共同的行为。`let`和`var`都是在声明变量时没有指定初始值的情况下，变量的评估结果会隐式地变为`undefined`。此外，`let`和`var`都允许在变量声明后赋值。

在下面的代码中，如果在**声明变量之后**引用没有初始值的变量，那么变量的评估结果将是`undefined`。

```
let let_x;
var var_x;
// 宣言後にそれぞれの変数を参照すると`undefined`となる
console.log(let_x); // => undefined
console.log(var_x); // => undefined
// 宣言後に値を代入できる
let_x = "letのx";
var_x = "varのx"; 
```

接下来，我们将看一下`let`和`var`的不同行为。

使用`let`，在**声明之前**引用变量会导致`ReferenceError`异常，无法访问。 下面的代码由于在声明变量`x`之前引用了变量，因此导致`ReferenceError`。 从错误消息中可以看出，错误并不是因为变量`x`不存在，而是因为在实际声明之前引用了它。^(1)

```
console.log(x); // => ReferenceError: can't access lexical declaration `x' before initialization
let x = "letのx"; 
```

另一方面，使用`var`，在**声明之前**引用变量会导致其为`undefined`。 下面的代码尽管在声明之前引用了变量，但不会报错，变量`x`的值会变为`undefined`。

```
// var 宣言より前に参照してもエラーにならない
console.log(x); // => undefined
var x = "varのx"; 
```

可以看出，使用`var`声明的变量可以在声明之前被引用，并且其值为`undefined`，这是一种特殊的行为。

为了理解这种`var`的行为，可以将变量声明看作由**声明**和**赋值**两部分组成。 使用`var`进行变量声明时，**声明**部分会被隐式地提升到最近的函数或全局作用域的顶部，而**赋值**部分则保持在原位置。

这种行为导致变量`x`的声明部分被移动到引用变量`x`的代码之前，导致变量`x`的值在隐式情况下变为`undefined`。 换句话说，上述代码在实际执行时可能被解释和执行如下。

```
// 解釈されたコード
// スコープの先頭に宣言部分が巻き上げられる
var x;
console.log(x); // => undefined
// 変数への代入はそのままの位置に残る
x = "varのx";
console.log(x); // => "varのx" 
```

此外，`var`变量的声明提升会将变量绑定到最近的函数或全局作用域，忽略块级作用域。 因此，即使在`{}`块中使用`var`声明变量，声明部分也会被提升到最近的函数作用域`fn`函数的顶部（在 if 语句或 for 循环中的块级作用域也会被忽略）。

```
function fn() {
    // 内側のスコープにあるはずの変数`x`が参照できる
    console.log(x); // => undefined
    {
        var x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn(); 
```

换句话说，上述代码在实际执行时可能被解释和执行如下。

```
// 解釈されたコード
function fn() {
    // もっとも近い関数スコープの先頭に宣言部分が巻き上げられる
    var x;
    console.log(x); // => undefined
    {
        // 変数への代入はそのままの位置に残る
        x = "varのx";
    }
    console.log(x); // => "varのx"
}
fn(); 
```

这种变量的**声明**部分被看作移动到最近的函数或全局作用域的顶部的行为称为变量的**提升**（hoisting）。

这样，`var`与`let`、`const`有不同的行为。 `var`通过变量提升来忽略块级作用域，自动将声明部分移动到函数作用域的顶部，这带来了一些难以预测的问题。避免这个问题的最简单方法是不使用`var`，但在包含`var`的代码中需要注意这种行为。

## [](#function-declaration-hoisting)*函数声明和变量提升*

*使用`function`关键字进行函数声明也会像`var`一样被提升到最近的函数或全局作用域的顶部。 在下面的代码中，您可以在实际声明`hello`函数的行之前调用函数。

```
// `hello`関数の宣言より前に呼び出せる
hello(); // => "Hello"

function hello(){
    return "Hello";
} 
```

这是因为函数声明本身就是**声明**，所以`hello`函数本身会被提升到作用域的顶部。 换句话说，上述代码在实际执行时可能被解释和执行如下。

```
// 解釈されたコード
// `hello`関数の宣言が巻き上げられる
function hello(){
    return "Hello";
}

hello(); // => "Hello" 
```

使用`function`关键字进行函数声明也会被提升。 但与使用`var`进行变量声明的提升不同，这几乎不会引起问题。 这是因为实际上提升的函数可以被调用。

需要注意的是，如果将函数分配给使用`var`声明的变量，则会按照`var`的规则进行提升。 因此，在将函数分配给变量的函数表达式中使用`var`声明的情况下，由于`hello`变量被提升为`undefined`，因此无法调用（请参阅“函数和声明（函数表达式）”）。

```
// `hello`変数は巻き上げられ、暗黙的に`undefined`となる
hello(); // => TypeError: hello is not a function

// `hello`変数へ関数を代入している
var hello = function(){
    return "Hello";
}; 
```

### [](#immediate-function)*[专栏] 立即执行函数*

*立即执行函数（**IIFE**，*Immediately-Invoked Function Expression*）是为了避免全局作用域污染而产生的习惯用法。

通过在声明无名函数后立即调用，可以将任意处理封装在函数作用域中。 通过创建函数作用域，`foo`变量无法从无名函数外部访问。

```
// 無名関数を宣言 + 実行を同時に行っている
(function() {
    // 関数のスコープ内でfoo 変数を宣言している
    var foo = "foo";
    console.log(foo); // => "foo"
})();
// foo 変数のスコープ外
console.log(typeof foo === "undefined"); // => true 
```

将函数定义为**表达式**，并立即调用它。 由于以`function`开头会被 JavaScript 引擎解释为**函数声明**，因此用无害的括号等将其包围以将其解释为**函数表达式**是一种特殊的写法。 这种写法与下面的写法意义相同，但可以更简洁地定义和执行匿名函数，而不会在全局作用域中留下多余的函数定义。

```
function fn() {
    var foo = "foo";
    console.log(foo); // => "foo"
}
fn();
// foo 変数のスコープ外
console.log(typeof foo === "undefined"); // => true 
```

在 ECMAScript 5 之前，只有`var`一种方法来声明变量。 因此，立即执行函数被用来防止`var`污染全局作用域。

但是，通过 ECMAScript 2015 引入的`let`和`const`，可以在块级作用域中声明变量。 因此，不再需要立即执行函数来防止全局作用域的污染。 上述的立即执行函数可以被`let`和`const`与块级作用域替代。

```
{
    // ブロックスコープ内でfoo 変数を宣言している
    const foo = "foo";
    console.log(foo); // => "foo"
}
// foo 変数のスコープ外
console.log(typeof foo === "undefined"); // => true 
```

## [](#closure)*闭包*

*最后，在本章中我们将探讨与函数和作用域相关的特性，称为闭包。 闭包是指函数具有的一种性质，即“可以保持对外部作用域中变量的引用”。

[闭包](https://wiki.example.org/closure)是一种很难用言语解释清楚的特性。本节的目标是理解使用闭包的代码是如何运作的。

在下面的示例中，`createCounter`函数返回在函数内定义的`increment`函数。 将返回的`increment`函数赋值给`myCounter`变量。每次执行`myCounter`变量时，它都会返回增加 1 的值。

此外，再次执行`createCounter`函数，并将其返回值赋给`newCounter`变量。 `newCounter`变量每次执行时也会递增 1，但可以看出`newCounter`变量与`myCounter`变量及其值并不共享。

```
// `increment`関数を定義して返す関数
function createCounter() {
    let count = 0;
    // `increment`関数は`count`変数を参照
    function increment() {
        count = count + 1;
        return count;
    }
    return increment;
}
// `myCounter`は`createCounter`が返した関数を参照
const myCounter = createCounter();
myCounter(); // => 1
myCounter(); // => 2
// 新しく`newCounter`を定義する
const newCounter = createCounter();
newCounter(); // => 1
newCounter(); // => 2
// `myCounter`と`newCounter`は別々の状態を持っている
myCounter(); // => 3
newCounter(); // => 3 
```

这种机制使得函数好像具有状态（在这里是逐渐增加的`count`值）一样，背后的原理是闭包。 由于闭包很难直观理解，因此首先需要了解“静态作用域”和“内存管理机制”来理解闭包。

### [](#static-scope)*静的スコープ*

*クロージャーを理解するために、今まで意識してこなかったスコープの性質について見ていきます。 JavaScriptのスコープには、どの識別子がどの変数を参照するかが静的に決定されるという性質があります。 つまり、コードを実行する前にどの識別子がどの変数を参照しているかがわかるということです。

次のような例を見てみます。 `printX`関数内で変数`x`を参照していますが、変数`x`はグローバルスコープと関数`run`の中で、それぞれ定義されています。 このとき`printX`関数内の`x`という識別子がどの変数`x`を参照するかは静的に決���されます。

結論から言えば、`printX`関数中にある識別子`x`はグローバルスコープ（＊1）の変数`x`を参照します。 そのため、`printX`関数の実行結果は常に`10`となります。

```
const x = 10; // ＊1

function printX() {
    // この識別子`x`は常に ＊1 の変数`x`を参照する
    console.log(x); // => 10
}

function run() {
    const x = 20; // ＊2
    printX(); // 常に10が出力される
}

run(); 
```

スコープチェーンの仕組みを思い出すと、この識別子`x`は次のように名前解決されてグローバルスコープの変数`x`を参照することがわかります。

1.  `printX`の関数スコープに変数`x`が定義されていない

1.  ひとつ外側のスコープ（グローバルスコープ）を確認する

1.  ひとつ外側のスコープに`const x = 10;`が定義されているので、識別子`x`はこの変数を参照する

つまり、`printX`関数中に書かれた`x`という識別子は、`run`関数の実行とは関係なく、静的に＊1で定義された変数`x`を参照することが決定されます。 このように、どの識別子がどの変数を参照しているかを静的に決定する性質を**静的スコープ**と呼びます。

この静的スコープの仕組みは`function`キーワードを使った関数宣言、メソッド、Arrow Functionなどすべての関数で共通する性質です。

### [](#dynamic-scope)*[コラム] 動的スコープ*

*JavaScriptは静的スコープです。 しかし、動的スコープという呼び出し元により識別子がどの変数を参照するかが変わる仕組みを持つ言語もあります。

次のコードは、動的スコープの動きを説明する**疑似的な言語のコード例**です。 識別子`x`が呼び出し元のスコープを参照する仕組みである場合には、次のような結果になります。

```
// 動的スコープの疑似的な言語のコード例（JavaScriptではありません）
// 変数`x`を宣言
var x = 10;

// `printX`という関数を定義
fn printX() {
    // 動的スコープの言語では、識別子`x`は呼び出し元によってどの変数`x`を参照するかが変わる
    // `print`関数でコンソールへログ出力する
    print(x);
}

fn run() {
    // 呼び出し元のスコープで、変数`x`を定義している
    var x = 20;
    printX();
}

printX(); // ここでは 10 が出力される
run(); // ここでは 20 が出力される 
```

このように関数呼び出し時に呼び出し元のスコープの変数を参照する仕組みを**動的スコープ**と呼びます。

JavaScriptは変数や関数の参照先は静的スコープで決まるため、上記のような動的スコープではありません。 しかし、JavaScriptでも`this`という特別なキーワードだけは、呼び出し元によって動的に参照先が変わります。 `this`というキーワードについては次の章で解説します。

## [](#memory-management)*メモリ管理の仕組み*

*プログラミング言語は、使わなくなった変数やデータを解放する仕組みを持っています。 なぜなら、変数や関数を定義すると定義されたデータはメモリ上に確保されますが、ハードウェアのメモリは有限だからです。 そのため、メモリからデータがあふれないように、必要なタイミングで不要なデータをメモリから解放する必要があります。

不要なデータをメモリから解放する方法は言語によって異なりますが、JavaScriptでは**ガベージコレクション**が採用されています。 ガベージコレクションとは、どこからも参照されなくなったデータを不要なデータと判断して自動的にメモリ上から解放する仕組みのことです。

JavaScriptにはガベージコレクションがあるため、手動でメモリを解放するコードを書く必要はありません。 しかし、ガベージコレクションといったメモリ管理の仕組みを理解することは、スコープやクロージャーに関係するため大切です。

どのようなタイミングでメモリ上から不要なデータが解放されるのか、具体的な例を見てみましょう。

次の例では、最初に`"before text"`という文字列のデータがメモリ上に確保され、変数`x`はそのメモリ上のデータを参照しています。 その後、`"after text"`という新しい文字列のデータを作り、変数`x`はその新しいデータへ参照先を変えています。

このとき、最初にメモリ上へ確保した`"before text"`という文字列のデータはどこからも参照されなくなっています。 どこからも参照されなくなった時点で不要になったデータと判断されるためガベージコレクションの回収対象となります。 その後、任意のタイミングでガベージコレクションによって回収されてメモリ上から解放されます。^(2)

```
let x = "before text";
// 変数`x`に新しいデータを代入する
x = "after text";
// このとき"before text"というデータはどこからも参照されなくなる
// その後、ガベージコレクションによってメモリ上から解放される 
```

次にこのガベージコレクションと関数の関係性について考えてみましょう。 よくある誤解として「関数の中で作成したデータは、その関数の実行が終了したら解放される」というのがあります。 関数の中で作成したデータは、その関数の実行が終了した時点で必ずしも解放されるわけではありません。

具体的に、「関数の実行が終了した際に解放される場合」と「関数の実行が終了しても解放されない場合」の例をそれぞれ見ていきます。

まずは、関数の実行が終了した際に解放されるデータの例です。

次のコードでは、`printX`関数の中で変数`x`を定義しています。 この変数`x`は、`printX`関数が実行されるたびに定義され、実行終了後にどこからも参照されなくなります。 どこからも参照されなくなったものは、ガベージコレクションによって回収されてメモリ上から解放されます。

```
function printX() {
    const x = "X";
    console.log(x); // => "X"
}

printX();
// この時点で`"X"`を参照するものはなくなる -> 解放される 
```

次に、関数の実行が終了しても解放されないデータの例です。

次のコードでは、`createArray`関数の中で定義された変数`tempArray`は、`createArray`関数の返り値となっています。 この、関数で定義された変数`tempArray`は返り値として、別の変数`array`に代入されています。 つまり、変数`tempArray`が参照している配列オブジェクトは、`createArray`関数の実行終了後も変数`array`から参照され続けています。 ひとつでも参照されているならば、そのデータが自動的に解放されることはありません。

```
function createArray() {
    const tempArray = [1, 2, 3];
    return tempArray;
}
const array = createArray();
console.log(array); // => [1, 2, 3]
// 変数`array`が`[1, 2, 3]`という値を参照している -> 解放されない 
```

つまり、関数の実行が終了したことと関数内で定義したデータの解放のタイミングは直接関係ないことがわかります。 そのデータがメモリ上から解放されるかどうかはあくまで、そのデータが参照されているかによって決定されます。

### [](#why-closure-work)*クロージャーがなぜ動くのか*

*ここまでで「静的スコープ」と「メモリ管理の仕組み」について説明してきました。

+   静的スコープ: ある変数がどの値を参照するかは静的に決まる

+   メモリ管理の仕組み: 参照されなくなったデータはガベージコレクションにより解放される

クロージャーとはこの２つの仕組みを利用して、関数内から特定の変数を参照し続けることで関数が状態を持てる仕組みのことを言います。

最初にクロージャーの例として紹介した`createCounter`関数の例を改めて見てみましょう。

```
const createCounter = () => {
    let count = 0;
    return function increment() {
        // `increment`関数は`createCounter`関数のスコープに定義された`変数`count`を参照している
        count = count + 1;
        return count;
    };
};
// createCounter()の実行結果は、内側で定義されていた`increment`関数
const myCounter = createCounter();
// myCounter 関数の実行結果は`count`の評価結果
console.log(myCounter()); // => 1
console.log(myCounter()); // => 2 
```

因此，可以确认`myCounter`变量和`count`变量之间存在以下引用关系：

+   `myCounter`变量引用了`createCounter`函数的返回值`increment`函数

+   `myCounter`变量通过`increment`函数引用了`count`变量

+   `myCounter`变量执行后，对`count`变量的引用仍然保持

> `myCounter` → `increment` → `count`

由于有引用`count`变量的存在，`count`变量不会自动释放。 因此，`count`变量的值会持续保持，并且每次执行`myCounter`变量时都会增加 1。

`count`变量可以持续保持不释放的原因是因为它是“`increment`函数内部引用了外部`createCounter`函数作用域中的`count`变量”的结果。 这种特性称为**闭包**。 闭包由“静态作用域”和“持续引用的变量数据被保持”的两个特性组成。

JavaScript 函数始终具有静态作用域和内存管理的两个特性。 因此，在某种程度上，所有函数都是闭包，但这里指的是函数通过引用特定变量来持有状态。

在之前的示例中，每次执行`createCounter`函数时，都会定义一个新的`count`和`increment`函数。 因此，每次执行`createCounter`函数时，都会定义不同的`increment`函数，并且分别引用不同的`count`变量。

如果多次调用`createCounter`函数，可以确认它们具有不同的状态。

```
const createCounter = () => {
    let count = 0;
    return function increment() {
        // 変数`count`を参照し続けている
        count = count + 1;
        return count;
    };
};
// countUpとnewCountUpはそれぞれ別のincrement 関数(内側にあるのも別のcount 変数)
const countUp = createCounter();
const newCountUp = createCounter();
// 参照している関数(オブジェクト)は別であるため===は一致しない
console.log(countUp === newCountUp);// false
// それぞれの状態も別となる
console.log(countUp()); // => 1
console.log(newCountUp()); // => 1 
```

### [](#closure-usecase)*闭包的用途*

*闭包可用于各种用途，但经常用于以下情况：

+   作为使函数具有状态的手段

+   作为定义无法从外部引用的变量的手段

+   作为减少全局变量的手段

+   高阶函数的一部分包括

这些也是闭包的特征，因此它们经常一起使用。

例如，在以下示例中，我们定义了名为`privateCount`的变量。 这个`privateCount`变量无法直接从外部全局作用域引用。 通过将不需要从外部引用的变量封闭在闭包函数中，可以减少全局定义的变量。

```
const createCounter = () => {
    // 外のスコープから`privateCount`を直接参照できない
    let privateCount = 0;
    return () => {
        privateCount++;
        return `${privateCount}回目`;
    };
};
const counter = createCounter();
console.log(counter()); // => "1 回目"
console.log(counter()); // => "2 回目" 
```

另外，将函数作为返回值的函数称为高阶函数，通过利用闭包的特性，可以创建判断是否大于`n`的高阶函数。 虽然可以直接定义一个名为`greaterThan5`的函数，但使用高阶函数可以灵活地在之后定义条件等。

```
function greaterThan(n) {
    return function(m) {
        return m > n;
    };
}
// 5より大きな値かを判定する関数を作成する
const greaterThan5 = greaterThan(5);
console.log(greaterThan5(4)); // => false
console.log(greaterThan5(5)); // => false
console.log(greaterThan5(6)); // => true 
```

闭包由函数具有静态作用域和数据持续引用保持的两个特性组成。

JavaScript 提供了便于使用闭包的环境，例如可以通过 Arrow Function 或高阶函数如 Array 的`forEach`方法来定义函数。 在理解函数时，理解闭包是很重要的。

### [](#closure-vs-function-object)*[专栏] 具有状态的函数对象*

*在 JavaScript 中，函数是一种对象。 作为对象，函数可以直接分配值给属性。 因此，即使不使用闭包，也可以通过以下方式为函数设置属性并保持状态。

```
function countUp() {
    // countプロパティを参照して変更する
    countUp.count = countUp.count + 1;
    return countUp.count;
}
// 関数オブジェクトにプロパティとして値を代入する
countUp.count = 0;
// 呼び出すごとにcountが更新される
console.log(countUp()); // => 1
console.log(countUp()); // => 2 
```

然而，这种方法并不推荐。 因为可以从函数外部更改`count`属性。 函数对象的属性可以从外部引用，并且其属性值可以更改。 如果想要处理仅在函数内部可引用的状态，那么强制使用闭包是有效的。

```
function countUp() {
    // countプロパティを参照して変更する
    countUp.count = countUp.count + 1;
    return countUp.count;
}
countUp.count = 0;
// 呼び出すごとにcountが更新される
console.log(countUp()); // => 1
// 直接値を変更できてしまう
countUp.count = 10;
console.log(countUp()); // => 11 
```

## [](#conclusion)*总结*

*本章主要学习了关于函数的作用域。

+   函数或块具有作用域

+   作用域可以嵌套

+   最外层是全局作用域

+   作用域链是指从内部向外部作用域按顺序搜索变量定义的机制

+   使用`var`关键字声明变量或使用`function`声明函数时会发生提升

+   闭包是由函数具有静态作用域和内存管理机制组成的性质

> ¹. 这种机制被称为 Temporal Dead Zone（TDZ）。 ↩
> 
> ². 根据 ECMAScript 规范，垃圾收集的实现规范是没有的，因此它是依赖于具体实现的。 ↩****************
