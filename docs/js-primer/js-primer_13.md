# 暗黙的な���変換

> 原文：[`jsprimer.net/basic/implicit-coercion/`](https://jsprimer.net/basic/implicit-coercion/)

この章では、明示的な型変換と暗黙的な型変換について学んでいきます。

「演算子」の章にて、 等価演算子（`==`）ではなく厳密等価演算子（`===`）の利用を推奨していました。 これは厳密等価演算子（`===`）が**暗黙的な型変換**をせずに、値同士を比較できるためです。

厳密等価演算子（`===`）では異なるデータ型を比較した場合に、その比較結果は必ず`false`となります。 次のコードは、数値の`1`と文字列の`"1"`という異なるデータ型を比較しているので、結果は`false`となります。

```
// `===`では、異なるデータ型の比較結果はfalse
console.log(1 === "1"); // => false 
```

しかし、等価演算子（`==`）では異なるデータ型を比較した場合に、同じ型となるように**暗黙的な型変換**をしてから比較します。 次のコードでは、数値の`1`と文字列の`"1"`の比較結果が`true`となっています。 これは、等価演算子（`==`）は右辺の文字列`"1"`を数値の`1`へと暗黙的な型変換をしてから、比較するためです。

```
// `==`では、異なるデータ型は暗黙的な型変換をしてから比較される
// 暗黙的な型変換によって 1 == 1 のように変換されてから比較される
console.log(1 == "1"); // => true 
```

このように、暗黙的な型変換によって意図しない結果となるため、比較には厳密等価演算子（`===`）を使うべきです。

別の暗黙的な型変換の例として、数値と真偽値の加算を見てみましょう。 多くの言語では、数値と真偽値の加算のような異なるデータ型同士の加算はエラーとなります。 しかし、JavaScriptでは暗黙的な型変換が行われてから加算されるため、エラーなく処理されます。

次のコードでは、真偽値の`true`が数値の`1`へと暗黙的に変換されてから加算処理が行われます。

```
// 暗黙的な型変換が行われ、数値の加算として計算される
1 + true; // => 2
// 次のように暗黙的に変換されてから計算される
1 + 1; // => 2 
```

JavaScriptでは、エラーが発生するのではなく、暗黙的な型変換が行われてしまうケースが多くあります。 暗黙的に変換が行われた場合、プログラムは例外を投げずに処理が進むため、バグの発見が難しくなります。 このように、暗黙的な型変換はできる限り避けるべき挙動です。

この章では、次のことについて学んでいきます。

+   暗黙的な型変換とはどのようなものなのか

+   暗黙的ではない明示的な型変換の方法

+   明示的な変換だけでは解決しないこと

## [](#what-is-implicit-coercion)*暗黙的な型変換とは*

*暗黙的な型変換とは次のことを言います。

+   ある処理において、その処理過程で行われる明示的ではない型変換のこと

暗黙的な型変換は、演算子による演算や関数の処理過程で行われます。 ここでは、演算子における暗黙的な型変換を中心に見ていきます。

### [](#implicit-coercion-of-equal-operator)*等価演算子の暗黙的な型変換*

*もっとも有名な暗黙的な型変換は、先ほども出てきた等価演算子（`==`）です。 等価演算子は、オペランド同士が同じ型となるように暗黙的な型変換をしてから、比較します。

次のように等価演算子（`==`）による比較は、驚くような結果を作り出します。

```
// 異なる型である場合に暗黙的な型変換が行われる
console.log(1 == "1"); // => true
console.log(0 == false); // => true
console.log(10 == ["10"]); // => true 
```

このほかにも等価演算子による予想できない結果は、比較する値と型の組み合わせの数だけあります。 そのため、等価演算子の比較結果がどうなるかを覚えるのは現実的でありません。

![等価演算子による比較結果をまとめた表。緑はtrueとなる組み合わせ](https://dorey.github.io/JavaScript-Equality-Table/)

しかし、等価演算子の暗黙的な型変換を避ける簡単な方法があります。

それは、常に厳密等価演算子（`===`）を使うことです。 値を比較する際は、常に厳密等価演算子を使うことで、暗黙的な型変換をせずに値を比較できます。

```
console.log(1 === "1"); // => false
console.log(0 === false); // => false
console.log(10 === ["10"]); // => false 
```

厳密等価演算子（`===`）を使うことで、意図しない比較結果を避けることができます。 そのため、比較には等価演算子（`==`）ではなく厳密等価演算子（`===`）を使うことを推奨します。

### [](#various-implicit-coercion)*さまざまな暗黙的な型変換*

*他の演算子についても、具体的な例を見てみましょう。

次のコードでは、数値の`1`と文字列の`"2"`をプラス演算子で処理しています。 プラス演算子（`+`）は、数値の加算と文字列の結合を両方実行できるように多重定義されています。 このケースでは、JavaScriptは文字列の結合を優先する仕様となっています。 そのため、数値の`1`を文字列の`"1"`へ暗黙的に変換してから、文字列結合します。

```
1 + "2"; // => "12"
// 演算過程で次のように暗黙的な型変換が行われる
"1" + "2"; // => "12" 
```

もうひとつ、数値と文字列での暗黙的な型変換を見てみましょう。 次のコードでは、数値の`1`から文字列の`"2"`を減算しています。

JavaScriptには、文字列に対するマイナス演算子（`-`）の定義はありません。 そのため、マイナス演算子の対象となる数値への暗黙的な型変換が行われます。 これにより、文字列の`"2"`を数値の`2`へ暗黙的に変換してから、減算します。

```
1 - "2"; // => -1
// 演算過程で次のように暗黙的な型変換が行われる
1 - 2; // => -1 
```

2つの値までは、まだ結果の型を予想できます。 しかし、3つ以上の値を扱う場合に結果を予測するのが難しくなります。

次のように3つ以上の値を`+`演算子で演算する場合に、値の型が混ざっていると、 演算する順番によっても結果が異なります。

```
const x = 1, y = "2", z = 3;
console.log(x + y + z); // => "123"
console.log(y + x + z); // => "213"
console.log(x + z + y); // => "42" 
```

このように、処理の過程でオペランドの型によって、 自動的に変換されることを**暗黙的な型変換**と呼んでいます。

暗黙的な型変換では、結果の値の型はオペランドの型に依存しています。 それを避けるには、暗黙的ではない変換 ーー つまり明示的な型変換をする必要があります。

## [](#explicit-coercion)*明示的な型変換*

*プリミティブ型へ明示的な型変換をする方法を見ていきます。

### [](#any-to-boolean)*任意の値 → 真偽値*

*JavaScriptでは`Boolean`コンストラクタ関数を使うことで、任意の値を`true`または`false`の真偽値に変換できます。

```
Boolean("string"); // => true
Boolean(1); // => true
Boolean({}); // => true
Boolean(0); // => false
Boolean(""); // => false
Boolean(null); // => false 
```

JavaScriptでは、次の値は`false`へ変換されます。

+   `false`

+   `undefined`

+   `null`

+   `0`

+   `0n`

+   `NaN`

+   `""`（空文字列）

暗黙的な型変換によって`false`に変換されるこれらの値をまとめて**falsy**な値と呼びます。 falsyではない値は、`true`へと変換されます。

この変換ルールはif 文の条件式の評価と同様です。 次のようにif 文に対して、真偽値以外の値を渡したときに、真偽値へと暗黙的に変換されてから判定されます。

```
// x は undefined
let x; 
if (!x) {
    console.log("falsyな値なら表示", x);
} 
```

真偽値については、暗黙的な型変換のルールが少ないため、明示的に変換せずに扱われることも多いです。 しかし、より正確な判定をして真偽値を得るには、次のように厳密等価演算子（`===`）を使って比較します。

```
// x は undefined
let x;
if (x === undefined) {
    console.log("xがundefinedなら表示", x);
} 
```

### [](#number-to-string)*数値 → 文字列*

*要明确从数字转换为字符串，可以使用`String`构造函数。

```
String(1); // => "1" 
```

`String`构造函数还可以将除了数字之外的各种值转换为字符串。

```
String("str"); // => "str"
String(true); // => "true"
String(null); // => "null"
String(undefined); // => "undefined"
String(Symbol("シンボルの説明文")); // => "Symbol(シンボルの説明文)"
// プリミティブ型ではない値の場合
String([1, 2, 3]); // => "1,2,3"
String({ key: "value" }); // => "[object Object]"
String(function() {}); // "function() {}" 
```

正如上面的结果所示，`String`构造函数的明确转换并不是一种万能方法。 对于布尔值、数字、字符串、未定义、null、符号等原始类型的值，转换结果可能不尽人意。

另一方面，对于对象，返回的字符串通常没有太多意义。 这是因为对于对象，存在比`String`构造函数更适合的方法。 对于数组，有`join`方法，对于对象，有`JSON.stringify`方法等。 因此，`String`构造函数的转换应仅限于原始类型。

### [](#symbol-to-string)*符号 → 字符串*

*当将加法运算符用于字符串时，优先考虑字符串连接。 您可能会想：“如果其中一个是字符串，那么结果就是字符串，而不管另一个操作数是什么？”。

```
"文字列" + x; // 文字列となる？ 
```

然而，在 ES2015 中添加的原始类型 Symbol 无法进行隐式类型转换。 对符号使用字符串连接运算符会抛出异常。 因此，即使一个是字符串，加法运算符的结果也不一定是字符串。

下面的代码示例中，使用字符串连接运算符(`+`)无法将符号转换为字符串，因此会引发`TypeError`异常。

```
"文字列と" + Symbol("シンボルの説明"); // => TypeError: can't convert symbol to string 
```

通过使用`String`构造函数，可以解决这个问题，将符号明确转换为字符串。

```
"文字列と" + String(Symbol("シンボルの説明")); // => "文字列とSymbol(シンボルの説明)" 
```

### [](#string-to-number)*字符串 → 数值*

*将字符串转换为数字的典型案例是接收用户输入的数字。 用户输入始终以字符串形式接收，因此必须先将其转换为数字才能使用。

若要明确从字符串转换为数字，可以使用`Number`构造函数。

```
// ユーザー入力を文字列として受け取る
const input = window.prompt("数字を入力してください", "42");
// 文字列を数値に変換する
const num = Number(input);
console.log(typeof num); // => "number"
console.log(num); // 入力された文字列を数値に変換したもの 
```

此外，还可以使用`Number.parseInt`、`Number.parseFloat`等函数从字符串中提取并转换数字。 `Number.parseInt`从字符串中提取整数，`Number.parseFloat`从字符串中提取浮点数。 `Number.parseInt(字符串, 基数)`的第二个参数指定基数。 例如，如果要解析字符串以获取十进制数值，则将`10`作为第二个参数。

```
// "1"をパースして10 進数として取り出す
console.log(Number.parseInt("1", 10)); // => 1
// 余計な文字は無視してパースした結果を返す
console.log(Number.parseInt("42px", 10)); // => 42
console.log(Number.parseInt("10.5", 10)); // => 10
// 文字列をパースして浮動小数点数として取り出す
console.log(Number.parseFloat("1")); // => 1
console.log(Number.parseFloat("42.5px")); // => 42.5
console.log(Number.parseFloat("10.5")); // => 10.5 
```

然而，用户并不总是输入数字。 `Number`构造函数、

```
// 数字ではないため、数値へは変換できない
Number("文字列"); // => NaN
// 未定義の値はNaNになる
Number(undefined); // => NaN 
```

因此，如果从任意值转换为数字后结果为`NaN`，则需要编写相应的处理。 可以使用`Number.isNaN(x)`方法来检查转换结果是否为`NaN`。

```
const userInput = "任意の文字列";
const num = Number.parseInt(userInput, 10);
if (Number.isNaN(num)) {
    console.log("パースした結果 NaNになった", num);
} 
```

### [](#nan-is-number-type)*`NaN`是非数字但是属于 Number 类型*

*在这里，我们将更详细地了解频繁出现的值`NaN`的情况。 `NaN`是 Not a Number 的缩写，是一种具有特殊性质的 Number 类型的数据。

关于这种名为`NaN`的数据的性质在[IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)中有规定，并不仅限于 JavaScript。

创建`NaN`值的方法很简单，即将不兼容 Number 类型的数据转换为 Number 类型，结果将为`NaN`。 例如，对象是与数字不兼容的数据。 因此，即使明确转换对象，结果也将为`NaN`。

```
Number({}); // => NaN 
```

また、`NaN`是一种特殊的值，无论如何进行运算，结果都将是`NaN`。 下面的例子展示了当在计算过程中出现`NaN`值时，最终结果也会是`NaN`。

```
const x = 10;
const y = x + NaN;
const z = y + 20;
console.log(x); // => 10
console.log(y); // => NaN
console.log(z); // => NaN 
```

`NaN`看起来像是与其名字“Not a Number”相矛盾的数据。

```
// NaNはnumber 型
console.log(typeof NaN); // => "number" 
```

`NaN`具有一个特殊的属性，即它与自身不匹配。 通过利用这一特性，可以判断一个值是否为`NaN`。

```
function isNaN(x) {
    // NaNは自分自身と一致しない
    return x !== x;
}
console.log(isNaN(1)); // => false
console.log(isNaN("str")); // => false
console.log(isNaN({})); // => false
console.log(isNaN([])); // => false
console.log(isNaN(NaN)); // => true 
```

作为相似处理方式，可以使用`Number.isNaN(x)`方法。 在实际判断值是否为`NaN`时，最好使用`Number.isNaN(x)`方法。^(1)

```
Number.isNaN(NaN); // => true 
```

`NaN`是在隐式类型转换中最应该避免的值之一。 原因是，正如前面介绍的那样，无论进行何种运算，`NaN`的结果都是`NaN`。 这会使得计算中出现`NaN`的位置不清晰，从而导致调试困难。

例如，下面的`sum`函数接受可变数量的参数，并返回它们的总和。 但是，当调用`sum(x, y, z)`时，结果变为`NaN`。 这是因为参数中包含了`undefined`（未定义值）。

```
// 任意の個数の数値を受け取り、その合計値を返す関数
function sum(...values) {
    return values.reduce((total, value) => {
        return total + value;
    }, 0);
}
const x = 1, z = 10;
let y; // `y`はundefined
console.log(sum(x, y, z)); // => NaN 
```

因此，`sum(x, y, z);`将产生与下面相同的结果。 将数值加到`undefined`上会得到`NaN`。

```
sum(1, undefined, 10); // => NaN
// 計算中にNaNとなるため、最終結果もNaNになる
1 + undefined; // => NaN
NaN + 10; // => NaN 
```

这意味着，即使在`sum`函数中明确将参数转换为 Number 类型，问题也无法避免。 换句话说，可以看出明确的类型转换也无法解决这个问题。

```
function sum(...values) {
    return values.reduce((total, value) => {
        // `value`をNumberで明示的に数値へ変換してから加算する
        return total + Number(value);
    }, 0);
}
const x = 1, z = 10;
let y; // `y`はundefined
console.log(sum(x, y, z)); // => NaN 
```

避免意外的`NaN`转换的方法大致分为两种。

+   在`sum`函数的一侧（被调用方）中，仅接受 Number 类型的值

+   在调用`sum`函数时，仅传递 Number 类型的值

换句话说，这是由调用方或被调用方处理的，两者都会导致更安全的代码。

因此，需要明确指定`sum`函数仅接受数字。

明确的方法包括在`sum`函数的文档（注释）中描述，或者在参数中添加处理以抛出异常，表示除了数值以外的值。

在 JavaScript 中，用于描述参数类型的注释格式[JSDoc](https://jsdoc.app/)很有名。此外，通过在运行时检查值是否为 Number 类型并通过`throw`语句抛出异常，可以明确`sum`函数的使用方式（关于`throw`语句的解释将在“错误处理”章节中说明）。

通过这两个方面详细实现了`sum`函数的前提条件如下：

```
/**
 * 数値を合計した値を返します。
 * 1つ以上の数値と共に呼び出す必要があります。
 * @param {...number} values
 * @returns {number}
 **/
function sum(...values) {
    return values.reduce((total, value) => {
        // 値がNumber 型ではない場合に、例外を投げる
        if (typeof value !== "number") {
            throw new Error(`${value}はNumber 型ではありません`);
        }
        return total + Number(value);
    }, 0);
}
const x = 1, z = 10;
let y; // `y`はundefined
console.log(x, y, z);
// Number 型の値ではない`y`を渡しているため例外が発生する
console.log(sum(x, y, z)); // => Error 
```

通过明确说明`sum`函数的使用方式，当发生错误时，调用方和被调用方可以清楚地知道问题出在哪里。在这种情况下，问题出在将`undefined`值传递给`sum`函数的调用方。

JavaScript 对于类型错误非常宽容，例如会进行隐式类型转换，因此，在编写大型应用程序时，编写能够发现这些难以检测到的错误的代码非常重要。

## [](#unsolved-problem)*即使是显式转换也无法解决的问题*

*正如前面的例子所示，不是所有情况都可以通过显式转换来解决。将不兼容于 Number 类型的值转换为数字，结果将会是`NaN`。一旦出现`NaN`，就只能通过`Number.isNaN(x)`来判断并结束处理。

JavaScript 的类型转换基本上是向信息减少的方向进行的。因此，在进行显式转换之前，首先需要考虑是否需要转换。

### [](#judge-empty-string)*判断是否为空字符串*

*例如，假设我们想要判断字符串是否为空字符串。 `""`（空字符串）是 falsy 值，因此可以通过显式使用`Boolean`构造函数将其转换为布尔值。 但是，虽然 falsy 值不仅限于空字符串，但通过显式转换并不意味着只能判断空字符串。

在下面的代码中，虽然进行了显式类型转换，但`0`也会变成**空字符串**，导致意外行为。

```
// 空文字列かどうかを判定
function isEmptyString(str) {
    // `str`がfalsyな値なら、`isEmptyString`関数は`true`を返す
    return !Boolean(str);
}
// 空文字列列の場合は、trueを返す
console.log(isEmptyString("")); // => true
// falsyな値の場合は、trueを返す
console.log(isEmptyString(0)); // => true
// undefinedの場合は、trueを返す
console.log(isEmptyString()); // => true 
```

在大多数情况下，获取布尔值的方法不是通过类型转换，而是通过其他方式。

在这种情况下，空字符串被定义为“String 类型且长度为 0 的值”，这样一来，我们可以更准确地编写`isEmptyString`函数。通过以下实现，我们现在能够正确判断值是否为空字符串。

```
// 空文字列かどうかを判定
function isEmptyString(str) {
    // String 型でlengthが0の値の場合はtrueを返す
    return typeof str === "string" && str.length === 0;
}
console.log(isEmptyString("")); // => true
// falsyな値でも正しく判定できる
console.log(isEmptyString(0)); // => false
console.log(isEmptyString()); // => false 
```

使用`Boolean`进行类型转换是为了方便，但并不是获取准确布尔值的方法。因此，在进行类型转换之前，首先考虑是否可以通过其他方式解决问题也很重要。

## [](#conclusion)*总结*

*本章我们学习了隐式类型转换和显式类型转换。

+   避免使用隐式类型转换，因为它容易导致意外结果。

+   在比较时应使用严格等于运算符（`===`）而不是等于运算符（`==`）

+   使用函数进行显式类型转换而不是运算符进行隐式类型转换

+   除了显式类型转换外，还有其他方法可以获得布尔值。

> ¹. 虽然有名为`isNaN`的函数类似，但由于它无法正确判断`NaN`，因此建议使用`Number.isNaN`方法。 ↩************
