- en: MarkdownをHTMLに変換する
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Markdown转换为HTML
- en: 原文：[`jsprimer.net/use-case/nodecli/md-to-html/`](https://jsprimer.net/use-case/nodecli/md-to-html/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/use-case/nodecli/md-to-html/`](https://jsprimer.net/use-case/nodecli/md-to-html/)
- en: 前のセクションではコマンドライン引数で受け取ったファイルを読み込み、標準出力に表示しました。 次は読み込んだMarkdownファイルをHTMLに変換して、その結果を標準出力に表示してみましょう。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们通过命令行参数读取文件，并将其显示在标准输出中。接下来，让我们尝试将读取的Markdown文件转换为HTML，并将结果输出到标准输出。
- en: '[](#use-marked-package)*markedパッケージを使う*'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#use-marked-package)*使用marked包*'
- en: '*JavaScriptでMarkdownをHTMLへ変換するために、今回は[marked](https://github.com/markedjs/marked)というライブラリを使用します。
    markedのパッケージはnpmで配布されているので、commanderと同様に`npm install`コマンドでパッケージをインストールしましょう。'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了将Markdown转换为HTML，这次我们使用了[marked](https://github.com/markedjs/marked)这个库。marked的包通过npm进行分发，所以像commander一样，使用`npm
    install`命令来安装包。'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: インストールが完了したら、Node.jsのスクリプトから読み込みます。 前のセクションの最後で書いたスクリプトに、`marked`モジュールの読み込み処理を追加しましょう。
    次のように`main.js`を変更し、読み込んだMarkdownファイルをmarkedを使ってHTMLに変換します。 `marked`モジュールからインポートした`marked.parse`関数は、Markdown
    文字列を引数にとり、HTML 文字列に変換して返します。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，从Node.js脚本中读取。在前面的章节的最后，添加`marked`模块的读取处理到脚本中。以下是如何修改`main.js`，使用marked将Markdown文件转换为HTML。
- en: main.js
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: main.js
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[](#create-convert-option)*変換オプションを作成する*'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#create-convert-option)*创建转换选项*'
- en: '*markedにはMarkdownの[変換オプション](https://marked.js.org/#/USING_ADVANCED.md#options)があり、オプションの設定によって変換後のHTMLが変化します。
    そこで、アプリケーション中でオプションのデフォルト値を決め、さらにコマンドライン引数から設定を切り替えられるようにしてみましょう。'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: marked有Markdown的[转换选项](https://marked.js.org/#/USING_ADVANCED.md#options)，根据选项的设置，转换后的HTML会有所不同。因此，在应用程序中，我们可以设置选项的默认值，并允许通过命令行参数进行切换。
- en: 今回のアプリケーションでは、例として`gfm`というmarkedのオプションを扱います。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次应用程序中，我们以`gfm`为例处理marked的选项。
- en: '[](#gfm-option)*gfmオプション*'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#gfm-option)*gfm选项*'
- en: '*`gfm`オプションは、GitHubにおけるMarkdownの仕様（[GitHub Flavored Markdown](https://github.github.com/gfm/),
    GFM）に合わせて変換するかを決めるオプションです。 markedではこの`gfm`オプションがデフォルトで`true`になっています。GFMは標準的なMarkdownにいくつかの拡張を加えたもので、代表的な拡張がURLの自動リンク化です。
    次のように`sample.md`を変更し、先ほどのスクリプトと`gfm`オプションを`false`にしたスクリプトで結果の違いを見てみましょう。'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*`gfm`选项是决定是否按照GitHub的Markdown规范（[GitHub Flavored Markdown](https://github.github.com/gfm/),
    GFM）进行转换的选项。marked中，这个`gfm`选项默认设置为`true`。GFM在标准Markdown的基础上添加了一些扩展，其中最著名的扩展是URL的自动链接化。以下是如何修改`sample.md`，并使用之前脚本和将`gfm`选项设置为`false`的脚本查看结果差异。'
- en: sample.md
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: sample.md
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`gfm`オプションが有効のときは、URLの文字列が自動的に`<a>`タグのリンクに置き換わります。'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当`gfm`选项有效时，URL字符串将自动转换为`<a>`标签的链接。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 一方、次のように`gfm`オプションを`false`にすると、単なる文字列として扱われ、リンクには置き換わりません。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，将`gfm`选项设置为`false`时，它将被简单地作为文本处理，不会转换为链接。
- en: main.js
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: main.js
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 自動リンクのほかにもいくつかの拡張がありますが、詳しくは[GitHub Flavored Markdown](https://github.github.com/gfm/)のドキュメントを参照してください。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动链接之外，还有一些其他扩展，但更详细的内容请参考[GitHub Flavored Markdown](https://github.github.com/gfm/)的文档。
- en: '[](#receive-option)*コマンドライン引数からオプションを受け取る*'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#receive-option)*从命令行参数接收选项*'
- en: '*次に、`gfm`オプションをコマンドライン引数で制御できるようにしましょう。 アプリケーションのデフォルトでは`gfm`オプションを無効にした上で、次のように`--gfm`オプションを付与してコマンドを実行できるようにします。'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*接下来，让我们将`gfm`选项通过命令行参数进行控制。在应用程序的默认设置中，将`gfm`选项设置为无效，然后通过添加`--gfm`选项来执行命令。'
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: コマンドライン引数で`--gfm`のようなオプションを扱いたいときには、commanderの`option`メソッドを使います。 次のように必要なオプションを定義してからコマンドライン引数をパースすると、`program.opts`メソッドでパース結果のオブジェクトを取得できます。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想处理像`--gfm`这样的命令行参数时，可以使用commander的`option`方法。首先定义所需的选项，然后解析命令行参数，就可以通过`program.opts`方法获取解析结果的对象。
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`--gfm`オプションはファイルパスを指定する`sample.md`の前後のどちらについていても動作します。 なぜなら`program.args`配列に��`program.option`メソッドで定義したオプションが含まれないためです。
    `process.argv`配列を直接使っているとこのようなオプションの処理が面倒なので、commanderのようなパース処理を挟むのが一般的です。'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`--gfm`选项可以在指定`sample.md`文件路径的前后使用。这是因为`program.args`数组中不包含通过`program.option`方法定义的选项。直接使用`process.argv`数组会使得处理此类选项变得复杂，因此使用像commander这样的解析处理是常见的做法。'
- en: '[](#declare-default)*デフォルト設定を定義する*'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#declare-default)*定义默认设置*'
- en: '*アプリケーション側でデフォルト設定を持っておくことで、将来的にmarkedの挙動が変わったときにも影響を受けにくくなります。 次のようにオプションを表現した`cliOptions`オブジェクトを作成し、`program.opts`メソッドの返り値から取得した値をセットします。
    コマンドライン引数で指定されなかったオプションには`??`（Nullish coalescing 演算子）を使ってデフォルトの値をセットします。 Nullish
    coalescing 演算子は左辺がnullishであるときにだけ右辺の値を返すため、値が指定されなかった状態と明示的に`false`が与えられた状態を区別したいときに便利です。'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中保留默认设置可以减少在marked行为发生变化时的影响。以下是如何创建表示选项的`cliOptions`对象，并使用`program.opts`方法获取的值进行设置。对于未指定的选项，使用`??`（空合并运算符）来设置默认值。空合并运算符仅在左边的值为nullish时才返回右边的值，因此它在需要区分值未指定和显式设置为`false`的情况时很有用。
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: こうして作成したcliOptionsオブジェクトを、markedの`parse`関数へオプションとして渡しましょう。`main.js`の全体は次のようになります。
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将这样创建的cliOptions对象作为选项传递给marked的`parse`函数。`main.js`的完整内容如下。
- en: main.js
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: main.js
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 定義したコマンドライン引数を使って、Markdownファイルを変換してみましょう。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义的命令行参数尝试将Markdown文件进行转换。
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: また、`gfm`オプションを付与して実行すると次のように出力されるはずです。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，添加`gfm`选项执行时，输出应该是这样的。
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: これでMarkdown 変換の設定をコマンドライン引数でオプションとして与えられるようになりました。 次のセクションではアプリケーションのコードを整理し、最後にユニットテストを導入します。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就可以通过命令行参数将Markdown转换的设置作为选项提供了。在下一节中，我们将整理应用程序的代码，并在最后引入单元测试。
- en: '[](#section-checklist)*このセクションのチェックリスト*'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#section-checklist)*本节检查清单*'
- en: '**   markedパッケージを使ってMarkdown 文字列をHTML 文字列に変換した'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用marked包将Markdown文本转换为HTML文本**'
- en: コマンドライン引数でmarkedの変換オプションを設定した
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行参数中设置了marked的转换选项
- en: デフォルトオプションを定義し、コマンドライン引数で上書きできるようにした******
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了默认选项，并允许通过命令行参数进行覆盖******
