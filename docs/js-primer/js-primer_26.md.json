["```\nclass MyClass {\n    constructor() {\n        // コンストラクタ関数の処理\n        // インスタンス化されるときに自動的に呼び出される\n    }\n} \n```", "```\nconst MyClass = class MyClass {\n    constructor() {}\n};\n\nconst AnonymousClass = class {\n    constructor() {}\n}; \n```", "```\nclass MyClassA {\n    constructor() {\n        // コンストラクタの処理が必要なら書く\n    }\n}\n// コンストラクタの処理が不要な場合は省略できる\nclass MyClassB {\n} \n```", "```\nclass MyClass {\n}\n// `MyClass`をインスタンス化する\nconst myClass = new MyClass();\n// 毎回新しいインスタンス(オブジェクト)を作成する\nconst myClassAnother = new MyClass();\n// それぞれのインスタンスは異なるオブジェクト\nconsole.log(myClass === myClassAnother); // => false\n// クラスのインスタンスかどうかは`instanceof`演算子で判定できる\nconsole.log(myClass instanceof MyClass); // => true\nconsole.log(myClassAnother instanceof MyClass); // => true \n```", "```\nclass Point {\n    // コンストラクタ関数の仮引数として`x`と`y`を定義\n    constructor(x, y) {\n        // コンストラクタ関数における`this`はインスタンスを示すオブジェクト\n        // インスタンスの`x`と`y`プロパティにそれぞれ値を設定する\n        this.x = x;\n        this.y = y;\n    }\n} \n```", "```\nclass Point {\n    // 2\\. コンストラクタ関数の仮引数として`x`には`3`、`y`には`4`が渡る\n    constructor(x, y) {\n        // 3\\. インスタンス(`this`)の`x`と`y`プロパティにそれぞれ値を設定する\n        this.x = x;\n        this.y = y;\n        // コンストラクタではreturn 文は書かない\n    }\n}\n\n// 1\\. コンストラクタを`new`演算子で引数とともに呼び出す\nconst point = new Point(3, 4);\n// 4\\. `Point`のインスタンスである`point`の`x`と`y`プロパティには初期化された値が入る\nconsole.log(point.x); // => 3\nconsole.log(point.y); // => 4 \n```", "```\nclass MyClass {\n    constructor() {}\n}\n// クラスは関数として呼び出すことはできない\nMyClass(); // => TypeError: class constructors must be invoked with |new| \n```", "```\n// 非推奨の例: コンストラクタで値を返すべきではない\nclass Point {\n    constructor(x, y) {\n        // `this`の代わりにただのオブジェクトを返せる\n        return { x, y };\n    }\n}\n\n// `new`演算子の結果はコンストラクタ関数が返したただのオブジェクト\nconst point = new Point(3, 4);\nconsole.log(point); // => { x: 3, y: 4 }\n// Pointクラスのインスタンスではない\nconsole.log(point instanceof Point); // => false \n```", "```\nclass Thing {}\nconst thing = new Thing(); \n```", "```\n// コンストラクタ関数\nconst Point = function PointConstructor(x, y) {\n    // インスタンスの初期化処理\n    this.x = x;\n    this.y = y;\n};\n\n// `new`演算子でコンストラクタ関数から新しいインスタンスを作成\nconst point = new Point(3, 4); \n```", "```\n// 関数でのクラス表現\nfunction MyClassLike() {\n}\n// 関数なので関数として呼び出せる\nMyClassLike();\n\n// `class`構文でのクラス\nclass MyClass {\n}\n// クラスは関数として呼び出すと例外が発生する\nMyClass(); // => TypeError: class constructors must be invoked with |new| \n```", "```\nclass クラス {\n    メソッド() {\n        // ここでの`this`はベースオブジェクトを参照\n    }\n}\n\nconst インスタンス = new クラス();\n// メソッド呼び出しのベースオブジェクト(`this`)は`インスタンス`となる\nインスタンス.メソッド(); \n```", "```\n// クラスでは次のようにメソッドを定義できない\nclass クラス {\n   // SyntaxError\n   メソッド: () => {}\n   // SyntaxError\n   メソッド: function(){}\n} \n```", "```\nclass Counter {\n    constructor() {\n        this.count = 0;\n    }\n    // `increment`メソッドをクラスに定義する\n    increment() {\n        // `this`は`Counter`のインスタンスを参照する\n        this.count++;\n    }\n}\nconst counterA = new Counter();\nconst counterB = new Counter();\n// `counterA.increment()`のベースオブジェクトは`counterA`インスタンス\ncounterA.increment();\n// 各インスタンスの持つプロパティ(状態)は異なる\nconsole.log(counterA.count); // => 1\nconsole.log(counterB.count); // => 0 \n```", "```\nclass Counter {\n    constructor() {\n        this.count = 0;\n    }\n    increment() {\n        this.count++;\n    }\n}\nconst counterA = new Counter();\nconst counterB = new Counter();\n// 各インスタンスオブジェクトのメソッドは共有されている(同じ関数を参照している)\nconsole.log(counterA.increment === counterB.increment); // => true \n```", "```\nclass クラス {\n    メソッド() {\n        // このメソッドはプロトタイプメソッドとして定義される\n    }\n} \n```", "```\nclass クラス {\n    // getter\n    get プロパティ名() {\n        return 値;\n    }\n    // setter\n    set プロパティ名(仮引数) {\n        // setterの処理\n    }\n}\nconst インスタンス = new クラス();\nインスタンス.プロパティ名; // getterが呼び出される\nインスタンス.プロパティ名 = 値; // setterが呼び出される \n```", "```\nclass NumberWrapper {\n    constructor(value) {\n        this._value = value;\n    }\n    // `_value`プロパティの値を返すgetter\n    get value() {\n        console.log(\"getter\");\n        return this._value;\n    }\n    // `_value`プロパティに値を代入するsetter\n    set value(newValue) {\n        console.log(\"setter\");\n        this._value = newValue;\n    }\n}\n\nconst numberWrapper = new NumberWrapper(1);\n// \"getter\"とコンソールに表示される\nconsole.log(numberWrapper.value); // => 1\n// \"setter\"とコンソールに表示される\nnumberWrapper.value = 42;\n// \"getter\"とコンソールに表示される\nconsole.log(numberWrapper.value); // => 42 \n```", "```\nconst array = [1, 2, 3, 4, 5];\n// 要素数を減らすと、インデックス以降の要素が削除される\narray.length = 2;\nconsole.log(array.join(\", \")); // => \"1, 2\"\n// 要素数だけを増やしても、配列の中身は空要素が増えるだけ\narray.length = 5;\nconsole.log(array.join(\", \")); // => \"1, 2, , , \" \n```", "```\n/**\n * 配列のようなlengthを持つクラス\n */\nclass ArrayLike {\n    constructor(items = []) {\n        this._items = items;\n    }\n\n    get items() {\n        return this._items;\n    }\n\n    get length() {\n        return this._items.length;\n    }\n\n    set length(newLength) {\n        const currentItemLength = this.items.length;\n        // 現在要素数より小さな`newLength`が指定された場合、指定した要素数となるように末尾を削除する\n        if (newLength < currentItemLength) {\n            this._items = this.items.slice(0, newLength);\n        } else if (newLength > currentItemLength) {\n            // 現在要素数より大きな`newLength`が指定された場合、指定した要素数となるように末尾に空要素を追加する\n            this._items = this.items.concat(new Array(newLength - currentItemLength));\n        }\n    }\n}\n\nconst arrayLike = new ArrayLike([1, 2, 3, 4, 5]);\n// 要素数を減らすとインデックス以降の要素が削除される\narrayLike.length = 2;\nconsole.log(arrayLike.items.join(\", \")); // => \"1, 2\"\n// 要素数を増やすと末尾に空要素が追加される\narrayLike.length = 5;\nconsole.log(arrayLike.items.join(\", \")); // => \"1, 2, , , \" \n```", "```\nclass Counter {\n    constructor() {\n        this.count = 0;\n    }\n    increment() {\n        this.count++;\n    }\n} \n```", "```\nclass クラス {\n    プロパティ名 = プロパティの初期値;\n} \n```", "```\nclass Counter {\n    count = 0;\n    increment() {\n        this.count++;\n    }\n}\nconst counter = new Counter();\ncounter.increment();\nconsole.log(counter.count); // => 1 \n```", "```\n// 別々のプロパティ名がそれぞれ定義される\nclass MyClass {\n    publicField = 1;\n    constructor(arg) {\n        this.property = arg;\n    }\n}\nconst myClass = new MyClass(2);\nconsole.log(myClass.publicField); // => 1\nconsole.log(myClass.property); // => 2 \n```", "```\n// 同じプロパティ名の場合は、constructorでの代入が後となる\nclass OwnClass {\n    publicField = 1;\n    constructor(arg) {\n        this.publicField = arg;\n    }\n}\nconst ownClass = new OwnClass(2);\nconsole.log(ownClass.publicField); // => 2 \n```", "```\nclass MyClass {\n    // myPropertyはundefinedで初期化される\n    myProperty;\n} \n```", "```\nclass Loader {\n    loadedContent;\n    load() {\n        this.loadedContent = \"読み込んだコンテンツ内容\";\n    }\n} \n```", "```\nclass Loader {\n    load() {\n        this.loadedContent = \"読み込んだコンテンツ内容\";\n    }\n} \n```", "```\nclass Counter {\n    count = 0;\n    // upはincrementメソッドを参照している\n    up = this.increment;\n    increment() {\n        this.count++;\n    }\n}\nconst counter = new Counter();\ncounter.up(); // 結果的にはincrementメソッドが呼び出される\nconsole.log(counter.count); // => 1 \n```", "```\nclass Counter {\n    count = 0;\n    // クラスフィールドでの`this`はクラスのインスタンスとなる\n    // upメソッドは、クラスのインスタンスに定義される\n    up = () => {\n        this.increment();\n    };\n    increment() {\n        this.count++;\n    }\n}\nconst counter = new Counter();\n// Arrow Functionなので、thisはクラスのインスタンスに固定されている\nconst up = counter.up;\nup();\nconsole.log(counter.count); // => 1\n// 通常のメソッド定義では、`this`が`undefined`となってしまうため例外が発生する\nconst increment = counter.increment;\nincrement(); // Error: Uncaught TypeError: this is undefined \n```", "```\nclass ExampleClass {\n    fieldMethod = () => {\n        console.log(\"クラスフィールドで定義されたメソッド\");\n    };\n    constructor() {\n        this.propertyMethod = () => {\n            console.log(\"インスタンスにプロパティとして定義されたメソッド\");\n        };\n    }\n} \n```", "```\nclass ExampleClass {\n    field = \"フィールド\";\n    constructor() {\n        this.property = \"コンストラクタ\";\n    }\n    // クラスフィールド名に対応するsetter\n    set field(value) {\n        console.log(\"fieldで定義された値\", value);\n    }\n    // thisのプロパティ名に対応するsetter\n    set property(value) {\n        console.log(\"consctrutorで代入された値\", value);\n    }\n}\n// set fieldは呼び出されない\n// 一方で、set propertyは呼び出される\nconst example = new ExampleClass(); \n```", "```\nclass クラス {\n    プロパティ名 = プロパティの初期値;\n} \n```", "```\nclass クラス {\n    // プライベートなプロパティは#をつける\n    #フィールド名 = プロパティの初期値;\n} \n```", "```\nclass PrivateExampleClass {\n    #privateField = 42;\n    dump() {\n        // Privateクラスフィールドはクラス内からのみ参照できる\n        console.log(this.#privateField); // => 42\n    }\n}\nconst privateExample = new PrivateExampleClass();\nprivateExample.dump(); \n```", "```\nclass NumberWrapper {\n    // Publicクラスフィールドなのでクラスの外からアクセスができる\n    _value;\n    constructor(value) {\n        this._value = value;\n    }\n    // `_value`プロパティの値を返すgetter\n    get value() {\n        return this._value;\n    }\n    // `_value`プロパティに値を代入するsetter\n    set value(newValue) {\n        this._value = newValue;\n    }\n}\nconst numberWrapper = new NumberWrapper(1);\n// _valueプロパティは外からもアクセスできる\nconsole.log(numberWrapper._value); // => 1 \n```", "```\nclass NumberWrapper {\n    // valueはPrivateクラスフィールドとして定義\n    #value;\n    constructor(value) {\n        this.#value = value;\n    }\n    // `#value`フィールドの値を返すgetter\n    get value() {\n        return this.#value;\n    }\n    // `#value`フィールドに値を代入するsetter\n    set value(newValue) {\n        this.#value = newValue;\n    }\n}\n\nconst numberWrapper = new NumberWrapper(1);\n// クラスの外からPrivateクラスフィールドには直接はアクセスできない\nconsole.log(numberWrapper.#value); // => SyntaxError: reference to undeclared private field or method #value \n```", "```\nclass PrivateLoader {\n    // 途中で値が入る場合でも最初に`undefined`で初期化されるフィールドの定義が必須\n    #loadedContent;\n    load() {\n        this.#loadedContent = \"読み込んだコンテンツ内容\";\n    }\n} \n```", "```\nclass クラス {\n    static メソッド() {\n        // 静的メソッドの処理\n    }\n}\n// 静的メソッドの呼び出し\nクラス.メソッド(); \n```", "```\nclass ArrayWrapper {\n    // new 演算子で引数が渡されたなかった場合の初期値は空配列\n    constructor(array = []) {\n        this.array = array;\n    }\n\n    // rest parametersとして要素を受けつける\n    static of(...items) {\n        return new ArrayWrapper(items);\n    }\n\n    get length() {\n        return this.array.length;\n    }\n}\n\n// 配列を引数として渡している\nconst arrayWrapperA = new ArrayWrapper([1, 2, 3]);\n// 要素を引数として渡している\nconst arrayWrapperB = ArrayWrapper.of(1, 2, 3);\nconsole.log(arrayWrapperA.length); // => 3\nconsole.log(arrayWrapperB.length); // => 3 \n```", "```\nclass ArrayWrapper {\n    constructor(array = []) {\n        this.array = array;\n    }\n\n    static of(...items) {\n        // `this`は`ArrayWrapper`を参照する\n        return new this(items);\n    }\n\n    get length() {\n        return this.array.length;\n    }\n}\n\nconst arrayWrapper = ArrayWrapper.of(1, 2, 3);\nconsole.log(arrayWrapper.length); // => 3 \n```", "```\nclass Colors {\n    static GREEN = \"緑\";\n    static RED = \"赤\";\n    static BLUE = \"青\";\n}\n// クラスのプロパティとして参照できる\nconsole.log(Colors.GREEN); // => \"緑\" \n```", "```\nclass MyClass {\n    static #privateClassProp = \"This is private\";\n    static outputPrivate() {\n        // クラス内からはPrivate 静的クラスフィールドで定義したプロパティを参照できる\n        console.log(this.#privateClassProp);\n    }\n}\nMyClass.outputPrivate(); \n```", "```\nclass ExampleClass {\n    // クラスフィールドを使い、インスタンスにメソッドを定義\n    instanceMethod = () => {\n        console.log(\"インスタンスメソッド\");\n    };\n    // メソッド構文を使い、プロトタイプオブジェクトにメソッドを定義\n    prototypeMethod() {\n        console.log(\"プロトタイプメソッド\");\n    }\n}\nconst example = new ExampleClass();\n// どちらのメソッドもインスタンスから呼び出せる\nexample.instanceMethod();\nexample.prototypeMethod(); \n```", "```\nclass ConflictClass {\n    // インスタンスオブジェクトに`method`を定義\n    method = () => {\n        console.log(\"インスタンスオブジェクトのメソッド\");\n    };\n\n    // クラスのプロトタイプメソッドとして`method`を定義\n    method() {\n        console.log(\"プロトタイプのメソッド\");\n    }\n}\n\nconst conflict = new ConflictClass();\nconflict.method(); // どちらの`method`が呼び出される？ \n```", "```\nclass ConflictClass {\n    // インスタンスオブジェクトに`method`を定義\n    method = () => {\n        console.log(\"インスタンスオブジェクトのメソッド\");\n    };\n\n    method() {\n        console.log(\"プロトタイプメソッド\");\n    }\n}\n\nconst conflict = new ConflictClass();\nconflict.method(); // \"インスタンスオブジェクトのメソッド\"\n// インスタンスの`method`プロパティを削除\ndelete conflict.method;\nconflict.method(); // \"プロトタイプメソッド\" \n```", "```\nfunction fn() {\n}\n// `prototype`プロパティにプロトタイプオブジェクトが存在する\nconsole.log(typeof fn.prototype === \"object\"); // => true\n\nclass MyClass {\n}\n// `prototype`プロパティにプロトタイプオブジェクトが存在する\nconsole.log(typeof MyClass.prototype === \"object\"); // => true \n```", "```\nclass MyClass {\n    method() {}\n}\n\nconsole.log(typeof MyClass.prototype.method === \"function\"); // => true\n// クラスのconstructorはクラス自身を参照する\nconsole.log(MyClass.prototype.constructor === MyClass); // => true \n```", "```\nclass MyClass {\n    method() {\n        console.log(\"プロトタイプのメソッド\");\n    }\n}\nconst instance = new MyClass();\ninstance.method(); // \"プロトタイプのメソッド\" \n```", "```\nclass MyClass {\n    method() {\n        console.log(\"プロトタイプのメソッド\");\n    }\n}\nconst instance = new MyClass();\n// `instance`の`[[Prototype]]`内部プロパティは`MyClass.prototype`と一致する\nconst MyClassPrototype = Object.getPrototypeOf(instance);\nconsole.log(MyClassPrototype === MyClass.prototype); // => true \n```", "```\nclass MyClass {\n    method() {\n        console.log(\"プロトタイプのメソッド\");\n    }\n}\nconst instance = new MyClass();\n// インスタンスには`method`プロパティがないため、プロトタイプオブジェクトの`method`が参照される\ninstance.method(); // \"プロトタイプのメソッド\"\n// `instance.method`の参照はプロトタイプオブジェクトの`method`と一致する\nconst Prototype = Object.getPrototypeOf(instance);\nconsole.log(instance.method === Prototype.method); // => true \n```", "```\n// プロトタイプチェーンの動作の疑似的なコード\nclass MyClass {\n    method() {\n        console.log(\"プロトタイプのメソッド\");\n    }\n}\nconst instance = new MyClass();\n// `instance.method()`を実行する場合\n// 次のような呼び出し処理が行われている\n// インスタンスが`method`プロパティを持っている場合\nif (Object.hasOwn(instance, \"method\")) {\n    instance.method();\n} else {\n    // インスタンスの`[[Prototype]]`の参照先（`MyClass`のプロトタイプオブジェクト）を取り出す\n    const prototypeObject = Object.getPrototypeOf(instance);\n    // プロトタイプオブジェクトが`method`プロパティを持っている場合\n    if (Object.hasOwn(prototypeObject, \"method\")) {\n        // `this`はインスタンス自身を指定して呼び出す\n        prototypeObject.method.call(instance);\n    }\n} \n```", "```\nclass 子クラス extends 親クラス {\n} \n```", "```\nclass Parent {\n}\nclass Child extends Parent {\n}\nconst instance = new Child(); \n```", "```\n// 親クラス\nclass Parent {\n    constructor(...args) {\n        console.log(\"Parentコンストラクタの処理\", ...args);\n    }\n}\n// Parentを継承したChildクラスの定義\nclass Child extends Parent {\n    constructor(...args) {\n        // Parentのコンストラクタ処理を呼び出す\n        super(...args);\n        console.log(\"Childコンストラクタの処理\", ...args);\n    }\n}\nconst child = new Child(\"引数 1\", \"引数 2\");\n// \"Parentコンストラクタの処理\", \"引数 1\", \"引数 2\"\n// \"Childコンストラクタの処理\", \"引数 1\", \"引数 2\" \n```", "```\nclass Parent {}\nclass Child extends Parent {} \n```", "```\nclass Parent {}\nclass Child extends Parent {\n    constructor(...args) {\n        super(...args); // 親クラスに引数をそのまま渡す\n    }\n} \n```", "```\nclass Parent {\n    constructor() {\n        this.name = \"Parent\";\n    }\n}\nclass Child extends Parent {\n    constructor() {\n        // 子クラスでは`super()`を`this`に触る前に呼び出さなければならない\n        super();\n        // 子クラスのコンストラクタ処理\n        // 親クラスで書き込まれた`name`は上書きされる\n        this.name = \"Child\";\n    }\n}\nconst parent = new Parent();\nconsole.log(parent.name); // => \"Parent\"\nconst child = new Child();\nconsole.log(child.name); // => \"Child\" \n```", "```\nclass Parent {\n    parentField = \"親クラスで定義したフィールド\";\n}\n// `Parent`を継承した`Child`を定義\nclass Child extends Parent {\n    childField = \"子クラスで定義したフィールド\";\n}\nconst instance = new Child();\nconsole.log(instance.parentField); // => \"親クラスで定義したフィールド\"\nconsole.log(instance.childField); // => \"子クラスで定義したフィールド\" \n```", "```\nclass Parent {\n    field = \"親クラスで定義したフィールド\";\n}\n// `Parent`を継承した`Child`を定義\nclass Child extends Parent {\n    field = \"子クラスで定義したフィールド\";\n}\nconst instance = new Child();\nconsole.log(instance.field); // => \"子クラスで定義したフィールド\" \n```", "```\nclass Parent {\n    #parentField = \"親クラスで定義したPrivateフィールド\";\n}\n// `Parent`を継承した`Child`を定義\nclass Child extends Parent {\n    dump() {\n        console.log(this.#parentField); // => SyntaxError: reference to undeclared private field or method #parentFeild\n    }\n}\nconst instance = new Child();\ninstance.dump(); \n```", "```\nclass Parent {\n    method() {\n        console.log(\"Parent.prototype.method\");\n    }\n}\n// `Parent`を継承した`Child`を定義\nclass Child extends Parent {\n    // methodの定義はない\n}\n// `Child`のインスタンスは`Parent`のプロトタイプメソッドを継承している\nconst instance = new Child();\ninstance.method(); // \"Parent.prototype.method\" \n```", "```\nclass Parent {\n    static hello() {\n        return \"Hello\";\n    }\n}\nclass Child extends Parent {}\nconsole.log(Child.hello()); // => \"Hello\" \n```", "```\nclass Parent {\n    method() {\n        console.log(\"Parent.prototype.method\");\n    }\n}\nclass Child extends Parent {\n    method() {\n        console.log(\"Child.prototype.method\");\n        // `this.method()`だと自分(`this`)のmethodを呼び出して無限ループする\n        // そのため明示的に`super.method()`を呼ぶことで、Parent.prototype.methodを呼び出す\n        super.method();\n    }\n}\nconst child = new Child();\nchild.method();\n// コンソールには次のように出力される\n// \"Child.prototype.method\"\n// \"Parent.prototype.method\" \n```", "```\nclass Parent {\n    static method() {\n        console.log(\"Parent.method\");\n    }\n}\nclass Child extends Parent {\n    static method() {\n        console.log(\"Child.method\");\n        // `super.method()`で`Parent.method`を呼びだす\n        super.method();\n    }\n}\nChild.method();\n// コンソールには次のように出力される\n// \"Child.method\"\n// \"Parent.method\" \n```", "```\nclass Parent {}\nclass Child extends Parent {}\n\nconst parent = new Parent();\nconst child = new Child();\n// `Parent`のインスタンスは`Parent`のみを継承したインスタンス\nconsole.log(parent instanceof Parent); // => true\nconsole.log(parent instanceof Child); // => false\n// `Child`のインスタンスは`Child`と`Parent`を継承したインスタンス\nconsole.log(child instanceof Parent); // => true\nconsole.log(child instanceof Child); // => true \n```", "```\nclass MyArray extends Array {\n    get first() {\n        return this.at(0);\n    }\n\n    get last() {\n        return this.at(-1);\n    }\n}\n\n// Arrayを継承しているのでArray.fromも継承している\n// Array.fromはIterableなオブジェクトから配列インスタンスを作成する\nconst array = MyArray.from([1, 2, 3, 4, 5]);\nconsole.log(array.length); // => 5\nconsole.log(array.first); // => 1\nconsole.log(array.last); // => 5 \n```"]