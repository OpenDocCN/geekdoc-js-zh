# 语句和表达式

> 原文：[`jsprimer.net/basic/statement-expression/`](https://jsprimer.net/basic/statement-expression/)

在正式学习基本语法之前，先看看 JavaScript 这种编程语言是由哪些元素组成的。

JavaScript 由**语句**（Statement）和**表达式**（Expression）组成。

## *表达式*

***表达式**（Expression）可以简洁地描述为，可以生成值并可以赋值给变量的东西。

`42`这样的字面量或`foo`这样的变量、函数调用是表达式。此外，`1 + 1`这样的表达式和运算符的组合也称为表达式。

表达式的特征是，评估表达式可以得到结果值。这个结果值被称为**评估值**。

可以将评估结果赋值给变量的东西是**表达式**。

```
// 1という式の評価値を表示
console.log(1); // => 1
// 1 + 1という式の評価値を表示
console.log(1 + 1); // => 2
// 式の評価値を変数に代入
const total = 1 + 1;
// 関数式の評価値(関数オブジェクト)を変数に代入
const fn = function() {
    return 1;
};
// fn() という式の評価値を表示
console.log(fn()); // => 1 
```

## *语句*

**语句**（Statement）可以简洁地描述为，处理 1 个步骤的语句。在 JavaScript 中，通过在语句末尾放置分号(`;`)来分隔语句和语句。

通过从上到下处理源代码中的语句，程序被执行。

```
処理する文;
処理する文;
処理する文; 
```

例如，if 语句或 for 语句等被称为**语句**的东西。有时，作为语句处理的一部分，可以包含表达式。

```
const isTrue = true;
// isTrueという式がif 文の中に出てくる
if (isTrue) {
} 
```

另一方面，if 语句等是语句，不是表达式。

**不是表达式**，因此不能将 if 语句赋值给变量。以下代码在语法上有问题，因此会导致语法错误（`SyntaxError`）。

```
// 構文として間違っているため、SyntaxErrorが発生する
const forIsNotExpression = if (true) { /* ifは文であるため式にはなれない */ } 
```

### *表达式语句*

*另一方面，**表达式**（Expression）可以成为**语句**（Statement）。将变成语句的表达式称为**表达式语句**。基本上，可以在可以写语句的地方写表达式。

在这种情况下，**表达式语句**（Expression statement）是语句的一种，因此我们使用分号来分隔语句。

```
// 式文であるためセミコロンをつけている
式; 
```

表达式可以变成语句，但像之前的 if 语句那样，语句不能变成表达式。

### *块语句*

*将以下用`{`和`}`包围的部分称为**块**。块中可以写多个**语句**。

```
{
    文;
    文;
} 
```

块语句可以单独编写，但基本上与其他结构（如 if 语句或 for 语句）结合使用。以下代码通过将 if 语句和块语句结合使用，将多个语句写入 if 语句的处理内容中。

```
// if 文とブロック文の組み合わせ
if (true) {
    console.log("文 1");
    console.log("文 2");
} 
```

之前提到，在语句的末尾应该加上分号，但作为例外，**以块结束的语句**的末尾不需要分号。

```
// ブロックで終わらない文なので、セミコロンが必要
if (true) console.log(true);
// ブロックで終わる文なので、セミコロンが不要
if (true) {
    console.log(true);
} 
```

## *[专栏] 单独的块语句的应用*

*在应用程序的源代码中，几乎不会单独编写 if 语句等与组合的块语句。但是，在 REPL 中重复执行相同代码的一部分时，单独的块语句有时也会很有用。

在 REPL 中，如果以相同变量名重新定义，将发生语法错误（详细信息请参考“变量与声明”章节中的“`var`的问题”）。因此，要再次执行相同的代码，必须通过在浏览器中重新加载页面来重置变量定义。

```
// REPLでの動作。»はREPLの入力欄
» const count = 1;
undefined
» const count = 2;
SyntaxError: redeclaration of const count 
```

这个问题可以通过使用单独的块语句来定义变量来避免。在块语句（`{}`）中使用 let 或 const 定义变量时，它不会影响块语句之外的内容。因此，可以通过以下方式使用块语句来避免相同的变量名定义导致的语法错误（`SyntaxError`）。

```
// REPLでの動作。»はREPLの入力欄
» {
    const count = 1;
}
undefined // ここでブロック内で定義した変数`count`は参照できなくなる
» {
    const count = 1;
}
undefined // ここでブロック内で定義した変数`count`は参照できなくなる 
```

这是由块作用域这种机制造成的，但具体的机制将在“函数与作用域”章节中解释。现在，只要知道使用块语句可以使 REPL 中的试错变得容易就可以了。

## *函数声明（文）与函数表达式*

*在“函数与声明”章节中，我们学习了定义函数的方法。可以从使用`function`关键字开始的**函数声明**和将**函数表达式**赋值给变量的方法开始。

函数声明（文）和函数式都使用了`function`这个关键字。

```
// learn 関数を宣言する関数宣言文
function learn() {
}
// 関数式をread 変数へ代入
const read = function() {
}; 
```

通过观察语句和表达式的区别，可以看出函数声明语句没有分号，而函数式有分号。这种差异可以从前面的内容中解释。

使用函数声明（文）定义的`learn`函数没有分号。这是因为**以块结束的语句**不需要分号。

另一方面，将函数式赋值给`read`变量时，有分号。

“可能是因为以块结束的函数不需要分号吗？”你可能会有这样的疑问。

但是，这个匿名函数是**表达式**，并且可以看出这个处理是变量声明语句的一部分。换句话说，可以将其替换为以下内容，因此需要在末尾添加分号。

```
function fn() {}
// fn(式)の評価値を代入する変数宣言の文
const read = fn; 
```

## *总结*

*在本章中，我们学习了以下内容。

+   JavaScript 由**语句**（Statement）和**表达式**（Expression）组成

+   语句不能变成表达式

+   表达式可以变成语句（**表达式语句**）

+   语句的末尾要加分号

+   以块结束的语句例外地不需要加分号

JavaScript 有一种基于特殊规则的机制，即使没有分号，也会在行末自动插入分号。但是，这个机制在无法正确解析语法的情况下，会插入分号，这可能会导致意外的行为。因此，建议始终在**语句**的末尾写上分号。

编辑器或 IDE 中有些可以辅助输入分号，或者可以使用[ESLint](https://eslint.org/ "ESLint - 可插拔的 JavaScript 代码检查工具")等 Lint 工具来检查是否需要分号。

要判断是否需要分号，需要一定程度的熟悉，但可以使用工具进行静态检查。因此，在工具等辅助下，通过经验逐渐熟悉也是一个好方法。*******
