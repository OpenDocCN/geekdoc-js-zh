# 変数と宣言

> 原文：[`jsprimer.net/basic/variables/`](https://jsprimer.net/basic/variables/)

プログラミング言語には、文字列や数値などのデータに名前をつけることで、繰り返し利用できるようにする**変数**という機能があります。

JavaScriptには「これは変数です」という宣言をするキーワードとして、 `const`、`let`、`var`の3つがあります。

`var`はもっとも古くからある変数宣言のキーワードですが、意図しない動作を作りやすい問題が知られています。 そのためECMAScript 2015で、`var`の問題を改善するために`const`と`let`という新しいキーワードが導入されました。

この章では`const`、`let`、`var`の順に、それぞれの方法で宣言した変数の違いについて見ていきます。

## [](#const)*[ES2015] `const`*

*`const`キーワードでは、再代入できない変数の宣言とその変数が参照する値（初期値）を定義できます。

次のように、`const`キーワードに続いて`変数名`を書き、代入演算子（`=`）の右辺に変数の`初期値`を書いて変数を定義できます。

```
const 変数名 = 初期値; 
```

次のコードでは`bookTitle`という変数を宣言し、初期値が`"JavaScript Primer"`という文字列であることを定義しています。

```
const bookTitle = "JavaScript Primer"; 
```

`const`、`let`、`var`どのキーワードも共通の仕組みですが、変数同士を`,`（カンマ）で区切ることにより、同時に複数の変数を定義できます。

次のコードでは、`bookTitle`と`bookCategory`という変数を順番に定義しています。

```
const bookTitle = "JavaScript Primer",
      bookCategory = "プログラミング"; 
```

これは次のように書いた場合と同じ意味になります。

```
const bookTitle = "JavaScript Primer";
const bookCategory = "プログラミング"; 
```

また、`const`は再代入できない変数を宣言するキーワードです。 そのため、`const`キーワードで宣言した変数に対して、後から値を代入することはできません。

次のコードでは、`const`で宣言した変数`bookTitle`に対して値を再代入しているため、次のようなエラー（`TypeError`）が発生します。 エラーが発生するとそれ以降の処理は実行されなくなります。

```
const bookTitle = "JavaScript Primer";
bookTitle = "新しいタイトル"; // => TypeError: invalid assignment to const 'bookTitle' 
```

一般的に変数への再代入は「変数の値は最初に定義した値と常に同じである」という参照透過性と呼ばれるルールを壊すため、バグを発生させやすい要因として知られています。そのため、変数に対して値を再代入する必要がない場合は、`const`キーワードで変数宣言することを推奨しています。

変数に値を再代入したいケースとして、ループなどの反復処理の途中で特定の変数が参照する値を変化させたい場合があります。 そのような場合には、変数への再代入が可能な`let`キーワードを利用します。

## [](#let)*[ES2015] `let`*

*`let`キーワードでは、値の再代入が可能な変数を宣言できます。 `let`の使い方は`const`とほとんど同じです。

次のコードでは、`bookTitle`という変数を宣言し、初期値が`"JavaScript Primer"`という文字列であることを定義しています。

```
let bookTitle = "JavaScript Primer"; 
```

`let`は`const`とは異なり、初期値を指定しない変数も定義できます。 初期値が指定されなかった変数はデフォルト値として`undefined`という値で初期化されます（`undefined`は値が未定義ということを表す値です）。

次のコードでは、`bookTitle`という変数を宣言しています。 このとき`bookTitle`には初期値が指定されていないため、デフォルト値として`undefined`で初期化されます。

```
let bookTitle;
// `bookTitle`は自動的に`undefined`という値になる 
```

この`let`で宣言された`bookTitle`という変数には、代入演算子（`=`）を使うことで値を代入できます。 代入演算子（`=`）の右側には変数へ代入する値を書きますが、ここでは`"JavaScript Primer"`という文字列を代入しています。

```
let bookTitle;
bookTitle = "JavaScript Primer"; 
```

`let`で宣言した変数に対しては何度でも値の代入が可能です。

```
let count = 0;
count = 1;
count = 2;
count = 3; 
```

## [](#var)*`var`*

*`var`キーワードでは、値の再代入が可能な変数を宣言できます。 `var`の使い方は`let`とほとんど同じです。

```
var bookTitle = "JavaScript Primer"; 
```

`var`では、`let`と同じように初期値がない変数を宣言でき、変数に対して値の再代入もできます。

```
var bookTitle;
bookTitle = "JavaScript Primer";
bookTitle = "新しいタイトル"; 
```

### [](#var-issues)*`var`の問題*

*`var`は`let`とよく似ていますが、`var`キーワードには同じ名前の変数を再定義できてしまう問題があります。

`let`や`const`では、同じ名前の変数を再定義しようとすると、次のような構文エラー（`SyntaxError`）が発生します。 そのため、間違えて変数を二重に定義してしまうというミスを防ぐことができます。

```
// "x"という変数名で変数を定義する
let x;
// 同じ名前の変数"x"を定義するとSyntaxErrorとなる
let x; // => SyntaxError: redeclaration of let x 
```

一方、`var`は同じ名前の変数を再定義できます。 これは意図せずに同じ変数名で定義してもエラーとならずに、値を上書きしてしまいます。

```
// "x"という変数を定義する
var x = 1;
// 同じ名前の変数"x"を定義できる
var x = 2;
// 変数 xは2となる 
```

また`var`には変数の巻き上げと呼ばれる意図しない挙動があり、`let`や`const`ではこの問題が解消されています。 `var`による変数の巻き上げの問題については「関数とスコープ」の章で解説します。 そのため、現時点では「`let`は`var`を改善したバージョン」ということだけ覚えておくとよいです。

このように、`var`にはさまざまな問題があります。 また、ほとんどすべてのケースで`var`は`const`か`let`に置き換えが可能です。 そのため、これから書くコードに対して`var`を利用することは避けたほうがよいでしょう。

## [](#why-add-let-and-const)*[コラム] なぜ`let`や`const`は追加されたのか？*

*ECMAScript 2015では、`var`そのものを改善するのではなく、新しく`const`と`let`というキーワードを追加することで、`var`の問題を回避できるようにしました。`var`自体の動作を変更しなかったのは、後方互換性のためです。

なぜなら、`var`の挙動自体を変更してしまうと、すでに`var`で書かれたコードの動作が変わってしまい、動かなくなるアプリケーションが出てくるためです。 新しく`const`や`let`などのキーワードをECMAScript 仕様に追加しても、そのキーワードを使っているソースコードは追加時点では存在しません。^(1) そのため、`const`や`let`が追加されても後方互換性には影響がありません。

このように、ECMAScriptでは機能を追加する際にも後方互換性を重視しているため、`var`自体の挙動は変更されませんでした。

## [](#variable-name)*変数名に使える名前のルール*

*到目前为止，我们已经了解了`const`、`let`、`var`关键字以及它们各自的变量声明特性。 在任何关键字中，可用于声明变量的名称规则都是相同的。 此外，此规则适用于 JavaScript 标识符，如变量名和函数名。

变量名（标识符）有以下规则：

1.  将变量名设为由半角字母、`_`（下划线）、`$`（美元符号）和数字`0`至`9`组成的名称

1.  变量名不能以数字开头

1.  不能使用保留字作为名称

变量名应为由半角字母`A`至`Z`（大写）和`a`至`z`（小写）、`_`（下划线）、`$`（美元符号）、数字`0`至`9`组成的名称。 在 JavaScript 中，区分大小写。

除此之外，虽然可以在变量名中使用平假名和部分汉字等，但是如果混合全角字符，则可能会因环境问题而难以处理，因此不建议使用。

```
let $; // OK: $が利用できる
let _title; // OK: _が利用できる
let jquery; // OK: 小文字のアルファベットが利用できる
let TITLE; // OK: 大文字のアルファベットが利用できる
let es2015; // OK: 数字は先頭以外なら利用できる
let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる 
```

可以在变量名中包含数字，但是变量名不能以数字开头。 这是因为会导致无法区分变量名和数字。

```
let 1st; // NG: 数字から始まっている
let 123; // NG: 数字のみで構成されている 
```

此外，无法将保留字用作变量名。 保留字是指具有语法意义的关键字，例如`let`。 可以在[保留字 - JavaScript | MDN](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar)上找到保留字列表，但基本上是保留用于语法的名称。

```
let let; // NG: `let`は変数宣言のために予約されているので利用できない
let if; // NG: `if`はif 文のために予約されているので利用できない 
```

## [](#const-is-not-constant)*[专栏] `const`并非常量*

*`const`是定义“不能重新赋值的变量”的变量声明，并不一定定义常量。常量是指一旦定义的名称（变量名）始终表示相同值的东西。

在 JavaScript 中，也可以使用`const`声明接近常量的变量。如果使用`const`声明的变量初始化为无法更改的原始值，则实际上就是常量。原始值是指除对象之外的数据，例如数字和字符串（有关详细信息，请参阅“数据类型和字面量”章节）。

```
// TEN_NUMBERという変数は常に10という値を示す
const TEN_NUMBER = 10; 
```

但是，在 JavaScript 中，也可以使用`const`声明对象等。 例如，对象值本身在初始化后也可以更改。

```
// `const`でオブジェクトを定義している
const object = {
    key: "値"
};
// オブジェクトそのものは変更できてしまう
object.key = "新しい値"; 
```

因此，由于使用`const`声明的变量不一定始终表示相同的值，因此不能称之为常量（有关详细信息，请参见“对象”章节）。

此外，`const`没有变量命名规则，也没有赋值限制。因此，最好理解`const`声明的特性是定义“不能重新赋值的变量”。

## [](#summary)*总结*

*本章介绍了 JavaScript 中用于声明变量的关键字`const`、`let`、`var`。

+   `const`可以声明不能重新赋值的变量

+   `let`可以声明可以重新赋值的变量

+   `var`可以声明可以重新赋值的变量，但已知存在一些问题

+   变量名（标识符）有一些可用的名称规则

`var`在大多数情况下都可以用`let`或`const`来替代。`const`定义了不能重新赋值的变量。通过禁止重新赋值，可以减少因错误而引起的 bug。因此，在声明变量时，首先考虑是否可以用`const`定义，如果不行，则建议使用`let`。

> ¹. 由于`let`和`const`在 ECMAScript 2015 之前被定义为保留字，所以不会与现有代码冲突。 ↩********
