- en: 处理命令行参数
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命令行参数
- en: 原文：[`jsprimer.net/use-case/nodecli/argument-parse/`](https://jsprimer.net/use-case/nodecli/argument-parse/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/use-case/nodecli/argument-parse/`](https://jsprimer.net/use-case/nodecli/argument-parse/)
- en: 此使用案例中创建的 CLI 应用程序的目标是将给定的 Markdown 文件转换为 HTML。本节将介绍如何在使用`node`命令执行脚本时传递参数并解析命令行参数。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此使用案例中创建的 CLI 应用程序的目标是将给定的 Markdown 文件转换为 HTML。本节将介绍如何在使用`node`命令执行脚本时传递参数并解析命令行参数。
- en: '*`process`对象和命令行参数*'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[`process`对象和命令行参数](#process-object-and-commandline-args)'
- en: '*在处理命令行参数之前，首先让我们了解一下`process`对象。`process`对象是 Node.js 执行环境的全局变量之一。`process`对象提供了有关当前
    Node.js 执行进程的信息获取和操作 API。有关详细信息，请参阅[官方文档](https://nodejs.org/docs/latest-v20.x/api/process.html#process_process)。'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*在处理命令行参数之前，首先让我们了解一下`process`对象。`process`对象是 Node.js 执行环境的全局变量之一。`process`对象提供了有关当前
    Node.js 执行进程的信息获取和操作 API。有关详细信息，请参阅[官方文档](https://nodejs.org/docs/latest-v20.x/api/process.html#process_process)。'
- en: 访问命令行参数的方法是通过`process`对象的`argv`属性，它是一个字符串数组。让我们修改`main.js`，并输出`process.argv`到控制台。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 访问命令行参数的方法是通过`process`对象的`argv`属性，它是一个字符串数组。让我们修改`main.js`，并输出`process.argv`到控制台。
- en: main.js
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: main.js
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 使用以下命令以带有命令行参数的形式执行此脚本。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令以带有命令行参数的形式执行此脚本。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 此命令的执行结果如下：
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的执行结果如下：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 第 1 个和第 2 个元素始终是`node`命令和执行的脚本文件路径。换句话说，应用程序使用的是第 3 个元素及以后的元素作为命令行参数。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 个和第 2 个元素始终是`node`命令和执行的脚本文件路径。换句话说，应用程序使用的是第 3 个元素及以后的元素作为命令行参数。
- en: '*解析命令行参数*'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[解析命令行参数](#parse-args)'
- en: '*通过使用`process.argv`数组，您可以获取命令行参数，但获取的信息可能包含应用程序不需要的内容。此外，由于以字符串数组的形式传递，因此在接收布尔值等真值时也不方便。因此，在处理命令行参数时，通常会对其进行解析并格式化为更易于处理的值。'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`process.argv`数组，您可以获取命令行参数，但获取的信息可能包含应用程序不需要的内容。此外，由于以字符串数组的形式传递，因此在接收布尔值等真值时也不方便。因此，在处理命令行参数时，通常会对其进行解析并格式化为更易于处理的值。'
- en: 在本例中，我们将使用名为[commander](https://github.com/tj/commander.js/)的库来解析命令行参数。虽然您可以手动进行字符串处理，但对于此类常见操作，使用现有库会更加简单。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将使用名为[commander](https://github.com/tj/commander.js/)的库来解析命令行参数。虽然您可以手动进行字符串处理，但对于此类常见操作，使用现有库会更加简单。
- en: '*安装`commander`包*'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[安装`commander`包](#install-commander)'
- en: '*可以使用[npm](https://www.npmjs.com/)的`npm install`命令来安装`commander`。如果您尚未准备好 npm
    运行环境，请先参考“设置本地环境”章节。'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以使用[npm](https://www.npmjs.com/)的`npm install`命令来安装`commander`。如果您尚未准备好 npm
    运行环境，请先参考“设置本地环境”章节。'
- en: 在使用 npm 安装包之前，首先要创建一个名为`package.json`的文件。`package.json`记录了应用程序依赖的包的类型和版本等信息，是一个
    JSON 格式的文件。可以使用`npm init`命令生成`package.json`文件的模板。通常会通过交互式提示来设置信息，但在这里我们将使用`--yes`选项以默认值创建`package.json`。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 npm 安装包之前，首先要创建一个名为`package.json`的文件。`package.json`记录了应用程序依赖的包的类型和版本等信息，是一个
    JSON 格式的文件。可以使用`npm init`命令生成`package.json`文件的模板。通常会通过交互式提示来设置信息，但在这里我们将使用`--yes`选项以默认值创建`package.json`。
- en: 在`nodecli`目录中，执行`npm init --yes`命令以创建`package.json`。
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在`nodecli`目录中，执行`npm init --yes`命令以创建`package.json`。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 生成的`package.json`文件如下所示：
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`package.json`文件如下所示：
- en: package.json
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 当`package.json`文件准备好后，使用`npm install`命令安装`commander`包。此命令的参数是要安装的包的名称和版本，用`@`符号连接。如果不指定版本，则自动选择当前的最新稳定版本。执行以下命令以安装
    commander 的 9.0 版本。^(1)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当`package.json`文件准备好后，使用`npm install`命令安装`commander`包。此命令的参数是要安装的包的名称和版本，用`@`符号连接。如果不指定版本，则自动选择当前的最新稳定版本。执行以下命令以安装
    commander 的 9.0 版本。^(1)
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 安装完成后，`package.json`文件如下所示：
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，`package.json`文件如下所示：
- en: package.json
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 此外，执行`npm install`时会同时生成`package-lock.json`文件。该文件记录了 npm 安装的包的实际版本。虽然我们将 commander
    的版本设置为`9.0`，但实际安装的将是与`9.0.x`匹配的最新版本。`package-lock.json`文件记录了实际安装的版本，这样再次执行`npm
    install`时就可以防止安装不同的版本。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，执行`npm install`时会同时生成`package-lock.json`文件。该文件记录了 npm 安装的包的实际版本。虽然我们将 commander
    的版本设置为`9.0`，但实际安装的将是与`9.0.x`匹配的最新版本。`package-lock.json`文件记录了实际安装的版本，这样再次执行`npm
    install`时就可以防止安装不同的版本。
- en: '*使用 ECMAScript 模块*'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 ECMAScript 模块](#esmodule)'
- en: '*在这个使用案例中，我们将使用安装的`commander`包，并结合我们学到的基本语法 ECMAScript 模块。`commander`包支持 ECMAScript
    模块，因此可以使用`import`语句来导入变量和函数等。'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个使用案例中，我们将使用安装的`commander`包，并结合我们学到的基本语法 ECMAScript 模块。`commander`包支持 ECMAScript
    模块，因此可以使用`import`语句来导入变量和函数等。'
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 但是，要导入 ECMAScript 模块的包，导入源文件本身也必须是 ECMAScript 模块。因为[Node.js](https://nodejs.org/)支持另一种模块形式，即[CommonJS
    模块](https://nodejs.org/docs/latest/api/modules.html)，而 CommonJS 模块形式不支持`import`语句。因此，需要告诉
    Node.js 即将执行的 JavaScript 文件使用哪种形式。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要导入 ECMAScript 模块的包，导入源文件本身也必须是 ECMAScript 模块。因为[Node.js](https://nodejs.org/)支持另一种模块形式，即[CommonJS
    模块](https://nodejs.org/docs/latest/api/modules.html)，而 CommonJS 模块形式不支持`import`语句。因此，需要告诉
    Node.js 即将执行的 JavaScript 文件使用哪种形式。
- en: Node.js 通过最接近的上级目录的`package.json`的`type`字段值来确定 JavaScript 文件的模块格式。 如果`type`字段为`module`，则将其视为
    ECMAScript 模块；如果`type`字段为`commonjs`，则将其视为 CommonJS 模块。^(2) 此外，还可以通过 JavaScript
    文件的扩展名明确指定。如果扩展名为`.mjs`，则被识别为 ECMAScript 模块；如果为`.cjs`，则被识别为 CommonJS 模块。
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 通过最接近的上级目录的`package.json`的`type`字段值来确定 JavaScript 文件的模块格式。 如果`type`字段为`module`，则将其视为
    ECMAScript 模块；如果`type`字段为`commonjs`，则将其视为 CommonJS 模块。^(2) 此外，还可以通过 JavaScript
    文件的扩展名明确指定。如果扩展名为`.mjs`，则被识别为 ECMAScript 模块；如果为`.cjs`，则被识别为 CommonJS 模块。
- en: 为了将`main.js`识别为 ECMAScript 模块，可以将`package.json`中添加`type`字段如下。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`main.js`识别为 ECMAScript 模块，可以将`package.json`中添加`type`字段如下。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: package.json
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: package.json
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*[专栏] CommonJS 模块*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[专栏] [CommonJS 模块](#commonjs-module)'
- en: '*[CommonJS 模块](https://nodejs.org/docs/latest/api/modules.html)是 Node.js 环境中使用的
    JavaScript 模块化机制。 CommonJS 模块在 ECMAScript 模块规范制定之前就已经在 Node.js 中使用。'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*[CommonJS 模块](https://nodejs.org/docs/latest/api/modules.html)是 Node.js 环境中使用的
    JavaScript 模块化机制。 CommonJS 模块在 ECMAScript 模块规范制定之前就已经在 Node.js 中使用。'
- en: 尽管 Node.js 现在也支持 ECMAScript 模块，但诸如`fs`之类的标准模块仍以 CommonJS 模块的形式提供。 此外，即使在第三方库或长期开发的项目源代码中，也经常使用
    CommonJS 模块。 因此，在这两种模块格式共存的情况下，开发人员需要注意模块格式之间的互操作性（组合时的行为）。^(3)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Node.js 现在也支持 ECMAScript 模块，但诸如`fs`之类的标准模块仍以 CommonJS 模块的形式提供。 此外，即使在第三方库或长期开发的项目源代码中，也经常使用
    CommonJS 模块。 因此，在这两种模块格式共存的情况下，开发人员需要注意模块格式之间的互操作性（组合时的行为）。^(3)
- en: Node.js 支持从 ECMAScript 模块导入 CommonJS 模块的双向互操作性。 例如，使用 CommonJS 模块中的`exports`对象导出的对象可以通过
    ECMAScript 模块中的`import`语句导入。 Node.js 的标准模块可以从 ECMAScript 模块的 JavaScript 文件中使用，但这是由于这种互操作性造成的。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 支持从 ECMAScript 模块导入 CommonJS 模块的双向互操作性。 例如，使用 CommonJS 模块中的`exports`对象导出的对象可以通过
    ECMAScript 模块中的`import`语句导入。 Node.js 的标准模块可以从 ECMAScript 模块的 JavaScript 文件中使用，但这是由于这种互操作性造成的。
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 另一方面，不支持从 CommonJS 模块导入 ECMAScript 模块的双向互操作性。 如果来自现有库的模块是 ECMAScript 模块，则使用该库的应用程序也必须是
    ECMAScript 模块。 在开发 Node.js 应用程序时使用多个包时，需要注意互操作性。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不支持从 CommonJS 模块导入 ECMAScript 模块的双向互操作性。 如果来自现有库的模块是 ECMAScript 模块，则使用该库的应用程序也必须是
    ECMAScript 模块。 在开发 Node.js 应用程序时使用多个包时，需要注意互操作性。
- en: '*从命令行参数获取文件路径*'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*从命令行参数获取文件路径*'
- en: '*使用刚刚安装的`commander`包，获取通过命令行参数传递的文件路径。 在这个 CLI 应用程序中，将以以下命令格式接收要处理的文件路径。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用刚刚安装的`commander`包，获取通过命令行参数传递的文件路径。 在这个 CLI 应用程序中，将以以下命令格式接收要处理的文件路径。'
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 要使用 commander 解析命令行参数，需要将命令行参数传递给导入的`program`对象的`parse`方法。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 commander 解析命令行参数，需要将命令行参数传递给导入的`program`对象的`parse`方法。
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 调用`parse`方法后，可以从`program`对象中提取解析后的命令行参数结果。 在本例中，文件路径存储在`program.args`数组中。 `program.args`数组按顺序存储了除了选项和标志之外的剩余命令行参数。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`parse`方法后，可以从`program`对象中提取解析后的命令行参数结果。 在本例中，文件路径存储在`program.args`数组中。 `program.args`数组按顺序存储了除了选项和标志之外的剩余命令行参数。
- en: 然后，将`main.js`修改如下，以获取通过命令行参数传递的文件路径。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`main.js`修改如下，以获取通过命令行参数传递的文件路径。
- en: main.js
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: main.js
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 执行以下命令后，将获取存储在`program.args`数组中的`./sample.md`字符串并输出到控制台。 `./sample.md`在`process.argv`数组中是第
    3 个元素，但在解析后的`program.args`数组中变为第 1 个元素，更易于处理。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令后，将获取存储在`program.args`数组中的`./sample.md`字符串并输出到控制台。 `./sample.md`在`process.argv`数组中是第
    3 个元素，但在解析后的`program.args`数组中变为第 1 个元素，更易于处理。
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 通过使用类似 commander 的库来声明性地定义和处理命令行参数，而不是直接处理`process.argv`数组，可以更好地处理命令行参数。 在下一节中，将添加处理基于命令行参数获取的文件路径的过程。
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用类似 commander 的库来声明性地定义和处理命令行参数，而不是直接处理`process.argv`数组，可以更好地处理命令行参数。 在下一节中，将添加处理基于命令行参数获取的文件路径的过程。
- en: '*[错误示例] SyntaxError: Cannot use import statement
    outside a module*'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*[错误示例] SyntaxError: Cannot use import statement
    outside a module*'
- en: '*如果出现“无法在模块外部使用 import 语��”的错误，则表示 Node.js 无法识别`main.js`文件为 ECMAScript 模块。'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果出现“无法在模块外部使用 import 语句”的错误，则表示 Node.js 无法识别`main.js`文件为 ECMAScript 模块。'
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 如使用 ECMAScript 模块所述，将`package.json`的`type`字段设置为`module`。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如使用 ECMAScript 模块所述，将`package.json`的`type`字段设置为`module`。
- en: '*本节的检查清单*'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*本节的检查清单*'
- en: '**   确认`process.argv`数组中包含`node`命令的命令行参数'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**   确认`process.argv`数组中包含`node`命令的命令行参数'
- en: 理解使用 npm 安装包的方法
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使用 npm 安装包的方法
- en: 确认使用 ECMAScript 模块加载包
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认使用 ECMAScript 模块加载包
- en: 确认可以使用 commander 解析命令行参数
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认可以使用 commander 解析命令行参数
- en: 可以获取通过命令行参数传递的文件路径并输出到控制台
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以获取通过命令行参数传递的文件路径并输出到控制台
- en: ¹. 使用--save 选项安装的意义相同。从 npm 5.0.0 开始，--save 成为默认选项。 ↩
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹. 使用--save 选项安装的意义相同。从 npm 5.0.0 开始，--save 成为默认选项。 ↩
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ². [package.json 和文件扩展名](https://nodejs.org/api/packages.html#packagejson-and-file-extensions)
    ↩
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ². [package.json 和文件扩展名](https://nodejs.org/api/packages.html#packagejson-and-file-extensions)
    ↩
- en: ''
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ³. [与 CommonJS 的互操作性](https://nodejs.org/api/esm.html#interoperability-with-commonjs)
    ↩********
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³. [与 CommonJS 的互操作性](https://nodejs.org/api/esm.html#interoperability-with-commonjs)
    ↩********
