- en: オブジェクト
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: 原文：[`jsprimer.net/basic/object/`](https://jsprimer.net/basic/object/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/object/`](https://jsprimer.net/basic/object/)
- en: オブジェクトはプロパティの集合です。プロパティとは名前（キー）と値（バリュー）が対になったものです。 プロパティのキーには文字列または`Symbol`が利用でき、値には任意のデータを指定できます。
    また、1つのオブジェクトは複数のプロパティを持てるため、1つのオブジェクトで多種多様な値を表現できます。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是属性的集合。属性是指名称（键）与值（值）相对应的项。属性的键可以使用字符串或`Symbol`，值可以指定任意的数据。此外，一个对象可以拥有多个属性，因此一个对象可以表示多种多样的值。
- en: 今までも登場してきた、配列や関数などもオブジェクトの一種です。 JavaScriptには、あらゆるオブジェクトの元となる`Object`というビルトインオブジェクトがあります。
    ビルトインオブジェクトは、実行環境にあらかじめ定義されているオブジェクトのことです。 `Object`というビルトインオブジェクトはECMAScriptの仕様で定義されているため、あらゆるJavaScriptの実行環境で利用できます。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之前出现的数组或函数等也是对象的一种。JavaScript有一个名为`Object`的内置对象，它是所有对象的基类。内置对象是在执行环境中预先定义的对象。`Object`这个内置对象是在ECMAScript规范中定义的，因此可以在所有JavaScript执行环境中使用。
- en: この章では、オブジェクトの作成や扱い方、`Object`というビルトインオブジェクトについて見ていきます。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍对象的创建和操作方法，以及内置对象`Object`。
- en: '[](#create-object)*オブジェクトを作成する*'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#create-object)*创建对象*'
- en: '*オブジェクトを作成するには、オブジェクトリテラル（`{}`）を利用します。'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*创建对象时，可以使用对象字面量（`{}`）。'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: オブジェクトリテラルでは、初期値としてプロパティを持つオブジェクトを作成できます。 プロパティは、オブジェクトリテラル（`{}`）の中にキーと値を`:`（コロン）で区切って記述します。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量中，可以创建具有初始属性的空对象。属性是在对象字面量（`{}`）中用冒号（`:`）分隔键和值来描述的。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: オブジェクトリテラルのプロパティ名（キー）はクォート（`"`や`'`）を省略できます。 そのため、次のように書いても同じです。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量的属性名（键）可以省略引号（`"`或`'`）。因此，可以这样写。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ただし、変数名として利用できないプロパティ名はクォート（`"`や`'`）で囲む必要があります。 次の`my-prop`というプロパティ名は、変数名として利用できない`-`が含まれているため定義できません（「変数と宣言」の章の「変数名に使える名前のルール
    」を参照）
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不能用作变量名的属性名需要用引号（`"`或`'`）括起来。下面的`my-prop`属性名因为包含不能用作变量名的`-`，所以无法定义（请参考“变量与声明”章节中的“变量名可以使用名称的规则”）。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`my-prop`というプロパティ名を定義する場合は、クォート（`"`や`''`）で囲む必要があります。'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`my-prop`这样的属性名时，需要用引号（`"`或`'`）括起来。
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: オブジェクトリテラルでは複数のプロパティ（キーと値の組み合わせ）を持つオブジェクトも作成できます。 複数のプロパティを定義するには、それぞれのプロパティを`,`（カンマ）で区切ります。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量可以创建具有多个属性（键和值的组合）的对象。要定义多个属性，需要用逗号（`,`）分隔每个属性。
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: プロパティの値に変数名を指定すれば、そのキーは指定した変数を参照します。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将变量名指定为属性值，则该键将引用指定的变量。
- en: '[PRE6]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ��たES2015からは、プロパティ名と値に指定する変数名が同じ場合は`{ name }`のように省略して書けます。 次のコードは、プロパティ名`name`に変数`name`を値にしたプロパティを設定しています。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES2015开始，如果指定的属性名和值中的变量名相同，则可以省略`{ name }`，如下面的代码所示，将变量`name`作为值设置到属性名`name`中。
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: この省略記法は、モジュールや分割代入においても共通した表現です。 そのため、`{}`の中でプロパティ名が単独で書かれている場合は、この省略記法を利用していることに注意してください。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种省略语法在模块或分割赋值中也是通用的。因此，当在`{}`中单独书写属性名时，请注意这是在利用这种省略语法。
- en: '[](#object-instance-object)*`{}`は`Object`のインスタンスオブジェクト*'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#object-instance-object)*`{}`是`Object`的实例对象*'
- en: '*`Object`はJavaScriptのビルトインオブジェクトです。 オブジェクトリテラル（`{}`）は、このビルトインオブジェクトである`Object`を元にして新しいオブジェクトを作成するための構文です。'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Object`是JavaScript的内置对象。对象字面量（`{}`）是创建基于此内置对象`Object`的新对象的语法。'
- en: オブジェクトリテラル以外の方法として、`new`演算子を使うことで、`Object`から新しいオブジェクトを作成できます。 次のコードでは、`new Object()`でオブジェクトを作成していますが、これは空のオブジェクトリテラルと同じ意味です。
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象字面量之外，还可以使用`new`运算符从`Object`创建新的对象。下面的代码中，使用`new Object()`创建对象，但这与空对象字面量具有相同的意义。
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: オブジェクトリテラルのほうが明らかに簡潔で、プロパティの初期値も指定できるため、`new Object()`を使う利点はありません。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量更简洁，可以指定属性的初始值，因此使用`new Object()`没有优势。
- en: '`new Object()`でオブジェクトを作成することは、「`Object`のインスタンスオブジェクトを作成する」と言います。 しかしながら、`Object`やインスタンスオブジェクトなどややこしい言葉の使い分けが必要となってしまいます。
    そのため、この書籍ではオブジェクトリテラルと`new Object`どちらの方法であっても、単に「オブジェクトを作成する」と呼びます。'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new Object()`创建对象被称为“创建`Object`的实例对象”。然而，需要区分`Object`、实例对象等术语。因此，本书中无论是使用对象字面量还是`new
    Object`，都统称为“创建对象”。
- en: オブジェクトリテラルは、`Object`から新しいインスタンスオブジェクトを作成していることを意識しておくとよいでしょう。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意对象字面量是从`Object`创建新的实例对象。
- en: '[](#property-access)*プロパティへのアクセス*'
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#property-access)*属性访问*'
- en: '*オブジェクトのプロパティにアクセスする方法として、**ドット記法**（`.`）を使う方法と**ブラケット記法**（`[]`）があります。 それぞれの記法でプロパティ名を指定すると、その名前を持ったプロパティの値を参照できます。'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问对象属性的方法有两种：**点记法**（`.`）和**方括号记法**（`[]`）。使用这两种记法指定属性名时，可以引用具有该名称的属性的值。'
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ドット記法（`.`）では、プロパティ名が変数名と同じく識別子の命名規則を満たす必要があります（「変数と宣言」の章の「変数名に使える名前のルール 」を参照）。
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在点记法（`.`）中，属性名需要满足与变量名相同的标识符命名规则（请参考“变量与声明”章节中的“变量名可以使用名称的规则”）。
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 一方、**ブラケット記法**では、`[`と`]`の間に任意の式を書けます。 そのため、識別子の命名規則とは関係なく、任意の文字列をプロパティ名として指定できます。
    ただし、プロパティ名は文字列へと暗黙的に変換されることに注意してください。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**方括号记法**可以在`[`和`]`之间写任意表达式。因此，与标识符的命名规则无关，可以指定任意字符串作为属性名。但请注意，属性名会隐式地转换为字符串。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: また、ブラケット記法ではプロパティ名に変数も利用できます。 次のコードでは、プロパティ名に`myLang`という変数をブラケット記法で指定しています。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在方括号记法中，可以使用变量作为属性名。下面的代码中，使用方括号记法指定了变量`myLang`作为属性名。
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ドット記法ではプロパティ名に変数は利用できないため��プロパティ名に変数を指定したい場合はブラケット記法を利用します。 基本的には簡潔なドット記法（`.`）を使い、ドット記法で書けない場合はブラケット記法（`[]`）を使うとよいでしょう。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在点记法中，不能使用变量作为属性名，因此如果需要指定变量作为属性名，则应使用方括号记法。基本上，可以使用简洁的点记法（`.`），如果点记法无法使用，则可以使用方括号记法（`[]`）。
- en: '[](#object-destructuring)*[ES2015] オブジェクトと分割代入*'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#object-destructuring)*[ES2015] 对象与分割赋值*'
- en: '*同じオブジェクトのプロパティに何度もアクセスする場合に、何度も`オブジェクト.プロパティ名`と書くと冗長となりやすいです。 そのため、短い名前で利用できるように、そのプロパティを変数として定義し直すことがあります。'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*在需要多次访问同一对象的属性时，多次书写`对象.属性名`会显得冗长。因此，有时会重新定义一个短名称的变量来引用该属性。'
- en: 次のコードでは、変数`ja`と`en`を定義し、その初期値として`languages`オブジェクトのプロパティを代入しています。
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，定义了变量`ja`和`en`，并将其初始值设置为`languages`对象的属性。
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: このようにオブジェクトのプロパティを変数として定義し直すときには、分割代入（Destructuring assignment）が利用できます。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新定义对象属性为变量时，可以使用分割赋值（Destructuring assignment）。
- en: オブジェクトの分割代入では、左辺にオブジェクトリテラルのような構文で変数名を定義します。 右辺のオブジェクトから対応するプロパティ名が、左辺で定義した変数に代入されます。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象的分割赋值中，将变量名定义为类似于对象字面量的结构。右边的对象中的相应属性名将被赋值给左侧定义的变量。
- en: 次のコードでは、先ほどのコードと同じように`languages`オブジェクトから`ja`と`en`プロパティを取り出して変数として定義しています。 代入演算子のオペランドとして左辺と右辺それぞれに`ja`と`en`と書いていたのが、分割代入では一箇所に書くことができます。
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，与之前的代码相同，从`languages`对象中提取`ja`和`en`属性，并将其定义为变量。
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[](#add-property)*添加属性*'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#add-property)*添加属性*'
- en: '*对象具有可变（mutable）的特性，即使创建后也可以更改其值。 因此，可以在创建后向对象添加属性。'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象具有可变（可修改）的特性，即使创建后也可以更改其值。因此，可以在创建后向对象添加属性。'
- en: 添加属性的方法很简单，只需将值分配给要创建的属性名即可。 在这种情况下，如果对象中不存在指定的属性，则会自动创建该属性。
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 添加属性的方法很简单，只需将值分配给要创建的属性名即可。 在这种情况下，如果对象中不存在指定的属性，则会自动创建该属性。
- en: 可以使用点表示法或方括号表示法来添加属性。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用点表示法或方括号表示法来添加属性。
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 正如前面介绍的，点表示法只能使用作为变量标识符的属性名。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面介绍的，点表示法只能使用作为变量标识符的属性名。
- en: 另一方面，方括号表示法使用`object[expression]`中`expression`的评估结果作为属性名。 因此，当要将下面的内容作为属性名处理时，应使用方括号表示法。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，方括号表示法使用`object[expression]`中`expression`的评估结果作为属性名。 因此，当要将下面的内容作为属性名处理时，应使用方括号表示法。
- en: 变量
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: 无法作为变量标识符的字符串
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法作为变量标识符的字符串
- en: Symbol
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Symbol
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 使用方括号表示法定义属性也可以在对象字面量中使用。 在对象字面量中使用方括号表示法定义的属性名称为**Computed property names**。
    Computed property names 是从 ES2015 引入的语法，但其将`expression`的评估结果用作属性名与方括号表示法相同。
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号表示法定义属性也可以在对象字面量中使用。 在对象字面量中使用方括号表示法定义的属性名称为**Computed property names**。
    Computed property names 是从 ES2015 引入的语法，但其将`expression`的评估结果用作属性名与方括号表示法相同。
- en: 下面的代码使用 Computed property names，将`key`变量的评估结果`"key-string"`作为属性名。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用 Computed property names，将`key`变量的评估结果`"key-string"`作为属性名。
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 我们已经介绍了 JavaScript 对象在创建后是可变的特性。 因此，函数可以向其传递的对象自行添加属性。
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 JavaScript 对象在创建后是可变的特性。 因此，函数可以向其传递的对象自行添加属性。
- en: 下面的代码是一个不好的例子，它在`changeProperty`函数中向传入的对象添加属性。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是一个不好的例子，它在`changeProperty`函数中向传入的对象添加属性。
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 这样做会使对象的属性难以理解，因此最好尽量避免在创建后添加新属性。 我们建议在对象创建时使用对象字面量中定义属性。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会使对象的属性难以理解，因此最好尽量避免在创建后添加新属性。 我们建议在对象创建时使用对象字面量中定义属性。
- en: '[](#remove-property)*删除属性*'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[删除属性](#remove-property)'
- en: '*要删除对象的属性，可以使用`delete`运算符。 可以通过将要删除的属性指定为`delete`运算符的右侧来删除属性。'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*要删除对象的属性，可以使用`delete`运算符。 可以通过将要删除的属性指定为`delete`运算符的右侧来删除属性。'
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[](#const-and-object)*[专栏] 使用 const 定义的对象是可变的*'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 const 定义的对象是可变的](#const-and-object)*[专栏]*'
- en: '*在前面的代码示例中，可以看到使用`const`声明的对象的属性可以无错误地更改。 执行下面的代码后，可以看到对象的属性值已更改。'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前面的代码示例中，可以看到使用`const`声明的对象的属性可以无错误地更改。 执行下面的代码后，可以看到对象的属性值已更改。'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: JavaScript 的`const`并不是固定值，而是用于防止对变量的重新赋值。 因此，虽然可以防止对`obj`变量的重新赋值，但无法阻止对变量所指向的对象的更改（参考"变量和声明"中的
    const）。
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的`const`并不是固定值，而是用于防止对变量的重新赋值。 因此，虽然可以防止对`obj`变量的重新赋值，但无法阻止对变量所指向的对象的更改（参考"变量和声明"中的
    const）。
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 要防止更改创建的对象的属性，需要使用`Object.freeze`方法。 `Object.freeze`会冻结对象。 对冻结的对象进行属性添加或更改将导致抛出异常。
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止更改创建的对象的属性，需要使用`Object.freeze`方法。 `Object.freeze`会冻结对象。 对冻结的对象进行属性添加或更改将导致抛出异常。
- en: 但是，如果使用`Object.freeze`方法，则必须与 strict mode 一起使用（有关详细信息，请参阅"JavaScript 简介"中的 strict
    mode）。 在非 strict mode 下，即使对象被冻结，也不会抛出异常，而是简单地忽略对冻结对象的属性更改。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果使用`Object.freeze`方法，则必须与 strict mode 一起使用（有关详细信息，请参阅"JavaScript 简介"中的 strict
    mode）。 在非 strict mode 下，即使对象被冻结，也不会抛出异常，而是简单地忽略对冻结对象的属性更改。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[](#confirm-property)*确认属性是否存在*'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[确认属性是否存在](#confirm-property)'
- en: '*在 JavaScript 中，访问不存在的属性不会引发异常，而是返回`undefined`。 下面的代码尝试访问`obj`中不存在的`notFound`属性，因此返回`undefined`值。'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 JavaScript 中，访问不存在的属性不会引发异常，而是返回`undefined`。 下面的代码尝试访问`obj`中不存在的`notFound`属性，因此返回`undefined`值。'
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 在 JavaScript 中，访问不存在的属性不会引发异常。 由于属性名拼写错误，只会返回`undefined`值，这可能导致错误不易被发现。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，访问不存在的属性不会引发异常。 由于属性名拼写错误，只会返回`undefined`值，这可能导致错误不易被发现。
- en: 即使属性名拼写错误，也不会引发异常。 只有在尝试访问嵌套属性名时才会引发异常。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 即使属性名拼写错误，也不会引发异常。 只有在尝试访问嵌套属性名时才会引发异常。
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`undefined`和`null`不是对象，因此访问不存在的属性会导致异常。 有四种方法可以检查对象是否具有某个属性。'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`和`null`不是对象，因此访问不存在的属性会导致异常。 有四种方法可以检查对象是否具有某个属性。'
- en: '`undefined`与之比较'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`undefined`与之比较'
- en: '`in`演算子'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`演算子'
- en: '`Object.hasOwn`静���方法^([ES2022])'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.hasOwn`静态方法^([ES2022])'
- en: '`Object.prototype.hasOwnProperty`方法'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.prototype.hasOwnProperty`方法'
- en: '[](#compare-to-undefined)*检查属性是否存在：与 undefined 比较*'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[检查属性是否存在：与 undefined 比较](#compare-to-undefined)'
- en: '*访问不存在的属性会返回`undefined`，因此通过实际访问属性也可以进行判断。 下面的代码通过检查`key`属性的值是否不为`undefined`来判断属性是否存在。'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问不存在的属性会返回`undefined`，因此通过实际访问属性也可以进行判断。 下面的代码通过检查`key`属性的值是否不为`undefined`来判断属性是否存在。'
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 然而，这种方法存在一个问题，即当属性的值为`undefined`时，无法区分属性本身是否存在。 在下面的代码中，由于`key`属性的值为`undefined`，因此尽管属性存在，但
    if 语句块不会执行。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法存在一个问题，即当属性的值为`undefined`时，无法区分属性本身是否存在。 在下面的代码中，由于`key`属性的值为`undefined`，因此尽管属性存在，但
    if 语句块不会执行。
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 由于存在这样的问题，要判断属性是否存在，可以使用`in`运算符或`Object.hasOwn`静态方法。
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在这样的问题，要判断属性是否存在，可以使用`in`运算符或`Object.hasOwn`静态方法。
- en: '[](#in-operator)*检查属性是否存在：使用 in 运算符*'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[检查属性是否存在：使用 in 运算符](#in-operator)'
- en: '*`in`运算符用于判断指定对象上是否存在指定属性，并返回布尔值。'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*`in`运算符用于判断指定对象上是否存在指定属性，并返回布尔值。'
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 下面的代码检查`obj`是否具有`key`属性。 `in`运算符只关注属性的存在与否，而不关心属性的值。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码检查`obj`是否具有`key`属性。 `in`运算符只关注属性的存在与否，而不关心属性的值。
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[](#object-hasown-method)*[ES2022] 检查属性是否存在：`Object.hasOwn`静态方法*'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[检查属性是否存在：`Object.hasOwn`静态方法](#object-hasown-method)*[ES2022]*'
- en: '*`Object.hasOwn`静态方法可以确定目标对象是否具有指定的属性。 将要检查的属性名称作为`Object.hasOwn`静态方法的参数传递给它。'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Object.hasOwn`静态方法可以确定目标对象是否具有指定的属性。 将要检查的属性名称作为`Object.hasOwn`静态方法的参数传递给它。'
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 下面的代码判断了`obj`是否具有`key`属性。 `Object.hasOwn`静态方法也是如此，无论属性的值如何，只要对象具有指定的属性，它就会返回`true`。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码判断了`obj`是否具有`key`属性。 `Object.hasOwn`静态方法也是如此，无论属性的值如何，只要对象具有指定的属性，它就会返回`true`。
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`in`操作符和`Object.hasOwn`静态方法返回相同的结果，但在严格意义上它们的行为有时会有所不同。 要了解这种行为上的差异，首先需要理解特殊对象——原型对象。
    因此，关于`in`操作符和`Object.hasOwn`静态方法的区别，将在下一章的“原型对象”中详细解释。'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`操作符和`Object.hasOwn`静态方法返回相同的结果，但在严格意义上它们的行为有时会有所不同。 要了解这种行为上的差异，首先需要理解特殊对象——原型对象。
    因此，关于`in`操作符和`Object.hasOwn`静态方法的区别，将在下一章的“原型对象”中详细解释。'
- en: '[](#hasOwnProperty-method)*检查属性是否存在：`Object.prototype.hasOwnProperty`方法*'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[检查属性是否存在：`Object.prototype.hasOwnProperty`方法](#hasOwnProperty-method)'
- en: '*`Object.hasOwn`静态方法是在 ES2022 中引入的。 在 ES2022 之前，通常使用类似的方法`Object.prototype.hasOwnProperty`。
    `hasOwnProperty`方法与`Object.hasOwn`静态方法非常相似，但它们在调用它们的对象实例方面有所不同。'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Object.hasOwn`静态方法是在 ES2022 中引入的。 在 ES2022 之前，通常使用类似的方法`Object.prototype.hasOwnProperty`。
    `hasOwnProperty`方法与`Object.hasOwn`静态方法非常相似，但它们在调用它们的对象实例方面有所不同。'
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 但是，由于`hasOwnProperty`方法存在缺陷，因此在可以使用`Object.hasOwn`静态方法的情况下，没有理由使用它。 由于这个缺陷也与原型对象有关，所以将在下一章的“原型对象”中详细解释。
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，由于`hasOwnProperty`方法存在缺陷，因此在可以使用`Object.hasOwn`静态方法的情况下，没有理由使用它。 由于这个缺陷也与原型对象有关，所以将在下一章的“原型对象”中详细解释。
- en: '[](#optional-chaining-operator)*[ES2020] 可选链操作符（`?.`）*'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[可选链操作符（`?.`）](#optional-chaining-operator)*[ES2020]*'
- en: '*介绍了 4 种检查属性是否存在的方法。 如果属性的存在很重要，通常会使用`in`操作符或`Object.hasOwn`静态方法。*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*介绍了 4 种检查属性是否存在的方法。 如果属性的存在很重要，通常会使用`in`操作符或`Object.hasOwn`静态方法。*'
- en: 但是，如果最终想要获取的是属性的值，则使用 if 语句与`undefined`进行比较也没有问题。 因为当需要获取值时，区分属性是否存在以及属性的值是否为`undefined`并没有意义。
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果最终想要获取的是属性的值，则使用 if 语句与`undefined`进行比较也没有问题。 因为当需要获取值时，区分属性是否存在以及属性的值是否为`undefined`并没有意义。
- en: 下面的代码如果定义了`widget.window.title`属性的值（不是`undefined`），则将该属性的值显示在控制台上。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码如果定义了`widget.window.title`属性的值（不是`undefined`），则将该属性的值显示在控制台上。
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 在访问嵌套属性（如`widget.window.title`）时，必须逐个检查属性的存在。 这是因为如果`widget`对象不具有`window`属性，则会返回`undefined`。
    在这种情况下，如果进一步访问嵌套的`widget.window.title`属性，则会导致引用`undefined.title`，从而导致异常。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问嵌套属性（如`widget.window.title`）时，必须逐个检查属性的存在。 这是因为如果`widget`对象不具有`window`属性，则会返回`undefined`。
    在这种情况下，如果进一步访问嵌套的`widget.window.title`属性，则会导致引用`undefined.title`，从而导致异常。
- en: 然而，每次访问属性时都用 AND 操作符（`&&`）与`undefined`进行比较会显得冗长。
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次访问属性时都用 AND 操作符（`&&`）与`undefined`进行比较会显得冗长。
- en: 为了解决这个问题，在 ES2020 中引入了一个新的语法，即可选链操作符（`?.`）。 可选链操作符（`?.`）与点表示法（`.`）类似，用于访问属性。
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在 ES2020 中引入了一个新的语法，即可选链操作符（`?.`）。 可选链操作符（`?.`）与点表示法（`.`）类似，用于访问属性。
- en: 可选链操作符（`?.`）在左操作数为 nullish（`null`或`undefined`）时不会继续评估并返回`undefined`。 反之，如果属性存在，则返回该属性的值。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链操作符（`?.`）在左操作数为 nullish（`null`或`undefined`）时不会继续评估并返回`undefined`。 反之，如果属性存在，则返回该属性的值。
- en: 换句话说，可选链操作符（`?.`）在访问不存在的属性时不会引发异常，而是返回`undefined`。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，可选链操作符（`?.`）在访问不存在的属性时不会引发异常，而是返回`undefined`。
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 当使用 Optional chaining 操作符（`?.`）时，甚至不需要使用 if 语句就可以编写一个函数来显示上述小部件的标题。 在下面的`printWidgetTitle`函数中，如果可以访问`widget?.window?.title`，那么它的评估结果将被赋给变量`title`。
    如果无法访问属性，则返回`undefined`，因此通过 Nullish coalescing 操作符(`??`)，右侧的`"未定义"`将成为变量`title`的默认值。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Optional chaining 操作符（`?.`）时，甚至不需要使用 if 语句就可以编写一个函数来显示上述小部件的标题。 在下面的`printWidgetTitle`函数中，如果可以访问`widget?.window?.title`，那么它的评估结果将被赋给变量`title`。
    如果无法访问属性，则返回`undefined`，因此通过 Nullish coalescing 操作符(`??`)，右侧的`"未定义"`将成为变量`title`的默认值。
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 此外，可选链操作符（`?.`）也可以与方括号表示法（`[]`）结合使用。 在方括号表示法中，如果左操作数为 nullish（`null`或`undefined`），则不会继续评估并返回`undefined`。
    反之，如果属性存在，则返回该属性的值。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可选链操作符（`?.`）也可以与方括号表示法（`[]`）结合使用。 在方括号表示法中，如果左操作数为 nullish（`null`或`undefined`），则不会继续评估并返回`undefined`。
    反之，如果属性存在，则返回该属性的值。
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[](#toString-method)*`toString`方法*'
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#toString-method)*`toString`方法*'
- en: '*对象的`toString`方法是一种将对象本身转换为字符串的方法。 也可以使用`String`构造函数来执行此操作。 那么这两者有什么区别呢？（关于`String`构造函数，请参阅“隐式强制类型转换”）*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象的`toString`方法是一种将对象本身转换为字符串的方法。 也可以使用`String`构造函数来执行此操作。 那么这两者有什么区别呢？（关于`String`构造函数，请参阅“隐式强制类型转换”）*'
- en: 实际上`String`构造函数会调用传递给它的对象的`toString`方法。因此，`String`构造函数和`toString`方法的结果都是相同的。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上`String`构造函数会调用传递给它的对象的`toString`方法。因此，`String`构造函数和`toString`方法的结果都是相同的。
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 这一点可以通过重新定义对象的`toString`方法来理解。 试着将自定义的`toString`方法定义为对象，然后尝试使用`String`构造函数将其转换为字符串。
    结果会发现，重新定义的`toString`方法的返回值将成为`String`构造函数的返回值。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点可以通过重新定义对象的`toString`方法来理解。 试着将自定义的`toString`方法定义为对象，然后尝试使用`String`构造函数将其转换为字符串。
    结果会发现，重新定义的`toString`方法的返回值将成为`String`构造函数的返回值。
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[](#object-property-is-to-string)*[专栏] 对象属性名会被转换为字符串*'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#object-property-is-to-string)*[专栏] 对象属性名会被转换为字符串*'
- en: '*在访问对象的属性时，指定的属性名会被隐式转换为字符串。 使用方括号表示法时，可以将对象作为属性名指定，但这并不会按预期工作。 这是因为将对象转换为字符串会得到`"[object
    Object]"`这样的字符串。'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*在访问对象的属性时，指定的属性名会被隐式转换为字符串。 使用方括号表示法时，可以将对象作为属性名指定，但这并不会按预期工作。 这是因为将对象转换为字符串会得到`"[object
    Object]"`这样的字符串。'
- en: 下面的代码中，使用方括号表示法指定了`keyObject1`和`keyObject2`作为属性名。 但是，`keyObject1`和`keyObject2`都会被转换为相同的`"[object
    Object]"`字符串，导致属性被意外覆盖。
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码中，使用方括号表示法指定了`keyObject1`和`keyObject2`作为属性名。 但是，`keyObject1`和`keyObject2`都会被转换为相同的`"[object
    Object]"`字符串，导致属性被意外覆盖。
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 作为唯一的例外，Symbol 不会被转换为字符串，可以作为对象的属性名。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 作为唯一的例外，Symbol 不会被转换为字符串，可以作为对象的属性名。
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 通常，应该记住对象的属性名被视为字符串。 此外，内置对象`Map`可以将对象用作键（详细信息请参阅“Map/Set”章节）。 因此，如果要将对象用作键，则应使用`Map`。
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应该记住对象的属性名被视为字符串。 此外，内置对象`Map`可以将对象用作键（详细信息请参阅“Map/Set”章节）。 因此，如果要将对象用作键，则应使用`Map`。
- en: '[](#static-method)*对象的静态方法*'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#static-method)*对象的静态方法*'
- en: '*最后，让我们看一下作为内置对象的`Object`的静态方法。 **静态方法**是可以从实例对象的基础对象调用的方法。'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后，让我们看一下作为内置对象的`Object`的静态方法。 **静态方法**是可以从实例对象的基础对象调用的方法。'
- en: '`Object`的`toString`方法等是从`Object`的实例对象调用的方法。 相反，像`Object.hasOwn`这样的静态方法是`Object`本身实现的方法。'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object`的`toString`方法等是从`Object`的实例对象调用的方法。 相反，像`Object.hasOwn`这样的静态方法是`Object`本身实现的方法。'
- en: 这里介绍了一些在对象处理中常用的**静态方法**。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了一些在对象处理中常用的**静态方法**。
- en: '[](#enumeration)*对象的枚举*'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#enumeration)*对象的枚举*'
- en: '*正如之前提到的，对象是属性的集合。 有三种静态方法可用于枚举对象的属性。'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如之前提到的，对象是属性的集合。 有三种静态方法可用于枚举对象的属性。'
- en: '`Object.keys`方法：返回一个由对象的属性名组成的数组'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.keys`方法：返回一个由对象的属性名组成的数组'
- en: '`Object.values`方法^([ES2017])：返回对象值的数组'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.values`方法^([ES2017])：返回对象值的数组'
- en: '`Object.entries`方法^([ES2017])：返回对象属性名和值的数组的数组'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.entries`方法^([ES2017])：返回对象属性名和值的数组的数组'
- en: 分别返回对象的键、值和键值对的数组。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 分别返回对象的键、值和键值对的数组。
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 结合这些列举属性的静态方法和数组的`forEach`方法，可以对属性进行迭代处理。 下面的代码使用`Object.keys`方法获取属性名列表并将其输出到控制台。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些列举属性的静态方法和数组的`forEach`方法，可以对属性进行迭代处理。 下面的代码使用`Object.keys`方法获取属性名列表并将其输出到控制台。
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[](#copy-and-merge)*对象的合并和复制*'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[](#copy-and-merge)*对象的合并和复制*'
- en: '*`Object.assign`方法^([ES2015])可以将一个对象分配给另一个对象。 使用此方法可以复制对象或合并对象。'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*`Object.assign`方法^([ES2015])可以将一个对象分配给另一个对象。 使用此方法可以复制对象或合并对象。'
- en: '`Object.assign`方法用于将一个或多个`sources`对象的可枚举属性复制到`target`对象中。 返回值是`target`对象。'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`方法用于将一个或多个`sources`对象的可枚举属性复制到`target`对象中。 返回值是`target`对象。'
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[](#merge)*对象的合并*'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#merge)*对象的合并*'
- en: '*让我们看一些具体的对象合并示例。'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们看一些具体的对象合并示例。'
- en: 下面的代码将创建一个新的空对象作为`target`。 这个空对象（`target`）将合并`objectA`和`objectB`，成为`Object.assign`方法的返回值。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将创建一个新的空对象作为`target`。 这个空对象（`target`）将合并`objectA`和`objectB`，成为`Object.assign`方法的返回值。
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 第一���参数可以是现有对象，而不仅仅是空对象。 如果指定现有对象作为第一个参数，则该对象的属性将被修改。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一���参数可以是现有对象，而不仅仅是空对象。 如果指定现有对象作为第一个参数，则该对象的属性将被修改。
- en: 下面的代码向指定的`objectA`添加属性。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码向指定的`objectA`添加属性。
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 通过将空对象作为`target`，可以创建一个合并了对象而不影响现有对象的新对象。 因此，通常将空对象字面量作为`Object.assign`方法的第一个参数是典型用法。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将空对象作为`target`，可以创建一个合并了对象而不影响现有对象的新对象。 因此，通常将空对象字面量作为`Object.assign`方法的第一个参数是典型用法。
- en: 当属性名重复时，后一个对象的属性将覆盖前一个对象的属性。 在 JavaScript 中，通常是按顺序从前到后处理。 因此，可以将`objectA`分配给空对象，然后将`objectB`分配给结果。
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性名重复时，后一个对象的属性将覆盖前一个对象的属性。 在 JavaScript 中，通常是按顺序从前到后处理。 因此，可以将`objectA`分配给空对象，然后将`objectB`分配给结果。
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[](#object-spread-syntax)*[ES2018] 对象的 spread 構文合并*'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#object-spread-syntax)*[ES2018] 对象的 spread 構文合并*'
- en: '*在 ES2018 中，引入了对象的合并操作符`...`（spread 構文）。 在 ES2015 中，数组元素的展开操作符`...`（spread
    構文）已经被支持，而在 ES2018 中也支持了对象。 对象的 spread 構文可以展开指定对象的属性到对象字面量中。'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 ES2018 中，引入了对象的合并操作符`...`（spread 構文）。 在 ES2015 中，数组元素的展开操作符`...`（spread
    構文）已经被支持，而在 ES2018 中也支持了对象。 对象的 spread 構文可以展开指定对象的属性到对象字面量中。'
- en: 对象的 spread 構文会创建一个新对象，与`Object.assign`不同。 这是因为 spread 構文只能在对象字面量中使用，而对象字面量会创建新对象。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的 spread 構文会创建一个新对象，与`Object.assign`不同。 这是因为 spread 構文只能在对象字面量中使用，而对象字面量会创建新对象。
- en: 下面的代码将返回合并了`objectA`和`objectB`的新对象。
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码将返回合并了`objectA`和`objectB`的新对象。
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 当属性名冲突时，后一个对象将优先。 因此，当合并具有相同属性名的对象时，后一个对象将覆盖属性。
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性名冲突时，后一个对象将优先。 因此，当合并具有相同属性名的对象时，后一个对象将覆盖属性。
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[](#copy)*对象的复制*'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[](#copy)*对象的复制*'
- en: '*JavaScript 中没有提供复制对象的函数。 但是，通过创建一个新的空对象，并将现有对象的属性复制到其中，可以实现对象的复制。 使用`Object.assign`方法可以复制对象。'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript 中没有提供复制对象的函数。 但是，通过创建一个新的空对象，并将现有对象的属性复制到其中，可以实现对象的复制。 使用`Object.assign`方法可以复制对象。'
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 需要注意的是，`Object.assign`方法只会进行浅拷贝（shallow copy）操作，即只会拷贝`sources`对象直接的属性。浅拷贝意味着不会递归地复制嵌套对象的属性。如果属性的值是一个对象，它不会复制嵌套的对象。
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`Object.assign`方法只会进行浅拷贝（shallow copy）操作，即只会拷贝`sources`对象直接的属性。浅拷贝意味着不会递归地复制嵌套对象的属性。如果属性的值是一个对象，它不会复制嵌套的对象。
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 相反，如果要递归地复制属性值，即进行深拷贝（deep copy），可以通过递归调用浅拷贝来实现。下面的代码示例展示了如何使用`shallowClone`来实现`deepClone`。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果要递归地复制属性值，即进行深拷贝（deep copy），可以通过递归调用浅拷贝来实现。下面的代码示例展示了如何使用`shallowClone`来实现`deepClone`。
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 因此，JavaScript 的内置方法通常只提供浅实现，并且很少提供深实现。这是因为 JavaScript 作为一种语言只提供了最基本的功能，更复杂的功能需要用户自己实现。
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JavaScript 的内置方法通常只提供浅实现，并且很少提供深实现。这是因为 JavaScript 作为一种语言只提供了最基本的功能，更复杂的功能需要用户自己实现。
- en: JavaScript 作为语言规范最低限度地定义了功能，因此有很多由用户创建的小型功能库来补充它。这些库通过名为 npm 的 JavaScript 包管理工具进行发布，构建了
    JavaScript 生态系统。有关使用库的信息，请参阅“用例：在 Node.js 中创建 CLI 应用程序”章节。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 作为语言规范最低限度地定义了功能，因此有很多由用户创建的小型功能库来补充它。这些库通过名为 npm 的 JavaScript 包管理工具进行发布，构建了
    JavaScript 生态系统。有关使用库的信息，请参阅“用例：在 Node.js 中创建 CLI 应用程序”章节。
- en: '[](#conclusion)*まとめ*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#conclusion)*总结*'
- en: '*本章介绍了对象。*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章介绍了对象。*'
- en: 存在名为`Object`的内置对象。
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在名为`Object`的内置对象。
- en: 使用`{}`（对象字面量）来创建和更新对象的方法。
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`{}`（对象字面量）来创建和更新对象的方法。
- en: 要确认属性是否存在，可以使用`in`操作符或`Object.hasOwn`静态方法。
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确认属性是否存在，可以使用`in`操作符或`Object.hasOwn`静态方法。
- en: 可选链操作符（`?.`）允许同时检查嵌套属性的存在并访问它们。
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选链操作符（`?.`）允许同时检查嵌套属性的存在并访问它们。
- en: 对象的实例方法和静态方法。
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的实例方法和静态方法。
- en: JavaScript 的`Object`是其他对象的基础对象。接下来的"prototype-object"章节将探讨`Object`作为基础对象的运作方式。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的`Object`是其他对象的基础对象。接下来的"原型对象"章节将探讨`Object`作为基础对象的运作方式。
