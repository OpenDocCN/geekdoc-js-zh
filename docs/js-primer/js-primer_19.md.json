["```\nconst obj = {};\nconsole.log(obj.toString()); // \"[object Object]\" \n```", "```\n// `Object.prototype`オブジェクトに`toString`メソッドの定義がある\nconsole.log(typeof Object.prototype.toString); // => \"function\" \n```", "```\nconst obj = {\n    \"key\": \"value\"\n};\n// `obj`インスタンスは`Object.prototype`に定義されたものを継承する\n// `obj.toString`は継承した`Object.prototype.toString`を参照している\nconsole.log(obj.toString === Object.prototype.toString); // => true\n// インスタンスからプロトタイプメソッドを呼び出せる\nconsole.log(obj.toString()); // => \"[object Object]\" \n```", "```\n// オブジェクトのインスタンスにtoStringメソッドを定義\nconst customObject = {\n    toString() {\n        return \"custom value\";\n    }\n};\nconsole.log(customObject.toString()); // => \"custom value\" \n```", "```\nconst obj = {};\n// `obj`というオブジェクト自体に`toString`メソッドが定義されているわけではない\nconsole.log(Object.hasOwn(obj, \"toString\")); // => false\n// `in`演算子は指定されたプロパティ名が見つかるまで親をたどるため、`Object.prototype`まで見にいく\nconsole.log(\"toString\" in obj); // => true \n```", "```\n// オブジェクトのインスタンスにtoStringメソッドを定義\nconst obj = {\n    toString() {\n        return \"custom value\";\n    }\n};\n// オブジェクトのインスタンスが`toString`メソッドを持っている\nconsole.log(Object.hasOwn(obj, \"toString\")); // => true\nconsole.log(\"toString\" in obj); // => true \n```", "```\n// const obj = {} と同じ意味\nconst obj = Object.create(Object.prototype);\n// `obj`は`Object.prototype`を継承している\n// そのため、`obj.toString`と`Object.prototype.toString`は同じとなる\nconsole.log(obj.toString === Object.prototype.toString); // => true \n```", "```\n// このコードはイメージです！\n// `Array`コンストラクタ自身は関数でもある\nconst Array = function() {};\n// `Array.prototype`は`Object.prototype`を継承している\nArray.prototype = Object.create(Object.prototype);\n// `Array`のインスタンスは、`Array.prototype`を継承している\nconst array = Object.create(Array.prototype);\n// `array`は`Object.prototype`を継承している\nconsole.log(array.hasOwnProperty === Object.prototype.hasOwnProperty); // => true \n```", "```\nconst array = [];\n// `Array`のインスタンス -> `Array.prototype` -> `Object.prototype`\nconsole.log(array.hasOwnProperty === Object.prototype.hasOwnProperty); // => true \n```", "```\nconst numbers = [1, 2, 3];\n// `Array.prototype.toString`が定義されているため、`Object.prototype.toString`とは異なる出力形式となる\nconsole.log(numbers.toString()); // => \"1,2,3\" \n```", "```\n// 親がnull、つまり親がいないオブジェクトを作る\nconst obj = Object.create(null);\n// Object.prototypeを継承しないため、hasOwnPropertyが存在しない\nconsole.log(obj.hasOwnProperty); // => undefined \n```", "```\n// 空オブジェクトを作成\nconst obj = {};\n// \"toString\"という値を定義してないのに、\"toString\"が存在している\nconsole.log(obj[\"toString\"]);// Function\n// Mapのような空オブジェクト\nconst mapLike = Object.create(null);\n// toStringキーは存在しない\nconsole.log(mapLike[\"toString\"]); // => undefined \n```", "```\n// Mapのような空オブジェクト\nconst mapLike = Object.create(null);\n// `Object.prototype`を継承していないため呼び出すと例外が発生する\nconsole.log(mapLike.hasOwnProperty(\"key\")); // => Error: hasOwnPropertyメソッドは呼び出せない \n```", "```\n// Mapのような空オブジェクト\nconst mapLike = Object.create(null);\n// keyは存在しない\nconsole.log(Object.hasOwn(mapLike, \"key\")); // => false \n```"]