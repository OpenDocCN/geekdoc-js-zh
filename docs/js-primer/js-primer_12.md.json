["```\n1 + 2; \n```", "```\n// 二項演算子とオペランドの関係\n左オペランド 演算子 右オペランド \n```", "```\nlet num = 1;\nnum++;\n// または\n++num; \n```", "```\nconsole.log(1 + 1); // => 2 \n```", "```\nconsole.log(10 + 0.5); // => 10.5 \n```", "```\nconst value = \"文字列\" + \"結合\";\nconsole.log(value); // => \"文字列結合\" \n```", "```\nconsole.log(1 - 1); // => 0\nconsole.log(10 - 0.5); // => 9.5 \n```", "```\nconsole.log(2 * 8); // => 16\nconsole.log(10 * 0.5); // => 5 \n```", "```\nconsole.log(8 / 2); // => 4\nconsole.log(10 / 0.5); // => 20 \n```", "```\nconsole.log(10 / 0); // => Infinity \n```", "```\nconsole.log(8 % 2); // => 0\nconsole.log(9 % 2); // => 1\nconsole.log(10 % 0.5); // => 0\nconsole.log(10 % 4.5); // => 1 \n```", "```\n// べき乗演算子（ES2016）で2の4 乗を計算\nconsole.log(2 ** 4); // => 16 \n```", "```\nconsole.log(Math.pow(2, 4)); // => 16 \n```", "```\nconsole.log(+1); // => 1 \n```", "```\nconsole.log(+\"1\"); // => 1 \n```", "```\n// 数値ではない文字列はNaNという値に変換される\nconsole.log(+\"文字列\"); // => NaN \n```", "```\n// 自分自身とも一致しない\nconsole.log(NaN === NaN); // => false\n// Number 型である\nconsole.log(typeof NaN); // => \"number\"\n// Number.isNaNでNaNかどうかを判定\nconsole.log(Number.isNaN(NaN)); // => true \n```", "```\nconsole.log(-1); // => -1 \n```", "```\nconsole.log(-(-1)); // => 1 \n```", "```\nconsole.log(-\"1\"); // => -1 \n```", "```\nconsole.log(-\"文字列\"); // => NaN \n```", "```\nlet num = 1;\nnum++;\nconsole.log(num); // => 2\n// 次のようにした場合と結果は同じ\n// num = num + 1; \n```", "```\nlet x = 1;\nconsole.log(x++); // => 1\nconsole.log(x);   // => 2 \n```", "```\nlet x = 1;\nconsole.log(++x); // => 2\nconsole.log(x);   // => 2 \n```", "```\nlet num = 1;\nnum--;\nconsole.log(num); // => 0\n// 次のようにした場合と結果は同じ\n// num = num - 1; \n```", "```\n// 後置デクリメント演算子\nlet x = 1;\nconsole.log(x--); // => 1\nconsole.log(x);   // => 0\n// 前置デクリメント演算子\nlet y = 1;\nconsole.log(--y); // => 0\nconsole.log(y);   // => 0 \n```", "```\nconsole.log(1 === 1); // => true\nconsole.log(1 === \"1\"); // => false \n```", "```\n// {} は新しいオブジェクトを作成している\nconst objA = {};\nconst objB = {};\n// 生成されたオブジェクトは異なる参照となる\nconsole.log(objA === objB); // => false\n// 同じ参照を比較している場合\nconsole.log(objA === objA); // => true \n```", "```\nconsole.log(1 !== 1); // => false\nconsole.log(1 !== \"1\"); // => true \n```", "```\nconsole.log(1 == 1); // => true\nconsole.log(\"str\" == \"str\"); // => true\nconsole.log(\"JavaScript\" == \"ECMAScript\"); // => false\n// オブジェクトは参照が一致しているならtrueを返す\n// {} は新しいオブジェクトを作成している\nconst objA = {};\nconst objB = {};\nconsole.log(objA == objB); // => false\nconsole.log(objA == objA); // => true \n```", "```\n// 文字列を数値に変換してから比較\nconsole.log(1 == \"1\"); // => true\n// \"01\"を数値にすると`1`となる\nconsole.log(1 == \"01\"); // => true\n// 真偽値を数値に変換してから比較\nconsole.log(0 == false); // => true\n// nullの比較はfalseを返す\nconsole.log(0 == null); // => false\n// nullとundefinedの比較は常にtrueを返す\nconsole.log(null == undefined); // => true \n```", "```\nconst value = undefined; /* または null */\n// === では2つの値と比較しないといけない\nif (value === null || value === undefined) {\n    console.log(\"valueがnullまたはundefinedである場合の処理\");\n}\n// == では null と比較するだけでよい\nif (value == null) {\n    console.log(\"valueがnullまたはundefinedである場合の処理\");\n} \n```", "```\nconsole.log(1 != 1); // => false\nconsole.log(\"str\" != \"str\"); // => false\nconsole.log(\"JavaScript\" != \"ECMAScript\"); // => true\nconsole.log(true != true);// => false\n// オブジェクトは参照が一致していないならtrueを返す\nconst objA = {};\nconst objB = {};\nconsole.log(objA != objB); // => true\nconsole.log(objA != objA); // => false \n```", "```\nconsole.log(1 != \"1\"); // => false\nconsole.log(0 != false); // => false\nconsole.log(0 != null); // => true\nconsole.log(null != undefined); // => false \n```", "```\nconsole.log(42 > 21); // => true\nconsole.log(42 > 42); // => false \n```", "```\nconsole.log(42 >= 21); // => true\nconsole.log(42 >= 42); // => true\nconsole.log(42 >= 43); // => false \n```", "```\nconsole.log(21 < 42); // => true\nconsole.log(42 < 42); // => false \n```", "```\nconsole.log(21 <= 42); // => true\nconsole.log(42 <= 42); // => true\nconsole.log(43 <= 42); // => false \n```", "```\nconsole.log(15     & 9);      // => 9\n// 同じ位の各ビット同士をAND 演算する（上位の`0`は省略）\n// 1111\n// 1001\n// ----\n// 1001\nconsole.log(0b1111 & 0b1001); // => 0b1001 \n```", "```\nconsole.log(15     | 9);      // => 15\n// 同じ位の各ビット同士をOR 演算する（上位の`0`は省略）\n// 1111\n// 1001\n// ----\n// 1111\nconsole.log(0b1111 | 0b1001); // => 0b1111 \n```", "```\nconsole.log(15     ^ 9);      // => 6\n// 同じ位の各ビット同士をXOR 演算する（上位の`0`は省略）\n// 1111\n// 1001\n// ----\n// 0110\nconsole.log(0b1111 ^ 0b1001); // => 0b0110 \n```", "```\nconsole.log(~15); // => -16 \n```", "```\nconst str = \"森森本森森\";\n// 見つかった場合はインデックスを返す\n// JavaScriptのインデックスは0から開始するので2を返す\nconsole.log(str.indexOf(\"本\")); // => 2\n// 見つからない場合は-1を返す\nconsole.log(str.indexOf(\"火\")); // => -1 \n```", "```\nconsole.log(~0); // => -1\nconsole.log(~(-1)); // => 0 \n```", "```\nconst str = \"森森木森森\";\n// indexOfメソッドは見つからなかった場合は -1 を返す\nif (str.indexOf(\"木\") !== -1) {\n    console.log(\"木を見つけました\");\n}\n// 否定演算子（`~`）で同じ動作を実装\n// (~(-1)) は 0 となるため、見つからなかった場合はif 文の中身は実行されない\nif (~str.indexOf(\"木\")) {\n    console.log(\"木を見つけました\");\n} \n```", "```\nconst str = \"森森木森森\";\nif (str.includes(\"木\")) {\n    console.log(\"木を見つけました\");\n} \n```", "```\nnum << bit; \n```", "```\nconsole.log(     9 << 2); // => 36\nconsole.log(0b1001 << 2); // => 0b10_0100 \n```", "```\nnum >> bit; \n```", "```\nconsole.log((-9) >> 2); // => -3\n//    1111_1111_1111_1111_1111_1111_1111_0111 >> 2\n// => 1111_1111_1111_1111_1111_1111_1111_1101 \n```", "```\nconsole.log((-9) >>> 2); // => 1073741821\n//    1111_1111_1111_1111_1111_1111_1111_0111 >>> 2\n// => 0011_1111_1111_1111_1111_1111_1111_1101 \n```", "```\nlet x = 1;\nx = 42;\nconsole.log(x); // => 42 \n```", "```\nlet num = 1;\nnum += 10; // num = num + 10; と同じ\nconsole.log(num); // => 11 \n```", "```\nconst array = [1, 2];\n// aには`array`の0 番目の値、bには1 番目の値が代入される\nconst [a, b] = array;\nconsole.log(a); // => 1\nconsole.log(b); // => 2 \n```", "```\nconst array = [1, 2];\nconst a = array[0];\nconst b = array[1]; \n```", "```\nconst obj = {\n    \"key\": \"value\"\n};\n// プロパティ名`key`の値を、変数`key`として定義する\nconst { key } = obj;\nconsole.log(key); // => \"value\" \n```", "```\nconst obj = {\n    \"key\": \"value\"\n};\nconst key = obj.key; \n```", "```\n// 左辺はtrueであるため、右辺の評価結果を返す\nconsole.log(true && \"右辺の値\"); // => \"右辺の値\"\n// 左辺がfalseであるなら、その時点でfalseを返す\n// 右辺は評価されない\nconsole.log(false && \"右辺の値\"); // => false \n```", "```\n// 左辺がtrueなので、右辺は評価される\ntrue && console.log(\"このコンソールログは実行されます\");\n// 左辺がfalseなので、右辺は評価されない\nfalse && console.log(\"このコンソールログは実行されません\"); \n```", "```\n// 左辺はfalsyではないため、評価結果として右辺を返す\nconsole.log(\"文字列\" && \"右辺の値\"); // => \"右辺の値\"\nconsole.log(42 && \"右辺の値\"); // => \"右辺の値\"\n// 左辺がfalsyであるため、評価結果として左辺を返す\nconsole.log(\"\" && \"右辺の値\"); // => \"\"\nconsole.log(0 && \"右辺の値\"); // => 0\nconsole.log(null && \"右辺の値\"); // => null \n```", "```\nconst value = \"str\";\nif (typeof value === \"string\" && value === \"str\") {\n    console.log(`${value} is string value`);\n}\n// if 文のネストで書いた場合と結果は同じとなる\nif (typeof value === \"string\") {\n    if (value === \"str\") {\n        console.log(`${value} is string value`);\n    }\n} \n```", "```\n// 左辺がtrueなので、左辺の値が返される\nconsole.log(true || \"右辺の値\"); // => true\n// 左辺がfalseなので、右辺の値が返される\nconsole.log(false || \"右辺の値\"); // => \"右辺の値\" \n```", "```\n// 左辺がtrueなので、右辺は評価されない\ntrue || console.log(\"このコンソールログは実行されません\");\n// 左辺がfalseなので、右辺は評価される\nfalse || console.log(\"このコンソールログは実行されます\"); \n```", "```\n// 左辺がfalsyなので、右辺の値が返される\nconsole.log(0 || \"左辺はfalsy\"); // => \"左辺はfalsy\"\nconsole.log(\"\" || \"左辺はfalsy\"); // => \"左辺はfalsy\"\nconsole.log(null || \"左辺はfalsy\"); // => \"左辺はfalsy\"\n// 左辺はfalsyではないため、左辺の値が返される\nconsole.log(42 || \"右辺の値\"); // => 42\nconsole.log(\"文字列\" || \"右辺の値\"); // => \"文字列\" \n```", "```\nconst value = 1;\nif (value === 0 || value === 1) {\n    console.log(\"valueは0または1です。\");\n} \n```", "```\nconsole.log(!false); // => true\nconsole.log(!true);  // => false \n```", "```\n// falsyな値は`true`となる\nconsole.log(!0); // => true\nconsole.log(!\"\"); // => true\nconsole.log(!null); // => true\n// falsyではない値は`false`となる\nconsole.log(!42);  // => false\nconsole.log(!\"文字列\");  // => false \n```", "```\nconst str = \"\";\n// 空文字列はfalsyであるため、true -> falseへと変換される\nconsole.log(!!str); // => false \n```", "```\nconst str = \"\";\n// 空文字列(長さが0より大きな文字列)でないことを判定\nconsole.log(str.length > 0); // => false \n```", "```\n// 左辺がnullishであるため、右辺の値の評価結果を返す\nconsole.log(null ?? \"右辺の値\"); // => \"右辺の値\"\nconsole.log(undefined ?? \"右辺の値\"); // => \"右辺の値\"\n// 左辺がnullishではないため、左辺の値の評価結果を返す\nconsole.log(true ?? \"右辺の値\"); // => true\nconsole.log(false ?? \"右辺の値\"); // => false\nconsole.log(0 ?? \"右辺の値\"); // => 0\nconsole.log(\"文字列\" ?? \"右辺の値\"); // => \"文字列\" \n```", "```\nconst inputValue = 任意の値または未定義;\n// `inputValue`がfalsyの場合は、`value`には`42`が入る\n// `inputValue`が`0`の場合は、`value`に`42`が入ってしまう\nconst value = inputValue || 42;\nconsole.log(value); \n```", "```\nconst inputValue = 任意の値または未定義;\n// `inputValue`がnullishの場合は、`value`には42が入る\n// `inputValue`が`0`の場合は、`value`に`0`が入る\nconst value = inputValue ?? 42;\nconsole.log(value); \n```", "```\n条件式 ? Trueのとき処理する式 : Falseのとき処理する式; \n```", "```\nconst valueA = true ? \"A\" : \"B\";\nconsole.log(valueA); // => \"A\"\nconst valueB = false ? \"A\" : \"B\";\nconsole.log(valueB); // => \"B\" \n```", "```\nfunction addPrefix(text, prefix) {\n    // `prefix`が指定されていない場合は\"デフォルト:\"を付ける\n    const pre = typeof prefix === \"string\" ? prefix : \"デフォルト:\";\n    return pre + text;\n}\n\nconsole.log(addPrefix(\"文字列\")); // => \"デフォルト:文字列\"\nconsole.log(addPrefix(\"文字列\", \"カスタム:\")); // => \"カスタム:文字列\" \n```", "```\nfunction addPrefix(text, prefix) {\n    let pre = \"デフォルト:\";\n    if (typeof prefix === \"string\") {\n        pre = prefix;\n    }\n    return pre + text;\n}\n\nconsole.log(addPrefix(\"文字列\")); // => \"デフォルト:文字列\"\nconsole.log(addPrefix(\"文字列\", \"カスタム:\")); // => \"カスタム:文字列\" \n```", "```\nconst a = 1;\nconst b = 2;\nconst c = 3;\nconsole.log(a + b * c); // => 7\nconsole.log((a + b) * c); // => 9 \n```", "```\nif (x || y && z) {\n    // x が true または\n    // y かつ z が true\n} \n```", "```\nif (x || (y && z)) {\n    // x が true または\n    // y かつ z が true\n} \n```", "```\nif ((typeof a === \"string\" && typeof b === \"string\") || (typeof x === \"number\" && typeof y === \"number\")) {\n    // `a`と`b`が文字列型 または\n    // `x`と`y`が数値型\n} \n```", "```\nconst isAbString = typeof a === \"string\" && typeof b === \"string\";\nconst isXyNumber = typeof x === \"number\" && typeof y === \"number\";\nif (isAbString || isXyNumber) {\n    // `a`と`b`が文字列型 または\n    // `x`と`y`が数値型\n} \n```", "```\n式 1, 式 2, 式 3; \n```", "```\nconst a = 1, b = 2, c = a + b;\nconsole.log(c); // => 3 \n```"]