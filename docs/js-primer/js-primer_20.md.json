["```\nconst emptyArray = [];\nconst numbers = [1, 2, 3];\n// 2 次元配列（配列の配列）\nconst matrix = [\n    [\"a\", \"b\"],\n    [\"c\", \"d\"]\n]; \n```", "```\nconst array = [\"one\", \"two\", \"three\"];\nconsole.log(array[0]); // => \"one\" \n```", "```\n// 2 次元配列（配列の配列）\nconst matrix = [\n    [\"a\", \"b\"],\n    [\"c\", \"d\"]\n];\nconsole.log(matrix[0][0]); // => \"a\" \n```", "```\nconst array = [\"one\", \"two\", \"three\"];\nconsole.log(array.length); // => 3\n// 配列の要素数 - 1 が 最後の要素のインデックスとなる\nconsole.log(array[array.length - 1]); // => \"three\" \n```", "```\nconst array = [\"one\", \"two\", \"three\"];\n// `array`にはインデックスが100の要素は定義されていない\nconsole.log(array[100]); // => undefined \n```", "```\nconst obj = {\n    \"0\": \"one\",\n    \"1\": \"two\",\n    \"2\": \"three\",\n    \"length\": 3\n};\n// obj[\"100\"]は定義されていないため、undefinedが返る\nconsole.log(obj[100]); // => undefined \n```", "```\n// 未定義の箇所が1つ含まれる疎な配列\n// インデックスが1の値を省略しているので、カンマが2つ続いていることに注意\nconst sparseArray = [1, , 3];\nconsole.log(sparseArray.length); // => 3\n// 1 番目の要素は存在しないため undefined が返る\nconsole.log(sparseArray[1]); // => undefined \n```", "```\nconst array = [\"a\", \"b\", \"c\"];\n//\nconsole.log(array.at(0)); // => \"a\"\nconsole.log(array.at(1)); // => \"b\"\n// 後ろから1つ目の要素にアクセス\nconsole.log(array.at(-1)); // => \"c\"\n// -1は、次のように書いた場合と同じ結果\nconsole.log(array[array.length - 1]); // => \"c\" \n```", "```\nconst array = [\"a\", \"b\", \"c\"];\nconsole.log(array[-1]); // => undefined \n```", "```\nconst obj = {};\nconst array = [];\nconsole.log(Array.isArray(obj)); // => false\nconsole.log(Array.isArray(array)); // => true \n```", "```\nconst array = [];\nconsole.log(typeof array); // => \"object\" \n```", "```\n// TypedArrayを作成\nconst typedArray = new Int8Array(8);\nconsole.log(Array.isArray(typedArray)); // => false \n```", "```\nconst array = [\"one\", \"two\", \"three\"];\nconst [first, second, third] = array;\nconsole.log(first);  // => \"one\"\nconsole.log(second); // => \"two\"\nconsole.log(third);  // => \"three\" \n```", "```\n// 要素として`undefined`を持つ密な配列\nconst denseArray = [1, undefined, 3];\n// 要素そのものがない疎な配列\nconst sparseArray = [1, , 3];\nconsole.log(denseArray[1]); // => undefined\nconsole.log(sparseArray[1]); // => undefined \n```", "```\nconst denseArray = [1, undefined, 3];\nconst sparseArray = [1, , 3];\n// 要素自体は存在し、その値が`undefined`\nconsole.log(Object.hasOwn(denseArray, 1)); // => true\n// 要素自体が存在しない\nconsole.log(Object.hasOwn(sparseArray, 1)); // => false \n```", "```\nconst array = [\"Java\", \"JavaScript\", \"Ruby\", \"JavaScript\"];\n// 先頭から探索して最初に見つかった\"JavaScript\"のインデックスを取得\nconst indexOfJS = array.indexOf(\"JavaScript\");\nconsole.log(indexOfJS); // => 1\n// 末尾から探索して最初に見つかった\"JavaScript\"のインデックスを取得\nconst lastIndexOfJS = array.lastIndexOf(\"JavaScript\");\nconsole.log(lastIndexOfJS); // => 3\nconsole.log(array[indexOfJS]); // => \"JavaScript\"\nconsole.log(array[lastIndexOfJS]); // => \"JavaScript\"\n// \"JS\" という要素はないため `-1` が返される\nconsole.log(array.indexOf(\"JS\")); // => -1\nconsole.log(array.lastIndexOf(\"JS\")); // => -1 \n```", "```\nconst obj = { key: \"value\" };\nconst array = [\"A\", \"B\", obj];\nconsole.log(array.indexOf({ key: \"value\" })); // => -1\n// リテラルは新しいオブジェクトを作るため、異なるオブジェクトだと判定される\nconsole.log(obj === { key: \"value\" }); // => false\n// 等価のオブジェクトを検索してインデックスを返す\nconsole.log(array.indexOf(obj)); // => 2 \n```", "```\n// colorプロパティを持つオブジェクトの配列\nconst colors = [\n    { \"color\": \"red\" },\n    { \"color\": \"green\" },\n    { \"color\": \"blue\" }\n];\n// `color`プロパティが\"blue\"のオブジェクトのインデックスを取得\nconst indexOfBlue = colors.findIndex((obj) => {\n    return obj.color === \"blue\";\n});\nconsole.log(indexOfBlue); // => 2\nconsole.log(colors[indexOfBlue]); // => { \"color\": \"blue\" } \n```", "```\n// dateとcountプロパティを持つオブジェクトの配列\nconst records = [\n    { date: \"2020/12/1\", count: 5 },\n    { date: \"2020/12/2\", count: 11 },\n    { date: \"2020/12/3\", count: 9 },\n    { date: \"2020/12/4\", count: 12 },\n    { date: \"2020/12/5\", count: 3 }\n];\n// 10より大きい`count`プロパティを持つ最初のオブジェクトのインデックスを取得\nconst firstRecordIndex = records.findIndex((record) => {\n    return record.count > 10;\n});\n// 10より大きい`count`プロパティを持つ最後のオブジェクトのインデックスを取得\nconst lastRecordIndex = records.findLastIndex((record) => {\n    return record.count > 10;\n});\nconsole.log(firstRecordIndex); // => 1\nconsole.log(records[firstRecordIndex]); // => { date: \"2020/12/2\", count: 11 }\nconsole.log(lastRecordIndex); // => 3\nconsole.log(records[lastRecordIndex]); // => { date: \"2020/12/4\", count: 12 } \n```", "```\n// colorプロパティを持つオブジェクトの配列\nconst colors = [\n    { \"color\": \"red\" },\n    { \"color\": \"green\" },\n    { \"color\": \"blue\" }\n];\n// `color`プロパティが\"blue\"のオブジェクトを取得\nconst blueColor = colors.find((obj) => {\n    return obj.color === \"blue\";\n});\nconsole.log(blueColor); // => { \"color\": \"blue\" }\n// 該当する要素がない場合は`undefined`を返す\nconst whiteColor = colors.find((obj) => {\n    return obj.color === \"white\";\n});\nconsole.log(whiteColor); // => undefined \n```", "```\n// dateとcountプロパティを持つオブジェクトの配列\nconst records = [\n    { date: \"2020/12/1\", count: 5 },\n    { date: \"2020/12/2\", count: 11 },\n    { date: \"2020/12/3\", count: 9 },\n    { date: \"2020/12/4\", count: 12 },\n    { date: \"2020/12/5\", count: 3 }\n];\n// 10より大きい`count`プロパティを持つ最初のオブジェクトを取得\nconst firstRecord = records.find((record) => {\n    return record.count > 10;\n});\n// 10より大きい`count`プロパティを持つ最後のオブジェクトを取得\nconst lastRecord = records.findLast((record) => {\n    return record.count > 10;\n});\nconsole.log(firstRecord); // => { date: \"2020/12/2\", count: 11 }\nconsole.log(lastRecord); // => { date: \"2020/12/4\", count: 12 } \n```", "```\nconst array = [\"A\", \"B\", \"C\", \"D\", \"E\"];\n// インデックス1から4まで(4の要素は含まない)の範囲を取り出す\nconsole.log(array.slice(1, 4)); // => [\"B\", \"C\", \"D\"]\n// 第二引数を省略した場合は、第一引数から末尾の要素までを取り出す\nconsole.log(array.slice(1)); // => [\"B\", \"C\", \"D\", \"E\"]\n// マイナスを指定すると後ろから数えた位置となる\nconsole.log(array.slice(-1)); // => [\"E\"]\n// 第一引数と第二引数が同じ場合は、空の配列を返す\nconsole.log(array.slice(1, 1)); // => []\n// 第一引数 > 第二引数の場合、常に空配列を返す\nconsole.log(array.slice(4, 1)); // => [] \n```", "```\n +-----+-----+-----+-----+-----+\n | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" |\n +-----+-----+-----+-----+-----+\n 0     1     2     3     4     5\n-5    -4    -3    -2    -1 \n```", "```\nconst array = [\"Java\", \"JavaScript\", \"Ruby\"];\n// `indexOf`メソッドは含まれていないときのみ`-1`を返すことを利用\nconst indexOfJS = array.indexOf(\"JavaScript\");\nif (indexOfJS !== -1) {\n    console.log(\"配列にJavaScriptが含まれている\");\n    // ... いろいろな処理 ...\n    // `indexOfJS`は、含まれているのかの判定以外には利用してない\n} \n```", "```\nconst array = [\"Java\", \"JavaScript\", \"Ruby\"];\n// `includes`は含まれているなら`true`を返す\nif (array.includes(\"JavaScript\")) {\n    console.log(\"配列にJavaScriptが含まれている\");\n} \n```", "```\n// colorプロパティを持つオブジェクトの配列\nconst colors = [\n    { \"color\": \"red\" },\n    { \"color\": \"green\" },\n    { \"color\": \"blue\" }\n];\n// `color`プロパティが\"blue\"のオブジェクトがあるかどうか\nconst isIncludedBlueColor = colors.some((obj) => {\n    return obj.color === \"blue\";\n});\nconsole.log(isIncludedBlueColor); // => true \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\narray.push(\"D\"); // \"D\"を末尾に追加\nconsole.log(array); // => [\"A\", \"B\", \"C\", \"D\"]\nconst poppedItem = array.pop(); // 最末尾の要素を削除し、その要素を返す\nconsole.log(poppedItem); // => \"D\"\nconsole.log(array); // => [\"A\", \"B\", \"C\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\narray.unshift(\"S\"); // \"S\"を先頭に追加\nconsole.log(array); // => [\"S\", \"A\", \"B\", \"C\"]\nconst shiftedItem = array.shift(); // 先頭の要素を削除\nconsole.log(shiftedItem); // => \"S\"\nconsole.log(array); // => [\"A\", \"B\", \"C\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\nconst newArray = array.concat([\"D\", \"E\"]);\nconsole.log(newArray); // => [\"A\", \"B\", \"C\", \"D\", \"E\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\nconst newArray = array.concat(\"新しい要素\");\nconsole.log(newArray); // => [\"A\", \"B\", \"C\", \"新しい要素\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\n// Spread 構文を使った場合\nconst newArray = [\"X\", \"Y\", \"Z\", ...array];\n// concatメソッドの場合\nconst newArrayConcat = [\"X\", \"Y\", \"Z\"].concat(array);\nconsole.log(newArray); // => [\"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"]\nconsole.log(newArrayConcat); // => [\"X\", \"Y\", \"Z\", \"A\", \"B\", \"C\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\nconst newArray = [\"X\", ...array, \"Z\"];\nconsole.log(newArray); // => [\"X\", \"A\", \"B\", \"C\", \"Z\"] \n```", "```\nconst array = [[[\"A\"], \"B\"], \"C\"];\n// 引数なしは1を指定した場合と同じ\nconsole.log(array.flat()); // => [[\"A\"], \"B\", \"C\"]\nconsole.log(array.flat(1)); // => [[\"A\"], \"B\", \"C\"]\nconsole.log(array.flat(2)); // => [\"A\", \"B\", \"C\"]\n// すべてをフラット化するにはInfinityを渡す\nconsole.log(array.flat(Infinity)); // => [\"A\", \"B\", \"C\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\nconsole.log(array.flat()); // => [\"A\", \"B\", \"C\"] \n```", "```\nconst array = [];\narray.splice(インデックス, 削除する要素数);\n// 削除と同時に要素の追加もできる\narray.splice(インデックス, 削除する要素数, ...追加する要素); \n```", "```\nconst array = [\"a\", \"b\", \"c\"];\n// 1 番目から1つの要素(\"b\")を削除\narray.splice(1, 1);\nconsole.log(array); // => [\"a\", \"c\"]\nconsole.log(array.length); // => 2\nconsole.log(array[1]); // => \"c\"\n// すべて削除\narray.splice(0, array.length);\nconsole.log(array.length); // => 0 \n```", "```\nconst array = [1, 2, 3];\narray.length = 0; // 配列を空にする\nconsole.log(array); // => [] \n```", "```\nlet array = [1, 2, 3];\nconsole.log(array.length); // => 3\n// 新しい配列で変数を上書き\narray = [];\nconsole.log(array.length); // => 0 \n```", "```\nconst array = [1, 2, 3];\nconsole.log(array.length); // => 3\n// `const`で宣言された変数には再代入できない\narray = []; // TypeError: invalid assignment to const `array' が発生 \n```", "```\nconst myArray = [\"A\", \"B\", \"C\"];\nconst result = myArray.push(\"D\");\n// `push`の返り値は配列ではなく、追加後の配列のlength\nconsole.log(result); // => 4\n// `myArray`が参照する配列そのものが変更されている\nconsole.log(myArray); // => [\"A\", \"B\", \"C\", \"D\"] \n```", "```\nconst myArray = [\"A\", \"B\", \"C\"];\n// `concat`の返り値は結合済みの新しい配列\nconst newArray = myArray.concat(\"D\");\nconsole.log(newArray); // => [\"A\", \"B\", \"C\", \"D\"]\n// `myArray`は変更されていない\nconsole.log(myArray); // => [\"A\", \"B\", \"C\"]\n// `newArray`と`myArray`は異なる配列オブジェクト\nconsole.log(myArray === newArray); // => false \n```", "```\n// `array`の`index`番目の要素を削除した配列を返す関数\nfunction removeAtIndex(array, index) { /* 実装 */ } \n```", "```\n// `array`の`index`番目の要素を削除した配列を返す関数\n// 引数の`array`は破壊的に変更される\nfunction removeAtIndex(array, index) {\n    array.splice(index, 1);\n    return array;\n}\nconst array = [\"A\", \"B\", \"C\"];\n// `array`から1 番目の要素を削除した配列を取得\nconst newArray = removeAtIndex(array, 1);\nconsole.log(newArray); // => [\"A\", \"C\"]\n// `array`自体にも影響を与える\nconsole.log(array); // => [\"A\", \"C\"] \n```", "```\nconst myArray = [\"A\", \"B\", \"C\"];\n// `slice`は`myArray`のコピーを返す - `myArray.concat()`でも同じ\nconst copiedArray = myArray.slice();\nmyArray.push(\"D\");\nconsole.log(myArray); // => [\"A\", \"B\", \"C\", \"D\"]\n// `array`のコピーである`copiedArray`には影響がない\nconsole.log(copiedArray); // => [\"A\", \"B\", \"C\"]\n// コピーであるため参照は異なる\nconsole.log(copiedArray === myArray); // => false \n```", "```\n// `array`の`index`番目の要素を削除した配列を返す関数\nfunction removeAtIndex(array, index) {\n    // コピーを作成してから変更する\n    const copiedArray = array.slice();\n    copiedArray.splice(index, 1);\n    return copiedArray;\n}\nconst array = [\"A\", \"B\", \"C\"];\n// `array`から1 番目の要素を削除した配列を取得\nconst newArray = removeAtIndex(array, 1);\nconsole.log(newArray); // => [\"A\", \"C\"]\n// 元の`array`には影響がない\nconsole.log(array); // => [\"A\", \"B\", \"C\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\n// `toSpliced`は`array`を複製してから変更する\nconst newArray = array.toSpliced(1, 1);\nconsole.log(newArray); // => [\"A\", \"C\"]\n// コピー元の`array`には影響がない\nconsole.log(array); // => [\"A\", \"B\", \"C\"] \n```", "```\n// `array`の`index`番目の要素を削除した配列を返す関数\nfunction removeAtIndex(array, index) {\n    // コピーを作成してから変更する\n    return array.toSpliced(index, 1);\n}\nconst array = [\"A\", \"B\", \"C\"];\n// `array`から1 番目の要素を削除した配列を取得\nconst newArray = removeAtIndex(array, 1);\nconsole.log(newArray); // => [\"A\", \"C\"]\n// 元の`array`には影響がない\nconsole.log(array); // => [\"A\", \"B\", \"C\"] \n```", "```\nconst array = [\"A\", \"B\", \"C\"];\n// `array`の1 番目の要素を変更した配列を返す\nconst newArray = array.with(1, \"B2\");\nconsole.log(newArray); // => [\"A\", \"B2\", \"C\"] \n```", "```\nconst array = [1, 2, 3];\narray.forEach((currentValue, index, array) => {\n    console.log(currentValue, index, array);\n});\n// コンソールの出力\n// 1, 0, [1, 2, 3]\n// 2, 1, [1, 2, 3]\n// 3, 2, [1, 2, 3] \n```", "```\nconst array = [1, 2, 3];\n// 各要素に10を乗算した新しい配列を作成する\nconst newArray = array.map((currentValue, index, array) => {\n    return currentValue * 10;\n});\nconsole.log(newArray); // => [10, 20, 30]\n// 元の配列とは異なるインスタンス\nconsole.log(array === newArray); // => false \n```", "```\nconst array = [1, 2, 3];\n// 奇数の値を持つ要素だけを集めた配列を返す\nconst newArray = array.filter((currentValue, index, array) => {\n    return currentValue % 2 === 1;\n});\nconsole.log(newArray); // => [1, 3]\n// 元の配列とは異なるインスタンス\nconsole.log(array === newArray); // => false \n```", "```\nconst array = [1, 2, 3];\n// すべての要素を加算した値を返す\n// accumulatorの初期値は`0`\nconst totalValue = array.reduce((accumulator, currentValue, index, array) => {\n    return accumulator + currentValue;\n}, 0);\n// 0 + 1 + 2 + 3という式の結果が返り値になる\nconsole.log(totalValue); // => 6 \n```", "```\nconst array = [1, 2, 3];\n// 初期値は`0`\nlet totalValue = 0;\narray.forEach((currentValue) => {\n    totalValue += currentValue;\n});\nconsole.log(totalValue); // => 6 \n```", "```\nconst array = [1, 2, 3];\nfunction sum(array) {\n    return array.reduce((accumulator, currentValue) => {\n        return accumulator + currentValue;\n    }, 0);\n}\nconsole.log(sum(array)); // => 6 \n```", "```\nfunction myFunc() {\n    console.log(arguments[0]); // => \"a\"\n    console.log(arguments[1]); // => \"b\"\n    console.log(arguments[2]); // => \"c\"\n    // 配列ではないため、配列のメソッドは持っていない\n    console.log(typeof arguments.forEach); // => \"undefined\"\n}\nmyFunc(\"a\", \"b\", \"c\"); \n```", "```\nfunction myFunc() {\n    console.log(Array.isArray([1, 2, 3])); // => true\n    console.log(Array.isArray(arguments)); // => false\n}\nmyFunc(\"a\", \"b\", \"c\"); \n```", "```\nfunction myFunc() {\n    // Array-likeオブジェクトを配列へ変換\n    const argumentsArray = Array.from(arguments);\n    console.log(Array.isArray(argumentsArray)); // => true\n    // 配列のメソッドを利用できる\n    argumentsArray.forEach(arg => {\n        console.log(arg);\n    });\n}\nmyFunc(\"a\", \"b\", \"c\"); \n```", "```\nconst array = [\"a\"].concat(\"b\").concat(\"c\");\nconsole.log(array); // => [\"a\", \"b\", \"c\"] \n```", "```\n// メソッドチェーンを分解した例\n// 一時的な`abArray`という変数が増えている\nconst abArray = [\"a\"].concat(\"b\");\nconsole.log(abArray); // => [\"a\", \"b\"]\nconst abcArray = abArray.concat(\"c\");\nconsole.log(abcArray); // => [\"a\", \"b\", \"c\"] \n```", "```\n// ECMAScriptのバージョン名と発行年\nconst ECMAScriptVersions = [\n    { name: \"ECMAScript 1\", year: 1997 },\n    { name: \"ECMAScript 2\", year: 1998 },\n    { name: \"ECMAScript 3\", year: 1999 },\n    { name: \"ECMAScript 5\", year: 2009 },\n    { name: \"ECMAScript 5.1\", year: 2011 },\n    { name: \"ECMAScript 2015\", year: 2015 },\n    { name: \"ECMAScript 2016\", year: 2016 },\n    { name: \"ECMAScript 2017\", year: 2017 },\n];\n// メソッドチェーンで必要な加工処理を並べている\nconst versionNames = ECMAScriptVersions\n    // 2000 年以下のデータに絞り込み\n    .filter(ECMAScript => ECMAScript.year <= 2000)\n    // それぞれの要素から`name`プロパティを取り出す\n    .map(ECMAScript => ECMAScript.name);\nconsole.log(versionNames); // => [\"ECMAScript 1\", \"ECMAScript 2\", \"ECMAScript 3\"] \n```"]