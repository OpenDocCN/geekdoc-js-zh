["```\n// 1という式の評価値を表示\nconsole.log(1); // => 1\n// 1 + 1という式の評価値を表示\nconsole.log(1 + 1); // => 2\n// 式の評価値を変数に代入\nconst total = 1 + 1;\n// 関数式の評価値(関数オブジェクト)を変数に代入\nconst fn = function() {\n    return 1;\n};\n// fn() という式の評価値を表示\nconsole.log(fn()); // => 1 \n```", "```\n処理する文;\n処理する文;\n処理する文; \n```", "```\nconst isTrue = true;\n// isTrueという式がif 文の中に出てくる\nif (isTrue) {\n} \n```", "```\n// 構文として間違っているため、SyntaxErrorが発生する\nconst forIsNotExpression = if (true) { /* ifは文であるため式にはなれない */ } \n```", "```\n// 式文であるためセミコロンをつけている\n式; \n```", "```\n{\n    文;\n    文;\n} \n```", "```\n// if 文とブロック文の組み合わせ\nif (true) {\n    console.log(\"文 1\");\n    console.log(\"文 2\");\n} \n```", "```\n// ブロックで終わらない文なので、セミコロンが必要\nif (true) console.log(true);\n// ブロックで終わる文なので、セミコロンが不要\nif (true) {\n    console.log(true);\n} \n```", "```\n// REPLでの動作。»はREPLの入力欄\n» const count = 1;\nundefined\n» const count = 2;\nSyntaxError: redeclaration of const count \n```", "```\n// REPLでの動作。»はREPLの入力欄\n» {\n    const count = 1;\n}\nundefined // ここでブロック内で定義した変数`count`は参照できなくなる\n» {\n    const count = 1;\n}\nundefined // ここでブロック内で定義した変数`count`は参照できなくなる \n```", "```\n// learn 関数を宣言する関数宣言文\nfunction learn() {\n}\n// 関数式をread 変数へ代入\nconst read = function() {\n}; \n```", "```\nfunction fn() {}\n// fn(式)の評価値を代入する変数宣言の文\nconst read = fn; \n```"]