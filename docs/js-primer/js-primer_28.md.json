["```\nfunction taskA() {\n    console.log(\"タスクAを実行 at \" + Date.now());\n}\nfunction taskB() {\n    console.log(\"タスクBを実行 at \" + Date.now());\n}\n// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数\nfunction blockTime(timeout) {\n    // Date.now()は現在の時間をUnix 時間（1970 年 1 月 1 日午前 0 時 0 分 0 秒から経過した時間）のミリ秒を返す\n    const startTime = Date.now();\n    // `timeout`ミリ秒経過するまで無限ループをする\n    while (true) {\n        const diffTime = Date.now() - startTime;\n        if (diffTime >= timeout) {\n            return; // 指定時間経過したら関数の実行を終了\n        }\n    }\n}\ntaskA();\nblockTime(1000); // 他の処理を1000ミリ秒（1 秒間）ブロックする\ntaskB(); \n```", "```\nsetTimeout(コールバック関数, delay); \n```", "```\nfunction taskA() {\n    console.log(\"タスクAを実行 at \" + Date.now());\n}\nfunction taskB() {\n    console.log(\"タスクBを実行 at \" + Date.now());\n}\nfunction taskAsync() {\n    console.log(\"非同期のタスクを実行 at \" + Date.now());\n}\n\ntaskA();\nsetTimeout(() => {\n    taskAsync();\n}, 1000);\ntaskB(); \n```", "```\nfunction taskA() {\n    console.log(\"タスクAを実行 at \" + Date.now());\n}\nfunction taskB() {\n    console.log(\"タスクBを実行 at \" + Date.now());\n}\nfunction taskAsync() {\n    console.log(\"非同期のタスクを実行 at \" + Date.now());\n}\n// 指定した`timeout`ミリ秒経過するまで同期的にブロックする関数\nfunction blockTime(timeout) {\n    const startTime = Date.now();\n    while (true) {\n        const diffTime = Date.now() - startTime;\n        if (diffTime >= timeout) {\n            return; // 指定時間経過したら関数の実行を終了\n        }\n    }\n}\n\nconst startTime = Date.now();\ntaskA();\n// 10ミリ秒後にコールバック関数を呼び出すようにタイマーに登録する\nsetTimeout(() => {\n    const endTime = Date.now();\n    taskAsync();\n    console.log(`非同期処理のコールバックが呼ばれるまで${endTime - startTime}ミリ秒かかりました`);\n}, 10);\nblockTime(1000); // 1 秒間処理をブロックする\ntaskB(); \n```", "```\ntry {\n    throw new Error(\"同期的なエラー\");\n} catch (error) {\n    console.log(\"同期的なエラーをキャッチできる\");\n}\nconsole.log(\"この行は実行されます\"); \n```", "```\ntry {\n    setTimeout(() => {\n        throw new Error(\"非同期的なエラー\");\n    }, 10);\n} catch (error) {\n    // 非同期エラーはキャッチできないため、この行は実行されません\n}\nconsole.log(\"この行は実行されます\"); \n```", "```\n// 非同期処理の外\nsetTimeout(() => {\n    // 非同期処理の中\n    try {\n        throw new Error(\"エラー\");\n    } catch (error) {\n        console.log(\"エラーをキャッチできる\");\n    }\n}, 10);\nconsole.log(\"この行は実行されます\"); \n```", "```\n// asyncPromiseTask 関数は、Promiseインスタンスを返す\nfunction asyncPromiseTask() {\n    return new Promise((resolve, reject) => {\n        // さまざまな非同期処理を行う\n        // 非同期処理に成功した場合は、resolveを呼ぶ\n        // 非同期処理に失敗した場合は、rejectを呼ぶ\n    });\n}\n// asyncPromiseTask 関数の非同期処理が成功した時、失敗した時に呼ばれる処理をコールバック関数として登録する\nasyncPromiseTask().then(()=> {\n    // 非同期処理が成功したときの処理\n}).catch(() => {\n    // 非同期処理が失敗したときの処理\n}); \n```", "```\nconst executor = (resolve, reject) => {\n    // 非同期の処理が成功したときはresolveを呼ぶ\n    // 非同期の処理が失敗したときはrejectを呼ぶ\n};\nconst promise = new Promise(executor); \n```", "```\n// `Promise`インスタンスを作成\nconst promise = new Promise((resolve, reject) => {\n    // 非同期の処理が成功したときはresolve()を呼ぶ\n    // 非同期の処理が失敗したときにはreject()を呼ぶ\n});\nconst onFulfilled = () => {\n    console.log(\"resolveされたときに呼ばれる\");\n};\nconst onRejected = () => {\n    console.log(\"rejectされたときに呼ばれる\");\n};\n// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録\npromise.then(onFulfilled, onRejected); \n```", "```\n/**\n * 1000ミリ秒未満のランダムなタイミングでレスポンスを疑似的にデータ取得する関数\n * 指定した`path`にデータがある場合、成功として**Resolved**状態のPromiseオブジェクトを返す\n * 指定した`path`にデータがない場合、失敗として**Rejected**状態のPromiseオブジェクトを返す\n */\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/success\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// `then`メソッドで成功時と失敗時に呼ばれるコールバック関数を登録\n// /success/data のリソースは存在するので成功しonFulfilledが呼ばれる\ndummyFetch(\"/success/data\").then(function onFulfilled(response) {\n    console.log(response); // => { body: \"Response body of /success/data\" }\n}, function onRejected(error) {\n    // この行は実行されません\n});\n// /failure/data のリソースは存在しないのでonRejectedが呼ばれる\ndummyFetch(\"/failure/data\").then(function onFulfilled(response) {\n    // この行は実行されません\n}, function onRejected(error) {\n    console.error(error); // Error: \"NOT FOUND\"\n}); \n```", "```\nfunction delay(timeoutMs) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve();\n        }, timeoutMs);\n    });\n}\n// `then`メソッドで成功時のコールバック関数だけを登録\ndelay(10).then(() => {\n    console.log(\"10ミリ秒後に呼ばれる\");\n}); \n```", "```\nfunction errorPromise(message) {\n    return new Promise((resolve, reject) => {\n        reject(new Error(message));\n    });\n}\n// 非推奨: `then`メソッドで失敗時のコールバック関数だけを登録\nerrorPromise(\"thenでエラーハンドリング\").then(undefined, (error) => {\n    console.log(error.message); // => \"thenでエラーハンドリング\"\n});\n// 推奨: `catch`メソッドで失敗時のコールバック関数を登録\nerrorPromise(\"catchでエラーハンドリング\").catch(error => {\n    console.log(error.message); // => \"catchでエラーハンドリング\"\n}); \n```", "```\nfunction throwPromise() {\n    return new Promise((resolve, reject) => {\n        // Promiseコンストラクタの中で例外は自動的にキャッチされrejectを呼ぶ\n        throw new Error(\"例外が発生\");\n        // 例外が発生すると、これ以降のコンストラクタの処理は実行されません\n    });\n}\n\nthrowPromise().catch(error => {\n    console.log(error.message); // => \"例外が発生\"\n}); \n```", "```\nconst promise = new Promise((resolve, reject) => {\n    // 非同期でresolveする\n    setTimeout(() => {\n        resolve();\n        // すでにresolveされているため無視される\n        reject(new Error(\"エラー\"));\n    }, 16);\n});\npromise.then(() => {\n    console.log(\"Fulfilledとなった\");\n}, (error) => {\n    // この行は呼び出されない\n}); \n```", "```\nconst promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve();\n        resolve(); // 二度目以降のresolveやrejectは無視される\n    }, 16);\n});\npromise.then(() => {\n    console.log(\"最初のresolve 時に一度だけ呼ばれる\");\n}, (error) => {\n    // この行は呼び出されない\n}); \n```", "```\nconst fulfilledPromise = Promise.resolve(); \n```", "```\n// const fulfilledPromise = Promise.resolve(); と同じ意味\nconst fulfilledPromise = new Promise((resolve) => {\n    resolve();\n}); \n```", "```\n// `resolve(42)`された`Promise`インスタンスを作成する\nconst fulfilledPromise = Promise.resolve(42);\nfulfilledPromise.then(value => {\n    console.log(value); // => 42\n}); \n```", "```\nconst promise = Promise.resolve();\npromise.then(() => {\n    console.log(\"2\\. コールバック関数が実行されました\");\n});\nconsole.log(\"1\\. 同期的な処理が実行されました\"); \n```", "```\nconst promise = new Promise((resolve) => {\n    console.log(\"1\\. resolveします\");\n    resolve();\n});\npromise.then(() => {\n    console.log(\"3\\. コールバック関数が実行されました\");\n});\nconsole.log(\"2\\. 同期的な処理が実行されました\"); \n```", "```\nconst rejectedPromise = Promise.reject(new Error(\"エラー\")); \n```", "```\nconst rejectedPromise = new Promise((resolve, reject) => {\n    reject(new Error(\"エラー\"));\n}); \n```", "```\nPromise.reject(new Error(\"エラー\")).catch(() => {\n    console.log(\"2\\. コールバック関数が実行されました\");\n});\nconsole.log(\"1\\. 同期的な処理が実行されました\"); \n```", "```\n// Promiseインスタンスでメソッドチェーン\nPromise.resolve()\n    // thenメソッドは新しい`Promise`インスタンスを返す\n    .then(() => {\n        console.log(1);\n    })\n    .then(() => {\n        console.log(2);\n    }); \n```", "```\n// Promiseチェーンを変数に入れた場合\nconst firstPromise = Promise.resolve();\nconst secondPromise = firstPromise.then(() => {\n    console.log(1);\n});\nconst thirdPromise = secondPromise.then(() => {\n    console.log(2);\n});\n// それぞれ新しいPromiseインスタンスが作成される\nconsole.log(firstPromise === secondPromise); // => false\nconsole.log(secondPromise === thirdPromise); // => false \n```", "```\n// ランダムでFulfilledまたはRejectedの`Promise`インスタンスを返す関数\nfunction asyncTask() {\n    return Math.random() > 0.5\n        ? Promise.resolve(\"成功\")\n        : Promise.reject(new Error(\"失敗\"));\n}\n\n// asyncTask 関数は新しい`Promise`インスタンスを返す\nasyncTask()\n    // thenメソッドは新しい`Promise`インスタンスを返す\n    .then(function onFulfilled(value) {　\n        console.log(value); // => \"成功\"\n    })\n    // catchメソッドは新しい`Promise`インスタンスを返す\n    .catch(function onRejected(error) {\n        console.log(error.message); // => \"失敗\"\n    }); \n```", "```\n// RejectedなPromiseは次の失敗時の処理までスキップする\nconst rejectedPromise = Promise.reject(new Error(\"失敗\"));\nrejectedPromise.then(() => {\n    // このthenのコールバック関数は呼び出されません\n}).then(() => {\n    // このthenのコールバック関数は呼び出されません\n}).catch(error => {\n    console.log(error.message); // => \"失敗\"\n}); \n```", "```\nPromise.resolve().then(() => {\n    // 例外が発生すると、thenメソッドはRejectedなPromiseを返す\n    throw new Error(\"例外\");\n}).then(() => {\n    // このthenのコールバック関数は呼び出されません\n}).catch(error => {\n    console.log(error.message); // => \"例外\"\n}); \n```", "```\nPromise.reject(new Error(\"エラー\")).catch(error => {\n    console.error(error); // Error: エラー\n}).then(() => {\n    console.log(\"thenのコールバック関数が呼び出される\");\n}); \n```", "```\nPromise.resolve(1).then((value) => {\n    console.log(value); // => 1\n    return value * 2;\n}).then(value => {\n    console.log(value); // => 2\n    return value * 2;\n}).then(value => {\n    console.log(value); // => 4\n    // 値を返さない場合は undefined を返すのと同じ\n}).then(value => {\n    console.log(value); // => undefined\n}); \n```", "```\nPromise.reject(new Error(\"失敗\")).catch(error => {\n    // 一度 catchすれば、次に呼ばれるのは成功時のコールバック\n    return 1;\n}).then(value => {\n    console.log(value); // => 1\n    return value * 2;\n}).then(value => {\n    console.log(value); // => 2\n}); \n```", "```\nPromise.resolve().then(function onFulfilledA() {\n    return Promise.reject(new Error(\"失敗\"));\n}).then(function onFulfilledB() {\n    // onFulfilledBは呼び出されません\n}).catch(function onRejected(error) {\n    console.log(error.message); // => \"失敗\"\n}).then(function onFulfilledC() {\n    console.log(\"onFulfilledCは呼び出されます\");\n}); \n```", "```\nfunction main() {\n    return Promise.reject(new Error(\"エラー\"));\n}\n// mainはRejectedなPromiseを返す\nmain().catch(error => {\n    // mainで発生したエラーのログを出力する\n    console.error(error);\n    // Promiseチェーンはそのままエラーを継続させる\n    return Promise.reject(error);\n}).then(() => {\n    // 前のcatchでRejectedなPromiseが返されたため、この行は実行されません\n}).catch(error => {\n    console.log(\"メインの処理が失敗した\");\n}); \n```", "```\n// `promise`にはResolvedまたはRejectedなPromiseインスタンスがランダムで入る\nconst promise = Math.random() < 0.5 ? Promise.resolve() : Promise.reject();\npromise.then(() => {\n    console.log(\"Promiseのthenメソッド\");\n}).catch((error) => {\n    console.log(\"Promiseのcatchメソッド\");\n}).finally(() => {\n    // 成功、失敗どちらの場合でも呼び出される\n    console.log(\"Promiseのfinallyメソッド\");\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// リソースを取得中かどうかのフラグ\nlet isLoading = true;\ndummyFetch(\"/resource/A\").then(response => {\n    console.log(response);\n}).catch(error => {\n    console.error(error);\n}).finally(() => {\n    isLoading = false;\n    console.log(\"Promiseのfinallyメソッド\");\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n\nconst results = [];\n// Resource Aを取得する\ndummyFetch(\"/resource/A\").then(response => {\n    results.push(response.body);\n    // Resource Bを取得する\n    return dummyFetch(\"/resource/B\");\n}).then(response => {\n    results.push(response.body);\n}).then(() => {\n    console.log(results); // => [\"Response body of /resource/A\", \"Response body of /resource/B\"]\n}); \n```", "```\n// `timeoutMs`ミリ秒後にresolveする\nfunction delay(timeoutMs) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(timeoutMs);\n        }, timeoutMs);\n    });\n}\nconst promise1 = delay(1);\nconst promise2 = delay(2);\nconst promise3 = delay(3);\n\nPromise.all([promise1, promise2, promise3]).then(function(values) {\n    console.log(values); // => [1, 2, 3]\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n\nconst fetchedPromise = Promise.all([\n    dummyFetch(\"/resource/A\"),\n    dummyFetch(\"/resource/B\")\n]);\n// fetchedPromiseの結果をDestructuringでresponseA, responseBに代入している\nfetchedPromise.then(([responseA, responseB]) => {\n    console.log(responseA.body); // => \"Response body of /resource/A\"\n    console.log(responseB.body); // => \"Response body of /resource/B\"\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n\nconst fetchedPromise = Promise.all([\n    dummyFetch(\"/resource/A\"),\n    dummyFetch(\"/not_found/B\") // Bは存在しないため失敗する\n]);\nfetchedPromise.then(([responseA, responseB]) => {\n    // この行は実行されません\n}).catch(error => {\n    console.error(error); // Error: NOT FOUND\n}); \n```", "```\n// `timeoutMs`ミリ秒後にresolveする\nfunction delay(timeoutMs) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(timeoutMs);\n        }, timeoutMs);\n    });\n}\n// 1つでもresolveまたはrejectした時点で次の処理を呼び出す\nconst racePromise = Promise.race([\n    delay(1),\n    delay(32),\n    delay(64),\n    delay(128)\n]);\nracePromise.then(value => {\n    // もっとも早く完了するのは1ミリ秒後\n    console.log(value); // => 1\n}); \n```", "```\n// `timeoutMs`ミリ秒後にrejectする\nfunction timeout(timeoutMs) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            reject(new Error(`Timeout: ${timeoutMs}ミリ秒経過`));\n        }, timeoutMs);\n    });\n}\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// 500ミリ秒以内に取得できなければ失敗時の処理が呼ばれる\nPromise.race([\n    dummyFetch(\"/resource/data\"),\n    timeout(500),\n]).then(response => {\n    console.log(response.body); // => \"Response body of /resource/data\"\n}).catch(error => {\n    console.log(error.message); // => \"Timeout: 500ミリ秒経過\"\n}); \n```", "```\nasync function doAsync() {\n    return \"値\";\n}\n// doAsync 関数はPromiseを返す\ndoAsync().then(value => {\n    console.log(value); // => \"値\"\n}); \n```", "```\n// 通常の関数でPromiseインスタンスを返している\nfunction doAsync() {\n    return Promise.resolve(\"値\");\n}\ndoAsync().then(value => {\n    console.log(value); // => \"値\"\n}); \n```", "```\n// 関数宣言のAsync Function 版\nasync function fn1() {}\n// 関数式のAsync Function 版\nconst fn2 = async function() {};\n// Arrow FunctionのAsync Function 版\nconst fn3 = async() => {};\n// メソッドの短縮記法のAsync Function 版\nconst obj = { async method() {} }; \n```", "```\n// 1\\. resolveFnは値を返している\n// 何もreturnしていない場合はundefinedを返したのと同じ扱いとなる\nasync function resolveFn() {\n    return \"返り値\";\n}\nresolveFn().then(value => {\n    console.log(value); // => \"返り値\"\n});\n\n// 2\\. rejectFnはPromiseインスタンスを返している\nasync function rejectFn() {\n    return Promise.reject(new Error(\"エラーメッセージ\"));\n}\n\n// rejectFnはRejectedなPromiseを返すのでcatchできる\nrejectFn().catch(error => {\n    console.log(error.message); // => \"エラーメッセージ\"\n});\n\n// 3\\. exceptionFnは例外を投げている\nasync function exceptionFn() {\n    throw new Error(\"例外が発生しました\");\n    // 例外が発生したため、この行は実行されません\n}\n\n// Async Functionで例外が発生するとRejectedなPromiseが返される\nexceptionFn().catch(error => {\n    console.log(error.message); // => \"例外が発生しました\"\n}); \n```", "```\nasync function asyncMain() {\n    // PromiseがFulfilledまたはRejectedとなるまで待つ\n    await Promiseインスタンス;\n    // Promiseインスタンスの状態が変わったら処理を再開する\n} \n```", "```\n// async functionは必ずPromiseを返す\nasync function doAsync() {\n    // 非同期処理\n}\nasync function asyncMain() {\n    // doAsyncの非同期処理が完了するまでまつ\n    await doAsync();\n    // 次の行はdoAsyncの非同期処理が完了されるまで実行されない\n    console.log(\"この行は非同期処理が完了後に実行される\");\n} \n```", "```\nasync function asyncMain() {\n    const value = await Promise.resolve(42);\n    console.log(value); // => 42\n}\nasyncMain(); // Promiseインスタンスを返す \n```", "```\nfunction asyncMain() {\n    return Promise.resolve(42).then(value => {\n        console.log(value); // => 42\n    });\n}\nasyncMain(); // Promiseインスタンスを返す \n```", "```\nasync function asyncMain() {\n    // `await`式で評価した右辺のPromiseがRejectedとなったため、例外がthrowされる\n    const value = await Promise.reject(new Error(\"エラーメッセージ\"));\n    // await 式で例外が発生したため、この行は実行されません\n}\n// Async Functionは自動的に例外をキャッチできる\nasyncMain().catch(error => {\n    console.log(error.message); // => \"エラーメッセージ\"\n}); \n```", "```\nasync function asyncMain() {\n    // await 式のエラーはtry...catchできる\n    try {\n        // `await`式で評価した右辺のPromiseがRejectedとなったため、例外がthrowされる\n        const value = await Promise.reject(new Error(\"エラーメッセージ\"));\n        // await 式で例外が発生したため、この行は実行されません\n    } catch (error) {\n        console.log(error.message); // => \"エラーメッセージ\"\n    }\n}\n// asyncMainはResolvedなPromiseを返す\nasyncMain().catch(error => {\n    // すでにtry...catchされているため、この行は実行されません\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// リソースAとリソースBを順番に取得する\nfunction fetchAB() {\n    const results = [];\n    return dummyFetch(\"/resource/A\").then(response => {\n        results.push(response.body);\n        return dummyFetch(\"/resource/B\");\n    }).then(response => {\n        results.push(response.body);\n        return results;\n    });\n}\n// リソースを取得して出力する\nfetchAB().then((results) => {\n    console.log(results); // => [\"Response body of /resource/A\", \"Response body of /resource/B\"]\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// リソースAとリソースBを順番に取得する\nasync function fetchAB() {\n    const results = [];\n    const responseA = await dummyFetch(\"/resource/A\");\n    results.push(responseA.body);\n    const responseB = await dummyFetch(\"/resource/B\");\n    results.push(responseB.body);\n    return results;\n}\n// リソースを取得して出力する\nfetchAB().then((results) => {\n    console.log(results); // => [\"Response body of /resource/A\", \"Response body of /resource/B\"]\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// 複数のリソースを順番に取得する\nasync function fetchResources(resources) {\n    const results = [];\n    // for...of 文でresourcesの配列から1つずつ要素を取り出して処理\n    for (const resource of resources) {\n        // ループ内で非同期処理の完了を待っている\n        const response = await dummyFetch(resource);\n        results.push(response.body);\n    }\n    // 反復処理がすべて終わったら結果を返す(返り値となるPromiseを`results`でresolveする)\n    return results;\n}\n// 取得したいリソースのパス配列\nconst resources = [\n    \"/resource/A\",\n    \"/resource/B\"\n];\n// リソースを取得して出力する\nfetchResources(resources).then((results) => {\n    console.log(results); // => [\"Response body of /resource/A\", \"Response body of /resource/B\"]\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// 複数のリソースをまとめて取得する\nasync function fetchAllResources(resources) {\n    // それぞれのリソースを取得する非同期処理を呼び出す\n    const promises = resources.map((resource) => {\n        return dummyFetch(resource);\n    });\n    // すべてのリソースが取得できるまで待つ\n    // Promise.allは [ResponseA, ResponseB] のように結果が配列となる\n    const responses = await Promise.all(promises);\n    // 取得した結果からレスポンスのボディだけを取り出す\n    return responses.map((response) => {\n        return response.body;\n    });\n}\nconst resources = [\n    \"/resource/A\",\n    \"/resource/B\"\n];\n// リソースを取得して出力する\nfetchAllResources(resources).then((results) => {\n    console.log(results); // => [\"Response body of /resource/A\", \"Response body of /resource/B\"]\n}); \n```", "```\n// asyncではない関数では`await`式は利用できない\nfunction main(){\n    // SyntaxError: await is only valid in async functions\n    await Promise.resolve();\n} \n```", "```\nasync function asyncMain() {\n    // 中でawaitしても、Async Functionの外側の処理まで止まるわけではない\n    await new Promise((resolve) => {\n        setTimeout(resolve, 16);\n    });\n}\nconsole.log(\"1\\. asyncMain 関数を呼び出します\");\n// Async Functionは外から見れば単なるPromiseを返す関数\nasyncMain().then(() => {\n    console.log(\"3\\. asyncMain 関数が完了しました\");\n});\n// Async Functionの外側の処理はそのまま進む\nconsole.log(\"2\\. asyncMain 関数外では、次の行が同期的に呼び出される\"); \n```", "```\nasync function fetchResources(resources) {\n    const results = [];\n    // Syntax Errorとなる例\n    resources.forEach(function(resource) {\n        // Async Functionではないスコープで`await`式を利用しているためSyntax Errorとなる\n        const response = await dummyFetch(resource);\n        results.push(response.body);\n    });\n    return results;\n} \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// リソースを順番に取得する\nasync function fetchResources(resources) {\n    const results = [];\n    // コールバック関数をAsync Functionに変更\n    resources.forEach(async function(resource) {\n        // await 式を利用できるようになった\n        const response = await dummyFetch(resource);\n        results.push(response.body);\n    });\n    return results;\n}\nconst resources = [\"/resource/A\", \"/resource/B\"];\n// リソースを取得して出力する\nfetchResources(resources).then((results) => {\n    // しかし、resultsは空になってしまう\n    console.log(results); // => []\n}); \n```", "```\nfunction dummyFetch(path) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            if (path.startsWith(\"/resource\")) {\n                resolve({ body: `Response body of ${path}` });\n            } else {\n                reject(new Error(\"NOT FOUND\"));\n            }\n        }, 1000 * Math.random());\n    });\n}\n// リソースを順番に取得する\nasync function fetchResources(resources) {\n    const results = [];\n    console.log(\"1\\. fetchResourcesを開始\");\n    resources.forEach(async function(resource) {\n        console.log(`2\\. ${resource}の取得開始`);\n        const response = await dummyFetch(resource);\n        // `dummyFetch`が完了するのは、`fetchResources`関数が返したPromiseが解決された後\n        console.log(`5\\. ${resource}の取得完了`);\n        results.push(response.body);\n    });\n    console.log(\"3\\. fetchResourcesを終了\");\n    return results;\n}\nconst resources = [\"/resource/A\", \"/resource/B\"];\n// リソースを取得して出力する\nfetchResources(resources).then((results) => {\n    console.log(\"4\\. fetchResourcesの結果を取得\");\n    console.log(results); // => []\n}); \n```", "```\n// このコードはModuleのトップレベルでのみ動作する\nconsole.log(\"実行開始\");\nconst startTime = Date.now();\n// awaitを使って1 秒待つ\nawait new Promise(resolve => setTimeout(resolve, 1000));\nconsole.log(`実行終了: ${Date.now() - startTime}ms 経過しました`); \n```", "```\n// awaitを使うためだけに、Async Functionの即時実行関数を実行している\n(async function() {\n    // awaitを使う処理\n    const result = await doAsyncTask();\n    // ...\n})(); \n```", "```\nfs.readFile(\"./example.txt\", (error, data) => {\n    if (error) {\n        // 読み込み中にエラーが発生しました\n    } else {\n        // データを読み込むことができました\n    }\n}); \n```", "```\n/**\n * 1000ミリ秒未満のランダムなタイミングでレスポンスを疑似的にデータ取得する関数\n * 指定した`path`にデータがある場合は`callback(null, レスポンス)`を呼ぶ\n * 指定した`path`にデータがない場合は`callback(エラー)`を呼ぶ\n */\nfunction dummyFetch(path, callback) {\n    setTimeout(() => {\n        // /success からはじまるパスにはリソースがあるという設定\n        if (path.startsWith(\"/success\")) {\n            callback(null, { body: `Response body of ${path}` });\n        } else {\n            callback(new Error(\"NOT FOUND\"));\n        }\n    }, 1000 * Math.random());\n}\n// /success/data にリソースが存在するので、`response`にはデータが入る\ndummyFetch(\"/success/data\", (error, response) => {\n    if (error) {\n        // この行は実行されません\n    } else {\n        console.log(response); // => { body: \"Response body of /success/data\" }\n    }\n});\n// /failure/data にリソースは存在しないので、`error`にはエラーオブジェクトが入る\ndummyFetch(\"/failure/data\", (error, response) => {\n    if (error) {\n        console.log(error.message); // => \"NOT FOUND\"\n    } else {\n        // この行は実行されません\n    }\n}); \n```"]