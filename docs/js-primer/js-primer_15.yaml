- en: 文と式
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jsprimer.net/basic/statement-expression/`](https://jsprimer.net/basic/statement-expression/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 本格的に基本文法について学ぶ前に、JavaScriptというプログラミング言語がどのような要素からできているかを見ていきましょう。
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptは、**文**（Statement）と**式**（Expression）から構成されています。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#expression)*式*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '***式**（Expression）を簡潔に述べると、値を生成し、変数に代入できるものを言います。'
  prefs: []
  type: TYPE_NORMAL
- en: '`42`のようなリテラルや`foo`といった変数、関数呼び出しが式です。 また、`1 + 1`のような式と演算子の組み合わせも式と呼びます。'
  prefs: []
  type: TYPE_NORMAL
- en: 式の特徴として、式を評価すると結果の値を得ることができます。 この結果の値を**評価値**と呼びます。
  prefs: []
  type: TYPE_NORMAL
- en: 評価した結果を変数に代入できるものは**式**であるという理解で問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[](#statement)*文*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '***文**（Statement）を簡潔に述べると、処理する1ステップが1つの文と言えます。 JavaScriptでは、文の末尾にセミコロン(`;`)を置くことで文と文に区切りをつけます。'
  prefs: []
  type: TYPE_NORMAL
- en: ソースコードとして書かれた文を上から処理していくことで、プログラムが実行されます。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: たとえば、if 文やfor 文などが**文**と呼ばれるものです。 次のように、文の処理の一部として式を含むことがあります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 一方、if 文などは文であり式にはなれません。
  prefs: []
  type: TYPE_NORMAL
- en: '**式**ではないため、if 文を変数へ代入することはできません。 次のようなコードは構文として問題があるため、構文エラー（`SyntaxError`）となります。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[](#expression-statement)*式文*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*一方で、**式**（Expression）は**文**（Statement）になれます。文となった式のことを**式文**と呼びます。 基本的に文が書ける場所には式を書けます。'
  prefs: []
  type: TYPE_NORMAL
- en: その際に、**式文**（Expression statement）は文の一種であるため、セミコロンで文を区切っています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 式は文になれますが、先ほどのif 文のように文は式になれ���せん。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#block-statement)*ブロック文*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*次のような、文を`{`と`}`で囲んだ部分を**ブロック**と言います。 ブロックには、複数の**文**が書けます。'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: ブロック文は単独でも書けますが、基本的にはif 文やfor 文など他の構文と組み合わせて書くことがほとんどです。 次のコードでは、if 文とブロック文を組み合わせることで、if
    文の処理内容に複数の文を書いています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 文の末尾にはセミコロンをつけるとしていましたが、 例外として**ブロックで終わる文**の末尾には、セミコロンが不要となっています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[](#isolate-block-statement)*[コラム] 単独のブロック文の活用*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*アプリケーションのソースコードにif 文などと組み合わせない単独のブロック文を書くことはほとんどありません。 しかし、REPLで同じコードの一部を変更して実行を繰り返している場合には、単独のブロック文が役に立つ機会もあります。'
  prefs: []
  type: TYPE_NORMAL
- en: REPLでは、次のように同じ変数名を再定義すると、構文エラーが発生します（詳細は「変数と宣言」の章の「`var`の問題」を参照）。 そのため、同じコードを再び実行するには、ブラウザでページをリロードして変数定義をリセットしないといけませんでした。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: この問題は単独のブロック文で変数定義を囲むことで回避できます。 ブロック文（`{}`）の中でletやconstを用いて変数を定義しても、そのブロック文の外には影響しません。
    そのため、次のようにブロック文で囲んでおけば、同じ変数名を定義しても構文エラー（`SyntaxError`）にはなりません。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: これは、ブロックスコープという仕組みによるものですが、詳しい仕組みについては「関数とスコープ」の章で解説します。 今は、ブロック文を使うとREPLでの試行錯誤がしやすいということだけ知っていれば問題ありません。
  prefs: []
  type: TYPE_NORMAL
- en: '[](#function-statement-and-function-expression)*関数宣言（文）と関数式*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*「関数と宣言」の章において、関数を定義する方法を学びました。 functionキーワードから文を開始する**関数宣言**と、変数へ**関数式**を代入する方法があります。'
  prefs: []
  type: TYPE_NORMAL
- en: 関数宣言（文）と関数式は、どちらも`function`というキーワードを利用しています。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: この文と式の違いを見ると、関数宣言文にはセミコロンがなく、関数式にはセミコロンがあります。 このような違いがなぜ生まれるのかは、ここまでの内容から説明できます。
  prefs: []
  type: TYPE_NORMAL
- en: 関数宣言（文）で定義した`learn`関数には、セミコロンがありません。 これは、**ブロックで終わる文**にはセミコロンが不要であるためです。
  prefs: []
  type: TYPE_NORMAL
- en: 一方、関数式を`read`変数へ代入したものには、セミコロンがあります。
  prefs: []
  type: TYPE_NORMAL
- en: 「ブロックで終わる関数であるためセミコロンが不要なのでは？」と思うかもしれません。
  prefs: []
  type: TYPE_NORMAL
- en: しかし、この無名関数は**式**であり、この処理は変数を宣言する文の一部であることがわかります。 つまり、次のように置き換えても同じと言えるため、末尾にセミコロンが必要となります。
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[](#statement-expression-summary)*まとめ*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*この章では次のことについて学びました。'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScriptは**文**（Statement）と**式**（Expression）から構成される
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 文は式になれない
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 式は文になれる（**式文**）
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 文の末尾にはセミコロンをつける
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ブロックで終わる文は例外的にセミコロンをつけなくてよい
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScriptには、特殊なルールに基づき、セミコロンがない文も行末に自動でセミコロンが挿入されるという仕組みがあります。 しかし、この仕組みは構文を正しく解析できない場合に、セミコロンを足すという挙動を持っています。
    これにより、意図しない挙動を生むことがあります。そのため、必ず**文**の末尾にはセミコロンを書くようにします。
  prefs: []
  type: TYPE_NORMAL
- en: エディターやIDEの中にはセミコロンの入力の補助をしてくれるものや、[ESLint](https://eslint.org/ "ESLint - Pluggable
    JavaScript linter")などのLintツールを使うことで、 セミコロンが必要なのかをチェックできます。
  prefs: []
  type: TYPE_NORMAL
- en: セミコロンが必要か見分けるにはある程度慣れが必要ですが、ツールを使って静的にチェックできます。 そのため、ツールなどの支援を受けて経験的に慣れていくこともよい方法と言えます。*******
  prefs: []
  type: TYPE_NORMAL
