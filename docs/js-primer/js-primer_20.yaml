- en: 配列
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 原文：[`jsprimer.net/basic/array/`](https://jsprimer.net/basic/array/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/array/`](https://jsprimer.net/basic/array/)
- en: 配列はJavaScriptの中でもよく使われるオブジェクトです。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是JavaScript中常用的对象。
- en: 配列とは値に順序をつけて格納できるオブジェクトです。 配列に格納したそれぞれの値のことを**要素**、それぞれの要素の位置のことを**インデックス**（`index`）と呼びます。
    インデックスは先頭の要素から`0`、`1`、`2`のように`0`からはじまる連番となります。
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是按顺序存储值的对象。数组中存储的每个值称为**元素**，每个元素的位置称为**索引**（`index`）。索引是从第一个元素开始的`0`、`1`、`2`等连续序列。
- en: またJavaScriptにおける配列は可変長です。 そのため配列を作成後に配列へ要素を追加したり、配列から要素を削除できます。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript中的数组是可变长的。因此，可以在创建数组后向数组中添加元素或从数组中删除元素。
- en: この章では、配列の基本的な操作と配列を扱う場合においてのパターンについて学びます。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将学习数组的基本操作以及处理数组时的模式。
- en: '*配列の作成とアクセス*'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*数组的创建与访问*'
- en: '*配列の作成と要素へのアクセス方法は「データ型とリテラル」の章ですでに紹介していますが、 もう一度振り返ってみましょう。'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然数组的创建和访问方法已在“数据类型与字面量”章节中介绍，但让我们再次回顾一下。'
- en: 配列の作成には配列リテラルを使います。 配列リテラル（`[`と`]`）の中に要素をカンマ（`,`）区切りで記述するだけです。
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的创建使用数组字面量。数组字面量（`[`和`]`）中用逗号（`,`）分隔的元素进行描述。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 作成した配列の要素のインデックスとなる数値を、`配列[インデックス]`と記述することで、 そのインデックスの要素を配列から読み取れます。 配列の先頭要素のインデックスは`0`となります。配列のインデックスは、`0`以上`2³²
    - 1`未満の整数となります。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将创建的数组元素的索引数值用`数组[索引]`这样的方式来描述，可以从数组中读取该索引的元素。数组的第一个元素的索引是`0`。数组的索引是`0`以上的整数，小于`2³²
    - 1`。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 2 次元配列（配列の配列）からの値の読み取りも同様に`配列[インデックス]`でアクセスできます。 `配列[0][0]`は、配列の`0`番目の要素である配列（`["a",
    "b"]`）の`0`番目の要素を読み取ります。
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`数组[索引]`从二维数组（数组中的数组）中读取值。`数组[0][0]`将读取数组中`0`号元素（`["a", "b"]`）的`0`号元素。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 配列の`length`プロパティは配列の要素の数を返します。 そのため、配列の最後の要素へアクセスするには `array.length - 1` をインデックスとして利用できます。
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`length`属性返回数组元素的个数。因此，要访问数组的最后一个元素，可以使用`array.length - 1`作为索引。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 一方、存在しないインデックスにアクセスした場合はどうなるでしょうか？ JavaScriptでは、存在しないインデックスに対してアクセスした場合に、例外ではなく`undefined`を返します。
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果访问不存在的索引，会发生什么？在JavaScript中，访问不存在的索引时，不会抛出异常，而是返回`undefined`。
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: これは、配列がオブジェクトであることを考えると、次のように存在しないプロパティへアクセスしているのと原理は同じです。 オブジェクトでも、存在しないプロパティへアクセスした場合には`undefined`が返ってきます。
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，考虑到数组是对象，所以访问不存在的属性与原理相同。对象在访问不存在的属性时，也会返回`undefined`。
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: また、配列は常に`length`の数だけ要素を持っているとは限りません。 次のように、配列リテラルでは値を省略することで、未定義の要素を含めることができます。
    このような、配列の中に隙間があるものを**疎な配列**と呼びます。 一方、隙間がなくすべてのインデックスに要素がある配列を**密な配列**と呼びます。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数组不一定总是包含`length`数量的元素。如下所示，在数组字面量中省略值可以包含未定义的元素。这种在数组中存在空隙的数组称为**稀疏数组**。另一方面，没有空隙且所有索引都有元素的数组称为**密集数组**。
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*[ES2022] `Array.prototype.at`*'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[ES2022] `Array.prototype.at`*'
- en: '*配列の要素にアクセスするには`配列[インデックス]`という構文を使うことを紹介しました。 その際に、配列の末尾の要素へアクセスするには、`array[array.length
    - 1]`という`length`プロパティを使う必要があります。 `array`を2 回書く必要があるなど、末尾の要素へのアクセスは少し手間が必要になっていました。'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*在介绍访问数组元素时，我们提到了使用`数组[索引]`这种结构。在这种情况下，要访问数组的最后一个元素，需要使用`array[array.length
    - 1]`，这需要使用`length`属性。访问最后一个元素稍微有些麻烦，因为需要两次写入`array`。'
- en: この問題を解決するためES2022では、相対的なインデックスの値を指定して配列の要素へアクセスできる`Array.prototype.at`メソッドが追加されました。
    Arrayの`at`メソッドは、`配列[インデックス]`とよく似ていますが、引数には相対的なインデックスの値を引数として渡せます。 `.at(0)`や`.at(1)`などのように0
    以上のインデックスを渡した場合は、`配列[インデックス]`と同じく指定した位置の要素へアクセスできます。 一方で、`.at(-1)`のようにマイナスのインデックスを渡した場合は、末尾から数えた位置の要素へアクセスできます。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，ES2022中添加了`Array.prototype.at`方法，可以通过指定相对索引值来访问数组元素。`Array`的`at`方法与`数组[索引]`类似，但可以传递相对索引值作为参数。例如，`.at(0)`或`.at(1)`，传递0以上的索引时，与`数组[索引]`一样，可以访问指定位置的元素。另一方面，`.at(-1)`等传递负索引时，可以访问从末尾开始计数的指定位置的元素。
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`配列[インデックス]`のインデックスに`-1`を指定すると、配列オブジェクトの`"-1"`というプロパティ名へのアクセスとなります。 そのため`配列[-1]`と書くと、大抵の場合は`undefined`が返されます。'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将`-1`指定给`数组[索引]`的索引时，将访问数组对象的`"-1"`属性。因此，`数组[-1]`通常将返回`undefined`。
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*オブジェクトが配列かどうかを判定する*'
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*判断对象是否为数组*'
- en: '*あるオブジェクトが配列かどうかを判定するには`Array.isArray`メソッドを利用します。 `Array.isArray`メソッドは引数が配列ならば`true`を返します。'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*要判断一个对象是否为数组，可以使用`Array.isArray`方法。`Array.isArray`方法如果参数是数组，则返回`true`。'
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: また、`typeof`演算子では配列かどうかを判定することはできません。 配列もオブジェクトの一種であるため、`typeof`演算子の結果が`"object"`となるためです。
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`typeof`运算符无法判断是否为数组。因为数组是对象的一种，所以`typeof`运算符的结果为`"object"`。
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*[コラム] [ES2015] TypedArray*'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[专栏] [ES2015] TypedArray*'
- en: '*JavaScriptの配列は可変長のみですが、`TypedArray`という固定長でかつ型つきの配列を扱う別のオブジェクトが存在します。 `TypedArray`はバイナリデータのバッファを示すために使われるデータ型で、WebGLやバイナリを扱う場面で利用されます。
    文字列や数値などのプリミティブ型の値を直接は利用できないため、通常の配列とは用途や使い勝手が異なります。'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript的数组是可变长的，但存在另一种名为`TypedArray`的对象，它具有固定长度和类型。`TypedArray`是用于表示二进制数据缓冲区的数据类型，在WebGL或处理二进制数据时使用。它不能直接使用字符串或数值等原始类型值，因此与普通数组的用途和易用性不同。'
- en: また、TypedArrayは`Array.isArray`のメソッドの結果が`false`となることからも別物と考えてよいでしょう。
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于`TypedArray`的`Array.isArray`方法的结果为`false`，因此可以将其视为另一种类型。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: そのため、JavaScriptで配列といった場合には`Array`を示します。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在JavaScript中提到数组时，应使用`Array`。
- en: '*[ES2015] 配列と分割代入*'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[ES2015] 数组与解构赋值*'
- en: '*配列の指定したインデックスの値を変数として定義し直す場合には、分割代入（Destructuring assignment）が利用できます。'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*在重新定义指定索引的值时，可以使用解构赋值（Destructuring assignment）。'
- en: 配列の分割代入では、左辺に配列リテラルのような構文で定義したい変数名を書きます。 右辺の配列から対応するインデックスの要素が、左辺で定義した変数に代入されます。
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组解构赋值中，在左边用类似数组字面量的结构定义要设置的变量名。右边的数组中相应索引的元素将被赋值到左边定义的变量中。
- en: 次のコードでは、左辺に定義した変数に対して、右辺の配列から対応するインデックスの要素が代入されます。 `first`にはインデックスが`0`の要素、`second`にはインデックスが`1`の要素、`third`にはインデックスが`2`の要素が代入されます。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，将左边的变量与右边的数组中相应索引的元素进行赋值。`first`将赋值为索引为`0`的元素，`second`将赋值为索引为`1`的元素，`third`将赋值为索引为`2`的元素。
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*[コラム] undefinedの要素と未定義の要素の違い*'
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[专栏] undefined的元素与未定义的元素的区别*'
- en: '*疎な配列で該当するインデックスに要素がない場合は`undefined`を返します。 しかし、`undefined`という値も存在するため、配列に`undefined`という値がある場合に区別できません。'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*在稀疏数组中，如果对应的索引没有元素，则返回`undefined`。但是，也存在`undefined`这个值，因此当数组中存在`undefined`值时，无法区分。'
- en: 次のコードでは、`undefined`という値を要素として定義した密な配列と、要素そのものがない疎な配列を定義しています。 どちらも要素にアクセスした結果は`undefined`となり、区別できていないことがわかります。
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，定义了一个包含`undefined`值的密集数组和一个没有元素的稀疏数组。两者访问元素的结果都是`undefined`，无法区分。
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 可以使用的区别方法是`Object.hasOwn`静态方法。 使用`Object.hasOwn`静态方法，可以确定数组对象在指定索引处是否存在元素。
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的区别方法是`Object.hasOwn`静态方法。 使用`Object.hasOwn`静态方法，可以确定数组对象在指定索引处是否存在元素。
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*从数组中搜索元素*'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*从数组中搜索元素*'
- en: '*主要有以下三种目的来搜索数组中的元素。'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*主要有以下三种目的来搜索数组中的元素。'
- en: 如果需要该元素的索引
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要该元素的索引
- en: 如果需要元素本身
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要元素本身
- en: 如果需要该元素是否包含在数组中的布尔值
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要该元素是否包含在数组中的布尔值
- en: 由于数组提供了相应的方法，因此可以按目的查看。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组提供了相应的方法，因此可以按目的查看。
- en: '*获取索引*'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*获取索引*'
- en: '*如果想知道指定元素在数组中的位置，可以使用 Array 的`indexOf`方法或`findIndex`方法^([ES2015])。 位置的概念称为**索引**（`index`），因此方法名称中也包含`index`。'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果想知道指定元素在数组中的位置，可以使用 Array 的`indexOf`方法或`findIndex`方法^([ES2015])。 位置的概念称为**索引**（`index`），因此方法名称中也包含`index`。'
- en: 下面的代码使用 Array 的`indexOf`方法，从数组中检索字符串`"JavaScript"`的索引。 `indexOf`方法从头开始搜索与参数和严格等式操作符（`===`）匹配的元素，并返回匹配元素的索引；如果没有匹配的元素，则返回`-1`。
    与`indexOf`方法相对应的是`lastIndexOf`方法，它从末尾开始搜索匹配结果。
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用 Array 的`indexOf`方法，从数组中检索字符串`"JavaScript"`的索引。 `indexOf`方法从头开始搜索与参数和严格等式操作符（`===`）匹配的元素，并返回匹配元素的索引；如果没有匹配的元素，则返回`-1`。
    与`indexOf`方法相对应的是`lastIndexOf`方法，它从末尾开始搜索匹配结果。
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`indexOf`方法可以发现数组中的原始元素，但如果对象具有相同的属性，则会被视为不同的对象。 看下面的代码，具有相同属性的不同对象无法使用`indexOf`方法找到。
    这是因为具有不同引用的对象之间即使使用`===`比较也不会相等。'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`方法可以发现数组中的原始元素，但如果对象具有相同的属性，则会被视为不同的对象。 看下面的代码，具有相同属性的不同对象无法使用`indexOf`方法找到。
    这是因为具有不同引用的对象之间即使使用`===`比较也不会相等。'
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 因此，如果想要找到不同对象但值相同的对象，则可以使用 Array 的`findIndex`方法。 将数组的每个元素作为回调函数传递给`findIndex`方法，与`indexOf`方法不同，可以自由编写测试代码。
    这样，就可以从数组中找到具有相同属性值的元素，并获取其索引。
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果想要找到不同对象但值相同的对象，则可以使用 Array 的`findIndex`方法。 将数组的每个元素作为回调函数传递给`findIndex`方法，与`indexOf`方法不同，可以自由编写测试代码。
    这样，就可以从数组中找到具有相同属性值的元素，并获取其索引。
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Array 的`findIndex`方法也有对应的`findLastIndex`方法^([ES2023])，`findLastIndex`方法返回从末尾搜索的结果。
    如下，`findIndex`返回匹配条件的第一个元素的索引，而`findLastIndex`返回最后一个元素的索引。
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Array 的`findIndex`方法也有对应的`findLastIndex`方法^([ES2023])，`findLastIndex`方法返回从末尾搜索的结果。
    如下，`findIndex`返回匹配条件的第一个元素的索引，而`findLastIndex`返回最后一个元素的索引。
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*获取匹配条件的元素*'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*获取匹配条件的元素*'
- en: '*作为从数组中获取元素的方法，也可以使用索引。 只需使用`findIndex`方法获取索引，然后使用该索引访问数组即可。'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为从数组中获取元素的方法，也可以使用索引。 只需使用`findIndex`方法获取索引，然后使用该索引访问数组即可。'
- en: 但是，在使用`findIndex`方法获取元素的情况下，不清楚是要获取索引还是要获取元素本身。
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在使用`findIndex`方法获取元素的情况下，不清楚是要获取索引还是要获取元素本身。
- en: 要更明确地表示需要元素本身，可以使用 Array 的`find`方法^([ES2015])。 将测试函数作为回调函数传递给`find`方法，`find`方法的返回值将是该元素本身，如果元素不存在，则返回`undefined`。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要更明确地表示需要元素本身，可以使用 Array 的`find`方法^([ES2015])。 将测试函数作为回调函数传递给`find`方法，`find`方法的返回值将是该元素本身，如果元素不存在，则返回`undefined`。
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 也有与`find`方法对应的`findLast`方法^([ES2023])，`findLast`方法返回从末尾搜索的结果。 如下，`find`返回第一个匹配条件的元素，而`findLast`返回最后一个元素。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也有与`find`方法对应的`findLast`方法^([ES2023])，`findLast`方法返回从末尾搜索的结果。 如下，`find`返回第一个匹配条件的元素，而`findLast`返回最后一个元素。
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*获取指定范围的元素*'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*获取指定范围的元素*'
- en: '*作为从数组中获取指定范围元素的方法，可以使用 Array 的`slice`方法。 `slice`方法从第一个参数的起始位置到第二个参数的结束位置（不包括结束位置的元素）提取一个新数组。
    第二个参数是可选的，如果省略，则返回包含从数组末尾到末尾的元素的新数组。'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为从数组中获取指定范围元素的方法，可以使用 Array 的`slice`方法。 `slice`方法从第一个参数的起始位置到第二个参数的结束位置（不包括结束位置的元素）提取一个新数组。
    第二个参数是可选的，如果省略，则返回包含从数组末尾到末尾的元素的新数组。'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 将`slice`方法与参数关联的关系如下图所示。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将`slice`方法与参数关联的关系如下图所示。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*获取布尔值*'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*获取布尔值*'
- en: '*最后，让我们看看如何知道指定的元素是否包含在数组中。 如果可以获取索引或元素，则可以知道该元素是否包含在数组中。'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后，让我们看看如何知道指定的元素是否包含在数组中。 如果可以获取索引或元素，则可以知道该元素是否包含在数组中。'
- en: 但是，如果只想知道指定元素是否**仅仅**包含在其中，Array 的`findIndex`方法或`find`方法就具有过多的功能。 这使得阅读代码的人无法明确获取的索引或元素的用途。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果只想知道指定元素是否**仅仅**包含在其中，Array 的`findIndex`方法或`find`方法就具有过多的功能。 这使得阅读代码的人无法明确获取的索引或元素的用途。
- en: 下面的代码使用 Array 的`indexOf`方法来检查数组中是否包含指定的元素。 将`indexOf`方法的结果分配给`indexOfJS`，但除了检查是否包含外，没有其他用途。
    必须完全阅读代码，才能明确意图，这导致代码的可读性不佳。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码使用 Array 的`indexOf`方法来检查数组中是否包含指定的元素。 将`indexOf`方法的结果分配给`indexOfJS`，但除了检查是否包含外，没有其他用途。
    必须完全阅读代码，才能明确意图，这导致代码的可读性不佳。
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 因此，可以使用 ES2016 引入的 Array 的`includes`方法^([ES2016])。 Array 的`includes`方法判断数组是否包含指定元素。
    由于`includes`方法返回布尔值，因此与使用`indexOf`方法相比，意图更明确。 在前述代码中，应该使用`includes`方法，如下所示。
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以使用 ES2016 引入的 Array 的`includes`方法^([ES2016])。 Array 的`includes`方法判断数组是否包含指定元素。
    由于`includes`方法返回布尔值，因此与使用`indexOf`方法相比，意图更明确。 在前述代码中，应该使用`includes`方法，如下所示。
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`includes`方法与`indexOf`方法类似，不能找到具有相同值但不同对象的对象。 要使用类似于 Array 的`find`方法的测试回调函数来获取布尔值，可以使用
    Array 的`some`方法。'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes`方法与`indexOf`方法类似，不能找到具有相同值但不同对象的对象。 要使用类似于 Array 的`find`方法的测试回调函数来获取布尔值，可以使用
    Array 的`some`方法。'
- en: Array 的`some`方法会检查回调函数是否有匹配的元素，如果有则返回`true`，否则返回`false`（参见“循环和迭代”章节）。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Array 的`some`方法会检查回调函数是否有匹配的元素，如果有则返回`true`，否则返回`false`（参见“循环和迭代”章节）。
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*添加和删除*'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*添加和删除*'
- en: '*由于数组是可变长度的，因此可以添加或删除元素到创建后的数组。'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于数组是可变长度的，因此可以添加或删除元素到创建后的数组。'
- en: 若要将元素添加到数组末尾，可以使用 Array 的`push`。 反之，要从末尾删除元素，可以使用 Array 的`pop`。
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将元素添加到数组末尾，可以使用 Array 的`push`。 反之，要从末尾删除元素，可以使用 Array 的`pop`。
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 要素を配列の先頭へ追加するにはArrayの`unshift`が利用できます。 一方、配列の先頭から要素を削除するにはArrayの`shift`が利用できます。
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要素を配列の先頭へ追加するにはArrayの`unshift`が利用できます。 一方、配列の先頭から要素を削除するにはArrayの`shift`が利用できます。
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*配列同士を結合*'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*配列同士を結合*'
- en: '*Arrayの`concat`メソッドを使うことで配列と配列を結合した新しい配列を作成できます。'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arrayの`concat`メソッドを使うことで配列と配列を結合した新しい配列を作成できます。'
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: また、`concat`メソッドは配列だけではなく任意の値を要素として結合できます。
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: また、`concat`メソッドは配列だけではなく任意の値を要素として結合できます。
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*[ES2015] 配列の展開*'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[ES2015] 配列の展開*'
- en: '*`...`（Spread 構文）を使うことで、配列リテラル中に既存の配列を展開できます。'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*`...`（Spread 構文）を使うことで、配列リテラル中に既存の配列を展開できます。'
- en: 次のコードでは、配列リテラルの末尾に配列を展開しています。 これは、Arrayの`concat`メソッドで配列同士を結合するのと同じ結果になります。
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 次のコードでは、配列リテラルの末尾に配列を展開しています。 これは、Arrayの`concat`メソッドで配列同士を結合するのと同じ結果になります。
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Spread 構文は、`concat`メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。 そのため、次のように要素の途中に配列を展開できます。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Spread 構文は、`concat`メソッドとは異なり、配列リテラル中の任意の位置に配列を展開できます。 そのため、次のように要素の途中に配列を展開できます。
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*[ES2019] 配列をフラット化*'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[ES2019] 配列をフラット化*'
- en: '*Arrayの`flat`メソッド^([ES2019])を使うことで、多次元配列をフラットな配列に変換できます。 引数を指定しなかった場合は1 段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
    配列をすべてフラット化する場合には、無限を意味する`Infinity`を値として渡すことで実現できます。'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*Arrayの`flat`メソッド^([ES2019])を使うことで、多次元配列をフラットな配列に変換できます。 引数を指定しなかった場合は1 段階のみのフラット化ですが、引数に渡す数値でフラット化する深さを指定できます。
    配列をすべてフラット化する場合には、無限を意味する`Infinity`を値として渡すことで実現できます。'
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: また、Arrayの`flat`メソッドは必ず新しい配列を作成して返すメソッドです。 そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: また、Arrayの`flat`メソッドは必ず新しい配列を作成して返すメソッドです。 そのため、これ以上フラット化できない配列をフラット化しても、同じ要素を持つ新しい配列を返します。
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*配列から要素を削除*'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*配列から要素を削除*'
- en: '*### *`Array.prototype.splice`*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*### *`Array.prototype.splice`*'
- en: '*配列の先頭や末尾の要素を削除する場合はArrayの`shift`メソッドや`pop`メソッドで行えます。 しかし、配列の任意のインデックスの要素を削除できません。
    配列の任意のインデックスの要素を削除するにはArrayの`splice`メソッドを利用できます。'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*要删除数组的开头或结尾元素，可以使用Array的`shift`方法或`pop`方法。但是，无法删除任意索引处的元素。要删除任意索引处的元素，请使用Array的`splice`方法。*'
- en: '`splice`メソッドを利用すると、削除した要素を自動で詰めることができます。 `splice`メソッドは指定したインデックスから、指定した数だけ要素を取り除き、必要ならば要素を同時に追加できます。'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`splice`方法可以自动填充删除的元素。`splice`方法可以从指定的索引处删除指定数量的元素，并在必要时添加元素。
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: たとえば、配列のインデックスが`1`の要素を削除するには、インデックス`1`から`1`つの要素を削除するという指定をする必要があります。 このとき、削除した要素は自動で詰められるため、疎な配列にはなりません。
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要删除索引为`1`的元素，需要指定从索引`1`开始删除一个元素。这时，删除的元素会自动填充，因此不会变成稀疏数组。
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*`length`プロパティへの代入*'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`length`属性赋值*'
- en: '*配列のすべての要素を削除することはArrayの`splice`で行えますが、 配列の`length`プロパティへの代入を利用した方法もあります。'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以通过Array的`splice`方法删除所有元素，也可以通过将`length`属性赋值为元素数的方法来实现。*'
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 配列の`length`プロパティへ`要素数`を代入すると、その要素数に配列が切り詰められます。 つまり、`length`プロパティへ`0`を代入すると、インデックスが`0`以降の要素がすべて削除されます。
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将`length`属性赋值为元素数时，数组会被截断到该元素数。也就是说，将`length`属性赋值为`0`时，索引为`0`及以上的所有元素都会被删除。
- en: '*空の配列を代入*'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*空数组赋值*'
- en: '*最後に、その配列の要素を削除するのではなく、新しい空の配列を変数へ代入する方法です。 次のコードでは、`array`変数に空の配列を代入することで、`array`に空の配列を参照させられます。'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*最后，不是删除数组的元素，而是将新的空数组赋值给变量。下面的代码中，通过将空数组赋值给`array`变量，使`array`引用空数组。*'
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 元々、`array`変数が参照していた`[1, 2, 3]`はどこからも参照されなくなり、ガベージコレクションによりメモリから解放されます。
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 原本`array`变量引用的`[1, 2, 3]`不再被任何地方引用，将通过垃圾回收从内存中释放。
- en: ���た、`const`で宣言した配列の場合は変数に対して再代入できないため、この手法は使えません。 そのため、再代入をしたい場合は`let`または`var`で変数宣言をする必要があります。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`const`声明了数组，则无法对变量进行重新赋值，因此这种方法不可用。因此，如果需要重新赋值，则需要使用`let`或`var`声明变量。
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*破壊的なメソッドと非破壊的なメソッド*'
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*破坏性方法与非破坏性方法*'
- en: '*これまで紹介してきた配列を変更するメソッドには、破壊的なメソッドと非破壊的メソッドがあります。 この破壊的なメソッドと非破壊的メソッドの違いを知ることは、意図しない結果を避けるために重要です。'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*介绍过的修改数组的方法有破坏性方法和非破坏性方法。了解这两种方法的区别对于避免意外结果非常重要。*'
- en: 破壊的なメソッド（Mutable Method）とは、配列オブジェクトそのものを変更し、変更した配列または変更箇所を返すメソッドです。 非破壊的メソッド（Immutable
    Method）とは、配列オブジェクトのコピーを作成してから変更し、そのコピーした配列を返すメソッドです。
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏性方法（可变方法）是指修改数组对象本身并返回修改后的数组或修改部分的函数。非破坏性方法（不可变方法）是指在创建数组对象的副本后进行修改，并返回该副本的函数。
- en: 破壊的なメソッドの例として、配列に要素を追加するArrayの`push`メソッドがあります。 `push`メソッドは、`myArray`の配列そのものへ要素を追加しています。
    その結果`myArray`変数の参照する配列が変更されるため破壊的なメソッドです。
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为破坏性方法的例子，有向数组中添加元素的Array的`push`方法。`push`方法向`myArray`的数组本身添加元素。因此，`myArray`变量引用的数组会改变，所以这是一个破坏性方法。
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 非破壊的なメソッドの例として、配列に要素を結合するArrayの`concat`メソッドがあります。 `concat`メソッドは、`myArray`をコピーした配列に対して要素を結合し、その配列を返します。
    `myArray`変数の参照する配列は変更されないため非破壊的なメソッドです。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为非破坏性方法的例子，有Array的`concat`方法。`concat`方法会复制`myArray`的数组并添加元素，然后返回这个新数组。由于`myArray`变量引用的数组没有改变，所以这是一个非破坏性方法。
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: JavaScriptにおいて破壊的なメソッドと非破壊的メソッドを名前から見分けるのは難しいという問題があります。 また、配列を返す破壊的なメソッドもあるため、返り値からも判別できません。
    たとえば、Arrayの`sort`メソッドは返り値がソート済みの配列ですが破壊的メソッドです。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，从名称上区分破坏性方法和非破坏性方法比较困难。此外，有些返回数组的破坏性方法，从返回值也无法区分。例如，Array的`sort`方法返回排序后的数组，但它是破坏性方法。
- en: 次の表で紹介するメソッドは破壊的なメソッドです。
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下表中介绍的这些方法是破坏性方法。
- en: '| メソッド名 | 返り値 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 方法名 | 返回值 |'
- en: '| --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | 配列の末尾の値 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | 数组的最后一个值 |'
- en: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | 変更後の配列のlength |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | 变更后的数组的length |'
- en: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | 取り除かれた要素を含む配列 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | 包含被删除元素的数组 |'
- en: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | 反転した配列 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | 反转后的数组 |'
- en: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | 数组的第一个值 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | 数组的第一个值 |'
- en: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | 排序后的数组 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | 排序后的数组 |'
- en: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | 修改后的数组的长度 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | 修改后的数组的长度 |'
- en: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 修改后的数组 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 修改后的数组 |'
- en: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 修改后的数组 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 修改后的数组 |'
- en: 由于破坏性方法可能会产生意外的副作用，因此使用时需要注意。 例如，如果想要提供一种从数组中删除特定索引处元素的函数`removeAtIndex`，就需要注意这一点。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于破坏性方法可能会产生意外的副作用，因此使用时需要注意。例如，如果想要提供一个从数组中删除特定索引处元素的函数`removeAtIndex`，就需要注意这一点。
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 使用破坏性方法删除数组中的元素时，如使用`splice`方法，将会影响作为参数传递的数组。 在这种情况下，因`removeAtIndex`函数具有副作用，因此对其具有破坏性的特性进行注释是有益的。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用破坏性方法删除数组中的元素时，例如使用`splice`方法，将会影响作为参数传递的数组。 在这种情况下，因`removeAtIndex`函数具有副作用，因此对其具有破坏性的特性进行注释是有益的。
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 另一方面，非破坏性方法会创建数组的副本，因此对原始数组没有影响。 要将此`removeAtIndex`函数变为非破坏性函数，需要将接收到的数组复制一份，然后进行更改。
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，非破坏性方法会创建数组的副本，因此对原始数组没有影响。 要将此`removeAtIndex`函数变为非破坏性函数，需要将接收到的数组复制一份，然后进行更改。
- en: JavaScript 中没有`copy`方法本身，但常用的数组复制方法是使用 Array 的`slice`方法和`concat`方法。 当不带参数调用`slice`方法和`concat`方法时，它们会返回该数组的副本。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中没有`copy`方法本身，但常用的数组复制方法是使用 Array 的`slice`方法和`concat`方法。 当不带参数调用`slice`方法和`concat`方法时，它们会返回该数组的副本。
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 通过对复制的数组进行更改，可以将`removeAtIndex`函数实现为非破坏性函数。 由于非破坏性函数不会对参数数组产生副作用，因此不需要提醒注释。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对复制的数组进行更改，可以将`removeAtIndex`函数实现为非破坏性函数。 由于非破坏性函数不会对参数数组产生副作用，因此不需要提醒注释。
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 这样，JavaScript 数组中存在破坏性和非破坏性方法。 由于名称上的区分困难，并且为了避免副作用，人们通常会创建副本然后使用破坏性方法。
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，JavaScript 数组中存在破坏性和非破坏性方法。 由于名称上的区分困难，并且为了避免副作用，人们通常会创建副本然后使用破坏性方法。
- en: 然而，ES2023 添加了一些变化以改进这种情况。 目前，仅有破坏性方法的`splice`、`reverse`和`sort`，现在也有了非破坏性版本，分别为`toSpliced`、`toReversed`和`toSorted`。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ES2023 添加了一些变化以改进这种情况。 目前，仅有破坏性方法的`splice`、`reverse`和`sort`，现在也有了非破坏性版本，分别为`toSpliced`、`toReversed`和`toSorted`。
- en: 以`to`开头的这些非破坏性方法接收与破坏性方法相同的参数，但它们返回的是经过非破坏性更改的数组。 下面的`toSpliced`方法示例表明，由于它复制了数组然后进行了更改，所以原始数组`array`没有受到影响。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以`to`开头的这些非破坏性方法接收与破坏性方法相同的参数，但它们返回的是经过非破坏性更改的数组。 下面的`toSpliced`方法示例表明，由于它复制了数组然后进行了更改，所以原始数组`array`没有受到影响。
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 在前面的`removeAtIndex`函数实现中，我们使用`slice`方法复制数组，然后调用`splice`方法。 下面的代码使用`toSpliced`方法更简洁地实现了非破坏性的`removeAtIndex`函数。
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`removeAtIndex`函数实现中，我们使用`slice`方法复制数组，然后调用`splice`方法。 下面的代码使用`toSpliced`方法更简洁地实现了非破坏性的`removeAtIndex`函数。
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 此外，ES2023 还引入了用于非破坏性地更改数组中指定索引元素的`with`方法。 `array[index] = value`的赋值操作本身是一种破坏性操作，而`with`方法是一种非破坏性方法，它复制数组然后更改指定索引的元素并返回该数组。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ES2023 还引入了用于非破坏性地更改数组中指定索引元素的`with`方法。 `array[index] = value`的赋值操作本身是一种破坏性操作，而`with`方法是一种非破坏性方法，它复制数组然后更改指定索引的元素并返回该数组。
- en: '[PRE47]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 下表总结了破坏性方法对应的非破坏性方法。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了破坏性方法对应的非破坏性方法。
- en: '| 破坏性方法 | 非破坏性方法 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 破坏性方法 | 非破坏性方法 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `array[index] = item` | [`Array.prototype.with`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/with)^([ES2023])
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `array[index] = item` | [`Array.prototype.with`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/with)^([ES2023])
    |'
- en: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | [`array.slice(0, -1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)和[`array.at(-1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.pop`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/pop)
    | [`array.slice(0, -1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)和[`array.at(-1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
- en: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | `[...array, item]`^([ES2015]) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.push`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
    | `[...array, item]`^([ES2015]) |'
- en: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | [`Array.prototype.toSpliced`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced)^([ES2023])
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.splice`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)
    | [`Array.prototype.toSpliced`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSpliced)^([ES2023])
    |'
- en: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | [`Array.prototype.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed)^([ES2023])
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.reverse`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)
    | [`Array.prototype.toReversed`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toReversed)^([ES2023])
    |'
- en: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | [`Array.prototype.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)^([ES2023])
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.sort`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
    | [`Array.prototype.toSorted`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toSorted)^([ES2023])
    |'
- en: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | [`array.slice(1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)和[`array.at(0)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.shift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/shift)
    | [`array.slice(1)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)和[`array.at(0)`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/at)^([ES2022])
    |'
- en: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | `[item, ...array]`^([ES2015]) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.unshift`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift)
    | `[item, ...array]`^([ES2015]) |'
- en: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 无 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| [`Array.prototype.copyWithin`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)^([ES2015])
    | 无 |'
- en: '| [`Array.prototype.fill`](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 无 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| [Array.prototype.fill](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)^([ES2015])
    | 无 |'
- en: 破坏性方法虽然简单，但会改变原始数组，可能会导致意外的副作用和错误。 非破坏性方法需要谨慎使用，但不会改变原始数组，因此不会产生副作用。
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏性方法虽然简单，但会改变原始数组，可能会导致意外的副作用和错误。 非破坏性方法需要谨慎使用，但不会改变原始数组，因此不会产生副作用。
- en: 因此，首先考虑使用非破坏性方法，如果不行的话，可以考虑使用破坏性方法。
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先考虑使用非破坏性方法，如果不行的话，可以考虑使用破坏性方法。
- en: '*数组迭代方法*'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*数组迭代方法*'
- en: '*在“Loop and Iteration”章节中，我们部分介绍了对数组进行迭代处理的方法，现在让我们重新看一下相关的 Array 方法。 `forEach`、`map`、`filter`、`reduce`方法是迭代处理中经常使用的。
    这些方法都需要一个回调函数作为参数，因此被称为高阶函数。'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*在“循环与迭代”章节中，我们部分介绍了对数组进行迭代处理的方法，现在让我们重新看一下相关的 Array 方法。 `forEach`、`map`、`filter`、`reduce`方法是迭代处理中经常使用的。
    这些方法都需要一个回调函数作为参数，因此被称为高阶函数。*'
- en: '*`Array.prototype.forEach`*'
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`Array.prototype.forEach`*'
- en: '*Array 的`forEach`方法会按顺序将数组元素传递给回调函数，进行迭代处理的方法。*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array 的`forEach`方法会按顺序将数组元素传递给回调函数，进行迭代处理的方法。*'
- en: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '*`Array.prototype.map`*'
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`Array.prototype.map`*'
- en: '*Array 的`map`方法会按顺序将数组元素传递给回调函数，并返回一个新数组，其中包含回调函数返回的值。 这是一个非破坏性方法，用于处理数组的每个元素。'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array 的`map`方法会按顺序将数组元素传递给回调函数，并返回一个新数组，其中包含回调函数返回的值。 这是一个非破坏性方法，用于处理数组的每个元素。*'
- en: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。 `map`方法的返回值是一个包含每个回调函数返回值的新数组。
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。 `map`方法的返回值是一个包含每个回调函数返回值的新数组。
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '*`Array.prototype.filter`*'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`Array.prototype.filter`*'
- en: '*Array 的`filter`方法会按顺序将数组元素传递给回调函数，返回回调函数返回`true`的元素组成的新数组。 这是一个非破坏性方法，用于创建一个新数组，其中包含从数组中删除不需要的元素。'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array 的`filter`方法会按顺序将数组元素传递给回调函数，返回回调函数返回`true`的元素组成的新数组。 这是一个非破坏性方法，用于创建一个新数组，其中包含从数组中删除不需要的元素。*'
- en: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。 `filter`方法的返回值是回调函数返回`true`的元素组成的新数组。
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的参数是`element, index, array`，它会从数组的第一个元素开始依次进行迭代处理。 `filter`方法的返回值是回调函数返回`true`的元素组成的新数组。
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '*`Array.prototype.reduce`*'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`Array.prototype.reduce`*'
- en: '*Array 的`reduce`方法会累加器和数组元素依次传递给回调函数，并返回一个累加器。 当你想要从数组中创建一个不包含数组的任意值时，可以使用它。'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*Array 的`reduce`方法会累加器和数组元素依次传递给回调函数，并返回一个累加器。 当你想要从数组中创建一个不包含数组的任意值时，可以使用它。*'
- en: 与之前介绍的迭代处理方法不同，回调函数的参数是`accumulator, element, index, array`。 你可以在`reduce`方法的第二个参数中传递一个初始值给`accumulator`。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前介绍的迭代处理方法不同，回调函数的参数是`accumulator, element, index, array`。 你可以在`reduce`方法的第二个参数中传递一个初始值给`accumulator`。
- en: 在下面的代码中，`reduce`方法将数组的每个元素相加并返回一个数字作为累加器的初始值。也就是说，它返回了数组元素的总和作为一个 Number 类型的值。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`reduce`方法将数组的每个元素相加并返回一个数字作为累加器的初始值。也就是说，它返回了数组元素的总和作为一个 Number 类型的值。
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 传递给`reduce`方法的回调函数会被调用 3 次，每次都会传递以下参数，并产生以下结果。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`reduce`方法的回调函数会被调用 3 次，每次都会传递以下参数，并产生以下结果。
- en: '|  | accumulator | currentValue | 返回的值 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  | accumulator | currentValue | 返回的值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 第一次调用 | 0 | 1 | 0 + 1 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 第一次调用 | 0 | 1 | 0 + 1 |'
- en: '| 第二次调用 | 1 | 2 | 1 + 2 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 第二次调用 | 1 | 2 | 1 + 2 |'
- en: '| 第三次调用 | 3 | 3 | 3 + 3 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 第三次调用 | 3 | 3 | 3 + 3 |'
- en: Array 的`reduce`方法稍微复杂一些，但它具有从数组创建非数组数据类型值的功能。 此外，由于`reduce`方法可以直接从数组返回 Number
    类型的值，因此在声明了无法重新赋值的`const`变量`totalValue`。
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Array 的`reduce`方法稍微复杂一些，但它具有从数组创建非数组数据类型值的功能。 此外，由于`reduce`方法可以直接从数组返回 Number
    类型的值，因此在声明了无法重新赋值的`const`变量`totalValue`。
- en: 使用`forEach`方法等迭代处理计算数组数字总和时，需要使用`let`声明的变量`totalValue`以便重新赋值。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`forEach`方法等迭代处理计算数组数字总和时，需要使用`let`声明的变量`totalValue`以便重新赋值。
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 因为使用`let`声明的变量可以重新赋值，所以变量的值可能会在意外的地方更改，从而导致错误。 因此，在可能的情况下，最好使用`const`声明变量。 在这种情况下，`reduce`方法非常有用。
    另一方面，`reduce`方法的可读性不太好，这可能会导致代码意图不明确。
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因为使用`let`声明的变量可以重新赋值，所以变量的值可能会在意外的地方更改，从而导致错误。 因此，在可能的情况下，最好使用`const`声明变量。 在这种情况下，`reduce`方法非常有用。
    另一方面，`reduce`方法的可读性不太好，这可能会导致代码意图不明确。
- en: 虽然`reduce`方法具有优点和可读性的折衷，但在使用时需要注意确保代码清晰易懂。 尤其是在处理`reduce`方法时，应该通过函数封装来明确处理意图。
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`reduce`方法具有优点和可读性的折衷，但在使用时需要注意确保代码清晰易懂。 尤其是在处理`reduce`方法时，应该通过函数封装来明确处理意图。
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*[专栏] 类似数组对象*'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[专栏] 类似数组对象*'
- en: '*类似数组的对象称为**Array-like 对象**。Array-like 对象可以像数组一样通过索引进行访问，并且像数组一样具有`length`属性。但是，它不是数组的实例，因此指的是不具有数组原型方法的对象。'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*类似数组的对象称为**Array-like 对象**。Array-like 对象可以像数组一样通过索引进行访问，并且像数组一样具有`length`属性。但是，它不是数组的实例，因此指的是不具有数组原型方法的对象。*'
- en: '| 功能 | 类似数组对象 | 数组 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 功能 | 类似数组对象 | 数组 |'
- en: '| --- | --- | --- |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 索引访问（`array[0]`） | 可以 | 可以 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 索引访问（`array[0]`） | 可以 | 可以 |'
- en: '| 长度（`array.length`） | 拥有 | 拥有 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 长度（`array.length`） | 拥有 | 拥有 |'
- en: '| Array 原型方法（如`forEach`方法等） | 有时没有 | 有 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Array 原型方法（如`forEach`方法等） | 有时没有 | 有 |'
- en: 类似数组对象的例子包括`arguments`。 `arguments`对象是可以从`function`声明的函数中引用的变量。 `arguments`对象按顺序存储传递给函数的参数值，并且可以像数组一样访问参数。
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 类似数组对象的例子包括`arguments`。 `arguments`对象是可以从`function`声明的函数中引用的变量。 `arguments`对象按顺序存储传递给函数的参数值，并且可以像数组一样访问参数。
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Array-like 对象还是数组可以通过使用`Array.isArray`方法来判断。 `Array-like`对象不是数组，所以结果始终为`false`。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Array-like 对象还是数组可以通过使用`Array.isArray`方法来判断。 `Array-like`对象不是数组，所以结果始终为`false`。
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Array-like 对象是一种看起来像数组但不是数组的对象。 使用`Array.from`方法^([ES2015])可以将 Array-like 对象转换为数组以进行处理。
    一旦转换为数组，就可以使用 Array 方法。
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Array-like 对象是一种看起来像数组但不是数组的对象。 使用`Array.from`方法^([ES2015])可以将 Array-like 对象转换为数组以进行处理。
    一旦转换为数组，就可以使用 Array 方法。
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*方法链与高阶函数*'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*方法链与高阶函数*'
- en: '*数组经常使用方法链的模式。 方法链是指对调用方法的返回值进行进一步的方法调用的模式。'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*数组经常使用方法链的模式。 方法链是指对调用方法的返回值进行进一步的方法调用的模式。*'
- en: 在下面的代码中，对 Array 的`concat`方法的返回值，也就是对数组进一步调用`concat`方法的方法链进行了处理。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，对 Array 的`concat`方法的返回值，也就是对数组进一步调用`concat`方法的方法链进行了处理。
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 将这段代码中的`concat`方法调用拆分开来可以更容易理解正在发生的事情。 `concat`方法的返回值是合并的新数组。在之前的方法链中，可以看到正在对该新数组进行进一步的值合并，使用`concat`方法。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码中的`concat`方法调用拆分开来可以更容易理解正在发生的事情。 `concat`方法的返回值是合并的新数组。在之前的方法链中，可以看到正在对该新数组进行进一步的值合并，使用`concat`方法。
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 使用方法链可以使处理过程更简洁。 尽管使用方法链的最终处理结果与其他方式相同，但可以省略中间的临时变量。 在上面的示例中，方法链中省略了名为`abArray`的临时变量。
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链可以使处理过程更简洁。 尽管使用方法链的最终处理结果与其他方式相同，但可以省略中间的临时变量。 在上面的示例中，方法链中省略了名为`abArray`的临时变量。
- en: 方法链不仅限于数组，但在数组中常见。 这是因为在显示数组数据时，通常需要将其处理为其他数据类型，如字符串或数字。 由于数组实现了许多返回数组的高阶函数，因此可以灵活处理数组。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链不仅限于数组，但在数组中常见。 这是因为在显示数组数据时，通常需要将其处理为其他数据类型，如字符串或数字。 由于数组实现了许多返回数组的高阶函数，因此可以灵活处理数组。
- en: 下面的代码定义了一个名为`ECMAScriptVersions`的数组，其中包含了 ECMAScript 的版本名称和发布年份。 假设我们要从该数组中提取`2000`年以前发行的
    ECMAScript 版本名称列表。 为了实现这个目标，需要将“筛选出 2000 年以前的数据”和“从数据中提取`name`”这两个处理结合起来。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个名为`ECMAScriptVersions`的数组，其中包含了 ECMAScript 的版本名称和发布年份。 假设我们要从该数组中提取`2000`年以前发行的
    ECMAScript 版本名称列表。 为了实现这个目标，需要将“筛选出 2000 年以前的数据”和“从数据中提取`name`”这两个处理结合起来。
- en: 这两个处理可以通过 Array 的`filter`方法和`map`方法来实现。 使用`filter`方法从数组中筛选出在`2000`年之前的数据，然后使用`map`方法从每个元素中提取`name`属性。
    由于这两种方法都返回数组，因此可以在方法链中连接它们。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个处理可以通过 Array 的`filter`方法和`map`方法来实现。 使用`filter`方法从数组中筛选出在`2000`年之前的数据，然后使用`map`方法从每个元素中提取`name`属性。
    由于这两种方法都返回数组，因此可以在方法链中连接它们。
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 使用方法链可以将由多个处理组成的处理看作一个整体处理。 过长的方法链会导致函数过长，难以阅读，但适度的方法链可以使处理过程更清晰。
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法链可以将由多个处理组成的处理看作一个整体处理。 过长的方法链会导致函数过长，难以阅读，但适度的方法链可以使处理过程更清晰。
- en: '*总结*'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*总结*'
- en: '*本章介绍了数组相关内容。'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章介绍了数组相关内容。'
- en: 数组是一种可以存储有序元素的对象。
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组是一种可以存储有序元素的对象。
- en: 数组有破坏性方法和非破坏性方法。
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组有破坏性方法和非破坏性方法。
- en: 数组具有用于执行迭代处理的高阶函数方法。
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组具有用于执行迭代处理的高阶函数方法。
- en: 方法链利用数组方法返回数组的特性。
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法链利用数组方法返回数组的特性。
- en: 数组是 JavaScript 中经常使用的对象之一，有许多不同类型的方法。 由于本书未介绍所有方法，请参阅[有关数组的文档](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array)以获取更多详细信息。
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是 JavaScript 中经常使用的对象之一，有许多不同类型的方法。 由于本书未介绍所有方法，请参阅[有关数组的文档](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array)以获取更多详细信息。
