- en: クラス
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: 原文：[`jsprimer.net/basic/class/`](https://jsprimer.net/basic/class/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jsprimer.net/basic/class/`](https://jsprimer.net/basic/class/)
- en: 「クラス」と一言にいってもさまざまであるため、こ��では**構造**、**動作**、**状態**を定義できるものを指すことにします。 また、この章では概念を示す場合は**クラス**と呼び、クラスに関する構文（記述するコード）のことを`class`構文と呼びます。
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “类”一词有多种含义，因此在这里，指代可以定义**结构**、**行为**和**状态**的东西。此外，在本章中，表示概念时称为**类**，而表示类相关结构（编写的代码）时称为`class`语法。
- en: '**クラス**とは**動作**や**状態**を定義した**構造**です。 クラスからはインスタンスと呼ばれるオブジェクトを作成でき、インスタンスはクラスに定義した**動作**を継承し、**状態**は動作によって変化します。
    とても抽象的なことに思えますが、これは今までオブジェクトや関数を使って表現してきたものです。 JavaScriptではES2015より前までは`class`構文はなく、関数を使ってクラスのようなものを表現して扱っていました。'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是定义**行为**或**状态**的**结构**。从类中可以创建称为实例的对象，实例继承类中定义的**行为**，**状态**会随着行为而变化。这听起来很抽象，但这实际上是以前用对象或函数表达的东西。在JavaScript中，ES2015之前没有`class`语法，而是用函数来表示类似类的东西并处理。'
- en: ES2015でクラスを表現するための`class`構文が導入されましたが、この`class`構文で定義したクラスは関数オブジェクトの一種です。 `class`構文ではプロトタイプベースの継承の仕組みを使って関数でクラスを表現しています。
    そのため、`class`構文はクラスを作るための関数定義や継承をパターン化した書き方と言えます。
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015引入了用于表示类的`class`语法，但用`class`语法定义的类实际上是函数对象的一种。`class`语法使用基于原型的继承机制用函数来表示类。因此，`class`语法可以说是对创建类和继承进行模式化的写法。
- en: また、関数の定義方法として関数宣言文と関数式があるように、クラスにもクラス宣言文とクラス式があります。 このように関数とクラスは似ている部分が多いです。
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像函数有函数声明和函数表达式定义方法一样，类也有类声明和类表达式。这样，函数和类有很多相似之处。
- en: この章では、`class`構文でのクラスの定義や継承、クラスの性質について学んでいきます。
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将学习`class`语法中的类定义、继承和类的性质。
- en: '*クラスの定義*'
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*类的定义*'
- en: '*クラスを定義するには`class`構文を使います。 クラスの定義方法にはクラス宣言文とクラス式があります。'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*定义类可以使用`class`语法。类的定义方法有类声明和类表达式两种。'
- en: まずは、クラス宣言文によるクラスの定義方法を見ていきます。
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先来看使用类声明定义类的方法。
- en: クラス宣言文では`class`キーワードを使い、`class クラス名{ }`のようにクラスの**構造**を定義できます。
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明语句中，使用`class`关键字，可以像`class クラス名{ }`这样定义类的**结构**。
- en: クラスは必ずコンストラクタを持ち、`constructor`という名前のメソッドとして定義します。 コンストラクタとは、そのクラスからインスタンスを作成する際にインスタンスに関する**状態**の初期化を行うメソッドです。
    `constructor`メソッドに定義した処理は、クラスをインスタンス化したときに自動的に呼び出されます。
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类必须有一个构造函数，并以`constructor`命名的方法来定义。构造函数是创建类实例时初始化实例相关**状态**的方法。`constructor`方法中定义的处理会在类实例化时自动调用。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: もうひとつの定義方法であるクラス式は、クラスを値として定義する方法です。 クラス式ではクラス名を省略できます。これは関数式における無名関数と同じです。
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种定义方法，即类表达式，是定义类作为值的方法。在类表达式中可以省略类名。这与函数表达式中的匿名函数相同。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: コンストラクタ関数内で、何も処理がない場合はコンストラクタの記述を省略できます。 省略した場合でも自動的に空のコンストラクタが定義されるため、クラスにはコンストラクタが必ず存在します。
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数内没有处理的情况下，可以省略构造函数的描述。省略后，也会自动定义一个空的构造函数，因此类中总是存在构造函数。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*クラスのインスタンス化*'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*类的实例化*'
- en: '*クラスは`new`演算子でインスタンスであるオブジェクトを作成できます。 `class`構文で定義したクラスからインスタンスを作成することを**インスタンス化**と呼びます。
    あるインスタンスが指定したクラスから作成されたものかを判定するには`instanceof`演算子が利用できます。'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*类可以使用`new`运算符创建实例对象。用`class`语法定义的类创建实例的过程称为**实例化**。要判断一个实例是否是由指定的类创建的，可以使用`instanceof`运算符。'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: このままでは何も処理がない空のクラスなので、値を持ったクラスを定義してみましょう。
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这样定义的类是空的，没有处理，所以定义一个具有值的类。
- en: クラスではインスタンスの初期化処理をコンストラクタ関数で行います。 コンストラクタ関数は`new`演算子でインスタンス化する際に自動的に呼び出されます。
    コンストラクタ関数内での`this`はこれから新しく作るインスタンスオブジェクトとなります。
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类中在构造函数中执行实例的初始化处理。构造函数在用`new`运算符实例化时自动调用。构造函数中的`this`是新创建的实例对象。
- en: 次のコードでは、`x`座標と`y`座標の値を持つ`Point`というクラスを定義しています。 コンストラクタ関数（`constructor`）の中でインスタンスオブジェクト（`this`）の`x`と`y`プロパティに値を代入して初期化しています。
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，定义了一个名为`Point`的类，该类具有`x`坐标和`y`坐标的值。在构造函数（`constructor`）中，将实例对象的`x`和`y`属性赋值并初始化。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: この`Point`クラスのインスタンスを作成するには`new`演算子を使います。 `new`演算子には関数呼び出しと同じように引数を渡すことができます。
    `new`演算子の引数はクラスの`constructor`メソッド（コンストラクタ関数）の仮引数に渡されます。 そして、コンストラクタの中ではインスタンスオブジェクト（`this`）の初期化処理を行います。
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Point`类的实例时使用`new`运算符。`new`运算符可以像函数调用一样传递参数。`new`运算符的参数传递给类的`constructor`方法（构造函数）。然后，在构造函数中执行实例对象的初始化处理。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: このようにクラスからインスタンスを作成するには必ず`new`演算子を使います。
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，从类创建实例时必须使用`new`运算符。
- en: 一方、クラスは通常の関数として呼ぶことができません。 これは、クラスのコンストラクタはインスタンス（`this`）を初期化する場所であり、通常の関数とは役割が異なるためです。
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，类不能像普通函数一样调用。这是因为类的构造函数是初始化实例（`this`）的地方，与普通函数的作用不同。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: また、コンストラクタ関数は`return`文で任意のオブジェクトを返すことが可能ですが、行うべきではありません。 なぜなら、クラスを`new`演算子で呼び出し、その評価結果はクラスのインスタンスを期待するのが一般的であるためです。
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，构造函数可以使用`return`语句返回任意对象，但不应这样做。因为通常情况下，使用`new`运算符调用类，期望其返回类实例。
- en: 次のコードのようにコンストラクタで返した値が`new`演算子で呼び出した際の返り値となります。 このような書き方は混乱を生むため避けるべきです。
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面的代码，构造函数中返回的值将成为使用`new`运算符调用时的返回值。这种写法容易引起混淆，应避免使用。
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*[Note] クラス名は大文字ではじめる*'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[注意] 类名以大写字母开头*'
- en: '*JavaScriptでは慣習としてクラス名には大文字ではじまる名前をつけます。 これは、変数名にキャメルケースを使う慣習があるのと同じで、名前自体に特別なルールがあるわけではありません。
    クラス名を大文字にしておき、そのインスタンスは小文字で開始すれば名前が被らないという合理的な理由で好まれています。'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*在JavaScript中，习惯上类名以大写字母开头。这与变量名使用驼峰式命名的习惯相同，名称本身没有特别的规则。将类名大写，其实例以小写开头，这样可以避免名称冲突，这是被广泛接受的理由。'
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*[コラム] `class`構文と関数でのクラスの違い*'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[专栏] `class`语法与函数的区别*'
- en: '*ES2015より前はこれらのクラスを`class`構文ではなく、関数で表現していました。 その表現方法は人によってさまざまで、これも`class`構文という統一した記法が導入された理由の1つです。'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*在ES2015之前，这些类不是用`class`语法，而是用函数来表示的。这种表示方法因人而异，这也是引入`class`语法统一记法的理由之一。'
- en: 次のコードは、関数でクラスを実装した1つの例です。 この関数でのクラス表現は、継承の仕組みなどは省かれていますが、`class`構文とよく似ています。
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是使用函数实现类的一个示例。这个函数中的类表示省略了继承机制等，但与`class`语法很相似。
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 大きな違いとして、`class`構文で定義したクラスは関数として呼び出すことができません。 クラスは`new`演算子でインスタンス化して使うものなので、これはクラスの誤用を防ぐ仕様です。
    一方、関数でのクラス表現はただの関数なので、当然関数として呼び出せます。
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的区别是，用`class`语法定义的类不能像函数一样调用。类是使用`new`运算符实例化的，所以这是防止类误用的规范。另一方面，函数中的类表示只是函数，当然可以像函数一样调用。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: このように、関数でクラスのようなものを実装した場合には、関数として呼び出せてしまう問題があります。 このような問題を避けるためにもクラスは`class`構文を使って実装します。
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，用函数实现类似类的东西时，会出现可以像函数一样调用的一个问题。为了避免这种问题，类使用`class`语法来实现。
- en: '*クラスのプロトタイプメソッドの定義*'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*类的原型方法定义*'
- en: '*クラスの**動作**はメソッドによって定義できます。 `constructor`メソッドは初期化時に呼ばれる特殊なメソッドですが、`class`構文ではクラスに対して自由にメソッドを定義できます。
    このクラスに定義したメソッドは作成したインスタンスが持つ動作となります。'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*类的行为可以通过方法来定义。`constructor`方法是在初始化时调用的特殊方法，但在`class`结构中，可以自由地为类定义方法。这个类中定义的方法是创建的实例所具有的行为。'
- en: 次のように`class`構文ではクラスに対してメソッドを定義できます。 メソッドの中からクラスのインスタンスを参照するには、`constructor`メソッドと同じく`this`を使います。
    このクラスのメソッドにおける`this`は「関数とthis」の章で学んだメソッドと同じくベースオブジェクトを参照します。
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示，在`class`结构中可以为类定义方法。要引用类的方法，可以使用与`constructor`方法相同的方式使用`this`。在这个类的这个方法中，`this`与我们在“函数与this”章节中学到的函数的`this`一样，都引用了基对象。
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'クラスのプロトタイプメソッド定義では、オブジェクトにおけるメソッドとは異なり`key : value`のように`:`区切りでメソッドを定義できないことに注意してください。
    つまり、次のような書き方は構文エラー（`SyntaxError`）となります。'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '在定义类的原型方法时，与对象中的方法不同，不能像`key : value`那样使用`:`分隔符来定义方法。也就是说，以下写法会导致语法错误（`SyntaxError`）。'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: このメソッド定義の構文でクラスに対して定義したメソッドは、クラスの各インスタンスから**共有されるメソッド**となります。 このインスタンス間で共有されるメソッドのことを**プロトタイプメソッド**と呼びます。
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法定义的语法中，为类定义的方法是**共享的方法**。在实例间共享的方法被称为**原型方法**。
- en: 次のコードでは、`Counter`クラスに`increment`メソッドを定義しています。 このときの`Counter`クラスのインスタンスは、それぞれ別々の状態（`count`プロパティ）を持ちます。
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们为`Counter`类定义了`increment`方法。这时，`Counter`类的实例各自持有不同的状态（`count`属性）。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: このときの`increment`メソッドはプロトタイプメソッドとして定義されています。 プロトタイプメソッドは各インスタンス間(`counterA`と`counterB`)で共有されます。
    そのため、次のように各インスタンスの`increment`メソッドの参照先は同じとなっていることがわかります。
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`increment`方法被定义为原型方法。原型方法是实例间（`counterA`和`counterB`）共享的。因此，可以知道每个实例的`increment`方法的引用是相同的。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: プロトタイプメソッドがなぜインスタンス間で共有されているのかは、クラスの継承の仕組みと密接に関係しています。 プロトタイプメソッドの仕組みについては後ほど解説します。
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么原型方法在实例间共享，这与类的继承机制密切相关。关于原型方法的机制将在后面进行说明。
- en: ここでは、次のような構文でクラスにメソッドを定義すると、各インスタンスで共有されるプロトタイプメソッドとして定義されるということが理解できていれば問題ありません。
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们理解了使用以下这种结构定义类方法，那么在各个实例中定义共享的原型方法就不会有问题。
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*クラスのアクセッサプロパティの定義*'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*定义类的访问器属性*'
- en: '*クラスに対してメソッドを定義できますが、メソッドは`インスタンス名.メソッド名()`のように呼び出す必要があります。 クラスでは、プロパティの参照（getter）、プロパティへの代入（setter）時に呼び出される特��なメソッドを定義できます。
    このメソッドはプロパティのように振る舞うため**アクセッサプロパティ**と呼ばれます。'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以为类定义方法。但是，方法需要像`实例名.方法名()`这样调用。在类中，可以定义在引用属性或向属性赋值时调用的特殊方法。这个方法像属性一样表现，因此被称为**访问器属性**。'
- en: 次のコードでは、プロパティの参照（getter）、プロパティへの代入（setter）に対するアクセッサプロパティを定義しています。 アクセッサプロパティはメソッド名（プロパティ名）の前に`get`または`set`をつけるだけです。
    getter（`get`）には仮引数はありませんが、必ず値を返す必要があります。 setter（`set`）の仮引数にはプロパティへ代入する値が入りますが、値を返す必要はありません。
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码中，我们定义了用于属性引用（getter）和属性赋值（setter）的访问器属性。访问器属性只需在方法名（属性名）前加上`get`或`set`即可。getter（`get`）没有参数，但必须返回一个值。setter（`set`）的参数是赋给属性的值，但不需要返回值。
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 次のコードでは、`NumberWrapper`クラスの`value`プロパティをアクセッサプロパティとして定義しています。 `value`プロパティへアクセスした際にそれぞれ定義したgetterとsetterが呼ばれているのがわかります。
    このアクセッサプロパティで実際に読み書きされているのは、`NumberWrapper`インスタンスの`_value`プロパティとなります。
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将`NumberWrapper`类的`value`属性定义为访问器属性。可以看到，当访问`value`属性时，分别调用了定义的getter和setter。这个访问器属性实际上是在读取和写入`NumberWrapper`实例的`_value`属性。
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*[コラム] `_`（アンダーバー）から始まるプロパティ名*'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[专栏] 以下划线（_）开头的属性名*'
- en: '*NumberWrapperの`value`のアクセッサプロパティで実際に読み書きしているのは、`_value`プロパティです。 このように、外から直接読み書きしてほしくないプロパティを`_`（アンダーバー）から始まる名前にするのはただの習慣であるため、構文としての意味はありません。'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*在NumberWrapper的`value`的访问器属性中实际读写的是`_value`属性。这样，将不需要直接读写的外部属性命名为以下划线（_）开头，只是习惯问题，并没有语法上的意义。'
- en: ECMAScript 2022から、外から直接読み書きしてほしくないプライベートなプロパティを定義するPrivateクラスフィールド構文が追加されました。
    Privateクラスフィールド構文では`#`（ハッシュ）記号をプロパティ名の前につけます。 そのため、外から直接読み書きしてほしくないプロパティを`_`からはじめるという慣習は、Privateクラスフィールド構文の利用が進むにつれて使われなくなっていくと考えています。
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从ECMAScript 2022开始，添加了用于定义外部直接读写不希望进行的私有属性的Private类字段结构。在Private类字段结构中，在属性名前加上`#`（井号）记号。因此，随着Private类字段结构的利用增加，以`_`开头命名属性的习惯将逐渐消失。
- en: Privateクラスフィールド構文については、この後に解説します。
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于私有类字段结构，将在后面进行说明。
- en: '*`Array.prototype.length`をアクセッサプロパティで再現する*'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*使用访问器属性再现`Array.prototype.length`*'
- en: '*getterやsetterを利用しないと実現が難しいものとして、`Array.prototype.length`プロパティがあります。 Arrayの`length`プロパティへ値を代入すると、そのインデックス以降の要素は自動的に削除される仕様になっています。'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*不使用getter或setter实现起来比较困难的是`Array.prototype.length`属性。当向`Array`的`length`属性赋值时，其后的元素会自动删除。*'
- en: 次のコードでは、配列の要素数（`length`プロパティ）を小さくすると配列の要素が削除されています。
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，当减小数组的元素数（`length`属性）时，数组元素被删除。
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: この`length`プロパティの挙動を再現する`ArrayLike`クラスを実装してみます。 Arrayの`length`プロパティは、`length`プロパティへ値を代入した際に次のようなことを行っています。
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 试着实现一个可以再现`length`属性行为的`ArrayLike`类。`Array`的`length`属性在向`length`属性赋值时会执行以下操作。
- en: 現在要素数より小さな**要素数**が指定された場合、その**要素数**を変更し、配列の末尾の要素を削除する
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定的**元素数**小于当前元素数时，更改**元素数**，并删除数组的末尾元素。
- en: 現在要素数より大きな**要素数**が指定された場合、その**要素数**だけを変更し、配列の実際の要素はそのままにする
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定的**元素数**大于当前元素数时，只更改**元素数**，实际数组元素保持不变。
- en: ArrayLikeの`length`プロパティのsetterで要素の追加や削除を実装することで、配列のような`length`プロパティを実装できます。
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`ArrayLike`的`length`属性setter中实现元素的添加或删除，可以实现对类似数组的`length`属性的实现。
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: このようにアクセッサプロパティでは、プロパティのようでありながら実際にアクセスした際には他のプロパティと連動する動作を実現できます。
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，访问器属性虽然像属性一样，但在实际访问时可以实现与其他属性联动的行为。
- en: '*[ES2022] Publicクラスフィールド*'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[ES2022] 公共类字段*'
- en: '*クラスでは、`constructor`メソッドの中でクラスの状態であるインスタンスのプロパティを初期化することを紹介しました。 先ほども紹介した`Counter`クラスでは、`constructor`メソッドの中で`count`プロパティの初期値を`0`として定義しています。'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*在类中，我们在`constructor`方法中介绍了如何初始化类状态，即实例的属性。在之前介绍的`Counter`类中，我们在`constructor`方法中将`count`属性的初始值定义为`0`。'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: この`Counter`では`new`演算子で何も引数を渡すことなく初期化するため、`constructor`メソッドには仮引数を定義していません。 このような場合でも、`constructor`メソッドを書かないとプロパティの初期化ができないためわずらわしいという問題がありました。
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Counter`中，由于没有通过`new`运算符传递任何参数来初始化，因此没有在`constructor`方法中定义任何参数。在这种情况下，即使不写`constructor`方法，也无法初始化属性，因此存在一些麻烦的问题。
- en: ES2022で，クラスのインスタンスが持つプロパティの初期化をわかりやすく宣言的にする構文として，**クラスフィールド**構文が追加されました。
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2022中，为了更清晰地声明类实例拥有的属性初始化，新增了**类字段**结构。
- en: クラスフィールドは，クラスのインスタンスが持つプロパティを定義する次のような構文です。
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类字段定义类实例拥有的属性，其结构如下。
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: クラスフィールドを使って先ほどの`Counter`クラスを書き直してみると次のようになります。 `count`プロパティをクラスフィールドとして定義して，その初期値は`0`としています。
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Counter`类重写为类字段，如下所示。将`count`属性定义为类字段，其初始值为`0`。
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: クラスフィールドで定義するのは，クラスのインスタンスが持つプロパティです。 そのため，`constructor`メソッドの中で`this.count =
    0`のように定義した場合と結果的にはほとんど同じ意味となります。 クラスフィールドで定義したプロパティは，クラス内から他のプロパティと同じように`this.プロパティ名`で参照できます。
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 类字段定义的是类实例拥有的属性。因此，与在`constructor`方法中定义`this.count = 0`类似，结果几乎相同。在类字段中定义的属性可以在类内部像其他属性一样通过`this.属性名`进行引用。
- en: クラスフィールドは`constructor`メソッドでの初期化と併用が可能です。 次のコードでは，クラスフィールドと`constructor`メソッドでそれぞれインスタンスのプロパティを定義しています。
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类字段可以与`constructor`方法一起使用。在下面的代码中，分别使用类字段和`constructor`方法定义了实例属性。
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: また，クラスフィールドでの初期化処理が行われ，そのあと`constructor`でのプロパティの定義という処理順となります。 そのため，同じプロパティ名への定義がある場合は，`constructor`メソッド内での定義でプロパティは上書きされます。
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，类字段的初始化处理会在之后进行`constructor`中属性定义的处理。因此，如果存在相同名称的属性定义，则`constructor`方法中的定义会覆盖属性。
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: この`publicField`プロパティのように，クラスの外からアクセスできるプロパティを定義するクラスフィールドを**Publicクラスフィールド**と呼びます。
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`publicField`属性这样，可以在类外部访问的属性被定义为**公共类字段**。
- en: '*クラスフィールドを使ってプロパティの存在を宣言する*'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*使用类字段声明属性的存在*'
- en: '*クラスフィ��ルドでは，プロパティの初期値は省略可能となっています。 そのため，次のように初期値を省略したPublicクラスフィールドも定義できます。'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*在类字段中，属性的初始值是可选的。因此，可以像下面这样定义省略了初始值的公共类字段。'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: このときの`myProperty`は`undefined`で初期化されます。 この初期値を省略したクラスフィールドの定義は，クラスのインスタンスが持つプロパティを明示するために利用できます。
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`myProperty`被初始化为`undefined`。省略了初始值的类字段定义可以用于明确指出类实例拥有的属性。
- en: 次の`Loader`クラスは，`load`メソッドを呼び出すまでは，`loadedContent`プロパティの値は`undefined`です。 クラスフィールドを使えば，`Loader`クラスのインスタンスは，`loadedContent`というプロパティを持っていることを宣言的に表現できます。
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`load`方法之前，`Loader`类的`loadedContent`属性的值是`undefined`。使用类字段可以显式地表达`Loader`类的实例拥有`loadedContent`属性。
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: JavaScriptでは，オブジェクトのプロパティは初期化時に存在していなくても，後から代入すれば作成できてしまいます。 そのため，次のように`Loader`クラスを実装しても意味は同じです。
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，即使对象的属性在初始化时不存在，也可以在之后进行赋值来创建它。因此，即使像下面这样实现`Loader`类，其意义也是相同的。
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: しかし，このように実装してしまうと`Loader`クラスを利用する側は，`loadedContent`プロパティの存在を`load`メソッドの中まで読まないとわからないという問題があります。
    これに対して，クラスフィールドを使って「`Loader`クラスは`loadedContent`というプロパティを持っている」ということを宣言的に表現できます。
    宣言的にプロパティを定義することで，エディターでのコード補完が可能になったり，コードを読む人に優しいというメリットがあります。
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这样实现，使用`Loader`类的用户可能不知道`loadedContent`属性的存在，除非在`load`方法中读取。为此，可以使用类字段显式地表达“`Loader`类拥有`loadedContent`属性”这一事实。通过显式地定义属性，可以实现代码补全或使代码更易于阅读等好处。
- en: '*クラスフィールドでの`this`はクラスのインスタンスを示す*'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*类字段中的`this`表示类的实例*'
- en: '*クラスフィールドの初期値には任意の式が書け，`this`も利用できます。 クラスフィールドでの`this`は，そのクラスのインスタンスを参照します。'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*类字段的初始值可以写任意表达式，也可以使用`this`。在类字段中，`this`引用的是该类的实例。'
- en: 次のコードでは，`up`フィールドの初期値に`increment`メソッドを指定しています。 JavaScriptでは関数も値として扱えるため，`up`メソッドを呼び出すと`increment`メソッドが呼び出されます。
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，将`up`字段的初始值指定为`increment`方法。由于JavaScript中函数也可以作为值处理，因此调用`up`方法会调用`increment`方法。
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: クラスフィールドでの`this`は，Arrow Functionと組み合わせると強力です。
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类字段中的`this`与箭头函数结合非常强大。
- en: 次のコードでは，`up`メソッドをArrow Functionとして定義し，関数内では`this.increment`メソッドを呼び出しています。 Arrow
    Functionで定義した関数における`this`は，どのような呼び出し方をしても変化しません（「Arrow Functionでコールバック関数を扱う」を参照）。
    そのため，`up`メソッドはどのような呼び方をした場合でも`this`がクラスのインスタンスとなるため，確実に`increment`メソッドを呼び出せます。
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，将`up`方法定义为箭头函数，并在函数内部调用`this.increment`方法。在箭头函数中定义的函数中的`this`不会因调用方式的不同而变化（请参阅“使用箭头函数处理回调函数”）。因此，无论以何种方式调用`up`方法，`this`都会指向类的实例，因此可以确保调用`increment`方法。
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*[コラム] クラスフィールドとインスタンスのプロパティの違い*'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[专栏] 类字段与实例属性的区别*'
- en: '*クラスフィールドで定義したプロパティやメソッドは，クラスのインスタンスにプロパティとして定義されます。 そのため，クラスフィールドは，`constructor`の中で`this`に対してプロパティを追加するのと意味的にはほぼ同じで，見た目がわかりやすくな���た構文と捉えることができます。'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在类字段中定义的属性或方法将被定义为类的实例属性。因此，类字段在`constructor`中为`this`添加属性时，在意义上几乎相同，并且可以将其视为一种使结构更易于理解的语法。
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: しかし，厳密にはこのふたつのプロパティ定義には異なる点はあります。 次のように，クラスフィールドと`constructor`の中で`this`に追加するプロパティ名に対するsetterを定義してみるとこの違いがわかります。
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，严格来说，这两个属性定义之间还是存在差异的。通过以下方式定义类字段和`constructor`中`this`的setter，可以了解这种差异。
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: クラスフィールド名に対するsetterは呼び出されないのに対して，`this.property`への代入に対するsetterは呼び出されています。 これは，クラスフィールドは`=`を使った代入で定義されるのではなく，[Object.defineProperty](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)メソッドを使ってプロパティが定義されるという違いがあります。
    `Object.defineProperty`を使ったプロパティの定義では，setterは無視してプロパティが定義されます。 setterは`=`での代入に反応します。そのため，`constructor`の中での`this.property`への代入に対してはsetterが呼び出されます。
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类字段名的setter不会调用，而对于`this.property`的赋值会调用setter。这是因为类字段不是通过使用`=`进行赋值来定义的，而是使用[Object.defineProperty](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)方法来定义属性。使用`Object.defineProperty`定义属性时，setter会被忽略，属性会被定义。setter会对`=`赋值做出反应。因此，在`constructor`中对`this.property`的赋值会调用setter。
- en: 同じプロパティの定義であっても，プロパティの定義の仕組みが微妙に異なる点から，このような挙動の違いが存在しています。 しかし，この違いを意識するようなコードを書くことは避けたほうが安全です。
    実際に見た目からこの違いを意識するのは難しく，それを意識させるようなコードは複雑性が高いためです。
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是相同的属性定义，由于属性定义的方式略有不同，因此存在这种行为差异。然而，为了避免编写需要意识到这种差异的代码，最好是避免这样做。实际上，从外观上很难意识到这种差异，而且编写旨在引起注意的代码会使复杂性增加。
- en: '*[ES2022] Privateクラスフィールド*'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*[ES2022] 私有类字段*'
- en: '*クラスフィールド構文で次のように書くと、定義したプロパティはクラスをインスタンス化した後に外からも参照できます。 そのため、Publicクラスフィールドと呼ばれます。'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用类字段结构如下所示，定义的属性在类实例化后也可以从外部访问。因此，被称为**公共类字段**。'
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 一方で外からアクセスされたくないインスタンスのプロパティも存在します。 そのようなプライベートなプロパティを定義する構文もES2022で追加されています。
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也存在一些不希望外部访问的实例属性。ES2022 中已经添加了定义此类私有属性的结构。
- en: Privateクラスフィールドは、次のように`#`をフィールド名の前につけたクラスフィールドを定義します。
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 私有类字段是通过在字段名前加上 `#` 来定义的类字段。
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 定義したPrivateクラスフィールドは、`this.#フィールド名`で参照できます。
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了私有类字段后，可以通过 `this.#fieldName` 来引用。
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: もう少し具体的なPrivateクラスフィールドの使い方を見ていきます。 アクセッサプロパティの例でも登場した`NumberWrapper`をPrivateクラスフィールドを使って書き直してみます。
    元々の`NumberWrapper`クラスでは、`_value`プロパティに実際の値を読み書きしていました。 この場合、`_value`プロパティは、外からもアクセスできてしまうため、定義したgetterとsetterが無視できてしまいます。
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更具体地看看私有类字段的用法。以之前出现的 `NumberWrapper` 类为例，使用私有类字段来重写它。在原始的 `NumberWrapper`
    类中，实际值是通过 `_value` 属性进行读写操作的。在这种情况下，`_value` 属性可以从外部访问，因此定义的 getter 和 setter 会被忽略。
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Privateクラスフィールドでは、外からアクセスされたくないプロパティを`#`をつけてクラスフィールドとして定義します。 次のコードでは、`#value`はプライベートプロパティとなっているため、構文エラーが発生し外からアクセスできなくなることが確認できます。
    Privateクラスフィールドを使うことで、クラスを利用する際はgetterとsetterを経由しないと`#value`を参照できなくなりました。
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在私有类字段中，可以通过在字段名前加上 `#` 来定义不希望外部访问的属性。下面的代码中，`#value` 被定义为私有属性，因此会引发语法错误，无法从外部访问。使用私有类字段，在利用类时，必须通过
    getter 和 setter 来引用 `#value`，而不是直接引用。
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Privateクラスフィールドを使うことで、クラスの外からアクセスさせたくないプロパティを宣言できます。 これは、実装したクラスの意図しない使われ方を防いだり、クラスの外からプロパティの状態を直接書き換えるといった行為を防げます。
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有类字段可以声明不希望从类外部访问的属性。这可以防止对实现类的不当使用，或者防止从类外部直接修改属性的状态。
- en: また、Privateクラスフィールドでは、途中から値が入る場合でもフィールドの宣言が必須となっています。 次のコードでは、`#loadedContent`に実際に値が入るのは`load`メソッドが呼び出されたときです。
    Publicクラスフィールドではフィールドの定義は省略可能でしたが、Privateクラスフィールドでは`#loadedContent`フィールドの定義が必須となっています。
    言い換えると、Privateクラスフィールドでは、クラスを定義した段階でクラスに存在するすべてのPrivateクラスフィールドを明示する必要があります。
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，私有类字段中，如果中间有值进入，则字段声明是必需的。在下面的代码中，`#loadedContent` 实际上是在 `load` 方法调用时填充的。在公共类字段中，字段定义是可选的，但在私有类字段中，`#loadedContent`
    字段的定义是必需的。换句话说，在私有类字段中，需要在定义类的阶段明确列出类中存在的所有私有类字段。
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*静的メソッド*'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*静态方法*'
- en: '*インスタンスメソッドは、クラスをインスタンス化して利用します。 一方、クラスをインスタンス化せずに利用できる静的メソッド（クラスメソッド）もあります。'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*实例方法是通过实例化类来使用的。另一方面，也有可以不实例化类就使用的静态方法（类方法）。'
- en: 静的メソッドの定義方法はメソッド名の前に、`static`をつけるだけです。
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法的定义方法是在方法名前加上 `static`。
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 次のコードでは、配列をラップする`ArrayWrapper`というクラスを定義しています。 `ArrayWrapper`はコンストラクタの引数として配列を受け取って初期化しています。
    このクラスに配列ではなく要素そのものを引数に受け取ってインスタンス化できる`ArrayWrapper.of`という静的メソッドを定義します。
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，定义了一个名为 `ArrayWrapper` 的类来包装数组。`ArrayWrapper` 接受数组作为构造函数的参数进行初始化。这个类定义了一个静态方法
    `ArrayWrapper.of`，可以接受数组中的元素本身作为参数来实例化。
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: クラスの静的メソッドにおける`this`は、そのクラス自身を参照します。 そのため、先ほどのコードは`new ArrayWrapper`の代わりに`new
    this`と書くこともできます。
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的静态方法中，`this` 指向的是该类自身。因此，之前的代码可以用 `new this` 代替 `new ArrayWrapper`。
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: このように静的メソッドでの`this`はクラス自身を参照するため、クラスのインスタンスは参照できません。 そのため静的メソッドは、クラスのインスタンスを作成する処理やクラスに関係する処理を書くために利用されます。
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，静态方法中的 `this` 指向的是类自身，因此无法引用类的实例。因此，静态方法用于编写创建类实例的处理或与类相关的处理。
- en: '*[ES2022] 静的クラスフィールド*'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*[ES2022] 静态类字段*'
- en: '*ES2022で追加されたクラスフィールドでは、インスタンスではなくクラス自体に定義する静的クラスフィールドも利用できます。'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*ES2022 中添加的类字段中，可以使用静态类字段来在类本身上定义，而不是在实例上定义。'
- en: 静的クラスフィールドは、フィールドの前に`static`をつけるだけです。 静的クラスフィールドで定義したプロパティは、クラス自体のプロパティとして定義されます。
    次のコードでは、Public 静的クラスフィールドを使って`Colors`クラス自体にプロパティを定義しています。
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类字段只需在字段前加上 `static`。使用静态类字段定义的属性将成为类的属性。在下面的代码中，使用公共静态类字段为 `Colors` 类本身定义了属性。
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: また、Privateクラスフィールドも静的に利用できます。 Private 静的クラスフィールドは、クラス自体にプロパティを定義したいが、そのプロパティを外から参照されたくない場合に利用します。
    Private 静的クラスフィールドはフィールドの前に、`static`をつけるだけです。
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，私有类字段也可以静态使用。私有静态类字段用于在类本身上定义属性，而不希望从外部引用。私有静态类字段只需在字段前加上 `static`。
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '*プロトタ��プに定義したメソッドとインスタンスに定義したメソッドの違い*'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*在原型中定义的方法与在实例中定义的方法的区别*'
- en: '*ここまでで、プロトタイプメソッドの定義とクラスフィールドを使ったインスタンスに対するメソッドの定義の2 種類を見てきました。 プロトタイプメソッドの定義方法は、メソッドをプロトタイプオブジェクトという特殊なオブジェクトに定義します。
    一方で、クラスフィールドで定義したメソッドは、クラスのインスタンスに対してメソッドを定義します。'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了两种方法：在原型对象中定义的方法和通过类字段定义的实例方法。原型方法的定义方法是将方法定义在特殊对象原型对象中。另一方面，通过类字段定义的方法是为类的实例定义方法。
- en: どちらのメソッド定義方法でも、`new`演算子でインスタンス化したオブジェクトからメソッドを呼び出すことができる点は同じです。
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法定义方法中，都可以通过 `new` 操作符从实例化的对象中调用方法。这一点是相同的。
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: しかしこの2つのメソッドの定義方法は、メソッドの定義先となるオブジェクトが異なります。
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种方法定义方法的区别在于方法定义的对象不同。
- en: まず、この2 種類のメソッドがそれぞれ別の場所へと定義されていることを見ていきます。 次のコードでは、`ConflictClass`クラスに`method`という同じ名前のメソッドをプロトタイプメソッドとインスタンスに対してそれぞれ定義しています。
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看这两种方法分别定义在不同的地方。下面的代码中，`ConflictClass` 类分别对原型和实例定义了同名的方法 `method`。
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 結論から述べると、この場合はインスタンスオブジェクトに定義した`method`が呼び出されます。 このとき、インスタンスの`method`プロパティを`delete`演算子で削除すると、今度はプロトタイプメソッドの`method`が呼び出されます。
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在这种情况下，定义在实例对象上的 `method` 被调用。此时，如果使用 `delete` 操作符删除实例的 `method` 属性，那么接下来会调用原型方法的
    `method`。
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: この実行結果から次のことがわかります。
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个执行结果中，我们可以得出以下结论。
- en: プロトタイプメソッドとインスタンスオブジェクトのメソッドは上書きされずにどちらも定義されている
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型方法和实例对象的方法定义不会相互覆盖，两者都存在。
- en: インスタンスオブジェクトの��ソッドがプロトタイプオブジェクトのメソッドよりも優先して呼ばれている
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例对象的方法比原型对象的方法有更高的优先级。
- en: どちらも注意深く意識しないと気づきにくいですが、この挙動はJavaScriptの重要な仕組みであるため理解することは重要です。
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都很难注意到，但这个行为是 JavaScript 的重要机制，因此理解它很重要。
- en: この挙動は**プロトタイプオブジェクト**と呼ばれる特殊なオブジェクトと**プロトタイプチェーン**と呼ばれる仕組みで成り立っています。 どちらも**プロトタイプ**とついていることからわかるように、2つで1
    組のような仕組みです。
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是通过称为 **原型对象** 的特殊对象和称为 **原型链** 的机制实现的。由于两者都带有 **原型**，因此它们似乎是一组机制。
- en: 次のセクションでは、**プロトタイプオブジェクト**と**プロトタイプチェーン**とはどのような仕組みなのかを見ていきます。
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨 **原型对象** 和 **原型链** 的机制。
- en: '*プロトタイプオブジェクト*'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*原型对象*'
- en: '***プロトタイプメソッド**と**インスタンスオブジェクトのメソッド**を同時に定義しても、互いのメソッドは上書きされるわけでありません。 なぜなら、プロトタイプメソッドは**プロトタイプオブジェクト**へ、インスタンスオブジェクトのメソッドは**インスタンスオブジェクト**へそれぞれ定義されるためです。'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '***原型方法**和**实例对象的方法**可以同时定义，但它们的方法不会相互覆盖。因为原型方法定义在**原型对象**上，而实例对象的方法定义在**实例对象**上。'
- en: プロトタイプオブジェクトについては「プロトタイプオブジェクト」の章で簡単に紹介していましたが、改めて解説していきます。
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于原型对象，我在“原型对象”章节中简单介绍过，但在这里我将重新解释。
- en: '**プロトタイプオブジェクト**とは、JavaScriptの関数オブジェクトの`prototype`プロパティに自動的に作成される特殊なオブジェクトです。
    クラスも一種の関数オブジェクトであるため、自動的に`prototype`プロパティにプロトタイプオブジェクトが作成されています。'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**原型对象**是JavaScript中函数对象的`prototype`属性自动创建的特殊对象。由于类也是函数对象的一种，因此会自动创建`prototype`属性的原型对象。'
- en: 次のコードでは、関数やクラス自身の`prototype`プロパティに、プロトタイプオブジェクトが自動的に作成されていることがわかります。
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，可以看到函数或类自身的`prototype`属性会自动创建原型对象。
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`class`構文のメソッド定義は、このプロトタイプオブジェクトのプロパティとして定義されます。'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`语法的`method`定义是作为原型对象的属性定义的。'
- en: 次のコードでは、クラスのメソッドがプロトタイプオブジェクトに定義されていることを確認できます。 また、クラスには`constructor`メソッド（コンストラクタ）が必ず定義されます。
    この`constructor`メソッドもプロトタイプオブジェクトに定義されており、この`constructor`プロパティはクラス自身を参照します。
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，可以看到类的方法定义在原型对象上。此外，类必须定义`constructor`方法（构造函数）。这个`constructor`方法也定义在原型对象上，这个`constructor`属性引用了类自身。
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: このように、プロトタイプメソッドはプロトタイプオブジェクトに定義され、インスタンスオブジェクトのメソッドとは異なるオブジェクトに定義されています。そのため、それぞれの方法でメソッドを定義しても、上書きされることはありません。
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这样，原型方法是在原型对象上定义的，与实例对象的`method`属性是不同的对象定义的。因此，即使使用不同的方法定义方法，也不会发生覆盖。
- en: '*プロトタイプチェーン*'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*原型链*'
- en: '*`class`構文で定義したプロトタイプメソッドはプロトタイプオブジェクトに定義されます。 しかし、インスタンス（オブジェクト）にはメソッドが定義されていないのに、インスタンスからクラスのプロトタイプメソッドを呼び出せます。'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用`class`语法定义的原型方法是定义在原型对象上的。即使实例（对象）上没有定义方法，也可以从实例调用类的原型方法。'
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: インスタンスからプロトタイプメソッドを呼び出せるのは**プロトタイプチェーン**と呼ばれる仕組みによるものです。 プロトタイプチェーンは2つの処理から成り立ちます。
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过**原型链**机制从原型对象中定义的原型方法调用实例。
- en: インスタンス作成時に、インスタンスの`[[Prototype]]`内部プロパティへプロトタイプオブジェクトの参照を保存する処理
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实例创建时，将原型对象的引用保存到实例的`[[Prototype]]`内部属性中的处理
- en: インスタンスからプロパティ（またはメソッド）を参照するときに、`[[Prototype]]`内部プロパティまで探索する処理
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从实例引用属性（或方法）时，会进行到`[[Prototype]]`内部属性为止的探索处理
- en: '*インスタンス作成とプロトタイプチェーン*'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*实例创建与原型链*'
- en: '*クラスから`new`演算子によってインスタンスを作成する際に、インスタンスにはクラスのプロトタイプオブジェクトへの参照が保存されます。 こ���とき、インスタンスからクラスのプロトタイプオブジェクトへの参照は、インスタンスオブジェクトの`[[Prototype]]`という内部プロパティに保存されます。'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*在通过`new`运算符创建实例时，实例会保存对类原型对象的引用。这时，实例对类原型对象的引用是保存在实例对象的`[[Prototype]]`这个内部属性中的。'
- en: '`[[Prototype]]`内部プロパティはECMAScriptの仕様で定められた内部的な表現であるため、通常のプロパティのようにはアクセスできません。
    ここでは説明のために、`[[プロパティ名]]`という書式でECMAScriptの仕様上に存在する内部プロパティを表現しています。'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[Prototype]]`内部属性是ECMAScript规范中定义的内部表示，因此不能像普通属性那样访问。在这里，为了说明，我们使用`[[属性名]]`这种格式来表示ECMAScript规范上存在的内部属性。'
- en: '`[[Prototype]]`内部プロパティへプロパティのようにはアクセスできませんが、`Object.getPrototypeOf`メソッドで`[[Prototype]]`内部プロパティを参照できます。'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不能像普通属性那样访问`[[Prototype]]`内部属性，但可以通过`Object.getPrototypeOf`方法引用`[[Prototype]]`内部属性。
- en: 次のコードでは、`instance`オブジェクトの`[[Prototype]]`内部プロパティを取得しています。 その取得した結果がクラスのプロトタイプオブジェクトを参照していることを確認できます。
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，可以看到正在获取`instance`对象的`[[Prototype]]`内部属性。确认获取的结果引用了类的原型对象。
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ここで重要なのは、インスタンスはどのクラスから作られたかやそのクラスのプロトタイプオブジェクトを知っているということです。
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，实例知道它是由哪个类创建的，以及它知道其类的原型对象。
- en: '*[Note] `[[Prototype]]`内部プロパティを読み書きする*'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*[注意] `[[Prototype]]`内部属性读写*'
- en: '*`Object.getPrototypeOf(オブジェクト)`で`オブジェクト`の`[[Prototype]]`を読み取ることができます。 一方、`Object.setPrototypeOf(オブジェクト,
    プロトタイプオブジェクト)`で`オブジェクト`の`[[Prototype]]`に`プロトタイプオブジェクト`を設定できます。 また、`[[Prototype]]`内部プロパティを通常のプロパティのように扱え���`__proto__`という特殊なアクセッサプロパティが存在します。'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以通过`Object.getPrototypeOf(对象)`读取`对象`的`[[Prototype]]`。另一方面，可以通过`Object.setPrototypeOf(对象,
    原型对象)`将`对象`的`[[Prototype]]`设置为`原型对象`。此外，存在一个特殊的访问器属性`__proto__`，可以像普通属性一样处理`[[Prototype]]`内部属性。'
- en: しかし、これらの`[[Prototype]]`内部プロパティを直接読み書きすることは通常の用途では行いません。 また、既存のビルトインオブジェクトの動作なども変更できるため、不用意に扱うべきではないでしょう。
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常不会直接读写这些`[[Prototype]]`内部属性。此外，由于它们可以改变现有内置对象的操作，因此不应该随意处理。
- en: '*プロパティの参照とプロトタイプチェーン*'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*属性的引用与原型链*'
- en: '*プロトタイプオブジェクトのプロパティがどのようにインスタンスから参照されるかを見ていきます。'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*查看原型对象的属性是如何从实例引用的。'
- en: オブジェクトのプロパティを参照するときに、オブジェクト自身がプロパティを持っていない場合でも、そこで探索が終わるわけではありません。 オブジェクトの`[[Prototype]]`内部プロパティ（仕様上の内部的なプロパティ）の参照先であるプロトタイプオブジェクトに対しても探索を続けます。
    これは、スコープに指定した識別子の変数がなかった場合に外側のスコープへと探索するスコープチェーンと良く似た仕組みです。
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用对象的属性时，即使对象自身没有属性，探索也不会结束。还会继续探索对象`[[Prototype]]`内部属性（规范上的内部属性）引用的原型对象。这与在指定作用域中找不到变量时，向外层作用域进行探索的作用域链类似。
- en: つまり、オブジェクトがプロパティを探索するときは次のような順番で、それぞれのオブジェクトを調べます。 すべてのオブジェクトにおいて見つからなかった場合の結果は`undefined`を返します。
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，当对象探索属性时，会按照以下顺序进行，检查每个对象。如果所有对象都没有找到，则返回`undefined`。
- en: '`instance`オブジェクト自身'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`对象自身'
- en: '`instance`オブジェクトの`[[Prototype]]`の参照先（プロトタイプオブジェクト）'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`对象的`[[Prototype]]`引用（原型对象）'
- en: どこにもなかった場合は`undefined`
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果哪里都没有，则返回`undefined`
- en: 次のコードでは、インスタンスオブジェクト自身は`method`プロパティを持っていません。 そのため、実際に参照しているのはクラスのプロトタイプオブジェクトの`method`プロパティです。
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，实例对象本身没有`method`属性。因此，实际引用的是类原型对象的`method`属性。
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: このように、インスタンスオブジェクトに`method`が定義されていなくても、クラスのプロトタイプオブジェクトの`method`を呼び出すことができます。
    このプロパティを参照する際に、オブジェクト自身から`[[Prototype]]`内部プロパティへと順番に探す仕組みのことを**プロトタイプチェーン**と呼びます。
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这样，即使实例对象没有定义`method`，也可以调用类的原型对象的`method`。在引用这个属性时，会从对象自身按顺序查找`[[Prototype]]`内部属性，这种按顺序查找的机制被称为**原型链**。
- en: プロトタイプチェーンの仕組みを疑似的なコードとして表現すると次のような動きをしています。
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 原型链的机制可以用模拟代码表示如下。
- en: '[PRE51]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 通过原型链机制，我们可以从原型对象中定义的原型方法中调用实例。
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过原型链机制，我们可以从原型对象中定义的原型方法中调用实例。
- en: 普通情况下，无需关注原型对象或原型链等机制。 `class`语法是为了让我们在不关注这些原型的情况下使用类而引入的语法。 但是，在基于原型的 JavaScript
    中，了解类是如何通过原型来表示是有好处的。
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 普通情况下，无需关注原型对象或原型链等机制。 `class`语法是为了让我们在不关注这些原型的情况下使用类而引入的语法。 但是，在基于原型的 JavaScript
    中，了解类是如何通过原型来表示是有好处的。
- en: '*继承*'
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*继承*'
- en: '*通过使用`extends`关键字，您可以继承现有的类。 继承是指定义一个新类，该类继承了父类的**结构**和**功能**。'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`extends`关键字，您可以继承现有的类。 继承是指定义一个新类，该类继承了父类的**结构**和**功能**。'
- en: '*继承的类定义*'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*继承的类定义*'
- en: '*通过使用`extends`关键字来定义继承自父类（基类）的**子类**（派生类）。 通过在`class`语法的右侧使用`extends`关键字指定要继承的**父类**（基类），可以定义继承自父类的**子类**（派生类）。'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`extends`关键字来定义继承自父类（基类）的**子类**（派生类）。 通过在`class`语法的右侧使用`extends`关键字指定要继承的**父类**（基类），可以定义继承自父类的**子类**（派生类）。'
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 在下面的代码中，我们定义了继承自`Parent`类的`Child`类。 实例化子类`Child`类与普通类一样使用`new`运算符。
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们定义了继承自`Parent`类的`Child`类。 实例化子类`Child`类与普通类一样使用`new`运算符。
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '*`super`*'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`super`*'
- en: '*要从使用`extends`定义的子类引用父类，需要使用名为`super`的关键字。 我们将看到使用最简单的`super`的示例，以查看构造函数的处理。'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*要从使用`extends`定义的子类引用父类，需要使用名为`super`的关键字。 我们将看到使用最简单的`super`的示例，以查看构造函数的处理。'
- en: 就像在`class`语法中介绍的那样，类必须具有`constructor`方法（构造函数）。 这也适用于继承的子类。
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`class`语法中介绍的那样，类必须具有`constructor`方法（构造函数）。 这也适用于继承的子类。
- en: 在下面的代码中，在`Child`类的构造函数中，我们调用了`super()`。 `super()`会调用父类的`constructor`方法。
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，在`Child`类的构造函数中，我们调用了`super()`。 `super()`会调用父类的`constructor`方法。
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 在`class`语法中，如果`constructor`方法（构造函数）不执行任何操作，则可以省略它。 这也适用于继承的子类。
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`语法中，如果`constructor`方法（构造函数）不执行任何操作，则可以省略它。 这也适用于继承的子类。
- en: 在下面的代码中，`Child`类的构造函数没有执行任何操作。 因此，可以省略`Child`类的`constructor`方法的定义。
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`Child`类的构造函数没有执行任何操作。 因此，可以省略`Child`类的`constructor`方法的定义。
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 如果在子类中省略了`constructor`，则与下面的代码相同。 接收`constructor`方法的所有参数，并将它们按顺序传递给`super`。
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在子类中省略了`constructor`，则与下面的代码相同。 接收`constructor`方法的所有参数，并将它们按顺序传递给`super`。
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '*构造函数的处理顺序是从父类到子类*'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*构造函数的处理顺序是从父类到子类*'
- en: '*构造函数的处理顺序是从父类到子类。'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*构造函数的处理顺序是从父类到子类。'
- en: 在`class`语法中，必须首先执行父类的构造函数处理（调用`super()`），然后执行子类的构造函数处理。 在子类的构造函数中，在引用`this`之前必须先调用`super()`以调用父类的构造函数处理，否则会导致`ReferenceError`。
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`语法中，必须首先执行父类的构造函数处理（调用`super()`），然后执行子类的构造函数处理。 在子类的构造函数中，在引用`this`之前必须先调用`super()`以调用父类的构造函数处理，否则会导致`ReferenceError`。
- en: 在下面的代码中，我们分别在`Parent`和`Child`中写入了实例（`this`）的`name`属性。 在子类中，必须先调用`super()`，然后才能引用`this`。
    因此，构造函数的处理顺序被限制为从`Parent`到`Child`。
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们分别在`Parent`和`Child`中写入了实例（`this`）的`name`属性。 在子类中，必须先调用`super()`，然后才能引用`this`。
    因此，构造函数的处理顺序被限制为从`Parent`到`Child`。
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*类字段继承*'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*类字段继承*'
- en: '*Public 类字段与构造函数的处理顺序相同，即在初始化父类字段之后初始化子类字段。 Public 类字段是一种定义实例对象属性的语法。 因此，父类中定义的字段也会被定义为实际实例化的对象的属性。'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*Public 类字段与构造函数的处理顺序相同，即在初始化父类字段之后初始化子类字段。 Public 类字段是一种定义实例对象属性的语法。 因此，父类中定义的字段也会被定义为实际实例化的对象的属性。'
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 如果存在相同名称的字段，则将在子类的字段定义中进行覆盖。
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在相同名称的字段，则将在子类的字段定义中进行覆盖。
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Public 类字段会将父类中定义的字段也定义在子类中。 另一方面，Private 类字段不会将父类中定义的字段定义在子类中。
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Public 类字段会将父类中定义的字段也定义在子类中。 另一方面，Private 类字段不会将父类中定义的字段定义在子类中。
- en: 在下面的代码中，我们试图从子类中引用在父类中定义的 Private 类字段。 但是，我们发现`#parentField`无法被引用，导致语法错误。
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们试图从子类中引用在父类中定义的 Private 类字段。 但是，我们发现`#parentField`无法被引用，导致语法错误。
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 这是因为 Private 类字段的 Private 旨在保护每个类的 Private，因此从继承的类中可以使用 Private 类字段，这会导致 Private
    信息泄漏给子类。 在 JavaScript 中，没有一种语���可以定义既不想公开给类外部又想让子类使用的中间限制属性。
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Private 类字段的 Private 旨在保护每个类的 Private，因此从继承的类中可以使用 Private 类字段，这会导致 Private
    信息泄漏给子类。 在 JavaScript 中，没有一种语���可以定义既不想公开给类外部又想让子类使用的中间限制属性。
- en: 这样，严格拒绝从子类外部访问的 Private 称为 hard private。 JavaScript 中的 Private 类字段被视为 hard private。
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，严格拒绝从子类外部访问的 Private 称为 hard private。 JavaScript 中的 Private 类字段被视为 hard private。
- en: 另一方面，允许子类访问或允许类外部访问的 Private 称为 soft private。 在 JavaScript 中，soft private 需要用户自己使用
    WeakMap 或 WeakSet 来实现（请参考“Map/Set”章节）。
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，允许子类访问或允许类外部访问的 Private 称为 soft private。 在 JavaScript 中，soft private 需要用户自己使用
    WeakMap 或 WeakSet 来实现（请参考“Map/Set”章节）。
- en: '*原型继承*'
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*原型继承*'
- en: '*在下面的代码中，我们使用`extends`关键字定义了继承自`Parent`类的`Child`类。 由于`Parent`类定义了`method`，因此可以从继承该方法的`Child`类的实例中调用。'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*在下面的代码中，我们使用`extends`关键字定义了继承自`Parent`类的`Child`类。 由于`Parent`类定义了`method`，因此可以从继承该方法的`Child`类的实例中调用。'
- en: '[PRE61]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 这样，通过原型链机制，子类的实例也可以调用父类的原型方法。
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，通过原型链机制，子类的实例也可以调用父类的原型方法。
- en: 通过`extends`继承时，子类的原型对象的`[[Prototype]]`内部属性将设置为父类的原型对象。 在此代码中，`Child.prototype`对象的`[[Prototype]]`内部属性将设置为`Parent.prototype`。
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`extends`继承时，子类的原型对象的`[[Prototype]]`内部属性将设置为父类的原型对象。在此代码中，`Child.prototype`对象的`[[Prototype]]`内部属性将设置为`Parent.prototype`。
- en: 这样，当引用属性时，会按照以下顺序搜索对象。
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当引用属性时，会按照以下顺序搜索对象。
- en: '`instance`对象本身'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instance`对象本身'
- en: '`Child.prototype`（指向`instance`对象的`[[Prototype]]`）'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Child.prototype`（指向`instance`对象的`[[Prototype]]`）'
- en: '`Parent.prototype`（指向`Child.prototype`对象的`[[Prototype]]`）'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parent.prototype`（指向`Child.prototype`对象的`[[Prototype]]`）'
- en: 通过这种原型链的机制，`method`属性引用了在`Parent.prototype`对象中定义的方法。
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种原型链的机制，`method`属性引用了在`Parent.prototype`对象中定义的方法。
- en: 通过 JavaScript 的`class`语法和`extends`关键字，可以继承类的**功能**。`class`语法通过引用原型对象来实现继承。因此，这种继承机制被称为**原型继承**。
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 JavaScript 的`class`语法和`extends`关键字，可以继承类的**功能**。`class`语法通过引用原型对象来实现继承。因此，这种继承机制被称为**原型继承**。
- en: '*静态方法的继承*'
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*静态方法的继承*'
- en: '*在实例与类的原型对象之间存在原型链。类本身（类的构造函数）也与其父类本身（父类的构造函数）之间存在原型链。'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实例与类的原型对象之间存在原型链。类本身（类的构造函数）也与其父类本身（父类的构造函数）之间存在原型链。'
- en: 简而言之，静态方法也会被继承。
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，静态方法也会被继承。
- en: '[PRE62]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 当通过`extends`进行继承时，子类构造函数的`[[Prototype]]`内部属性会被设置为父类构造函数。在这段代码中，`Child`构造函数的`[[Prototype]]`内部属性会被设置为`Parent`构造函数。
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`extends`进行继承时，子类构造函数的`[[Prototype]]`内部属性会被设置为父类构造函数。在这段代码中，`Child`构造函数的`[[Prototype]]`内部属性会被设置为`Parent`构造函数。
- en: 换句话说，在先前的代码中，如果引用了`Child.hello`属性，将按照以下顺序搜索对象。
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在先前的代码中，如果引用了`Child.hello`属性，将按照以下顺序搜索对象。
- en: '`Child`构造函数'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Child`构造函数'
- en: '`Parent`构造函数（指向`Child`构造函数的`[[Prototype]]`）'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Parent`构造函数（指向`Child`构造函数的`[[Prototype]]`）'
- en: 由于类的构造函数之间也存在原型链的机制，子类可以调用父类的静态方法。
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类的构造函数之间也存在原型链的机制，子类可以调用父类的静态方法。
- en: '*`super`属性*'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*`super`属性*'
- en: '*子类调用父类构造函数的处理需要使用`super()`。同样地，从子类的原型方法中，可以通过`super.属性名`来引用父类的原型方法。'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*子类调用父类构造函数的处理需要使用`super()`。同样地，从子类的原型方法中，可以通过`super.属性名`来引用父类的原型方法。'
- en: 在下面的代码中，通过在`Child.prototype.method`中编写`super.method()`，调用了`Parent.prototype.method`。因此，可以通过子类引用父类的原型方法。
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，通过在`Child.prototype.method`中编写`super.method()`，调用了`Parent.prototype.method`。因此，可以通过子类引用父类的原型方法。
- en: '[PRE63]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 我们介绍了原型链的概念，该链从实例到类，然后到父类，以搜索方法。在这段代码中，由于`Child.prototype.method`被定义，因此`child.method`将调用`Child.prototype.method`。然后，由于`Child.prototype.method`调用了`super.method`，因此将调用`Parent.prototype.method`。
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了原型链的概念，该链从实例到类，然后到父类，以搜索方法。在这段代码中，由于`Child.prototype.method`被定义，因此`child.method`将调用`Child.prototype.method`。然后，由于`Child.prototype.method`调用了`super.method`，因此将调用`Parent.prototype.method`。
- en: 类的静态方法之间也可以通过`super.method()`来调用。在下面的代码中，从继承了`Parent`的`Child`中调用了父类的静态方法。
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 类的静态方法之间也可以通过`super.method()`来调用。在下面的代码中，从继承了`Parent`的`Child`中调用了父类的静态方法。
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '*继承的判定*'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*继承的判定*'
- en: '*通过使用`instanceof`运算符，可以确定一个类是否继承了指定的类。'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*通过使用`instanceof`运算符，可以确定一个类是否继承了指定的类。'
- en: 下面的代码确认了`Child`的实例是一个继承了`Child`类和`Parent`类的对象。
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码确认了`Child`的实例是一个继承了`Child`类和`Parent`类的对象。
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 更具体的继承用法将在"使用案例:Todo 应用"章节中介绍。
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体的继承用法将在"使用案例:Todo 应用"章节中介绍。
- en: '*内置对象的继承*'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*内置对象的继承*'
- en: '*到目前为止，我们已经学习了如何继承自己定义的类，但是内置对象的构造函数也可以继承。内置对象包括`Array`、`String`、`Object`、`Number`、`Error`、`Date`等。这些内置对象的构造函数可以通过`class`语法进行继承。'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们已经学习了如何继承自己定义的类，但是内置对象的构造函数也可以继承。内置对象包括`Array`、`String`、`Object`、`Number`、`Error`、`Date`等。这些内置对象的构造函数可以通过`class`语法进行继承。'
- en: 下面的代码定义了一个继承自内置对象`Array`并添加了自定义方法的`MyArray`类。继承的`MyArray`类继承了`Array`的方法和状态管理机制。除了继承的性质外，MyArray
    类还添加了`first`和`last`等访问器属性。
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码定义了一个继承自内置对象`Array`并添加了自定义方法的`MyArray`类。继承的`MyArray`类继承了`Array`的方法和状态管理机制。除了继承的性质外，MyArray
    类还添加了`first`和`last`等访问器属性。
- en: '[PRE66]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 继承自`Array`的`MyArray`可以使用`Array`原先具有的`length`属性和`Array.from`方法等。
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自`Array`的`MyArray`可以使用`Array`原先具有的`length`属性和`Array.from`方法等。
- en: '*总结*'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*总结*'
- en: '*在本章中，我们学习了有关类的内容。'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们学习了有关类的内容。'
- en: JavaScript 的类是基于原型的
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的类是基于原型的
- en: 类可以使用`class`语法来定义
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以使用`class`语法来定义
- en: 在类中定义的方法可以通过原型对象和原型链的机制来调用
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类中定义的方法可以通过原型对象和原型链的机制来调用
- en: 类实例的属性定义可以使用类字段
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例的属性定义可以使用类字段
- en: 使用私有类字段可以定义不希望从外部访问的属性
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用私有类字段可以定义不希望从外部访问的属性
- en: 通过定义 getter 和 setter 方法，访问器属性可以像属性一样使用
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义 getter 和 setter 方法，访问器属性可以像属性一样使用
- en: 类可以通过`extends`来进行继承
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以通过`extends`来进行继承
- en: 类的原型方法和静态方法都会被继承********************************
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的原型方法和静态方法都会被继承********************************
