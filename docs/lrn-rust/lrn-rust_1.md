# å…³äºæˆ‘

# å…³äºæˆ‘

ä½ å¥½ï¼Œæˆ‘æ˜¯[Dumindu Madunuwan](https://lk.linkedin.com/in/dumindunuwan)ã€‚æˆ‘æ˜¯ä¸€åç½‘é¡µå¼€å‘è€…ï¼Œä¸»è¦ä½¿ç”¨ PHPã€‚

å¤§çº¦åœ¨ 2007 å¹´è‡³ 2009 å¹´ï¼Œæˆ‘é€‰æ‹©äº†ç½‘é¡µå¼€å‘ï¼Œå› ä¸ºé‚£æ—¶æˆ‘çœŸæ­£ç›¸ä¿¡ï¼Œç½‘ç»œå°†æˆä¸ºä¸‹ä¸€ä¸ªç»ˆæã€ç³»ç»Ÿç‹¬ç«‹å’Œè¯­è¨€ç‹¬ç«‹çš„å¹³å°ï¼Œä¸‹ä¸€ä»£è½¯ä»¶ç”Ÿæ€ç³»ç»Ÿå°†åœ¨æµè§ˆå™¨ä¹‹ä¸Šå®ç°ã€‚æˆ‘æœŸæœ›çš„ç½‘ç»œä¸æ­¤æœ‰äº›ç›¸ä¼¼ã€‚

![Web çš„æœªæ¥ï¼šMozilla Labs Aurora æ¦‚å¿µæµè§ˆå™¨](http://www.youtube.com/watch?v=FZ-zvx1QCcA "Web çš„æœªæ¥ï¼šMozilla Labs Aurora æ¦‚å¿µæµè§ˆå™¨")

åƒä¸€äº›ç½‘é¡µå¼€å‘è€…ä¸€æ ·ï¼Œæˆ‘è¿‡å»ç¡®å®æ›´çœ‹å¥½ HTML5 è€Œä¸æ˜¯æœ¬æœºåº”ç”¨ç¨‹åºã€‚æˆ‘å­¦ä¹ äº† HTML5ã€CSS3ã€RWDã€Mobile First Designã€UI/UX ç­‰ã€‚å¦‚ä»Šï¼Œæˆ‘ä»¬æœ‰æ•°ç™¾ä¸ªå‰ç«¯æ¡†æ¶ï¼Œä½†ä»ç„¶æ— æ³•èƒœè¿‡æœ¬æœºåº”ç”¨ç¨‹åºï¼Œå°¤å…¶æ˜¯åœ¨æ€§èƒ½æ–¹é¢ã€‚

ç¡®å®ï¼Œç½‘ç»œæŠ€æœ¯æ­£åœ¨é€æ¸é€‚åº”é€šè¿‡ asmjsã€NativeScriptã€Electronã€WebAssemblyã€React Native è¿›è¡Œæœ¬æœºåº”ç”¨ç¨‹åºå¼€å‘ï¼Œä½†ç”±äºæ–°å…´çš„è”ç½‘æ±½è½¦å’Œè™šæ‹Ÿç°å®ç”Ÿæ€ç³»ç»Ÿï¼Œæœªæ¥çš„ç½‘ç»œåº”ç”¨ç¨‹åºå¼€å‘å°†å˜å¾—æ›´åŠ å¤æ‚ã€‚

å¦ä¸€æ–¹é¢ï¼Œç°åœ¨æˆ‘ä»¬æœ‰è®¸å¤šå¼ºå¤§çš„ PHP æ›¿ä»£å“ï¼Œæ¯”å¦‚ node å’Œ Goã€‚æ‰€ä»¥ä½œä¸º PHP å¼€å‘è€…ï¼Œç°åœ¨æ˜¯å­¦ä¹ æ–°ä¸œè¥¿çš„æ—¶å€™ï¼Œå­¦ä¹ ä¸€é—¨æ–°çš„è¯­è¨€ã€‚æˆ‘é€‰æ‹© Rust æ˜¯å› ä¸ºå®ƒæ˜¯ä¸€é—¨æœ‰è¶£çš„å­¦ä¹ è¯­è¨€ï¼Œä¸‹ä¸€ä»£æµè§ˆå™¨å¼•æ“[Servo](https://servo.org/)æ˜¯ç”¨ Rust ç¼–å†™çš„ã€‚

* * *

![Medium](https://medium.com/@dumindu "Medium") ![Ycombinator](https://news.ycombinator.com/user?id=dumindunuwan "Ycombinator") ![Reddit](https://www.reddit.com/user/dumindunuwan/ "Reddit") ![Github](https://github.com/dumindu/ "Github") ![LinkedIn](https://lk.linkedin.com/in/dumindunuwan/ "LinkedIn") ![Pinterest](https://www.pinterest.com/dumindu/ "Pinterest") ![Behance](https://www.behance.net/dumindu-madunuwan/ "Behance")

# ä¸ºä»€ä¹ˆé€‰æ‹© Rustï¼Ÿ

# ä¸ºä»€ä¹ˆé€‰æ‹© Rustï¼Ÿ

Rust æœ€åˆç”± Mozilla å‘˜å·¥ Graydon Hoare ä½œä¸ºä¸ªäººé¡¹ç›®è®¾è®¡å’Œå¼€å‘ã€‚Mozilla äº 2009 å¹´å¼€å§‹èµåŠ©è¯¥é¡¹ç›®ï¼Œå¹¶åœ¨ 2010 å¹´å®£å¸ƒã€‚ä½†æ˜¯ï¼Œç¬¬ä¸€ä¸ªç¨³å®šç‰ˆæœ¬ Rust 1.0 äº 2015 å¹´ 5 æœˆ 15 æ—¥å‘å¸ƒã€‚

![é‡æ–°æ€è€ƒç³»ç»Ÿç¼–ç¨‹](http://thoughtram.io/rust-and-nickel/#/11)

Rust çš„ç›®æ ‡æ˜¯æˆä¸ºåˆ›å»ºé«˜åº¦å¹¶å‘å’Œé«˜åº¦å®‰å…¨ç³»ç»Ÿçš„è‰¯å¥½è¯­è¨€ã€‚æ­£å¦‚æ‚¨åœ¨ä¸Šå›¾ä¸­æ‰€çœ‹åˆ°çš„ï¼ŒRust æ—¨åœ¨åŒæ—¶æä¾›é€Ÿåº¦å’Œå®‰å…¨æ€§ã€‚

> "Rust æ˜¯ä¸€ç§ä¸“æ³¨äºä¸‰ä¸ªç›®æ ‡çš„ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼šå®‰å…¨æ€§ã€é€Ÿåº¦å’Œå¹¶å‘æ€§ã€‚"
> 
> __ Rust æ–‡æ¡£

Rust æ˜¯ä¸€ç§éå¸¸å¹´è½»å’Œç°ä»£çš„è¯­è¨€ã€‚å®ƒæ˜¯ä¸€ç§**ç¼–è¯‘å‹ç¼–ç¨‹è¯­è¨€**ï¼Œåœ¨åç«¯ä½¿ç”¨[LLVM](https://en.wikipedia.org/wiki/LLVM)ã€‚æ­¤å¤–ï¼ŒRust æ˜¯ä¸€ç§**å¤šèŒƒå¼ç¼–ç¨‹è¯­è¨€**ï¼Œæ”¯æŒå‘½ä»¤å¼è¿‡ç¨‹ã€å¹¶å‘ actorã€é¢å‘å¯¹è±¡å’Œçº¯å‡½æ•°å¼é£æ ¼ã€‚å®ƒè¿˜æ”¯æŒé™æ€å’ŒåŠ¨æ€é£æ ¼çš„æ³›å‹ç¼–ç¨‹å’Œå…ƒç¼–ç¨‹ã€‚

å…¶è®¾è®¡å…ƒç´ æ¥è‡ªå„ç§æ¥æºã€‚

+   æŠ½è±¡æœºå™¨æ¨¡å‹ï¼š**C**

+   æ•°æ®ç±»å‹ï¼š**C, SML, OCaml, Lisp, Limbo**

+   å¯é€‰ç»‘å®šï¼š**Swift**

+   å«ç”Ÿå®ï¼š**Scheme**

+   å‡½æ•°å¼ç¼–ç¨‹ï¼š**Haskell, OCaml, F#**

+   å±æ€§ï¼š**ECMA**-335

+   å†…å­˜æ¨¡å‹å’Œå†…å­˜ç®¡ç†ï¼š**C++, ML Kit, Cyclone**

+   ç±»å‹ç±»ï¼š**Haskell**

+   ç®±ï¼š**ECMA**-335 CLI æ¨¡å‹ä¸­çš„æ±‡ç¼–

+   é€šé“å’Œå¹¶å‘æ€§ï¼š**Newsqueak, Alef, Limbo**

+   æ¶ˆæ¯ä¼ é€’å’Œçº¿ç¨‹å¤±è´¥ï¼š**Erlang**

ç­‰ç­‰ã€‚

Rust **é»˜è®¤ä¸ä½¿ç”¨è‡ªåŠ¨åƒåœ¾å›æ”¶**ç³»ç»Ÿï¼ˆGCï¼‰ã€‚

> ğŸ” Rust æœ€ç‹¬ç‰¹å’Œå¼•äººæ³¨ç›®çš„ç‰¹æ€§ä¹‹ä¸€æ˜¯[æ‰€æœ‰æƒ](https://doc.rust-lang.org/stable/book/ownership.html)ï¼Œå®ƒç”¨äºå®ç°å†…å­˜å®‰å…¨ã€‚ Rust ä¹è§‚åœ°åˆ›å»ºå†…å­˜æŒ‡é’ˆï¼Œé€šè¿‡ä½¿ç”¨[å¼•ç”¨å’Œå€Ÿç”¨](https://doc.rust-lang.org/stable/book/references-and-borrowing.html)åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å†…å­˜æŒ‡é’ˆçš„æœ‰é™è®¿é—®ã€‚å®ƒé€šè¿‡æ£€æŸ¥[Lifetimes](https://doc.rust-lang.org/stable/book/lifetimes.html)å®ç°è‡ªåŠ¨çš„ç¼–è¯‘æ—¶å†…å­˜ç®¡ç†ã€‚

Rust ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶è§‚å¯Ÿä»£ç ï¼Œå¹¶å¸®åŠ©[é˜²æ­¢è®¸å¤šç§å¯èƒ½åœ¨ C++ ä¸­ç¼–å†™çš„é”™è¯¯](https://doc.rust-lang.org/error-index.html)ã€‚

# å®‰è£…

# å®‰è£…

æœ‰è®¸å¤šå®‰è£… Rust çš„æ–¹æ³•ã€‚ç›®å‰å®˜æ–¹å®‰è£… Rust çš„æ–¹å¼æ˜¯ä½¿ç”¨[Rustup](https://rustup.rs/)ã€‚

[ğŸ•®](https://github.com/rust-lang-nursery/rustup.rs) Rustup ä»å®˜æ–¹å‘å¸ƒæ¸ é“å®‰è£… Rust ç¼–ç¨‹è¯­è¨€ï¼Œä½¿æ‚¨å¯ä»¥è½»æ¾åœ¨ç¨³å®šç‰ˆã€æµ‹è¯•ç‰ˆå’Œå¤œé—´ç‰ˆç¼–è¯‘å™¨ä¹‹é—´åˆ‡æ¢å¹¶ä¿æŒå…¶æ›´æ–°ã€‚å®ƒé€šè¿‡ä¸ºå¸¸è§å¹³å°æä¾›æ ‡å‡†åº“çš„äºŒè¿›åˆ¶æ„å»ºï¼Œç®€åŒ–äº†äº¤å‰ç¼–è¯‘ã€‚

[ğŸ•®](https://github.com/rust-lang-nursery/rustup.rs#installation) Rustup å°† `rustc`ã€`cargo`ã€`rustup` å’Œå…¶ä»–æ ‡å‡†å·¥å…·å®‰è£…åˆ° Cargo çš„ `bin` ç›®å½•ä¸­ã€‚åœ¨ Unix ä¸Šï¼Œå®ƒä½äº `$HOME/.cargo/bin`ï¼Œåœ¨ Windows ä¸Šä½äº `%USERPROFILE%\.cargo\bin`ã€‚è¿™æ˜¯ `cargo install` å°†å®‰è£… Rust ç¨‹åºå’Œ Cargo æ’ä»¶çš„ç›¸åŒç›®å½•ã€‚

**ğŸ’¡** æ›´å¤šä¿¡æ¯å¯ä»¥åœ¨[Rustup é¡¹ç›®çš„ Github é¡µé¢](https://github.com/rust-lang-nursery/rustup.rs)æ‰¾åˆ°ã€‚

å®‰è£… Rust åï¼Œæ‚¨å¯ä»¥åœ¨ç»ˆç«¯ä¸Šé”®å…¥ `rustc --version` æˆ– `rustc -V` æ¥æ£€æŸ¥å½“å‰ç‰ˆæœ¬ï¼Œä»¥éªŒè¯å®‰è£…æˆåŠŸã€‚

# Hello World

# Hello World

```
fn main() {
    println!("Hello, world!");
} 
```

`fn` è¡¨ç¤ºå‡½æ•°ã€‚ä¸»å‡½æ•°æ˜¯æ¯ä¸ª Rust ç¨‹åºçš„èµ·ç‚¹ã€‚

`println!` å°†æ–‡æœ¬æ‰“å°åˆ°æ§åˆ¶å°ï¼Œå…¶ *!* è¡¨ç¤ºå®ƒæ˜¯ä¸€ä¸ª [å®](https://doc.rust-lang.org/book/macros.html) è€Œä¸æ˜¯å‡½æ•°ã€‚

> ğŸ’¡ Rust æ–‡ä»¶åº”è¯¥å…·æœ‰ .rs æ–‡ä»¶æ‰©å±•åï¼Œå¦‚æœæ–‡ä»¶åä½¿ç”¨äº†å¤šä¸ªå•è¯ï¼Œè¯·éµå¾ª [snake_case](https://en.wikipedia.org/wiki/Snake_case)ã€‚

é€šè¿‡ `rustc file.rs` è¿›è¡Œç¼–è¯‘

åœ¨ Linux å’Œ Mac ä¸Šé€šè¿‡ `./file` æ‰§è¡Œï¼Œåœ¨ Windows ä¸Šé€šè¿‡ `file.exe` æ‰§è¡Œ

* * *

ğŸ’¯ è¿™æ˜¯ println! å®çš„å…¶ä»–ç”¨æ³•ï¼Œ

```
fn main() {
    println!("{}, {}!", "Hello", "world"); // Hello, world!
    println!("{0}, {1}!", "Hello", "world"); // Hello, world!
    println!("{greeting}, {name}!", greeting="Hello", name="world"); // Hello, world!

    println!("{:?}", [1,2,3]); // [1, 2, 3]
    println!("{:#?}", [1,2,3]);
    /*
        [
            1,
            2,
            3
        ]
    */

    // ğŸ” format! macro is used to store the formatted STRING
    let x = format!("{}, {}!", "Hello", "world");
    println!("{}", x); // Hello, world!
} 
```

# Cargoã€Crates å’ŒåŸºæœ¬é¡¹ç›®ç»“æ„

# Cargoã€Crates å’ŒåŸºæœ¬é¡¹ç›®ç»“æ„

Cargo æ˜¯ Rust çš„å†…ç½®åŒ…ç®¡ç†å™¨ã€‚ä½†ä¸»è¦ç”¨äºï¼Œ

â–¸ åˆ›å»ºæ–°é¡¹ç›®ï¼š`cargo new`

â–¸ æ›´æ–°ä¾èµ–ï¼š`cargo update`

â–¸ æ„å»ºé¡¹ç›®ï¼š`cargo build`

â–¸ æ„å»ºå¹¶è¿è¡Œé¡¹ç›®ï¼š`cargo run`

â–¸ è¿è¡Œæµ‹è¯•ï¼š`cargo test`

â–¸ é€šè¿‡ rustdoc ç”Ÿæˆæ–‡æ¡£ï¼š`cargo doc`

é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€äº› Cargo å‘½ä»¤ï¼Œä¸“é—¨ç”¨äºé€šè¿‡ cargo ç›´æ¥å‘å¸ƒ cratesã€‚

â–¸ `cargo login`ï¼šè·å– API ä»¤ç‰Œ

â–¸ `cargo package`ï¼šä½¿æœ¬åœ°åˆ›å»ºå¯ä¸Šä¼ åˆ° crates.io

â–¸ `cargo publish`ï¼šä½¿æœ¬åœ°åˆ›å»ºå¯ä¸Šä¼ åˆ° crates.io å¹¶ä¸Šä¼  crate

â­ï¸ **ä¸€ä¸ª crate æ˜¯ä¸€ä¸ª packageã€‚Crates å¯ä»¥é€šè¿‡** [**Cargo**](https://crates.io/) **åˆ†äº«ã€‚**

* * *

ä¸€ä¸ª crate å¯ä»¥ç”Ÿæˆä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶æˆ–ä¸€ä¸ªåº“ã€‚æ¢å¥è¯è¯´ï¼Œå®ƒå¯ä»¥æ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶ crate æˆ–ä¸€ä¸ªåº“ crateã€‚

1.  `cargo new crate_name --bin`ï¼šç”Ÿæˆä¸€ä¸ª **å¯æ‰§è¡Œæ–‡ä»¶**

1.  `cargo new crate_name --lib` æˆ– `cargo new crate_name`ï¼šç”Ÿæˆä¸€ä¸ª **åº“**

ç¬¬ä¸€ç§ç”Ÿæˆæ–¹å¼ä¸ºï¼Œ

```
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ main.rs 
```

ç¬¬äºŒç§ç”Ÿæˆæ–¹å¼ä¸ºï¼Œ

```
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src
    â””â”€â”€ lib.rs 
```

+   **Cargo.toml**ï¼ˆå¤§å†™çš„ cï¼‰æ˜¯é…ç½®æ–‡ä»¶ï¼ŒåŒ…å«äº† Cargo ç¼–è¯‘é¡¹ç›®æ‰€éœ€çš„æ‰€æœ‰å…ƒæ•°æ®ã€‚

+   **src** æ–‡ä»¶å¤¹æ˜¯å­˜å‚¨æºä»£ç çš„åœ°æ–¹ã€‚

+   æ¯ä¸ª crate éƒ½æœ‰ä¸€ä¸ªéšå¼ crate æ ¹ / å…¥å£ç‚¹ã€‚å¯¹äºäºŒè¿›åˆ¶ crateï¼Œ**main.rs** æ˜¯ crate æ ¹ï¼Œå¯¹äºåº“ crateï¼Œ**lib.rs** æ˜¯ crate æ ¹ã€‚

> ğŸ’¡ å½“æˆ‘ä»¬é€šè¿‡ `cargo build` æˆ– `cargo run` æ„å»ºä¸€ä¸ªäºŒè¿›åˆ¶ crate æ—¶ï¼Œå¯æ‰§è¡Œæ–‡ä»¶å°†å­˜å‚¨åœ¨ **target/debug/** æ–‡ä»¶å¤¹ä¸­ã€‚ä½†å½“é€šè¿‡ `cargo build --release` æ„å»ºç”¨äºå‘å¸ƒçš„ç‰ˆæœ¬æ—¶ï¼Œå¯æ‰§è¡Œæ–‡ä»¶å°†å­˜å‚¨åœ¨ **target/release/** æ–‡ä»¶å¤¹ä¸­ã€‚

* * *

è¿™æ˜¯ [Cargo Docs æè¿°](http://doc.crates.io/guide.html#project-layout) æ¨èçš„é¡¹ç›®å¸ƒå±€ï¼Œ

```
.
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ benches
â”‚   â””â”€â”€ large-input.rs
â”œâ”€â”€ examples
â”‚   â””â”€â”€ simple.rs
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ bin
â”‚   â”‚   â””â”€â”€ another_executable.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â””â”€â”€ main.rs
â””â”€â”€ tests
    â””â”€â”€ some-integration-tests.rs 
```

â–¸ æºä»£ç æ”¾åœ¨ `src` ç›®å½•ä¸­ã€‚

â–¸ é»˜è®¤åº“æ–‡ä»¶ä¸º `src/lib.rs`ã€‚

â–¸ é»˜è®¤å¯æ‰§è¡Œæ–‡ä»¶ä¸º `src/main.rs`ã€‚

â–¸ å…¶ä»–å¯æ‰§è¡Œæ–‡ä»¶å¯ä»¥æ”¾åœ¨ `src/bin/*.rs` ä¸­ã€‚

â–¸ é›†æˆæµ‹è¯•æ”¾åœ¨ `tests` ç›®å½•ä¸­ï¼ˆå•å…ƒæµ‹è¯•æ”¾åœ¨å®ƒä»¬æ‰€æµ‹è¯•çš„æ¯ä¸ªæ–‡ä»¶ä¸­ï¼‰ã€‚

â–¸ ç¤ºä¾‹æ”¾åœ¨ `examples` ç›®å½•ä¸­ã€‚

â–¸ åŸºå‡†æµ‹è¯•æ”¾åœ¨ `benches` ç›®å½•ä¸­ã€‚

# æ³¨é‡Šå’Œä»£ç æ–‡æ¡£

# æ³¨é‡Šå’Œä»£ç æ–‡æ¡£

```
// Line comments
/* Block comments */ 
```

æ”¯æŒåµŒå¥—çš„å—æ³¨é‡Šã€‚

ğŸ’¡ **å§‹ç»ˆé¿å…ä½¿ç”¨å—æ³¨é‡Šï¼Œæ”¹ç”¨è¡Œæ³¨é‡Šã€‚**

```
/// Line comments; document the next item
/** Block comments; document the next item */

//! Line comments; document the enclosing item
/*! Block comments; document the enclosing item !*/ 
```

æ–‡æ¡£æ³¨é‡Šæ”¯æŒ Markdown æ ‡è®°ã€‚ä½¿ç”¨ `cargo doc` å‘½ä»¤ï¼Œå¯ä»¥ä»è¿™äº›æ–‡æ¡£æ³¨é‡Šç”Ÿæˆ HTML æ–‡æ¡£ã€‚è®©æˆ‘ä»¬çœ‹çœ‹è¿™ä¸¤ç»„æ–‡æ¡£æ³¨é‡Šä¹‹é—´çš„åŒºåˆ«ã€‚

```
/// This module contains tests
mod test {
    // ...
}

mod test {
    //! This module contains tests

    // ...
} 
```

æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œä¸¤è€…éƒ½ç”¨äºè®°å½•ç›¸åŒçš„æ¨¡å—ã€‚ç¬¬ä¸€ä¸ªæ³¨é‡Šå·²æ·»åŠ åˆ°æ¨¡å—ä¹‹å‰ï¼Œè€Œç¬¬äºŒä¸ªæ³¨é‡Šå·²æ·»åŠ åˆ°æ¨¡å—å†…éƒ¨ã€‚

ğŸ’¡ **åªä½¿ç”¨//!ç¼–å†™ crate å’Œæ¨¡å—çº§æ–‡æ¡£ï¼Œä¸è¦å†™å…¶ä»–å†…å®¹ã€‚ä½¿ç”¨ mod å—æ—¶ï¼Œåœ¨å—å¤–ä½¿ç”¨///ã€‚**

æˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨**æ–‡æ¡£å±æ€§**æ¥è®°å½•ä»£ç ã€‚

> ğŸ” [å±æ€§](https://doc.rust-lang.org/reference.html#attributes)æ˜¯ä¸€ä¸ªé€šç”¨çš„ã€è‡ªç”±å½¢å¼çš„**å…ƒæ•°æ®**ï¼Œæ ¹æ®åç§°ã€çº¦å®šå’Œè¯­è¨€å’Œç¼–è¯‘å™¨ç‰ˆæœ¬è¿›è¡Œè§£é‡Šã€‚ä»»ä½•é¡¹ç›®å£°æ˜éƒ½å¯ä»¥åº”ç”¨å±æ€§ã€‚

è¿™é‡Œçš„æ¯ä¸ªæ³¨é‡Šéƒ½ç­‰åŒäºç›¸å…³çš„æ•°æ®å±æ€§ã€‚

```
/// Foo
#[doc="Foo"]

//! Foo
#![doc="Foo"] 
```

# å˜é‡ç»‘å®šï¼Œå¸¸é‡å’Œé™æ€å˜é‡

# å˜é‡ç»‘å®šï¼Œå¸¸é‡å’Œé™æ€å˜é‡

â­ï¸ åœ¨ Rust ä¸­ï¼Œå˜é‡é»˜è®¤æ˜¯**ä¸å¯å˜çš„**ï¼Œå› æ­¤æˆ‘ä»¬ç§°å®ƒä»¬ä¸º**å˜é‡ç»‘å®š**ã€‚è¦ä½¿å®ƒä»¬å¯å˜ï¼Œä½¿ç”¨`mut` å…³é”®å­—ã€‚

â­ï¸ Rust æ˜¯ä¸€ç§**é™æ€ç±»å‹**è¯­è¨€ï¼›å®ƒåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥æ•°æ®ç±»å‹ã€‚ä½†æ˜¯**å£°æ˜å˜é‡ç»‘å®šæ—¶ä¸éœ€è¦å®é™…è¾“å…¥ç±»å‹**ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šæ£€æŸ¥ç”¨æ³•å¹¶ä¸ºå…¶è®¾ç½®æ›´å¥½çš„æ•°æ®ç±»å‹ã€‚ä½†æ˜¯**å¸¸é‡å’Œé™æ€å˜é‡å¿…é¡»æ³¨æ˜ç±»å‹**ã€‚ç±»å‹åœ¨å†’å·(:)ä¹‹åå£°æ˜ã€‚

+   å˜é‡ç»‘å®š

```
let a = true;
let b: bool = true;

let (x, y) = (1, 2);

let mut z = 5;
z = 6; 
```

+   å¸¸é‡

```
const N: i32 = 5; 
```

+   é™æ€å˜é‡

```
static N: i32 = 5; 
```

**let** å…³é”®å­—ç”¨äºç»‘å®šè¡¨è¾¾å¼ã€‚æˆ‘ä»¬å¯ä»¥å°†åç§°ç»‘å®šåˆ°å€¼æˆ–å‡½æ•°ã€‚æ­¤å¤–ï¼Œç”±äº let è¡¨è¾¾å¼çš„å·¦ä¾§æ˜¯ä¸€ä¸ªâ€˜æ¨¡å¼â€™ï¼Œæ‚¨å¯ä»¥å°†å¤šä¸ªåç§°ç»‘å®šåˆ°ä¸€ç»„å€¼æˆ–å‡½æ•°å€¼ã€‚

**const** å…³é”®å­—ç”¨äºå®šä¹‰å¸¸é‡ã€‚å®ƒåœ¨æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸå†…å­˜åœ¨ï¼Œä½†åœ¨å†…å­˜ä¸­æ²¡æœ‰å›ºå®šçš„åœ°å€ã€‚**static** å…³é”®å­—ç”¨äºå®šä¹‰â€˜å…¨å±€å˜é‡â€™ç±»å‹çš„è®¾æ–½ã€‚æ¯ä¸ªå€¼åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå¹¶ä¸”ä½äºå†…å­˜ä¸­çš„**å›ºå®šä½ç½®**ã€‚

ğŸ’¡ **å§‹ç»ˆä½¿ç”¨ const**ï¼Œè€Œä¸æ˜¯ staticã€‚ä½ å®é™…ä¸Šå¾ˆå°‘éœ€è¦å°†å†…å­˜ä½ç½®ä¸å¸¸é‡å…³è”èµ·æ¥ï¼Œä½¿ç”¨ const å…è®¸è¿›è¡Œä¼˜åŒ–ï¼Œä¾‹å¦‚å¸¸é‡ä¼ æ’­ä¸ä»…åœ¨ä½ çš„ crate ä¸­ï¼Œåœ¨ä¸‹æ¸¸ crate ä¸­ä¹Ÿèƒ½è¿›è¡Œã€‚

ğŸ’¡ é€šå¸¸é™æ€å˜é‡æ”¾ç½®åœ¨ä»£ç æ–‡ä»¶çš„é¡¶éƒ¨ï¼Œå‡½æ•°ä¹‹å¤–ã€‚

# å‡½æ•°

# å‡½æ•°

+   å‡½æ•°ä½¿ç”¨å…³é”®å­— `fn` å£°æ˜

+   åœ¨ä½¿ç”¨**å‚æ•°**æ—¶ï¼Œæ‚¨**å¿…é¡»å£°æ˜æ•°æ®ç±»å‹**ã€‚

+   é»˜è®¤æƒ…å†µä¸‹ï¼Œå‡½æ•°**è¿”å›ç©ºå…ƒç»„ ()**ã€‚å¦‚æœè¦è¿”å›ä¸€ä¸ªå€¼ï¼Œå¿…é¡»åœ¨**->**ä¹‹åæŒ‡å®š**è¿”å›ç±»å‹**ã€‚

```
//Hello world function
fn main() {
    println!("Hello, world!");
}

//Function with arguments 
fn print_sum(a: i8, b: i8) {
    println!("sum is: {}", a + b);
}

//Returning
fn plus_one(a: i32) -> i32 {
    a + 1 //no ; means an expression, return a+1
}

fn plus_two(a: i32) -> i32 {
    return a + 2; //return a+2 but bad practice, 
    //should use only on conditional returnes, except it's last expression 
}

// â­ï¸ Function pointers, Usage as a Data Type
let b = plus_one;
let c = b(5); //6

let b: fn(i32) -> i32 = plus_one; //same, with type inference
let c = b(5); //6 
```

# åŸå§‹æ•°æ®ç±»å‹

# åŸå§‹æ•°æ®ç±»å‹

+   **bool**ï¼štrue æˆ– false

```
let x = true;
let y: bool = false;

// â­ï¸ no TRUE, FALSE, 1, 0 
```

+   **char**ï¼šä¸€ä¸ªå•ä¸€çš„ Unicode æ ‡é‡å€¼

```
let x = 'x';
let y = 'ğŸ˜';

// â­ï¸ no "x", only single quotes
//because of Unicode support, char is not a single byte, but four. 
```

+   **i8 i16 i32 i64**ï¼šå›ºå®šå¤§å°(bit)æœ‰ç¬¦å·(+/-)æ•´æ•°ç±»å‹

| æ•°æ®ç±»å‹ | æœ€å°å€¼ | æœ€å¤§å€¼ |
| --- | --- | --- |
| i8 | -128 | 127 |
| i16 | -32768 | 32767 |
| i32 | -2147483648 | 2147483647 |
| i64 | -9223372036854775808 | 9223372036854775807 |

ğŸ’¡ æœ€å°å€¼å’Œæœ€å¤§å€¼åŸºäº IEEE æ ‡å‡†çš„äºŒè¿›åˆ¶æµ®ç‚¹ç®—æœ¯ï¼›ä»**-2â¿â»Â¹åˆ° 2â¿â»Â¹-1**ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ **min_value()** å’Œ **max_value()** æ¥æ‰¾åˆ°æ¯ç§æ•´æ•°ç±»å‹çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä¾‹å¦‚ i8::min_value();

+   **u8 u16 u32 u64**ï¼šå›ºå®šå¤§å°(bit)æ— ç¬¦å·(+)æ•´æ•°ç±»å‹

| æ•°æ®ç±»å‹ | æœ€å°å€¼ | æœ€å¤§å€¼ |
| --- | --- | --- |
| u8 | 0 | 255 |
| u16 | 0 | 65535 |
| u32 | 0 | 4294967295 |
| u64 | 0 | 18446744073709551615 |

ğŸ’¡ ä¸æœ‰ç¬¦å·æ•°ä¸€æ ·ï¼Œæœ€å°å€¼å’Œæœ€å¤§å€¼åŸºäº IEEE äºŒè¿›åˆ¶æµ®ç‚¹ç®—æœ¯æ ‡å‡†ï¼›ä»**0 åˆ° 2â¿-1**ã€‚åŒæ ·ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨**min_value()**å’Œ**max_value()**æ¥æ‰¾åˆ°æ¯ç§æ•´æ•°ç±»å‹çš„æœ€å°å€¼å’Œæœ€å¤§å€¼ï¼Œä¾‹å¦‚ u8::max_value();

+   **isize**ï¼šå¯å˜å¤§å°çš„æœ‰ç¬¦å·ï¼ˆ+/-ï¼‰æ•´æ•°

ç®€å•æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§æ•°æ®ç±»å‹ï¼Œç”¨äºæ¶µç›–æ‰€æœ‰æœ‰ç¬¦å·æ•´æ•°ç±»å‹ï¼Œä½†å†…å­˜åˆ†é…æ ¹æ®æŒ‡é’ˆçš„å¤§å°ã€‚æœ€å°å’Œæœ€å¤§å€¼ç±»ä¼¼äº i64ã€‚

+   **usize**ï¼šå¯å˜å¤§å°çš„æ— ç¬¦å·ï¼ˆ+ï¼‰æ•´æ•°

ç®€å•æ¥è¯´ï¼Œè¿™æ˜¯ä¸€ç§æ•°æ®ç±»å‹ï¼Œç”¨äºæ¶µç›–æ‰€æœ‰æ— ç¬¦å·æ•´æ•°ç±»å‹ï¼Œä½†å†…å­˜åˆ†é…æ ¹æ®æŒ‡é’ˆçš„å¤§å°ã€‚æœ€å°å’Œæœ€å¤§å€¼ç±»ä¼¼äº u64ã€‚

+   **f32**ï¼š32 ä½æµ®ç‚¹æ•°

ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„æµ®ç‚¹æ•°ï¼Œ**å•ç²¾åº¦**ã€‚

ğŸ’¡ é™¤éæ‚¨è¿«åˆ‡éœ€è¦å‡å°‘å†…å­˜æ¶ˆè€—ï¼Œæˆ–è€…æ­£åœ¨è¿›è¡Œä½çº§ä¼˜åŒ–ï¼Œå½“ç›®æ ‡ç¡¬ä»¶ä¸æ”¯æŒåŒç²¾åº¦ï¼Œæˆ–è€…å½“å•ç²¾åº¦æ¯”åŒç²¾åº¦æ›´å¿«æ—¶ï¼Œåº”é¿å…ä½¿ç”¨è¿™ç§ç±»å‹ã€‚

+   **f64**ï¼š64 ä½æµ®ç‚¹æ•°

ç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„åŒç²¾åº¦ï¼Œ**åŒç²¾åº¦**ã€‚

+   **æ•°ç»„**ï¼šç›¸åŒæ•°æ®ç±»å‹çš„å›ºå®šå¤§å°å…ƒç´ åˆ—è¡¨

```
let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3
let mut b = [1, 2, 3];

let c: [int; 3] = [1, 2, 3]; //[Type; NO of elements]

let d: ["my value"; 3]; //["my value", "my value", "my value"];

let e: [i32; 0] = []; //empty array

println!("{:?}", a); //[1, 2, 3]
println!("{:#?}", a);
//  [
//      1,
//      2,
//      3
//  ] 
```

â­ï¸ æ•°ç»„é»˜è®¤ä¸º**ä¸å¯å˜**ï¼Œå³ä½¿ä½¿ç”¨ mutï¼Œå…¶å…ƒç´ æ•°é‡ä¹Ÿä¸èƒ½æ›´æ”¹ã€‚

> ğŸ” å¦‚æœæ‚¨æ­£åœ¨å¯»æ‰¾ä¸€ä¸ªåŠ¨æ€/å¯å¢é•¿çš„æ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨**Vec**ã€‚å‘é‡å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å…ƒï¿½ï¿½ï¿½ï¼Œä½†æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒçš„æ•°æ®ç±»å‹ã€‚

+   **å…ƒç»„**ï¼šå›ºå®šå¤§å°çš„æœ‰åºå…ƒç´ åˆ—è¡¨ï¼Œå…ƒç´ å¯ä»¥æ˜¯ä¸åŒï¼ˆæˆ–ç›¸åŒï¼‰æ•°æ®ç±»å‹

```
let a = (1, 1.5, true, 'a', "Hello, world!");
// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = "Hello, world!"

let b: (i32, f64) = (1, 1.5);

let (c, d) = b; // c = 1, d = 1.5
let (e, _, _, _, f) = a; //e = 1, f = "Hello, world!", _ indicates not interested of that item

let g = (0,); //single-element tuple

let h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)

println!("{:?}", a); //(1, 1.5, true, 'a', "Hello, world!") 
```

â­ï¸ å…ƒç»„é»˜è®¤ä¹Ÿæ˜¯**ä¸å¯å˜**çš„ï¼Œå³ä½¿ä½¿ç”¨ mutï¼Œå…¶å…ƒç´ æ•°é‡ä¹Ÿä¸èƒ½æ›´æ”¹ã€‚æ­¤å¤–ï¼Œå¦‚æœè¦æ›´æ”¹å…ƒç´ çš„å€¼ï¼Œæ–°å€¼åº”ä¸å…ˆå‰çš„æ•°æ®ç±»å‹ç›¸åŒã€‚

+   **åˆ‡ç‰‡**ï¼šå¯¹å¦ä¸€ä¸ªæ•°æ®ç»“æ„çš„åŠ¨æ€å¤§å°å¼•ç”¨

å¦‚æœæƒ³è¦è·å–/ä¼ é€’æ•°ç»„æˆ–ä»»ä½•å…¶ä»–æ•°æ®ç»“æ„çš„ä¸€éƒ¨åˆ†ã€‚è€Œä¸æ˜¯å°†å…¶å¤åˆ¶åˆ°å¦ä¸€ä¸ªæ•°ç»„ï¼ˆæˆ–ç›¸åŒæ•°æ®ç»“æ„ï¼‰ä¸­ï¼ŒRust å…è®¸åˆ›å»ºä¸€ä¸ªè§†å›¾/å¼•ç”¨ï¼Œä»…è®¿é—®æ•°æ®çš„é‚£éƒ¨åˆ†ã€‚å®ƒå¯ä»¥æ˜¯å¯å˜çš„æˆ–ä¸å¯å˜çš„ã€‚

```
let a: [i32; 4] = [1, 2, 3, 4];//Parent Array

let b: &[i32] = &a; //Slicing whole array
let c = &a[0..4]; // From 0th position to 4th(excluding)
let d = &a[..]; //Slicing whole array

let e = &a[1..3]; //[2, 3]
let e = &a[1..]; //[2, 3, 4]
let e = &a[..3]; //[1, 2, 3] 
```

+   **str**ï¼šæœªå®šå¤§å°çš„ UTF-8 Unicode å­—ç¬¦ä¸²åˆ‡ç‰‡

```
let a = "Hello, world."; //a: &'static str
let b: &str = "ã“ã‚“ã«ã¡ã¯, ä¸–ç•Œ!"; 
```

â­ï¸ è¿™æ˜¯ä¸€ä¸ª**ä¸å¯å˜/é™æ€åˆ†é…çš„åˆ‡ç‰‡**ï¼Œå…¶ä¸­å­˜å‚¨åœ¨å†…å­˜ä¸­çš„æŸä¸ªä½ç½®çš„**æœªçŸ¥å¤§å°çš„ UTF-8**ä»£ç ç‚¹åºåˆ—ã€‚**&str**ç”¨äºå€Ÿç”¨å¹¶å°†æ•´ä¸ªæ•°ç»„åˆ†é…ç»™ç»™å®šçš„å˜é‡ç»‘å®šã€‚

> ğŸ” [å­—ç¬¦ä¸²](https://doc.rust-lang.org/std/string/struct.String.html)æ˜¯ä¸€ä¸ª**å †**åˆ†é…çš„å­—ç¬¦ä¸²ã€‚è¯¥å­—ç¬¦ä¸²æ˜¯å¯å¢é•¿çš„ï¼Œå¹¶ä¸”ä¿è¯ä¸º UTF-8ã€‚å®ƒä»¬é€šå¸¸é€šè¿‡ä½¿ç”¨**to_string()**æˆ–**String::from()**æ–¹æ³•ä»å­—ç¬¦ä¸²åˆ‡ç‰‡è½¬æ¢è€Œæ¥ã€‚ä¾‹å¦‚ï¼š`â€œHelloâ€.to_string();` `String::from("Hello");`

ğŸ’¡ ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå½“æ‚¨éœ€è¦**æ‰€æœ‰æƒ**æ—¶åº”ä½¿ç”¨**String**ï¼Œå½“æ‚¨åªéœ€è¦**å€Ÿç”¨å­—ç¬¦ä¸²**æ—¶åº”ä½¿ç”¨**&str**ã€‚

+   **å‡½æ•°**

æ­£å¦‚æˆ‘ä»¬åœ¨å‡½æ•°éƒ¨åˆ†è®¨è®ºçš„é‚£æ ·ï¼Œb æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼ŒæŒ‡å‘ plus_one å‡½æ•°

```
fn plus_one(a: i32) -> i32 {
    a + 1
}

let b: fn(i32) -> i32 = plus_one;
let c = b(5); //6 
```

# è¿ç®—ç¬¦

# è¿ç®—ç¬¦

+   **ç®—æœ¯è¿ç®—ç¬¦**ï¼š+ - * / %

```
let a = 5;
let b = a + 1; //6
let c = a - 1; //4
let d = a * 2; //10
let e = a / 2; // â­ï¸ 2 not 2.5
let f = a % 2; //1

let g = 5.0 / 2.0; //2.5 
```

> ğŸ” è¿˜æœ‰**+**ç”¨äº**æ•°ç»„å’Œå­—ç¬¦ä¸²çš„è¿æ¥**

+   **æ¯”è¾ƒè¿ç®—ç¬¦**ï¼š== != < > <= >=

```
let a = 1;
let b = 2;

let c = a == b; //false
let d = a != b; //true
let e = a < b; //true
let f = a > b; //false
let g = a <= a; //true
let h = a >= a; //true

// ğŸ”
let i = true > false; //true
let j = 'a' > 'A'; //true 
```

+   **é€»è¾‘è¿ç®—ç¬¦**ï¼š! && ||

```
let a = true;
let b = false;

let c = !a; //false
let d = a && b; //false
let e = a || b; //true 
```

> ğŸ” åœ¨æ•´æ•°ç±»å‹ä¸Šï¼Œ!ä¼šåè½¬å€¼çš„äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºä¸­çš„å„ä¸ªä½ã€‚

```
let a = !-2; //1
let b = !-1; //0
let c = !0; //-1
let d = !1; //-2 
```

+   **ä½è¿ç®—ç¬¦**ï¼š& | ^ << >>

```
let a = 1;
let b = 2;

let c = a & b; //0  (01 && 10 -> 00)
let d = a | b; //3  (01 || 10 -> 11)
let e = a ^ b; //3  (01 != 10 -> 11)
let f = a << b; //4  (add 2 positions to the end -> '01'+'00' -> 100)
let g = a >> a; //0  (remove 2 positions from the end -> oÌ¶1Ì¶ -> 0) 
```

+   **èµ‹å€¼å’Œå¤åˆèµ‹å€¼è¿ç®—ç¬¦**

=è¿ç®—ç¬¦ç”¨äºå°†å€¼æˆ–å‡½æ•°çš„åç§°åˆ†é…ç»™ä¸€ä¸ªåç§°ã€‚å¤åˆèµ‹å€¼è¿ç®—ç¬¦æ˜¯é€šè¿‡å°†+ - * / % & | ^ << >>è¿ç®—ç¬¦ä¹‹ä¸€ä¸=è¿ç®—ç¬¦ç»„åˆè€Œæˆçš„ã€‚

```
let mut a = 2;

a += 5; //2 + 5 = 7
a -= 2; //7 - 2 = 5
a *= 5; //5 * 5 = 25
a /= 2; //25 / 2 = 12 not 12.5
a %= 5; //12 % 5 = 2

a &= 2; //10 && 10 -> 10 -> 2
a |= 5; //010 || 101 -> 111 -> 7
a ^= 2; //111 != 010 -> 101 -> 5
a <<= 1; //'101'+'0' -> 1010 -> 10
a >>= 2; //101Ì¶0Ì¶ -> 10 -> 2 
```

+   **ç±»å‹è½¬æ¢è¿ç®—ç¬¦**ï¼šas

```
let a = 15;
let b = (a as f64) / 2.0; //7.5 
```

+   **å€Ÿç”¨å’Œè§£å¼•ç”¨è¿ç®—ç¬¦**ï¼š& &mut *

**&æˆ–&mut**è¿ç®—ç¬¦ç”¨äº**å€Ÿç”¨**ï¼Œ*****è¿ç®—ç¬¦ç”¨äº**è§£å¼•ç”¨**ã€‚

> ğŸ” è¿™äº›è¿ç®—ç¬¦çš„ä½¿ç”¨æ˜¯ä¸€ä¸ªé«˜çº§è¯é¢˜ï¼Œæ›´å¤šä¿¡æ¯è¯·å‚è€ƒ[Rust å‚è€ƒæ–‡æ¡£](https://doc.rust-lang.org/reference.html#unary-operator-expressions)ã€‚

# æ§åˆ¶æµ

# æ§åˆ¶æµ

+   **if - else if - else**

```
// Simplest Example
let team_size = 7;
if team_size < 5 {
    println!("Small");
} else if team_size < 10 {
    println!("Medium");
} else {
    println!("Large");
}

// partially refactored code
let team_size = 7;
let team_size_in_text;
if team_size < 5 {
    team_size_in_text = "Small";
} else if team_size < 10 {
    team_size_in_text = "Medium";
} else {
    team_size_in_text = "Large";
}
println!("Current team size : {}", team_size_in_text);

//optimistic code
let team_size = 7;
let team_size_in_text = if team_size < 5 {
    "Small" //â­ï¸no ;
} else if team_size < 10 {
    "Medium"
} else {
    "Large"
};
println!("Current team size : {}", team_size_in_text);

let is_below_eighteen = if team_size < 18 { true } else { false }; 
```

â­ï¸ **å½“å°†å…¶ç”¨ä½œè¡¨è¾¾å¼æ—¶ï¼Œæ¯ä¸ªå—çš„è¿”å›æ•°æ®ç±»å‹åº”è¯¥ç›¸åŒã€‚**

+   **åŒ¹é…**

```
let tshirt_width = 20;
let tshirt_size = match tshirt_width {
    16 => "S", // check 16
    17 | 18 => "M", // check 17 and 18
    19 ... 21 => "L", // check from 19 to 21 (19,20,21)
    22 => "XL",
    _ => "Not Available",
};
println!("{}", tshirt_size); // L

let is_allowed = false;
let list_type = match is_allowed {
    true => "Full",
    false => "Restricted"
    // no default/ _ condition can be skipped 
    // Because data type of is_allowed is boolean and all possibilities checked on conditions 
};
println!("{}", list_type); // Restricted

let marks_paper_a: u8 = 25;
let marks_paper_b: u8 = 30;
let output = match (marks_paper_a, marks_paper_b) {
    (50, 50) => "Full marks for both papers",
    (50, _) => "Full marks for paper A",
    (_, 50) => "Full marks for paper B",
    (x, y) if x > 25 && y > 25 => "Good",
    (_, _) => "Work hard"
};
println!("{}", output); // Work hard 
```

+   **while**

```
let mut a = 1;
while a <= 10 { 
    println!("Current value : {}", a);
    a += 1; //no ++ or -- on Rust
}

// Usage of break and continue
let mut b = 0;
while b < 5 {
    if b == 0 { 
        println!("Skip value : {}", b);
        b += 1;
        continue;
    } else if b == 2 {
        println!("Break At : {}", b);
        break;
    }
    println!("Current value : {}", b);
    b += 1;
}

// Outer break
let mut c1 = 1;
'outer_while: while c1 < 6 { //set label outer_while
    let mut c2 = 1;
    'inner_while: while c2 < 6 { 
        println!("Current Value : [{}][{}]", c1, c2);
        if c1 == 2 && c2 == 2 { break 'outer_while; } //kill outer_while
        c2 += 1;
    }
    c1 += 1;
} 
```

+   **å¾ªç¯**

```
loop {
    println!("Loop forever!");
}

// Usage of break and continue
let mut a = 0;
loop {
    if a == 0 {
        println!("Skip Value : {}", a);
        a += 1;
        continue;
    } else if a == 2 {
        println!("Break At : {}", a);
        break;
    }
    println!("Current Value : {}", a);
    a += 1;
}

// Outer break
let mut b1 = 1;
'outer_loop: loop { //set label outer_loop
  let mut b2 = 1;
  'inner_loop: loop {
    println!("Current Value : [{}][{}]", b1, b2);
    if b1 == 2 && b2 == 2 {
        break 'outer_loop; // kill outer_loop
    } else if b2 == 5 {
        break;
    }
    b2 += 1;
  }
  b1 += 1;
} 
```

+   **for**

```
for a in 0..10 { //(a = o; a <10; a++) // 0 to 10(exclusive)
  println!("Current value : {}", a);
}

// Usage of break and continue
for b in 0..6 {
  if b == 0 {
    println!("Skip Value : {}", b);
    continue;
  } else if b == 2 {
    println!("Break At : {}", b);
    break;
  }
  println!("Current value : {}", b);
}

// Outer break
'outer_for: for c1 in 1..6 { //set label outer_for
  'inner_for: for c2 in 1..6 {
    println!("Current Value : [{}][{}]", c1, c2);
    if c1 == 2 && c2 == 2 { break 'outer_for; } //kill outer_for
  }
}

// Working with arrays/vectors
let group : [&str; 4] = ["Mark", "Larry", "Bill", "Steve"];

for n in 0..group.len() { //group.len() = 4 -> 0..4 ğŸ‘ check group.len()on each iteration
  println!("Current Person : {}", group[n]);
}

for person in group.iter() { //ğŸ‘ group.iter() turn the array into a simple iterator
  println!("Current Person : {}", person);
} 
```

# å‘é‡

# å‘é‡

å¦‚æœæ‚¨è®°å¾—ï¼Œæ•°ç»„æ˜¯ç›¸åŒæ•°æ®ç±»å‹çš„å›ºå®šå¤§å°å…ƒç´ åˆ—è¡¨ã€‚å³ä½¿ä½¿ç”¨ mutï¼Œå…¶å…ƒç´ è®¡æ•°ä¹Ÿä¸èƒ½æ›´æ”¹ã€‚å‘é‡æ˜¯ä¸€ç§å¯è°ƒæ•´å¤§å°çš„æ•°ç»„ï¼Œä½†æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯ç›¸åŒç±»å‹çš„ã€‚

â­ï¸ è¿™æ˜¯ä¸€ä¸ªé€šç”¨ç±»å‹ï¼Œå†™ä½œ Vec <t class="hljs-meta">ã€‚T å¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼Œä¾‹å¦‚ã€‚i32s çš„ Vec çš„ç±»å‹æ˜¯ Vec<i32 class="hljs-meta">ã€‚æ­¤å¤–ï¼Œå‘é‡æ€»æ˜¯åœ¨åŠ¨æ€åˆ†é…çš„å †ä¸­åˆ†é…å®ƒä»¬çš„æ•°æ®ã€‚</i32></t>

```
//Creating vectors - 2 ways
let mut a = Vec::new(); //1.with new() keyword
let mut b = vec![]; //2.using the vec! macro

//Creating with data types
let mut a2: Vec<i32> = Vec::new();
let mut b2: Vec<i32> = vec![];
let mut b3 = vec![1i32, 2, 3];//sufixing 1st value with data type

//Creating with data
let mut b4 = vec![1, 2, 3];
let mut b5: Vec<i32> = vec![1, 2, 3];
let mut b6  = vec![1i32, 2, 3];
let mut b7 = vec![0; 10]; //ten zeroes

//Accessing and changing exsisting data
let mut c = vec![5, 4, 3, 2, 1];
c[0] = 1;
c[1] = 2;
//c[6] = 2; can't assign values this way, index out of bounds
println!("{:?}", c); //[1, 2, 3, 2, 1]

//push and pop
let mut d: Vec<i32> = Vec::new();
d.push(1); //[1] : Add an element to the end
d.push(2); //[1, 2]
d.pop(); //[1] : : Remove an element from the end

// ğŸ” Capacity and reallocation
let mut e: Vec<i32> = Vec::with_capacity(10);
println!("Length: {}, Capacity : {}", e.len(), e.capacity()); //Length: 0, Capacity : 10

// These are all done without reallocating...
for i in 0..10 {
    e.push(i);
}
// ...but this may make the vector reallocate
e.push(11); 
```

â­ï¸ ä¸»è¦ä¸€ä¸ªå‘é‡ä»£è¡¨ 3 ä¸ªä¸œè¥¿ï¼›æŒ‡å‘æ•°æ®çš„æŒ‡é’ˆï¼Œå½“å‰æ‹¥æœ‰çš„å…ƒç´ æ•°é‡ï¼ˆé•¿åº¦ï¼‰ï¼Œå®¹é‡ï¼ˆä¸ºä»»ä½•æœªæ¥å…ƒç´ åˆ†é…çš„ç©ºé—´é‡ï¼‰ã€‚å¦‚æœå‘é‡çš„é•¿åº¦è¶…è¿‡å…¶å®¹é‡ï¼Œå…¶å®¹é‡å°†è‡ªåŠ¨å¢åŠ ã€‚ä½†å…¶å…ƒç´ å°†è¢«é‡æ–°åˆ†é…ï¼ˆå¯èƒ½ä¼šå¾ˆæ…¢ï¼‰ã€‚å› æ­¤ï¼Œå°½å¯èƒ½åœ¨å¯èƒ½çš„æƒ…å†µä¸‹å§‹ç»ˆä½¿ç”¨ Vec::with_capacityã€‚

> ğŸ” å­—ç¬¦ä¸²æ•°æ®ç±»å‹æ˜¯ UTF-8 ç¼–ç çš„å‘é‡ã€‚ä½†ç”±äºç¼–ç çš„åŸå› ï¼Œæ‚¨æ— æ³•å¯¹å­—ç¬¦ä¸²è¿›è¡Œç´¢å¼•ã€‚

å‘é‡å¯ä»¥ä»¥ä¸‰ç§æ–¹å¼ä¸è¿­ä»£å™¨ä¸€èµ·ä½¿ç”¨ï¼Œ

```
let mut v = vec![1, 2, 3, 4, 5];

for i in &v {
    println!("A reference to {}", i);
}

for i in &mut v {
    println!("A mutable reference to {}", i);
}

for i in v {
    println!("Take ownership of the vector and its element {}", i);
} 
```

# ç»“æ„ä½“

# ç»“æ„ä½“

â­ï¸ ç»“æ„ä½“ç”¨äºå°†ç›¸å…³å±æ€§å°è£…æˆä¸€ä¸ªç»Ÿä¸€çš„æ•°æ®ç±»å‹ã€‚

ğŸ’¡ æŒ‰ç…§æƒ¯ä¾‹ï¼Œç»“æ„ä½“çš„åç§°ä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œå¹¶éµå¾ªé©¼å³°å‘½åæ³•ã€‚

æœ‰ 3 ç§ç»“æ„ä½“çš„å˜ä½“ï¼Œ

1.  ç±»ä¼¼ C çš„ç»“æ„ä½“

1.  ä¸€ä¸ªæˆ–å¤šä¸ªé€—å·åˆ†éš”çš„åç§°:å€¼å¯¹

1.  å¤§æ‹¬å·åŒ…å›´çš„åˆ—è¡¨

1.  ä¸å…¶ä»–è¯­è¨€ï¼ˆå¦‚ Javaï¼‰ä¸­çš„ç±»ï¼ˆæ²¡æœ‰æ–¹æ³•ï¼‰ç±»ä¼¼

1.  å› ä¸ºå­—æ®µæœ‰åç§°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ï¿½ï¿½ï¿½ç¬¦å·è®¿é—®å®ƒä»¬

    1.  å…ƒç»„ç»“æ„ä½“

1.  ä¸€ä¸ªæˆ–å¤šä¸ªé€—å·åˆ†éš”çš„å€¼

1.  åƒå…ƒç»„ä¸€æ ·ç”¨æ‹¬å·æ‹¬èµ·æ¥çš„åˆ—è¡¨

1.  çœ‹èµ·æ¥åƒå‘½åå…ƒç»„

    1.  å•å…ƒç»“æ„ä½“

1.  ä¸€ä¸ªæ²¡æœ‰ä»»ä½•æˆå‘˜çš„ç»“æ„ä½“

1.  å®ƒå®šä¹‰äº†ä¸€ä¸ªæ–°ç±»å‹ï¼Œä½†å®ƒç±»ä¼¼äºä¸€ä¸ªç©ºå…ƒç»„ï¼Œ()

1.  å¾ˆå°‘ä½¿ç”¨ï¼Œä¸æ³›å‹ä¸€èµ·å¾ˆæœ‰ç”¨

â­ï¸ åœ¨ Rust ä¸­æ¶‰åŠé¢å‘å¯¹è±¡ç¼–ç¨‹æ—¶ï¼Œå±æ€§å’Œæ–¹æ³•åˆ†åˆ«æ”¾ç½®åœ¨ç»“æ„ä½“å’Œç‰¹å¾ä¸Šã€‚ç»“æ„ä½“ä»…åŒ…å«å±æ€§ï¼Œç‰¹å¾ä»…åŒ…å«æ–¹æ³•ã€‚å®ƒä»¬é€šè¿‡ impls è¿æ¥åœ¨ä¸€èµ·

## 01\. ç±» C ç»“æ„ä½“

```
// Struct Declaration
struct Color {
    red: u8,
    green: u8,
    blue: u8
}

fn main() {
  // creating an instance
  let black = Color {red: 0, green: 0, blue: 0};

  // accessing it's fields, using dot notation
  println!("Black = rgb({}, {}, {})", black.red, black.green, black.blue); //Black = rgb(0, 0, 0)

  // structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability
  let mut link_color = Color {red: 0,green: 0,blue: 255};
  link_color.blue = 238;
  println!("Link Color = rgb({}, {}, {})", link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)

  // copy elements from another instance
  let blue = Color {blue: 255, .. link_color};
  println!("Blue = rgb({}, {}, {})", blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)

  // destructure the instance using a `let` binding, this will not destruct blue instance
  let Color {red: r, green: g, blue: b} = blue;
  println!("Blue = rgb({}, {}, {})", r, g, b); //Blue = rgb(0, 0, 255)

  // creating an instance via functions & accessing it's fields
  let midnightblue = get_midnightblue_color();
  println!("Midnight Blue = rgb({}, {}, {})", midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)

  // destructure the instance using a `let` binding
  let Color {red: r, green: g, blue: b} = get_midnightblue_color();
  println!("Midnight Blue = rgb({}, {}, {})", r, g, b); //Midnight Blue = rgb(25, 25, 112)
}

fn get_midnightblue_color() -> Color {
    Color {red: 25, green: 25, blue: 112}
} 
```

## 02\. å…ƒç»„ç»“æ„ä½“

â­ï¸ å½“å…ƒç»„ç»“æ„åªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º 'newtype' æ¨¡å¼ã€‚å› ä¸ºå®ƒæœ‰åŠ©äºåˆ›å»ºä¸€ä¸ªæ–°ç±»å‹ã€‚

```
struct Color (u8, u8, u8);
struct Kilometers(i32);

fn main() {
  // creating an instance
  let black = Color (0, 0, 0);

  // destructure the instance using a `let` binding, this will not destruct black instance
  let Color (r, g, b) = black;
  println!("Black = rgb({}, {}, {})", r, g, b); //black = rgb(0, 0, 0);

  //newtype pattern
  let distance = Kilometers(20);
  // destructure the instance using a `let` binding
  let Kilometers(distance_in_km) = distance;
  println!("The distance: {} km", distance_in_km); //The distance: 20 km
} 
```

## 03\. å•å…ƒç»“æ„ä½“

è¿™æœ¬èº«å¾ˆå°‘æœ‰ç”¨ï¼Œä½†ä¸å…¶ä»–åŠŸèƒ½ç»“åˆä½¿ç”¨æ—¶ï¼Œå®ƒå¯ä»¥å˜å¾—æœ‰ç”¨ã€‚

> ğŸ“– ä¾‹å¦‚ï¼šä¸€ä¸ªåº“å¯èƒ½ä¼šè¦æ±‚æ‚¨åˆ›å»ºä¸€ä¸ªå®ç°æŸä¸ªç‰¹å®šç‰¹å¾ä»¥å¤„ç†äº‹ä»¶çš„ç»“æ„ã€‚å¦‚æœæ‚¨ä¸éœ€è¦åœ¨ç»“æ„ä¸­å­˜å‚¨ä»»ä½•æ•°æ®ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªç±»ä¼¼äºå•å…ƒçš„ç»“æ„ã€‚

```
struct Electron;

fn main() {
  let x = Electron;
} 
```

# æšä¸¾

# æšä¸¾

â­ï¸ æšä¸¾æ˜¯ä¸€ä¸ªå•ä¸€ç±»å‹ã€‚å®ƒåŒ…å«å˜ä½“ï¼Œè¿™äº›æ˜¯æšä¸¾åœ¨ç»™å®šæ—¶é—´çš„å¯èƒ½å€¼ã€‚ä¾‹å¦‚ï¼Œ

```
enum Day {
    Sunday,
    Monday, 
    Tuesday, 
    Wednesday, 
    Thursday,
    Friday,
    Saturday
}

// Day is the enum
// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants 
```

â­ï¸ å¯ä»¥é€šè¿‡ :: ç¬¦å·è®¿é—®å˜ä½“ï¼Œä¾‹å¦‚ Day::Sunday

â­ï¸ æ¯ä¸ªæšä¸¾å˜ä½“éƒ½å¯ä»¥æœ‰ï¼Œ

+   æ— æ•°æ®ï¼ˆå•å…ƒå˜ä½“ï¼‰

+   æœªå‘½åçš„æœ‰åºæ•°æ®ï¼ˆå…ƒç»„å˜ä½“ï¼‰

+   å‘½åæ•°æ®ï¼ˆstruct å˜ä½“ï¼‰

```
enum FlashMessage {
  Success, //a unit variant
  Warning{ category: i32, message: String }, //a struct variant
  Error(String) //a tuple variant
}

fn main() {
  let mut form_status = FlashMessage::Success;
  print_flash_message(form_status);

  form_status = FlashMessage::Warning {category: 2, message: String::from("Field X is required")};
  print_flash_message(form_status);

  form_status = FlashMessage::Error(String::from("Connection Error"));
  print_flash_message(form_status);
}

fn print_flash_message(m : FlashMessage) {
  // pattern matching with enum
  match m {
    FlashMessage::Success => 
      println!("Form Submitted correctly"),
    FlashMessage::Warning {category, message} => //Destructure, should use same field names
      println!("Warning : {} - {}", category, message),
    FlashMessage::Error(msg) => 
      println!("Error : {}", msg)
  }
} 
```

# æ³›å‹

# æ³›å‹

> ğŸ“– æœ‰æ—¶ï¼Œåœ¨ç¼–å†™å‡½æ•°æˆ–æ•°æ®ç±»å‹æ—¶ï¼Œæˆ‘ä»¬å¯èƒ½å¸Œæœ›å®ƒé€‚ç”¨äºå¤šç§ç±»å‹çš„å‚æ•°ã€‚åœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ³›å‹æ¥å®ç°è¿™ä¸€ç‚¹ã€‚

ğŸ’­ è¿™ä¸ªæ¦‚å¿µæ˜¯ï¼Œæˆ‘ä»¬ä¸æ˜¯å£°æ˜ä¸€ä¸ªç‰¹å®šçš„æ•°æ®ç±»å‹ï¼Œè€Œæ˜¯ä½¿ç”¨ä¸€ä¸ªå¤§å†™å­—æ¯ï¼ˆæˆ– CamelCase æ ‡è¯†ç¬¦ï¼‰ã€‚ä¾‹å¦‚ï¼Œä»£æ›¿ x : u8ï¼Œæˆ‘ä»¬ä½¿ç”¨ x : Tã€‚ä½†æˆ‘ä»¬å¿…é¡»å‘ç¼–è¯‘å™¨å£°æ˜ T æ˜¯ä¸€ä¸ªæ³›å‹ç±»å‹ï¼ˆå¯ä»¥æ˜¯ä»»ä½•ç±»å‹ï¼‰ï¼Œé€šè¿‡åœ¨æœ€å‰é¢æ·»åŠ  <t class="hljs-meta">ã€‚</t>

```
// generalizing functions
//-----------------------
fn takes_anything<T>(x: T) { // x has type T, T is a generic type
}

fn takes_two_of_the_same_things<T>(x: T, y: T) { // both x and y has same type
}

fn takes_two_things<T, U>(x: T, y: U) { // multiple types
}

// generalizing structs
//---------------------
struct Point<T> {
  x: T,
  y: T,
}

fn main() {
  let point_a = Point { x: 0, y: 0 }; // T is a int type
  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type
}

// ğŸ” When addding an implementation for a generic struct, the type parameters should be declared after the impl as well
// impl<T> Point<T> {

// generalizing enums
//-------------------
enum Option<T> {
    Some(T),
    None,
}

enum Result<T, E> {
    Ok(T),
    Err(E),
} 
```

> â­ï¸ ä¸Šè¿° Option å’Œ Result ç±»å‹æ˜¯ Rust æ ‡å‡†åº“ä¸­å·²ç»å®šä¹‰çš„ä¸€äº›ç‰¹æ®Šæ³›å‹ç±»å‹ã€‚
> 
> +   å¯é€‰å€¼å¯ä»¥æ˜¯ Some å€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯æ²¡æœ‰å€¼ / Noneã€‚
> +   
> +   ç»“æœå¯ä»¥è¡¨ç¤ºæˆåŠŸ / Ok æˆ–å¤±è´¥ / Err

```
// 01 - - - - - - - - - - - - - - - - - - - - - -
fn getIdByUsername(username: &str) -> Option<usize> {
    //if username can be found in the system, set userId
        return Some(userId);
    //else
        None
}

//ğŸ’­ So on above function, instead of setting return type as usize
// set return type as Option<usize>
//Instead of return userId, return Some(userId)
// else None (ğŸ’¡remember? last return statement no need return keyword and ending ;)

// 02 - - - - - - - - - - - - - - - - - - - - - -
struct Task {
    title: String,
    assignee: Option<Person>,
}

//ğŸ’­ Instead of assignee: Person, we use Option<Person>
//Because the task has not been assigned to a specific person

// - - - - - - - - - - - - - - - - - - - - - - -
//when using Option types as return types on functions
// we can use pattern matching to catch the relevant return type(Some/None) when calling them

fn main() {
    let username = "anonymous"
    match getIdByUsername(username) {
        None => println!("User not found"),
        Some(i) => println!("User Id: {}", i)
    }
} 
```

> ğŸ“– Option ç±»å‹æ˜¯ä½¿ç”¨ Rust çš„ç±»å‹ç³»ç»Ÿæ¥è¡¨è¾¾ç¼ºå¤±å¯èƒ½æ€§çš„ä¸€ç§æ–¹å¼ã€‚Result è¡¨è¾¾äº†é”™è¯¯çš„å¯èƒ½æ€§ã€‚

```
// - - - - - - - - - - - - - - - - - - - - - -
fn get_word_count_from_file(file_name: &str) -> Result<u32, &str> {
  //if the file is not found on the system, return error
    return Err("File can not be found!")
  //else, count and return the word count 
    //let mut word_count: u32; ....
    Ok(word_count)
}

//ğŸ’­ on above function, 
// instead panic(break) the app, when a file can not be found; return Err(something)
// or when it could get the relevant data; return Ok(data)

// - - - - - - - - - - - - - - - - - - - - - - -
// we can use pattern matching to catch the relevant return type(Ok/Err) when calling it

fn main() {
    let mut file_name = "file_a";
    match get_word_count_from_file(file_name) {
        Ok(i) => println!("Word Count: {}", i),
        Err(e) => println!("Error: {}", e)
    }
} 
```

> ğŸ” åœ¨ Option å’Œ Result ç±»å‹å‘¨å›´å·²ç»å®ç°äº†è®¸å¤šæœ‰ç”¨çš„æ–¹æ³•ã€‚å…³äºå®ƒä»¬çš„æ›´å¤šä¿¡æ¯å¯ä»¥åœ¨ Rust æ–‡æ¡£ä¸­çš„ std::option::Option å’Œ std::result::Result é¡µé¢æ‰¾åˆ°ã€‚

â­ï¸ åœ¨ Rust æ–‡æ¡£çš„é”™è¯¯å¤„ç†éƒ¨åˆ†ä¹Ÿå¯ä»¥æ‰¾åˆ°æ›´å¤šå…³äºé€‰é¡¹ï¼ˆOptionsï¼‰å’Œç»“æœï¼ˆResultsï¼‰çš„å®ç”¨ç¤ºä¾‹ã€‚

# å®ç° & ç‰¹å¾

# å®ç° & ç‰¹å¾

ğŸ’¡ å½“æˆ‘ä»¬è®¨è®ºç±»ä¼¼äº C çš„ç»“æ„ä½“æ—¶ï¼Œæˆ‘æåˆ°è¿‡å®ƒä»¬ä¸å…¶ä»–è¯­è¨€ï¼ˆå¦‚ Javaï¼‰ä¸­çš„ç±»ç›¸ä¼¼ï¼Œä½†æ²¡æœ‰å®ƒä»¬çš„æ–¹æ³•ã€‚impls ç”¨äºä¸º Rust ç»“æ„ä½“å’Œæšä¸¾å®šä¹‰æ–¹æ³•ã€‚

ğŸ’¡ ç‰¹å¾ä¸å…¶ä»–è¯­è¨€ï¼ˆå¦‚ Javaï¼‰ä¸­çš„æ¥å£æœ‰äº›ç›¸ä¼¼ã€‚å®ƒä»¬ç”¨äºå®šä¹‰ç±»å‹å¿…é¡»æä¾›çš„åŠŸèƒ½ã€‚ä¸€ä¸ªç±»å‹å¯ä»¥å®ç°å¤šä¸ªç‰¹å¾ã€‚

â­ï¸â­ï¸â­ï¸ ä½†ç‰¹å¾ä¹Ÿå¯ä»¥åŒ…å«æ–¹æ³•çš„é»˜è®¤å®ç°ã€‚å½“å®ç°ç±»å‹æ—¶ï¼Œå¯ä»¥è¦†ç›–é»˜è®¤æ–¹æ³•ã€‚

```
// 01 -----------------------------------------
// Adding methoids directly; without using traits

struct Player {
    first_name: String,
    last_name: String,
}

impl Player {
    fn full_name(&self) -> String {
        format!("{} {}", self.first_name, self.last_name)
    }
}

fn main() {
    let player_1 = Player {
        first_name: "Rafael".to_string(),
        last_name: "Nadal".to_string(),
    };

    println!("Player 01: {}", player_1.full_name());
}

// 02 -----------------------------------------
// Adding methoids by implementing traits

struct Player {
    first_name: String,
    last_name: String,
}

trait FullName {
    fn full_name(&self) -> String;
}

impl FullName for Player {
    fn full_name(&self) -> String {
        format!("{} {}", self.first_name, self.last_name)
    }
}

fn main() {
    let player_2 = Player {
        first_name: "Roger".to_string(),
        last_name: "Federer".to_string(),
    };

    println!("Player 02: {}", player_2.full_name());
}

// 03 -----------------------------------------
// a trait with default implementations of methods

trait Foo {
    fn bar(&self);
    fn baz(&self) { println!("We called baz."); }
}

// --------------------------------------------
// â­ï¸ In case 01, implementation must appear in the same crate as the self type

// ğŸ’¡ And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.
// Same way existing traits can be implemented for new types you are creating.
// But we can not implement existing traits into existing types

// ğŸ” Other than functions, traits can contain constants and types

// ğŸ” Traits also supprot generics; should specify after the trait name like generic functions

trait From<T> {
    fn from(T) -> Self;
}
    impl From<u8> for u16 { 
        //... 
    }
    impl From<u8> for u32{
        //...
    } 
```

â­ï¸ æ­£å¦‚æ‚¨æ‰€è§ï¼Œæ–¹æ³•æ¥å—ä¸€ä¸ªç‰¹æ®Šçš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå³ç±»å‹æœ¬èº«ã€‚å®ƒå¯ä»¥æ˜¯ selfã€&self æˆ– &mut selfã€‚å¦‚æœå®ƒæ˜¯å †æ ˆä¸Šçš„å€¼ï¼ˆæ‹¥æœ‰æƒï¼‰ï¼Œåˆ™ä¸º selfï¼Œå¦‚æœå®ƒæ˜¯å¼•ç”¨ï¼Œåˆ™ä¸º &selfï¼Œå¦‚æœå®ƒæ˜¯å¯å˜å¼•ç”¨ï¼Œåˆ™ä¸º &mut selfã€‚

> â­ï¸ ä¸€äº›å…¶ä»–è¯­è¨€æ”¯æŒé™æ€æ–¹æ³•ã€‚è¿™æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ç±»è°ƒç”¨ä¸€ä¸ªå‡½æ•°è€Œä¸åˆ›å»ºå¯¹è±¡ã€‚åœ¨ Rust ä¸­ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºå…³è”å‡½æ•°ã€‚å½“ä»ç»“æ„ä½“è°ƒç”¨å®ƒä»¬æ—¶ï¼Œæˆ‘ä»¬ä½¿ç”¨ :: è€Œä¸æ˜¯ .ã€‚ä¾‹å¦‚ï¼ŒPerson::newï¼ˆâ€œåŸƒéš†Â·é©¬æ–¯å…‹Â·å°â€ï¼‰;

```
struct Player {
    first_name: String,
    last_name: String,
}

impl Player {
    fn new(first_name: String, last_name: String) -> Player {
        Player {
            first_name : first_name,
            last_name : last_name,
        }
    }

    fn full_name(&self) -> String {
        format!("{} {}", self.first_name, self.last_name)
    }
}

fn main() {
    let player_name = Player::new("Serena".to_string(), "Williams".to_string()).full_name();
    println!("Player: {}", player_name);
}

// we have used :: notation for `new()` and . notation for `full_name()`

// ğŸ” Also in here we have used `Method Chaining`. Instead of using two statements for new() and full_name() 
// calls, we can use a single statement with Method Chaining. 
// ex. player.add_points(2).get_point_count(); 
```

â­ï¸ ç‰¹å¾å¯ä»¥ç»§æ‰¿è‡ªå…¶ä»–ç‰¹å¾ã€‚

```
trait Person {
    fn full_name(&self) -> String;
}

    trait Employee : Person { //Employee inherit from person trait
      fn job_title(&self) -> String;
    }

    trait ExpatEmployee : Employee + Expat { //ExpatEmployee inherit from Employee and Expat traits
      fn additional_tax(&self) -> f64;
    } 
```

ğŸ” è™½ç„¶ Rust åå‘äºé™æ€åˆ†æ´¾ï¼Œä½†ä¹Ÿæ”¯æŒé€šè¿‡ä¸€ç§ç§°ä¸ºâ€˜ç‰¹è´¨å¯¹è±¡â€™çš„æœºåˆ¶è¿›è¡ŒåŠ¨æ€åˆ†æ´¾ã€‚

> ğŸ…† åŠ¨æ€åˆ†æ´¾æ˜¯åœ¨è¿è¡Œæ—¶é€‰æ‹©è¦è°ƒç”¨çš„å¤šæ€æ“ä½œï¼ˆæ–¹æ³•æˆ–å‡½æ•°ï¼‰çš„è¿‡ç¨‹ã€‚

```
trait GetSound {
    fn get_sound(&self) -> String;
}

struct Cat {
    sound: String,
}
    impl GetSound for Cat {
        fn get_sound(&self) -> String {
            self.sound.clone()
        }
    }

struct Bell {
    sound: String,
}
    impl GetSound for Bell {
        fn get_sound(&self) -> String {
            self.sound.clone()
        }
    }

fn make_sound<T: GetSound>(t: &T) {
    println!("{}!", t.get_sound())
}

fn main() {
    let kitty = Cat { sound: "Meow".to_string() };
    let the_bell = Bell { sound: "Ding Dong".to_string() };

    make_sound(&kitty); // Meow!
    make_sound(&the_bell); // Ding Dong!
} 
```

# æ‹¥æœ‰æƒ

# æ‹¥æœ‰æƒ

```
fn main() {
    let a = [1, 2, 3];
    let b = a;
    println!("{:?} {:?}", a, b); // [1, 2, 3] [1, 2, 3]
}

fn main() {
    let a = vec![1, 2, 3];
    let b = a;
    println!("{:?} {:?}", a, b); // Error; use of moved value: `a`
} 
```

åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯å°è¯•**å°†â€˜aâ€™çš„å€¼èµ‹ç»™â€˜bâ€™**ã€‚ä¸¤ä¸ªä»£ç å—ä¸­çš„ä»£ç å‡ ä¹ç›¸åŒï¼Œä½†æœ‰**ä¸¤ç§ä¸åŒçš„æ•°æ®ç±»å‹**ã€‚ç¬¬äºŒä¸ªä¼šæŠ¥é”™ã€‚è¿™æ˜¯å› ä¸º**æ‰€æœ‰æƒ**ã€‚

â­ï¸ å˜é‡ç»‘å®šæ‹¥æœ‰å®ƒä»¬æ‰€ç»‘å®šçš„**æ‰€æœ‰æƒ**ã€‚ä¸€æ®µæ•°æ®ä¸€æ¬¡åªèƒ½æœ‰**ä¸€ä¸ªæ‰€æœ‰è€…**ã€‚å½“ä¸€ä¸ªç»‘å®šè¶…å‡ºèŒƒå›´æ—¶ï¼ŒRust ä¼šé‡Šæ”¾ç»‘å®šçš„èµ„æºã€‚è¿™å°±æ˜¯ Rust å®ç°**å†…å­˜å®‰å…¨**çš„æ–¹å¼ã€‚

> [æ‰€æœ‰æƒï¼ˆåè¯ï¼‰](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)
> 
> æ‹¥æœ‰æŸç‰©çš„è¡Œä¸ºã€çŠ¶æ€æˆ–æƒåˆ©ã€‚

â­ï¸ **å½“å°†**ä¸€ä¸ªå˜é‡ç»‘å®š**èµ‹ç»™å¦ä¸€ä¸ªå˜é‡ç»‘å®š**æ—¶ï¼ˆä¸å¼•ç”¨ï¼‰ï¼Œå¦‚æœå…¶æ•°æ®ç±»å‹æ˜¯ä¸€ä¸ª

1.  **å¤åˆ¶ç±»å‹**

    +   ç»‘å®šçš„èµ„æºè¢«**å¤åˆ¶å¹¶åˆ†é…**æˆ–ä¼ é€’ç»™å‡½æ•°ã€‚

    +   åŸå§‹ç»‘å®šçš„æ‰€æœ‰æƒçŠ¶æ€è¢«è®¾ç½®ä¸º**â€œå¤åˆ¶â€çŠ¶æ€**ã€‚

    +   **å¤§å¤šæ•°åŸå§‹ç±»å‹**

1.  **ç§»åŠ¨ç±»å‹**

    +   ç»‘å®šçš„èµ„æºè¢«**ç§»åŠ¨**åˆ°æ–°çš„å˜é‡ç»‘å®šï¼Œæˆ‘ä»¬**æ— æ³•å†è®¿é—®åŸå§‹çš„å˜é‡ç»‘å®š**ã€‚

    +   åŸå§‹ç»‘å®šçš„æ‰€æœ‰æƒçŠ¶æ€è¢«è®¾ç½®ä¸º**â€œç§»åŠ¨â€çŠ¶æ€**ã€‚

    +   **éåŸå§‹ç±»å‹**

> ğŸ” ä¸€ä¸ªç±»å‹çš„åŠŸèƒ½ç”±å·²å®ç°çš„ç‰¹è´¨å¤„ç†ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œå˜é‡ç»‘å®šå…·æœ‰â€˜ç§»åŠ¨è¯­ä¹‰â€™ã€‚ä½†æ˜¯ï¼Œå¦‚æœä¸€ä¸ªç±»å‹å®ç°äº†[**core::marker::Copy trait**](https://doc.rust-lang.org/core/marker/trait.Copy.html)ï¼Œå®ƒå…·æœ‰'å¤åˆ¶è¯­ä¹‰'ã€‚

ğŸ’¡ **æ‰€ä»¥åœ¨ä¸Šé¢çš„ç¬¬äºŒä¸ªä¾‹å­ä¸­ï¼ŒVec å¯¹è±¡çš„æ‰€æœ‰æƒç§»åŠ¨åˆ°â€œbâ€ï¼Œâ€œaâ€æ²¡æœ‰æ‰€æœ‰æƒè®¿é—®èµ„æºã€‚**

# å€Ÿç”¨

# å€Ÿç”¨

åœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦å°†å˜é‡ç»‘å®šä¼ é€’ç»™å…¶ä»–å‡½æ•°æˆ–å°†å®ƒä»¬åˆ†é…ç»™å¦ä¸€ä¸ªå˜é‡ç»‘å®šã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬**å¼•ç”¨**åŸå§‹ç»‘å®šï¼›**å€Ÿç”¨**å®ƒçš„æ•°æ®ã€‚

> [å€Ÿç”¨ï¼ˆåŠ¨è¯ï¼‰](https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf)
> 
> å¸¦æœ‰æ‰¿è¯ºè¿”å›çš„æ¥æ”¶ã€‚

â­ï¸ æœ‰ä¸¤ç§å€Ÿç”¨ç±»å‹ï¼Œ

1.  **å…±äº«å€Ÿç”¨** `(&T)`

    +   ä¸€æ®µæ•°æ®å¯ä»¥è¢«**å•ä¸ªæˆ–å¤šä¸ªç”¨æˆ·å€Ÿç”¨**ï¼Œä½†**æ•°æ®ä¸åº”è¯¥è¢«æ›´æ”¹**ã€‚

1.  **å¯å˜å€Ÿç”¨** `(&mut T)`

    +   ä¸€æ®µæ•°æ®å¯ä»¥è¢«**å•ä¸ªç”¨æˆ·å€Ÿç”¨å¹¶æ›´æ”¹**ï¼Œä½†æ­¤æ—¶å…¶ä»–ç”¨æˆ·ä¸åº”è¯¥èƒ½å¤Ÿè®¿é—®è¯¥æ•°æ®ã€‚

â­ï¸ è¿˜æœ‰å…³äºå€Ÿç”¨çš„**éå¸¸é‡è¦çš„è§„åˆ™**ï¼Œ

1.  ä¸€æ®µæ•°æ®å¯ä»¥è¢«å€Ÿç”¨ä¸º**å…±äº«å€Ÿç”¨** **æˆ–** ä½œä¸ºå¯å˜å€Ÿç”¨ **ä¹‹ä¸€**ã€‚ä½†ä¸èƒ½åŒæ—¶å‘ç”Ÿã€‚

1.  å€Ÿç”¨**é€‚ç”¨äºå¤åˆ¶ç±»å‹å’Œç§»åŠ¨ç±»å‹**ã€‚

1.  **æ´»æ€§**çš„æ¦‚å¿µ â†´

```
fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  &mut borrow of a starts here
                   //  â
  // some code     //  â
  // some code     //  â
}                  //  &mut borrow of a ends here

fn main() {
  let mut a = vec![1, 2, 3];
  let b = &mut a;  //  &mut borrow of a starts here
  // some code

  println!("{:?}", a); // trying to access a as a shared borrow, so giving error
}                  //  &mut borrow of a ends here

fn main() {
  let mut a = vec![1, 2, 3];
  {
    let b = &mut a;  //  &mut borrow of a starts here
    // any other code
  }                  //  &mut borrow of a ends here

  println!("{:?}", a); // allow to borrow a as a shared borrow
} 
```

ğŸ’¡ **è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•åœ¨ç¤ºä¾‹ä¸­ä½¿ç”¨å…±äº«å’Œå¯å˜å€Ÿç”¨ã€‚**

+   å…±äº«å€Ÿç”¨ç¤ºä¾‹

```
fn main() {
    let a = [1, 2, 3];
    let b = &a;
    println!("{:?} {}", a, b[0]); // [1, 2, 3] 1
}

fn main() {
    let a = vec![1, 2, 3];
    let b = get_first_element(&a);

    println!("{:?} {}", a, b); // [1, 2, 3] 1
}

fn get_first_element(a: &Vec<i32>) -> i32 {
    a[0]
} 
```

+   å¯å˜å€Ÿç”¨ç¤ºä¾‹

```
fn main() {
    let mut a = [1, 2, 3];
    let b = &mut a;
    b[0] = 4;
    println!("{:?}", b); // [4, 2, 3]
}

fn main() {
    let mut a = [1, 2, 3];
    {
        let b = &mut a;
        b[0] = 4;
    }

    println!("{:?}", a); // [4, 2, 3]
}

fn main() {
    let mut a = vec![1, 2, 3];
    let b = change_and_get_first_element(&mut a);

    println!("{:?} {}", a, b); // [4, 2, 3] 4
}

fn change_and_get_first_element(a: &mut Vec<i32>) -> i32 {
    a[0] = 4;
    a[0]
} 
```

# ç”Ÿå‘½å‘¨æœŸ

# ç”Ÿå‘½å‘¨æœŸ

å½“æˆ‘ä»¬å¤„ç†å¼•ç”¨æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿å¼•ç”¨çš„æ•°æ®åœ¨æˆ‘ä»¬åœæ­¢ä½¿ç”¨å¼•ç”¨ä¹‹å‰ä¿æŒå­˜æ´»ã€‚

æƒ³ä¸€æƒ³ï¼Œ

+   æˆ‘ä»¬æœ‰ä¸€ä¸ªå˜é‡ç»‘å®šï¼Œâ€œ**a**â€ã€‚

+   æˆ‘ä»¬æ­£åœ¨å¼•ç”¨â€œaâ€çš„å€¼ï¼Œæ¥è‡ªå¦ä¸€ä¸ªå˜é‡ç»‘å®šâ€œ**x**â€ã€‚æˆ‘ä»¬å¿…é¡»ç¡®ä¿â€œaâ€åœ¨æˆ‘ä»¬åœæ­¢ä½¿ç”¨â€œxâ€ä¹‹å‰**å­˜æ´»**ã€‚

> ğŸ” **å†…å­˜ç®¡ç†**æ˜¯åº”ç”¨äºè®¡ç®—æœºå†…å­˜çš„èµ„æºç®¡ç†å½¢å¼ã€‚ç›´åˆ° 1990 å¹´ä»£ä¸­æœŸï¼Œå¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä½¿ç”¨**æ‰‹åŠ¨å†…å­˜ç®¡ç†**ï¼Œéœ€è¦ç¨‹åºå‘˜ç»™å‡ºæ‰‹åŠ¨æŒ‡ä»¤æ¥è¯†åˆ«å’Œé‡Šæ”¾æœªä½¿ç”¨çš„å¯¹è±¡/åƒåœ¾ã€‚çº¦ 1959 å¹´ï¼Œçº¦ç¿°Â·éº¦å¡é”¡å‘æ˜äº†**åƒåœ¾æ”¶é›†**(GC)ï¼Œä¸€ç§**è‡ªåŠ¨å†…å­˜ç®¡ç†**(AMM)å½¢å¼ã€‚å®ƒç¡®å®šå“ªäº›å†…å­˜ä¸å†ä½¿ç”¨å¹¶è‡ªåŠ¨é‡Šæ”¾ï¼Œè€Œä¸ä¾èµ–äºç¨‹åºå‘˜ã€‚ç„¶è€Œï¼Œ**Objective-C å’Œ Swift**é€šè¿‡**è‡ªåŠ¨å¼•ç”¨è®¡æ•°**(ARC)æä¾›ç±»ä¼¼åŠŸèƒ½ã€‚

åœ¨ Rust ä¸­ï¼Œ

+   ä¸€ä¸ªèµ„æºä¸€æ¬¡åªèƒ½æœ‰**ä¸€ä¸ªæ‰€æœ‰è€…**ã€‚å½“å®ƒè¶…å‡ºèŒƒå›´æ—¶ï¼ŒRust ä¼šå°†å…¶ä»å†…å­˜ä¸­ç§»é™¤ã€‚

+   å½“æˆ‘ä»¬æƒ³è¦é‡å¤ä½¿ç”¨ç›¸åŒçš„èµ„æºæ—¶ï¼Œæˆ‘ä»¬æ­£åœ¨**å¼•ç”¨**å®ƒ/ **å€Ÿç”¨**å…¶å†…å®¹ã€‚

+   å¤„ç†**å¼•ç”¨**æ—¶ï¼Œæˆ‘ä»¬å¿…é¡»æŒ‡å®š**ç”Ÿå‘½å‘¨æœŸæ³¨è§£**ï¼Œä»¥ä¾¿ä¸º**ç¼–è¯‘å™¨**æä¾›æŒ‡ç¤ºï¼Œè®¾ç½®è¿™äº›å¼•ç”¨èµ„æº**åº”è¯¥å­˜æ´»å¤šä¹…**ã€‚

+   â­ï¸ä½†æ˜¯ç”±äºç”Ÿå‘½å‘¨æœŸæ³¨è§£ä½¿**ä»£ç æ›´å†—é•¿**ï¼Œä¸ºäº†ä½¿**å¸¸è§æ¨¡å¼**æ›´ç¬¦åˆäººä½“å·¥ç¨‹å­¦ï¼ŒRust å…è®¸åœ¨`fn`å®šä¹‰ä¸­**çœç•¥**ç”Ÿå‘½å‘¨æœŸã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼š**éšå¼**åˆ†é…ç”Ÿå‘½å‘¨æœŸæ³¨è§£ã€‚

ç”Ÿå‘½å‘¨æœŸæ³¨è§£åœ¨**ç¼–è¯‘æ—¶æ£€æŸ¥**ã€‚ç¼–è¯‘å™¨åœ¨æ•°æ®ç¬¬ä¸€æ¬¡å’Œæœ€åä¸€æ¬¡ä½¿ç”¨æ—¶è¿›è¡Œæ£€æŸ¥ã€‚æ ¹æ®è¿™ä¸€ç‚¹ï¼ŒRust åœ¨**è¿è¡Œæ—¶**ç®¡ç†å†…å­˜ã€‚è¿™æ˜¯ Rust ç¼–è¯‘æ—¶é—´**è¾ƒæ…¢**çš„ä¸»è¦åŸå› ã€‚

> +   ä¸ C å’Œ C++**ä¸åŒ**ï¼ŒRust é€šå¸¸ä¸ä¼šæ˜¾å¼ä¸¢å¼ƒå€¼ã€‚
> +   
> +   ä¸ GC ä¸åŒï¼ŒRust ä¸ä¼šåœ¨æ•°æ®ä¸å†è¢«å¼•ç”¨çš„åœ°æ–¹æ”¾ç½®é‡Šæ”¾è°ƒç”¨ã€‚
> +   
> +   Rust åœ¨æ•°æ®å³å°†è¶…å‡ºèŒƒå›´çš„åœ°æ–¹æ”¾ç½®é‡Šæ”¾è°ƒç”¨ï¼Œç„¶åå¼ºåˆ¶ç¡®ä¿åœ¨é‚£ä¸€ç‚¹ä¹‹åä¸å­˜åœ¨å¯¹è¯¥èµ„æºçš„å¼•ç”¨ã€‚

ğŸ’¡ ç”Ÿå‘½å‘¨æœŸç”¨æ’‡å·è¡¨ç¤ºã€‚æŒ‰ç…§æƒ¯ä¾‹ï¼Œå°å†™å­—æ¯ç”¨äºå‘½åã€‚é€šå¸¸ä»¥**'a**å¼€å¤´ï¼Œå¹¶åœ¨éœ€è¦æ·»åŠ **å¤šä¸ªç”Ÿå‘½å‘¨æœŸ**æ³¨è§£æ—¶æŒ‰å­—æ¯é¡ºåº**è·Ÿéš**ã€‚

åœ¨ä½¿ç”¨å¼•ç”¨æ—¶ï¼Œ

ğŸğŸ. åœ¨**å‡½æ•°å£°æ˜**ä¸­

+   å¸¦æœ‰å¼•ç”¨çš„è¾“å…¥å’Œè¾“å‡ºå‚æ•°åº”åœ¨`&`ç¬¦å·åé™„åŠ ç”Ÿå‘½å‘¨æœŸã€‚ä¾‹å¦‚ `..(x: &'a str)`ï¼Œ`..(x: &'a mut str)`

+   åœ¨å‡½æ•°åä¹‹åï¼Œæˆ‘ä»¬åº”è¯¥æåˆ°ç»™å®šçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ³›å‹ç±»å‹ã€‚ä¾‹å¦‚ `fn foo<'a>(..)`ï¼Œ`fn foo<'a, 'b>(..)`

```
// no inputs, return a reference
fn function<'a>() -> &'a str {} 

// single input
fn function<'a>(x: &'a str) {}

// single input and output, both has same lifetime
// output should live at least as long as input exists
fn function<'a>(x: &'a str) -> &'a str {}

// multiple inputs, only one input and the output share same lifetime
// output should live at least as long as y exists
fn function<'a>(x: i32, y: &'a str) -> &'a str {}

// multiple inputs. both inputs and the output share same lifetime
// output should live at least as long as x and y exist
fn function<'a>(x: &'a str, y: &'a str) -> &'a str {}

// multiple inputs. inputs can have diffent lifetimes ğŸ”
// output should live at least as long as x exists
fn function<'a, 'b>(x: &'a str, y: &'b str) -> &'a str {} 
```

ğŸğŸ. åœ¨**ç»“æ„ä½“æˆ–æšä¸¾å£°æ˜**ä¸­

+   å…·æœ‰å¼•ç”¨çš„å…ƒç´ åº”åœ¨`&`ç¬¦å·åé™„åŠ ç”Ÿå‘½å‘¨æœŸã€‚

+   åœ¨ç»“æ„ä½“æˆ–æšä¸¾çš„åç§°ä¹‹åï¼Œæˆ‘ä»¬åº”è¯¥æåˆ°ç»™å®šçš„ç”Ÿå‘½å‘¨æœŸæ˜¯æ³›å‹ç±»å‹ã€‚

```
// single element
// data of x should live at least as long as Struct exists
struct Struct<'a> { 
    x: &'a str 
}

// multiple elements
// data of x and y should live at least as long as Struct exists
struct Struct<'a> { 
    x: &'a str,
    y: &'a str 
}

// variant with single element
// data of the variant should live at least as long as Enum exists
enum Enum<'a> { 
    Variant(&'a Type)
} 
```

ğŸğŸ‘. ä½¿ç”¨**Impls å’Œ Traits**

```
struct Struct<'a> { 
    x: &'a str 
}
    impl<'a> Struct<'a> { 
        fn function<'a>(&self) -> &'a str {
            self.x 
        }
    }

struct Struct<'a> { 
    x: &'a str,
    y: &'a str
}
    impl<'a> Struct<'a> { 
        fn new(x: &'a str, y: &'a str) -> Struct<'a> { //no need to specify <'a> after new; impl already has it
          Struct {
              x : x,
              y : y
          }
        }
    }

// ğŸ”
impl<'a> Trait<'a> for Type
impl<'a> Trait for Type<'a> 
```

ğŸğŸ’. ä½¿ç”¨**æ³›å‹ç±»å‹**

```
// ğŸ”
fn function<F>(f: F) where for<'a> F: FnOnce(&'a Type)
struct Struct<F> where for<'a> F: FnOnce(&'a Type) { x: F }
enum Enum<F> where for<'a> F: FnOnce(&'a Type) { Variant(F) }
impl<F> Struct<F> where for<'a> F: FnOnce(&'a Type) { fn x(&self) -> &F { &self.x } } 
```

### ç”Ÿå‘½å‘¨æœŸçœç•¥

æ­£å¦‚æˆ‘ä¹‹å‰æåˆ°çš„ï¼Œä¸ºäº†ä½¿**å¸¸è§æ¨¡å¼**æ›´ç¬¦åˆäººä½“å·¥ç¨‹å­¦ï¼ŒRust å…è®¸çœç•¥ç”Ÿå‘½å‘¨æœŸã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸º**ç”Ÿå‘½å‘¨æœŸçœç•¥**ã€‚

ğŸ’¡ ç›®å‰ Rust ä»…åœ¨`fn`å®šä¹‰ä¸­æ”¯æŒç”Ÿå‘½å‘¨æœŸçœç•¥ã€‚ä½†åœ¨æœªæ¥ï¼Œå®ƒä¹Ÿå°†æ”¯æŒ`impl`å¤´éƒ¨çš„ç”Ÿå‘½å‘¨æœŸçœç•¥ã€‚

â­ï¸ fn å®šä¹‰çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šå¯ä»¥è¢«çœç•¥

å¦‚æœå…¶**å‚æ•°åˆ—è¡¨**ä¸­æœ‰è¦ä¹ˆï¼Œ

+   **åªæœ‰ä¸€ä¸ªè¾“å…¥å‚æ•°é€šè¿‡å¼•ç”¨ä¼ é€’**ã€‚

+   å…·æœ‰**è¦ä¹ˆ** `&self` **è¦ä¹ˆ** **&mut self** å¼•ç”¨çš„å‚æ•°ã€‚

```
fn triple(x: &u64) -> u64 { //only one input parameter passes by reference
    x * 3
}

fn filter(x: u8, y: &str) -> &str { // only one input parameter passes by reference
    if x > 5 { y } else { "invalid inputs" }
}

struct Player<'a> { 
    id: u8,
    name: &'a str
}
    impl<'a> Player<'a> { //so far Lifetime Elisions are allowed only on fn definitions; but in the future they might support on impl headers as well.
        fn new(id: u8, name: &str) -> Player { //only one input parameter passes by reference
            Player {
                id : id,
                name : name
            }
        }

        fn heading_text(&self) -> String { // a fn definition with &self (or &mut self) reference
            format!("{}: {}", self.id, self.name)
        }
    }

fn main() {
    let player1 = Player::new(1, "Serena Williams");
    let player1_heading_text = player1.heading_text()
    println!("{}", player1_heading_text);
} 
```

> ğŸ’¡ åœ¨ fn å®šä¹‰çš„ç”Ÿå‘½å‘¨æœŸçœç•¥è¿‡ç¨‹ä¸­ï¼Œ
> 
> +   æ¯ä¸ªé€šè¿‡å¼•ç”¨ä¼ é€’çš„å‚æ•°éƒ½æœ‰ä¸€ä¸ªä¸åŒçš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚ä¾‹å¦‚ `..(x: &str, y: &str)` ğŸ¡’ `..<'a, 'b>(x: &'a str, y: &'b str)`
> +   
> +   å¦‚æœå‚æ•°åˆ—è¡¨åªæœ‰ä¸€ä¸ªé€šè¿‡å¼•ç”¨ä¼ é€’çš„å‚æ•°ï¼Œåˆ™è¯¥ç”Ÿå‘½å‘¨æœŸå°†åˆ†é…ç»™è¯¥å‡½æ•°è¿”å›å€¼ä¸­æ‰€æœ‰çœç•¥çš„ç”Ÿå‘½å‘¨æœŸã€‚ä¾‹å¦‚ `..(x: i32, y: &str) -> &str` ğŸ¡’ `..<'a>(x: i32, y: &'a str) -> &'a str`
> +   
> +   å³ä½¿å®ƒæœ‰å¤šä¸ªé€šè¿‡å¼•ç”¨ä¼ é€’çš„å‚æ•°ï¼Œå¦‚æœå…¶ä¸­ä¸€ä¸ªæœ‰ &self æˆ– &mut selfï¼Œself çš„ç”Ÿå‘½å‘¨æœŸå°†åˆ†é…ç»™æ‰€æœ‰çœç•¥çš„è¾“å‡ºç”Ÿå‘½å‘¨æœŸã€‚ä¾‹å¦‚ `impl Impl{ fn function(&self, x: &str) -> &str {} }` ğŸ¡’ `impl<'a> Impl<'a>{ fn function(&'a self, x: &'b str) -> &'a str {} }`
> +   
> +   å¯¹äºæ‰€æœ‰å…¶ä»–æƒ…å†µï¼Œæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨ç¼–å†™ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚

### 'static

â­ï¸ `'static` ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šæ˜¯ä¸€ä¸ª**ä¿ç•™**çš„ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚è¿™äº›å¼•ç”¨åœ¨æ•´ä¸ªç¨‹åºä¸­éƒ½æœ‰æ•ˆã€‚å®ƒä»¬ä¿å­˜åœ¨äºŒè¿›åˆ¶æ–‡ä»¶çš„æ•°æ®æ®µä¸­ï¼Œæ‰€å¼•ç”¨çš„æ•°æ®æ°¸è¿œä¸ä¼šè¶…å‡ºä½œç”¨åŸŸã€‚

ğŸ’¡ **è®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•åœ¨ç¤ºä¾‹ä¸­ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸæ³¨é‡Šã€‚**

```
fn greeting<'a>() -> &'a str {
  "Hi!"
}

fn fullname<'a>(fname: &'a str, lname: &'a str) -> String {
  format!("{} {}", fname, lname)
}

struct Person<'a> { 
    fname: &'a str,
    lname: &'a str
}
  impl<'a> Person<'a> {
      fn new(fname: &'a str, lname: &'a str) -> Person<'a> { //no need to specify <'a> after new; impl already has it
          Person {
              fname : fname,
              lname : lname
          }
      }

      fn fullname(&self) -> String {
          format!("{} {}", self.fname , self.lname)
      }
  }

fn main() {
    let player = Person::new("Serena", "Williams");
    let player_fullname = player.fullname();

    println!("Player: {}", player_fullname);
} 
```
