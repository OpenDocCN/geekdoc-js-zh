# 第三章：高级编译器概述

> 原文：[`keleshev.com/compiling-to-assembly-from-scratch/03-high-level-compiler-overview`](https://keleshev.com/compiling-to-assembly-from-scratch/03-high-level-compiler-overview)

从零开始编译汇编

由 Vladimir Keleshev

**编译器**是一个程序，它将另一个程序从一种语言翻译成另一种语言。

在我们的案例中，它将我们从所谓的**基线语言**转换为 ARM 汇编语言。

## 编译器的类型

我们的编译器将是一个**即时编译器**（AOT）。只有当编译完成时，生成的程序才能运行。

还有**即时编译器**（JIT），它在程序运行时编译程序。

将 AOT 编译器想象成外语翻译服务：你可能向他们发送一些从英语翻译成日语的论文，当他们完成时，他们会将结果发回来。另一方面，即时编译器（JIT）更像是商务会议上的同声传译：他们在说话的同时翻译参与者。

我们的编译器**目标**是**汇编语言**，即生成汇编代码。汇编语言是处理器可以直接执行的二进制**机器语言**的文本表示。它可以直接转换为这样的二进制。这种转换称为**汇编**，并且比编译器中找到的简单得多。执行这种转换的程序称为**汇编器**。在大多数情况下，对于 ARM，一条汇编指令被翻译成一个 32 位的二进制整数。将汇编语言想象成直接访问处理器功能的 API。

一些编译器直接以**二进制机器代码**为目标，但这越来越少见。相反，大多数编译器编译到汇编，然后在幕后调用汇编器。

一些编译器以**字节码**为目标而不是汇编。字节码类似于汇编：它由类似的指令组成。然而，这些并不针对真实的处理器，而是针对一个**抽象机**，这是一个在软件中实现的处理器。这可能是因为可移植性原因，或者是为了添加硬件中不可用的安全功能。通常，字节码反过来由 JIT 编译器转换为机器代码。

可能的编译器目标可以是另一种编程语言。我们称这些编译器为**源到源**编译器。例如，TypeScript 编译器是一个源到源编译器，其目标是 JavaScript。

## 编译器遍历和中间表示

编译器被结构化为几个**遍历**。在高级别上，每个遍历都是一个函数，它接受程序的一种表示并将其转换为程序的不同表示。这种表示的第一种是程序的源代码。最后一种是目标语言的编译程序。在这两者之间，我们有编译器内部的表示。我们称它们为**中间表示**或 IR。

在图中，你可以看到一个三遍编译器的示例图。

![一个三遍编译器的示例](img/78d4f52a6ef376bc17915a0f5cfd4288.png)

一个三遍编译器的示例

程序的中间表示是我们在编译器的不同阶段方便操作的数据结构。对于某一阶段，我们可能希望使用树状表示。对于另一阶段，我们可能选择图状表示。对于某些情况，线性数组状表示是合适的。

要将一个 IR 转换为另一个 IR，每个遍历都需要遍历一次（或迭代通过它）。这就是为什么它被称为*遍*。

编译器的遍历次数差异很大，从单遍编译器到具有数十遍（有时称为*纳米遍*编译器）的多遍编译器。

编译器的遍历次数提出了一个权衡。一方面，我们希望编写许多小的遍历，每遍历做一件事情，并且可以独立维护和测试。我们也希望编写更多的遍历来进行复杂的分析，以提高生成的程序的性能。另一方面，我们希望最小化遍历次数以提高编译器的性能：编译程序的速度有多快。

我们的基线编译器是一个两遍编译器。第一遍将源代码转换为称为*抽象语法树*或 AST 的 IR。这个过程称为*解析*。第二遍将 AST 转换为汇编。这被称为*生成代码*或*代码生成*。

![基线编译器结构](img/7d2d772b01b6d4adc676f1350d8df889.png)

基线编译器结构

在书的*第二部分*中，我们将介绍一些更多的遍历。

抽象语法树是最常见的中间表示类型。让我们详细谈谈它们。

下一章：第四章 抽象语法树

* * *
