# 第七章：ARM 汇编编程

> 原文：[`keleshev.com/compiling-to-assembly-from-scratch/07-arm-assembly-programming`](https://keleshev.com/compiling-to-assembly-from-scratch/07-arm-assembly-programming)

从零开始编译汇编

作者：Vladimir Keleshev

到本章结束时，你将学习到足够的 ARM 汇编编程知识，以实现编译器的其余部分。

我们将使用 GNU 编译器集合（GCC）工具链，最显著的是 GNU 汇编器（GAS）。参见 *附录 B* 了解 GAS 和传统 ARMASM 语法之间的比较。

首先，我们将从简单的 hello-world 程序的鸟瞰图开始，以体验汇编编程。在初步的概述之后，我们将深入细节。

## 汇编的初体验

这不是那些 *如何画一只猫头鹰* 的教程之一。我将假设你从未进行过任何汇编编程，并引导你完成这个过程。然而，一开始，我想从一个小的、完整的程序开始，以体验汇编编程。之后，我们将详细讲解每个部分。

所以，这就是我们的第一个汇编程序：

```js
/* Hello-world program.
 Print "Hello, assembly!" and exit with code 42\. */

.data
 hello:
 .string "Hello, assembly!"

.text
 .global main
 main:
 push {ip, lr}

 ldr r0, =hello
 bl printf

 mov r0, #41
 add r0, r0, #1  // Increment

 pop {ip, lr}
 bx lr
```

该程序将 `Hello, assembly!` 打印到控制台，并以错误代码 `42` 退出。

现在，让我们逐步讨论这段汇编代码。

```js
.data
 hello:
 .string "Hello, assembly!"
```

程序从 `.data` 指令开始。在这个指令下，有我们全局数据的定义，可能是可变的（或可读可写）。那里只有一个定义，一个使用 `.string` 指令定义的字节字符串。它有一个 *标签* 名为 `hello:`，代表这个字符串的内存地址，我们可以引用它。数据部分结束，`.text` 指令开始 *代码* 部分。

```js
.text
 .global main
 main:
 push {ip, lr}
```

本节用于不可变（读取，不写入）数据。它用于常量，以及实际的汇编指令。`.text` 部分中唯一的定义是一个名为 `main` 的函数，使用标签 `main:` 定义。它使用 `.global` 指令声明为“公共”。函数以一个 `push` 指令开始，该指令将一些必要的寄存器保存到堆栈上。然后，它继续执行。

```js
 ldr r0, =hello
 bl printf
```

函数通过引用 `hello` 标签来加载我们之前定义的字符串的地址。指令 `ldr` *加载* 地址到 *寄存器* `r0`。指令 `bl printf` 是 *调用* 指令，用于调用 `printf` 函数以打印字符串。寄存器 `r0` 用于将参数传递给 `printf`。

```js
 mov r0, #41
 add r0, r0, #1
```

接下来，我们设置退出代码。首先，我们使用 `mov` 指令将数字 `41` *移动* 或复制到寄存器 `r0`。然后，`add` 指令将 `r0` 的值增加一个，结果为 `42`。退出代码 `42` 没有什么特殊之处，我们也不需要从 `41` 计算它。但如果没有展示一些基本指令如 `mov` 和 `add`，这段汇编的体验将是不完整的。

```js
 pop {ip, lr}
 bx lr
```

`main`函数以返回序列结束。我们最初保存的寄存器现在通过`pop`指令恢复，然后我们使用`bx lr`指令从函数返回，假设返回值在`r0`中，应该是`42`。

如你可能注意到的，单行和多行注释都得到了支持。

## 运行汇编程序

这是如何运行这个简单程序的方法。

> **注意**
> 
> 下面的说明假设你在运行基于 ARM 的计算机（如树莓派）上的 32 位操作系统上运行命令。如果你不是这种情况，请查看*附录 A*了解如何将这些说明适应其他环境。

使用文本编辑器将之前的程序保存到名为`hello.s`的文件中。然后在控制台中输入以下命令：

```js
$ gcc hello.s -o hello
```

这将指示 GCC 汇编并链接我们的程序，生成一个`hello`可执行文件。默认情况下，GCC 将我们的汇编与`libc`库链接，该库为我们提供了基本函数，例如我们在这里使用的`printf`。

你看，操作系统内核并不直接提供这样的功能。例如，打印到控制台是在`libc`等库中实现的，这些库建立在（操作）*系统调用*（如`writev`）之上。没有这些基础知识，我们甚至无法打印到控制台。

现在，你可以像往常一样运行生成的可执行文件：

```js
$ ./hello
Hello, assembly!
```

*哦，你好啊！*

我们可以通过打印 shell 变量`$?`来检查退出代码。

```js
$ echo $?
42
```

现在我们有了运行程序的模板和粗略的概述，我们将深入细节。

我们将从汇编程序的基本数据结构*机器字*开始，然后概述内存和寄存器的工作方式，最后将介绍操作寄存器和内存的不同类型的指令。

## 机器字

ARM 是一个 32 位指令集。这意味着大多数操作都使用一个名为*机器字*的 32 位数据结构。

在 ARM 中，一个字由 32 位组成。每个位是二进制`0`或`1`。

另一种看待它的方式是，一个单词由*四个*字节组成，其中每个字节是 8 位。

还有半字和双字。它们的名称就说明了问题。对它们的操作并不常见。

让我们看看以下单词。

![一个示例机器字](img/3a55cf5fa168850321234094d5cc05d6.png)

一个示例机器字

它是什么意思？它代表什么？嗯，处理器并不关心。它没有类型系统。它没有与单词相关联的任何信息来帮助我们区分单词在孤立状态下代表什么。

如果解释为无符号整数，这个字可以代表 `3_283_185_520`。如果解释为有符号整数，那么它是 `-1_011_781_776`。它可能是一个包含四个字节的字节数组，`[195, 177, 111, 112]`。它可能是一个位数组，其中每个位是一个单独的标志。或者它可能是一个 UTF-8 编码的字符串 `"ñop"`，其中 `ñ` 使用两个字节 `195, 177` 编码，而 `o` 和 `p` 则作为单字节 ASCII 字符，代码分别为 `111` 和 `112`。它也可能是带有助记符 `rsb` 的 ARM 指令的编码。或者它可能是一个指向内存中某些数据位置的地址。

是我们（程序员和编译器编写者）来为每个字分配意义，并跟踪它们所代表的内容。

> **注意**
> 
> 在本书中，我们将使用不同形状和大小的（非重叠）实心框来引用 32 位字。就像这里，我们将使用虚线来限定单个字节，这有助于提高清晰度。

## 数值表示法

正如我们在这里所做的那样，我们将使用 JavaScript 表示法来引用数据的不同解释。现代 JavaScript 在这方面做得相当不错。我们可以使用二进制（基数为 2）表示法，带 `0b` 前缀来引用上述字：

```js
0b11000011101100010110111101110000
```

JavaScript 允许我们添加下划线以提高可读性；例如，以区分单个字节的比特模式：

```js
0b11000011_10110001_01101111_01110000
```

我们可以使用传统的十进制（基数为 10）表示法：

```js
3_283_185_520
```

我们也可以使用带 `0x` 前缀的十六进制（基数为 16）表示法；

```js
0xC3_B1_6F_70
```

我们如何决定使用哪种表示法？为什么我们会使用十六进制？

二进制表示法简单直接：你可以看到单个比特，并且可以直观地将字分割为字节，但它非常冗长！

十进制表示法更简洁，你可以很好地理解数字的大小，但很难推理单个字节和比特的值。

十六进制表示法简洁，并且易于直观地分割字为字节。每个十六进制数字映射到四个比特，无论其在数字中的位置如何，所以两个十六进制数字总是映射到一个字节。你只需要记住 16 个十六进制数字的比特模式：

| 十六进制 | 二进制 |
| --- | --- |
| `0x0` | `0b0000` |
| `0x1` | `0b0001` |
| `0x2` | `0b0010` |
| `0x3` | `0b0011` |
| `0x4` | `0b0100` |
| `0x5` | `0b0101` |
| `0x6` | `0b0110` |
| `0x7` | `0b0111` |
| `0x8` | `0b1000` |
| `0x9` | `0b1001` |
| `0xA` | `0b1010` |
| `0xB` | `0b1011` |
| `0xC` | `0b1100` |
| `0xD` | `0b1101` |
| `0xE` | `0b1110` |
| `0xF` | `0b1111` |

这样我们就可以轻松地将十六进制转换为二进制，反之亦然。以 `0xC3_B1_6F_70` 为例：

+   `0xC3` 是 `0b1100_0011`

+   `0xB1` 是 `0x1011_0001`

+   `0x6F` 是 `0b0110_1111`

+   `0x70` 是 `0b0111_0000`

因此，我们可以得出结论，`0xC3_B1_6F_70` 与以下表示相同：

```js
0b11000011_10110001_01101111_01110000
```

用十进制表示法做不到这一点！

## 内存

将内存想象成一个大的连续字节数组。它包含我们的程序指令，以二进制字的形式编码。它包含我们的程序处理的数据：数据段、代码段、栈和堆（稍后会有更多介绍）。

就像字节数组一样，你可以通过数组的索引来访问内存中的单个字节。我们称这个索引为 *内存地址*。ARM 的内存地址是 32 位的（这一切是如何对齐的，对吧？）。

然而，你不仅可以访问内存中的单个字节，还可以访问整个 32 位字。但有一个限制：你只能访问 *对齐* 的字。在这种情况下，*对齐* 意味着非重叠的字或地址能被 4 整除的字。一个字包含四个字节，每个字节都有自己的地址，但我们只通过字中第一个字节的地址来引用字。

> **实际上，……**
> 
> 新的 ARM 处理器支持非对齐访问，但并非所有相关指令都支持，并且这会带来性能惩罚。在这本书中，我们避免使用它。

在下面的图中，你可以看到从地址 `0x00` 开始的内存段，展示了单个字节及其地址如何映射到对齐的字及其地址。

![字节级别的内存示例](img/e850519eb736df8b3b200aa68095323a.png)

字节级别的内存示例

从现在开始，当我们谈论内存时，我们不需要这么多细节，所以我们将使用简化的（但仍然非常精确）字级图。就像下一个描述相同内存段的图。

![同一内存段的字级示例](img/6054e608c175c84d5ae309a76ca837d3.png)

同一内存段的字级示例

有时我们会将内存地址存储在内存字中。我们称之为 *指针*。在我们的图中，我们将使用箭头来表示内存字指向的位置。我们将在图中省略实际的内存地址，因为确切值并不重要。重要的是它指向的位置，而不是值本身。

![指针表示法：左边——带有箭头，右边——带有实际值](img/e5596e647de28affaa1b7b71978e50f7.png)

指针表示法：左边——带有箭头，右边——带有实际值

正如我们之前提到的，内存包含我们的数据段、代码段、堆栈和堆。然而，它不包含（在大多数架构中，至少）的是 *寄存器*。

## 寄存器

寄存器是位于主内存之外的特殊内存字。它们用于中间值，有点像临时变量。这些寄存器的数量有限——通常是 8、16 或 32 个。

ARM 有 16 个主要寄存器和一个特殊的 *状态* 寄存器（CPSR）。主要寄存器称为 `r0` 到 `r15`，但其中一些有备选名称。请参见下一图以获取更多详细信息。

![ARM 中的寄存器](img/4d25c709f552949c71b9ccdcdc94740f.png)

ARM 中的寄存器

首先，为什么我们需要寄存器？指令不能直接与内存工作吗？它们可以，还有其他如累加器基础和堆栈基础的架构，只需要一个寄存器或者根本不需要寄存器。然而，ARM 是一种 *加载-存储* 架构。

在 *加载-存储* 架构中，基本的工作流程如下：

+   数据从内存加载到寄存器中，然后

+   操作是在寄存器上执行的，最后

+   数据被存储回内存中。

结果证明这种工作流程非常高效，并且大多数现代架构都遵循它。

大多数 ARM 寄存器都是通用的，可以用于任何中间值。当我们发现与它们一起工作的指令时，我们将介绍更**特殊用途**的寄存器，如`fp`、`ip`、`sp`、`lr`、`pc`和 CPSR。

* * *

您可能听说过**寄存器很快**。这到底是什么意思？为什么我们不能使用相同的技术来处理内存？

两个原因。

只有 16 个寄存器。这意味着您只能使用 4 位来引用一个寄存器。同时，内存地址是 32 位的。因此，您需要更少的字节（和指令）来编码对三个寄存器的操作，而不是对三个内存地址的操作。并且处理器可以更快地解码更少的指令。

第二，计算机内存有多个**级别**的缓存，通常称为**L1**至**L4**。即使最快的缓存使用与寄存器相同的技术，也可能发生**缓存未命中**。但在寄存器的情况下，这种情况永远不会发生。

## 加法指令

让我们来看我们的第一个指令，`add`：

```js
add r1, r2, r3     /* r1 = r2 + r3; */
```

它由一个助记符名称`add`以及三个寄存器操作数`r1`、`r2`和`r3`组成。在这种情况下，**操作数 1**是`r2`，**操作数 2**是`r3`，`r1`是结果，也称为**目标**操作数。这种指令被称为三操作数指令。

作为注释，我们提供了一个伪代码，描述了指令的效果。请注意，指令中操作数的顺序与伪代码中的顺序相同。ARM 汇编被设计成始终如此。

所有 ARM 指令都编码成内存中的单个 32 位字。在这个图中，您可以看到这个特定指令是如何编码成二进制的。我们故意没有解释一些位的含义。

![The encoding of: add r1, r2, r3](img/db4bf94d3d0c5a427e2509ba3575b2b8.png)

`add r1, r2, r3`的编码

> **实际上…**
> 
> 大多数 ARM 处理器支持多个指令集。它们在历史上被称为 ARM、Thumb 和 ARM64，但最近已更名为 A32、T32 和 A64。
> 
> 例如，T32（或 Thumb 2）是一个变长指令集，具有 16 位和 32 位指令。

## 立即操作数

`add`指令有一个第二种形式，其中**最后一个**操作数是一个直接编码到指令中的小数字。它被称为**立即**操作数，并且使用`#`符号表示：

```js
add r1, r2, #64000     /* r1 = r2 + 64000; */
```

GNU 汇编器允许使用`0x`前缀表示十六进制值和`0b`前缀表示二进制值。但是，它不允许在它们中使用下划线。因此，前面的指令可以重写为：

```js
add r1, r2, #0xFA00     /* r1 = r2 + 0xFA00; */
```

在下面的图中，您可以看到这个指令是如何编码的。

![The encoding of: add r1, r2, #0xFA00](img/e0848693a1c04b3c7414d0d1b8f09b7f.png)

`add r1, r2, #0xFA00`的编码

从图中，你可以看到有 8 位专门用于立即操作数，所以你可能得出结论，它可以表示任何单个字节的值。但是——等等！——在我们的例子中，我们使用了`64000`，这并不适合一个字节！实际上，指令中还有四个额外的位来编码立即数应该左移多少个偶数位。这样我们就可以表示`0xFA`、`0xFA0`、`0xFA00`、`0xFA000`等等。

这是一种巧妙的方法，在非常紧凑的空间中编码大量有趣的常数！

## 有符号、无符号、二进制补码

我们使用`add`指令添加的是什么？无符号整数？有符号整数？

结果表明，无论是将所有操作数都视为无符号整数，还是将它们都视为有符号整数，它都能正确工作。这要归功于大多数计算机使用的有符号数表示法，称为*二进制补码*。它是专门为这个技巧设计的：使用相同的硬件加法器对有符号数和无符号数进行操作。

> **注意**
> 
> 尽管`add`和大多数 ARM 指令在 32 位字上工作，但在本节中，我们将使用有符号和无符号 8 位字节来展示示例，以便它们更容易管理。

例如，如果我们尝试使用硬件加法器将`0b1111_1100`和`0b0000_0010`相加，我们得到`0b1111_1110`，这可以解释为无符号操作 252+2→254，或者解释为有符号操作-4+2→-2。在下面的表中，你可以看到一系列二进制模式可以解释为无符号或有符号整数。

整数的二进制补码表示

| 位模式 | 无符号解释 | 有符号解释 |
| --- | --- | --- |
| `0b0000_0000` | `0` | `0` |
| `0b0000_0001` | `1` | `1` |
| `0b0000_0010` | `2` | `2` |
| `0b0000_0011` | `3` | `3` |
| ⋮ | ⋮ | ⋮ |
| `0b0111_1100` | `124` | `124` |
| `0b0111_1101` | `125` | `125` |
| `0b0111_1110` | `126` | `126` |
| `0b0111_1111` | `127` | `127` |
|  |  | *— 有符号溢出 —* |
| `0b1000_0000` | `128` | `-128` |
| `0b1000_0001` | `129` | `-127` |
| `0b1000_0010` | `130` | `-126` |
| `0b1000_0011` | `131` | `-125` |
| ⋮ | ⋮ | ⋮ |
| `0b1111_1100` | `252` | `-4` |
| `0b1111_1101` | `253` | `-3` |
| `0b1111_1110` | `254` | `-2` |
| `0b1111_1111` | `255` | `-1` |
|  | *— 无符号溢出 —* |  |
| `0b0000_0000` | `0` | `0` |
| `0b0000_0001` | `1` | `1` |
| `0b0000_0010` | `2` | `2` |
| `0b0000_0011` | `3` | `3` |
| ⋮ | ⋮ | ⋮ |

二进制补码是一个优雅的系统，但在这里我们不会深入其细节。

## 算术和逻辑指令

因此，我们已经介绍了我们的第一个指令。花了一些时间，对吧？而且我有一个好消息要告诉你！ARM 中的所有算术和逻辑指令都有精确的三操作数形式！

这里只是其中的一些：

| 指令 | 助记符 | 效果 |
| --- | --- | --- |
| `add r1, r2, r3` | 加法 | `r1 = r2 + r3;` |
| `sub r1, r2, r3` | 减法 | `r1 = r2 - r3;` |
| `mul r1, r2, r3` | 乘法 | `r1 = r2 * r3;` |
| `sdiv r1, r2, r3` | 有符号除法 | `r1 = r2 / r3;` |
| `udiv r1, r2, r3` | 无符号除法 | `r1 = r2 / r3;` |
| `bic r1, r2, r3` | 按位清除 | `r1 = r2 & ~r3;` |
| `and r1, r2, r3` | 与（按位） | `r1 = r2 & r3;` |
| `orr r1, r2, r3` | 或（按位） | `r1 = r2 | r3;` |
| `eor r1, r2, r3` | 异或（按位） | `r1 = r2 ^ r3;` |

真是 neat，不是吗？我们现在基本上已经覆盖了指令集的大部分内容。让我们继续前进。

> **注意**
> 
> 除法是那些对于有符号和无符号整数操作不同的运算之一。由于 JavaScript 没有对无符号整数的适当支持，我们无法用我们的伪代码表示法轻松地表达这种差异。此外，一些 ARM 版本没有对`sdiv`和`udiv`指令的硬件支持（主要是受限制的嵌入式系统）。要使用它们，你需要传递一个汇编参数来指定支持它们的架构版本，例如，`gcc -march=armv7ve`。

## 移动指令

移动指令将一个字从寄存器复制到另一个寄存器，或者从立即数操作数复制到寄存器。立即数操作数有与之前相同的限制。还有一个“移动-非”指令，它执行按位取反。

| 指令 | 代码 | 效果 |
| --- | --- | --- |
| `mov r1, r2` | 移动 | `r1 = r2;` |
| `mvn r1, r2` | 移动-非 | `r1 = ~r2;` |

## 程序计数器

我们知道每个指令都被编码到一个字中。我们也知道指令在内存中一个接一个地排列。执行是如何从一个指令转移到下一个指令的呢？

为了做到这一点，使用的是*程序计数器*。程序计数器是寄存器`r15`，但更常见的是用它的别名：`pc`。在某些架构中，它被称为*指令指针*。程序计数器是一个指向当前正在执行的指令的指针。通过操作`pc`，我们可以改变下一个要执行的指令。

> **实际上，**
> 
> 由于指令流水线（我们在这里不会介绍），程序计数器通常指向当前正在执行的指令之后的两个指令。但，大部分情况下，我们可以安全地忽略这一点。

例如，如果寄存器`r0`包含我们想要*跳转*到的某个地址，我们可以通过将该地址移动到`pc`中来实现，执行将从那里继续：

```js
mov pc, r0        /* pc = r0; */
```

我们所说的*跳转*是指执行转移到不同的指令，而不是下一条指令。

值得强调的是，**每一条**指令都会影响程序计数器。至少，每条指令都会将程序计数器增加四个字节（一个字）以便执行可以转移到下一条指令。（否则，我们总是会陷入执行相同的指令）。因此，我们迄今为止所列出的每条指令的*效果*都需要在前面加上`pc += 4;`：

```js
add r1, r2, r3     /* pc += 4; r1 = r2 + r3; */
```

这里有一个汇编代码片段，其中我们通过增加`pc`来跳过两个指令，每次递增`r0`。

```js
/* This is not a recommended practice.    */
mov r0, #0       /* pc += 4; r0 = 0;      */
add r0, r0, #1   /* pc += 4; r0 = r0 + 1; */
add r0, r0, #1   /* pc += 4; r0 = r0 + 1; */
add pc, pc, #8   /* pc += 4; pc = pc + 8; */
add r0, r0, #1   /* …skipped…             */
add r0, r0, #1   /* …skipped…             */
add r0, r0, #1   /* pc += 4; r0 = r0 + 1; */
```

在这里，我们对 `pc` 的所有更改都是显式的。请注意，尽管 `add` 通常会将 `pc` 增加 4，但如果结果写入 `pc`，则会被覆盖。

从现在开始，我们将省略伪代码中的 `pc += 4;`。

我们可以得出结论，程序计数器是所有寄存器中最特殊的。通过改变它，我们改变程序中下一个要执行的指令。所以不要用它来存储一些临时值！

## 分支指令

我们可以通过向程序计数器添加和减去值来在代码中向前和向后跳转，但这非常繁琐。

我们可以使用汇编器的一点点帮助。汇编器允许我们插入代表特定指令地址的文本 *标签*。然后我们可以使用 *分支* 指令 `b`，汇编器将负责计算应用于 `pc` 的必要偏移量，以便到达正确的指令。

这样，我们之前的代码片段可以重写为：

```js
 mov r0, #0
 add r0, r0, #1
 add r0, r0, #1
 b myLabel        /* pc = myLabel; */
 add r0, r0, #1   /* …skipped… */
 add r0, r0, #1   /* …skipped… */
myLabel:
 add r0, r0, #1
```

尽管指令 `b` 跳转到相对于 `pc` 的偏移量，而不是绝对地址，但将标签视为存储在其中的绝对地址的常量是有帮助的。这就是我们将在描述每个指令效果的伪代码中使用它们的方式：

```js
 b myLabel        /* pc = myLabel; */
```

## 分支和交换

虽然 `b` 指令允许我们根据标签进行相对跳转，但 `bx`——或 *分支和交换*——允许我们跳转到寄存器中存储的地址：

```js
 bx r0       /* pc = r0; */
```

它与 `mov pc, r0` 有何不同？对我们来说，它是相同的。有些人会说它更易读。

然而，它还允许在 ARM 和 Thumb 指令集之间进行 *交换*。但在这本书中我们不会处理这一点。

## 分支和链接

*分支和链接*，或 `bl`，是一种相对跳转，就像 `b` 一样。唯一的区别是它会将程序计数器的值保存到一个特定的寄存器，`r14`，通常称为 `lr`，或 *链接寄存器*。

```js
 bl myLabel    /* lr = pc; pc = myLabel; */
```

它实际上所做的就是 *保存* 在覆盖之前 `pc` 的上一个值（从而，失去了它）。

我们可以用以下两个指令达到相同的效果：

```js
 mov lr, pc;
 b myLabel;
```

然而，这是一个如此常见的操作，以至于它值得拥有自己的指令。它之所以常见，是因为它用于实现函数调用。

## 过程内调用临时寄存器

注意，在底层，跳转到标签的指令（`b` 和 `bl`）编码了一个 24 位的立即值用于相对跳转。这允许我们在 ±32 MB 的代码空间内向前和向后跳转。但你不必处理这个限制。链接器将安排一个所谓的 *覆盖层*：在 ±32 MB 限制内跳转到特殊位置，然后如果需要更长的跳转，将加载完整的 32 位地址到 `pc`。

要做到这一点，它需要生成代码将完整地址加载到一个临时寄存器中。为了使其可预测，指定了一个特殊的寄存器来扮演这个角色：*过程调用临时寄存器*，被称为`r12`或`ip`。这主要与过程（换句话说，函数）调用相关，因为其他跳转到标签的操作通常相对较短。为什么叫*内联*？因为它用于调用*之间*：在调用者调用之后，但在控制权切换到被调用函数之前。它也被称为*临时*寄存器，意味着，短暂的临时存储。我们仍然可以使用这个寄存器来存储我们的临时值；我们只是不能依赖在调用之后值会被保留。因此，它最适合短暂的临时值。

## 函数调用基础

函数调用特别之处在于它们与其他类型的控制流跳转的区别在于函数调用会*返回*。在用高级语言编程时，我们不太考虑这一点，但在汇编级别，我们必须自己实现整个*返回*过程。

`bl`指令存储到`lr`中的值被称为*返回地址*。当函数结束时，它可以跳转到它以从被调用处继续执行。

让我们实现一个非常原始的函数`addFourtyTwo`，它接受一个参数并将`42`加到它上面。ARM 调用约定（我们稍后会详细讨论）表示我们应该在寄存器`r0`–`r3`（如果有）中传递前四个参数，并在`r0`（如果有，再次）中提供返回值。在我们的例子中，`addFourtyTwo`接受一个参数并返回一个值，所以我们使用`r0`来处理两者。

```js
 mov r0, #0         /* r0 = 0;                     */
 bl addFourtyTwo    /* lr = pc; pc = addFourtyTwo; */
 sub r0, r0, #3     /* r0 = r0 - 3;                */

addFourtyTwo:
 add r0, r0, #42    /* r0 = r0 + 42;               */
 bx lr              /* pc = lr;                    */
```

调用`addFourtyTwo`的*调用者*首先将寄存器`r0`设置为`0`，然后使用`bl`跳转到`addFourtyTwo`，它将返回地址保存到`lr`中。在`addFourtyTwo`的末尾，它通过`bx lr`返回，调用者继续（在这种情况下是减去`3`）。

另一种看待这个问题的方式是，我们将`lr`作为一个特殊参数传递给每个函数，这样函数就知道返回的位置了。

> **实际上，……**
> 
> 我忍不住在这里提到“延续传递风格”（*continuation-passing style*）。我们不会涉及它，但它是一种强大的编译器技术，它使得在编译器管道中早期明确传递返回地址（或*延续*）。

## 链接寄存器

链接寄存器`lr`或`r14`之所以特别，是因为`bl`只与`lr`一起工作。我们可以决定为返回地址使用不同的寄存器，比如`r8`（使用我们之前提到的`mov r8, pc; b myLabel`序列），但`bl`如此方便，我们将只为这个目的使用`lr`。 

我必须承认，“链接寄存器”这个名字并不完美。它之所以被称为这个名字，是因为它创建了一个可以追踪回被调用者的*链接*。在一些其他架构（如 RISC-V）中，这个寄存器被称为*返回地址*，或`ra`。

## 条件执行和 CPSR 寄存器

到目前为止，我们讨论的所有指令都是 *无条件执行* 的。只要 `pc` 能到达这些指令，它们就会执行。然而，有时我们想要 *条件执行*。这就是我们想要根据某些 *条件* 决定是否执行指令的时候。在 ARM 中，这通过两个步骤来完成：

+   比较指令 `cmp` 比较两个寄存器（或寄存器和立即数），并将比较结果保存到 CPSR 寄存器中。

+   带有 *条件代码* 的一条或多条指令从 CPSR 中读取比较结果，并根据条件代码执行（或不执行）。

CPSR 代表 *当前程序状态寄存器*。

下面是一个例子，其中根据条件执行了一系列 `mov` 指令：

```js
 cmp   r1, r2     /* cpsr = compare(r1, r2);    */
 moveq r1, #10    /* if (eq(cpsr)) { r1 = 10; } */
 mov   r2, #20    /* r2 = 20;                   */
 moval r3, #20    /* r3 = 20;                   */
 movne r4, #30    /* if (ne(cpsr)) { r4 = 30; } */
```

首先，`cmp` 指令比较寄存器 `r1` 和 `r2`，并将比较结果保存到 CPSR 中。它在 CPSR 中设置了一些位，但对于我们来说，哪些具体的位被设置并不重要，所以在伪代码中，我们将其隐藏在一个不透明的 `compare` 函数中。

接下来，我们看到一系列以 `mov` 开头的指令。这些是：`moveq`、`moval`、`movne`。它们并不是与 `mov` 相独立的指令，而是带有条件代码后缀的 `mov`。例如，带有 `eq` 代码的 `mov` 在上一次 `cmp` 指令比较的结果为相等时执行；带有 `ne`（不等于）的 `mov` 等等。`al` 代码代表 *总是*，是默认值，因此可以省略，所以 `mov` 和 `moval` 实际上是 *完全相同* 的指令。

在下面的表中，你可以看到一些条件代码的总结。这些并不是全部，但对于我们的用例来说已经足够多了。

选择 ARM 条件代码总结

| 代码 | 操作符 | 描述 | 有符号/无符号 |
| --- | --- | --- | --- |
| `eq` | `==` | 等于 | 任意 |
| `ne` | `!=` | 不等于 | 任意 |
|  |  |  |  |
| `gt` | `>` | 大于 | 有符号 |
| `ge` | `>=` | 大于或等于 | 有符号 |
| `lt` | `<` | 小于 | 有符号 |
| `le` | `<=` | 小于或等于 | 有符号 |
|  |  |  |  |
| `hi` | `>` | 大于 | 无符号 |
| `hs` | `>=` | 大于或等于 | 无符号 |
| `lo` | `<` | 小于 | 无符号 |
| `ls` | `<=` | 小于或等于 | 无符号 |
|  |  |  |  |
| `al` | — | 总是（默认） | — |

ARM 指令集的美丽之处在于，这些条件代码几乎可以添加到任何指令中！如果相等则分支？`beq`！如果大于则添加？`addgt`！比较——*再次*！如果不等于？`cmpne`！

这就是 ARM 指令集 *正交性* 的一部分特性：无论指令类型如何，都可以进行条件执行。

## 条件分支

将分支指令 `b` 和条件代码结合起来，我们得到了 *条件分支*。条件分支用于实现 `if`/`else` 语句和 `while`、`for` 循环等。

## 加载器

我们的程序是如何进入内存的？一个名为*加载器*的操作系统程序将我们的程序从磁盘复制到内存中，然后设置程序计数器，使我们的程序从`main`开始执行。

> **实际上，嗯……**
> 
> 实际的入口点称为`_start`，按照惯例，它不需要是`.global`。但是，我们用`libc`链接了我们的程序，它定义了自己的`_start`入口点，该入口点设置了程序命令行参数和其他对`libc`函数工作必要的机制。反过来，它将调用`main`，这就是为什么它需要声明为`.global`。

如果加载器是操作系统程序，那么操作系统是如何进入内存的？这是通过一个名为*引导加载程序*的程序来完成的。

> **实际上，嗯……**
> 
> 在嵌入式系统中，程序通常存储在只读存储器中，断电时不会擦除，并且当系统启动时，程序计数器从地址 0 开始执行。

## 数据和代码部分

让我们再次看看我们的 hello-world 程序的数据和代码部分。

```js
.data
 hello:
 .string "Hello, assembly!"

.text
 .global main
 main:
 push {ip, lr}

 ldr r0, =hello
 …
```

使用`.data`汇编指令声明的数据部分是另一段内存，允许你：

+   读取，

+   写入，

+   但不能执行。

使用`.text`声明的代码部分是另一段内存，允许你：

+   读取，

+   但不能写入，并且

+   执行。

我们为什么需要单独的部分？为什么有关于写入和执行的限制？答案有很多。

首先，这是许多操作系统的安全特性，禁止数据部分执行，并在运行时禁止修改代码部分。这使得通过欺骗程序更改其代码或跳转到不应执行的区域来注入恶意代码变得更加困难。它还有助于缓存，并允许在不同的数据上运行同一程序的多个实例。

更简单地说，在嵌入式系统中，代码部分通常会进入只读存储器，而数据部分将是主要的读写存储器。

## 段错误

在我们的 hello-world 程序中，我们没有修改问候字符串，对吧？这意味着我们可以将其放在`.text`部分下吗？是的；我们甚至可以省略`.text`部分，因为它默认存在：

```js
hello:
 .string "Hello, assembly!"

.global main
main:
 push {ip, lr}

 ldr r0, =hello
 bl printf

 mov r0, #41
 add r0, r0, #1

 pop {ip, lr}
 bx lr
```

尝试一下！

哦，不！我们的程序因为*段错误*而崩溃！发生了什么？什么是段错误？

这可能发生在我们尝试写入只读*段*时。但是，通常，这个术语适用于所有类型的*内存访问违规*。

那么，我们在这里违反了什么？对齐！我们的字符串——`"Hello, assembly!"`”——长度为 17 字节（包括隐式的零终止符`\0`）。因此，它将我们的`main`函数推到了一个不是对齐字的内存地址。我们可以用零填充字符串，使其占用 20 字节（可被四整除）：

```js
hello:
 .string "Hello, assembly!\0\0\0"
```

或者，我们可以使用一个名为`.balign`的汇编指令将其对齐到四字节（字）边界：

```js
hello:
 .string "Hello, assembly!"
 .balign 4
```

> **实际上，嗯……**
> 
> 此外，还有一个 `.align` 指令，但它在不同的架构和汇编器中的确切含义并不一致。另一方面，`.balign` 总是在指定的 *字节* 数的边界对齐。

## 数据指令

一种看待汇编语言的方式：它是一种编码二进制数据的方法。正如我们所知，每个 ARM 指令都被编码到一个机器字中。然而，汇编器有指令允许我们将字面数据也进行编码。

我们将要讨论的两个指令是 `.string` 和 `.word`，但还有更多可用。

我们已经看到了字符串指令。它的一个显著特点是它编码了一个以零结尾的字符串。也就是说，字符串被填充了一个单独的零字节：`\0`。

`.word` 指令允许我们使用数字记法将字面机器字插入到我们的二进制中：

```js
fourtyTwo:
 .word 42
```

在数据指令前放置一个标签是一个好主意，这样我们以后可以引用它，但正如你下面将看到的，这并不总是必要的。

数据指令有什么好处？它们可以用于我们程序中的常量或全局变量，但它们只是二进制数据的另一种编码方式。考虑以下程序。

```js
.global main
main:
 .word 0xE3A0002A /* Same as `mov r0, #42` */
 bx lr
```

这是一个简单的程序，它简单地以代码 42 退出。但在这里，我们不是写 `mov r0, #42`，而是写了 `.word 0xE3A0002A`，它编码了相同的值，就像指令一样。你可能还记得，从指令编码中，指令的最后字节编码了一个立即数，在这个例子中是 `0x2A`（十进制的 `42`）。

以这种方式编写指令 *绝对是一个坏主意*，但这是我们消除汇编器为我们所做事情神秘性的方法。

## 加载数据

加载意味着将数据从内存复制到一个或多个寄存器中。我们已经看到了如何通过标签加载数据，例如，加载一个字符串地址并将其传递给 `printf` 以在控制台打印。

```js
 ldr r0, =hello
 bl printf
```

同样，你可以加载一个单词的地址。但这种方式，你只能得到单词的地址，而不是单词本身。

一旦我们加载了一个单词的地址，我们就可以加载单词本身。为此，我们使用另一种形式的 `ldr` 指令，带有方括号：

```js
 ldr r1, =myWord    /* r1 = myWord */
 ldr r0, [r1]       /* r0 = M[r1]  */
```

这假设我们有一个带有该标签的单词存储在某个地方：

```js
myWord:
 .word 42
```

当我们将一个地址加载到一个寄存器中时，我们称它为 *指针*。这个指针 *引用* 另一个单词，但它本身并不是那个单词。当我们加载由该指针引用的单词时，我们说我们 *取消引用* 一个指针。

在这个例子中，当两条指令执行时，`r1` 将包含一些看似随机的数字，这是对应于标签 `myWord` 的地址，而 `r0` 将包含加载的值本身，即 `42`。

在列表中，我们为我们的伪代码使用了一种新的表示法。我们使用 `M[r1]` 来指代位于 `r1` 中地址的内存单词。记住，我们是如何说内存就像一个大数组？这种表示法很容易记住，因为指令语法中的方括号（`[r1]`）与数组表示法中的方括号（`M[r1]`）相匹配。这始终是这种情况。

然而，预先知道单个单词的加载并不很有趣。为此有一个捷径：

```js
 ldr r1, =42    /* r1 = 42 */
```

更好的是，如果我们正在加载的常数可以放入立即数中，汇编器将将其转换成：

```js
 mov r1, #42    /* r1 = 42 */
```

然而，如果它不适合立即数，它将转换成与我们的上一个例子大致等效的东西：

```js
 ldr r1, =temporaryWord    /* r1 = temporaryWord; */
 ldr r1, [r1]              /* r1 = M[r1]; */
 …

temporaryWord:
 .word 42
```

这种 `ldr` 指令的版本被称为 *伪指令*，因为我们刚刚看到，它将被汇编器转换为一个或多个实际指令。

## 使用立即偏移量加载

加载每个单词时不需要标签。你也可以通过给定另一个单词的 *偏移量* 来加载一个单词。

例如，如果我们有多个连续的单词：

```js
myArray:
 .word 42
 .word 44
 .word 46
```

（我们也可以这样写：）

```js
myArray:
 .word 42, 44, 46
```

然后，我们可以使用以下语法加载第三个单词：

```js
 ldr r1, =myArray       /* r1 = myArray;   */
 ldr r0, [r1, #8]       /* r0 = M[r1 + 8]; */
```

在这里，我们通过一个 8 字节（因此，2 个单词）的偏移量加载了一个单词。因此，我们将 `46` 加载到了 `r0`。

偏移量可以是正数或负数。它可以是立即的（就像在这个例子中）或寄存器。例如：

```js
 ldr r0, [r1, -r2]    /* r0 = M[r1 - r2]; */
```

## 存储数据

存储（storing）意味着将数据从一个或多个寄存器复制到内存中。换句话说，我们正在修改，或者说是 *mutating* 内存。

正如我们之前提到的，不可能将数据存储到我们用 `.text` 指令声明的只读段中：这将导致段错误。

然而，我们可以将数据存储到 `.data` 段，以及栈和堆（我们将在稍后讨论）。

存储指令使用 `str` 寄存器，并且与 `ldr` 指令使用相同的语法。一些示例（与 `ldr` 进行比较）：

```js
 str r0, [r1]         /* M[r1] = r0; */
 ldr r0, [r1]         /* r0 = M[r1]; */

 str r0, [r1, #8]     /* M[r1 + 8] = r0; */
 ldr r0, [r1, #8]     /* r0 = M[r1 + 8]; */

 str r0, [r1, -r2]    /* M[r1 - r2] = r0; */
 ldr r0, [r1, -r2]    /* r0 = M[r1 - r2]; */
```

方括号总是提醒我们哪个部分代表地址。

## 栈

*栈*，或称为 *调用栈*，用于实现嵌套的、可能递归的函数调用。它是一个内存段，与代码段和数据段类似。

在计算机科学中，*栈* 通常指的是一种特定的数据结构。*栈* 这个词被用作堆叠事物的隐喻，比如书籍。如果你有一堆书，很容易在顶部添加一本或几本书，也容易从顶部移除一本或几本书。然而，在栈的中间或底部添加或移除书籍则更为复杂。*栈* 是一种数据结构，它使得从一端添加和移除项目变得容易（且高效）。

在 JavaScript 中，你很少看到有人定义这样的数据结构。这是因为内置的 `Array` 已经足够作为一个栈使用：它有一个 `push` 方法来添加最后一个元素，以及一个 `pop` 方法来移除它，而且它们效率相当高。

调用栈在`Array`数据结构的意义上不是一个数据结构。它是一段内存。然而，与那些其他段不同，它要求我们遵循特定的纪律或约定来使用它。这个约定被称为调用约定。它被定义为使得用不同语言编写的函数或使用不同编译器的函数能够相互调用并在某些基本级别上交互操作。

例如，当我们调用一些`libc`函数，如`printf`时，我们需要遵循这个约定。如果我们想让其他函数调用我们定义的函数（比如`main`），我们也需要遵循它。

首先，我们将查看基本的栈操作：push 和 pop，然后我们将讨论调用约定，以及如何使用这些操作来实现它。

## Push 和 pop

栈指针是调用栈的核心概念。在 ARM 汇编中，它被称为`r13`或更常见的是`sp`。它保存着栈顶的地址。当栈指针改变其值时，我们说栈在增长或缩小。栈向内存中的较小地址增长，向较大地址缩小。我们说如果一个字被栈指针指向，或者在其下方，那么这个字是在栈上分配的。

以下指令将四个字推入栈中。

```js
 push {r0, r1, r2, r3}
```

在下一张图中，你可以看到几个寄存器和属于调用栈的一段内存，以两种状态展示。在左侧，你可以看到执行`push`指令前的状态，而在右侧，你可以看到执行后的状态。

![执行`push {r0, r1, r2, r3}`前后的调用栈](img/b5e3b458741c461c0baf30b373153e83.png)

执行`push {r0, r1, r2, r3}`前后的调用栈：`push {r0, r1, r2, r3}`

其效果是将字从寄存器复制到栈中，栈指针减少 16 字节，因此是四个字。它是减少的，因为它向较低的地址增长。栈指针上方的区域被灰色表示，表示这个区域没有被分配。

我们可以使用以下指令达到相同的效果：

```js
 sub sp, sp, #16
 str r0, [sp, #0]
 str r1, [sp, #4]
 str r2, [sp, #8]
 str r3, [sp, #12]
```

或者以下一系列单独的`push`指令：

```js
 push {r3}
 push {r2}
 push {r1}
 push {r0}
```

`push`指令有一个对应的指令`pop`：

```js
 pop {r0, r1, r2, r3}
```

这会逆转之前的行为：将`sp`增加 16，并将值从栈复制到寄存器中。它以相反的顺序执行，换句话说，就像这样：

```js
 pop {r0}
 pop {r1}
 pop {r2}
 pop {r3}
```

这些指令使用大括号，这让我们想起了集合表示法。这是为了表示你在汇编中写入它们的顺序并不重要。

你可以以任何一种方式来写它：

```js
 push {r3, r1, r2, r0}  // push {r0, r1, r2, r3}
```

但效果将是相同的：

+   较低的寄存器（比如`r0`）被推送到并从较低的内存地址中弹出。

+   较高的寄存器（比如`r15`）被推送到并从较高的内存地址中弹出。

`push` 和 `pop` 指令的编码有 16 位标志位，专门用于 16 个寄存器。因此，它们可以表示要推入或弹出哪些寄存器，但不能表示它们的顺序。顺序的选择是为了确保弹出操作能够撤销相应推入操作的效果。

## 栈对齐

调用栈的一个基本特性是，栈指针应该在所谓的“外部接口”的 8 字节（2 个字）边界对齐。在这本书中，我们不会讨论这意味着什么，只是提到调用 `libc` 函数是这种情况之一。我们的编译器不会区分从基线语言函数调用 `libc` 外部函数。为了简单起见，我们将假设一个更严格的要求，即*栈指针始终应该是 8 字节（2 个字）对齐的*。

那么，如果我们需要将单个字推入栈中呢？如果我们只是执行 `push {r4}`，那么我们的栈就不会对齐。因此，在需要时通常推入其他寄存器作为占位符以保持栈对齐：

```js
 push {r4, ip}
```

在这里我们使用了 `ip` 寄存器来达到这个目的。这与我们定义 `main` 函数时所做的相同：

```js
.global main
main:
 push {ip, lr}
 …
```

通常，我们总是可以用一个占位寄存器填充推入操作以保持栈对齐。在构建编译器时，我们还将讨论如何在不浪费空间的情况下保持栈对齐。

## 参数和返回值

函数参数通过前四个寄存器传递：`r0`–`r3`。关于不同大小的参数的规则很复杂，但在我们的编译器中，所有值都使用单个字表示。因此，我们可以说前四个参数是通过寄存器 `r0`–`r3` 传递的。这些寄存器有时也被称为*参数寄存器*。

其余的参数通过将它们推入栈中传递。

例如，如果一个函数 `f` 接收六个参数，为了调用 `f(10, 20, 30, 40, 50, 60)`，我们需要编写以下汇编代码：

```js
 mov r0, #50
 mov r1, #60
 push {r0, r1}   // 50 and 60 go on stack
 mov r0, #10     // 10, 20, 30, 40 go in registers
 mov r1, #20
 mov r2, #30
 mov r3, #40
 bl f            // The actual call
 add sp, sp, #8  // Deallocate 2 words of stack
```

这也是调用者的责任，在函数返回后，释放用于未适合四个参数寄存器的栈空间。函数返回后，期望的返回值（如果有）应在 `r0` 中。在 64 位返回值的情况下，它也可以跨越 `r0`–`r1`。

预期汇编程序员或编译器编写者（从外部来源）了解每个函数的正确签名：参数的数量、它们的大小以及关于返回值（如果有）。对于 `libc` 函数，我们可以在文档中查找它们，而对于在我们的语言中定义的函数，我们可以从其定义中看到它们。

## 寄存器约定

调用返回后，寄存器 `r0`–`r3` 的内容将是不可预测的和半随机的，不应依赖它们。（当然，这除外了用于返回值的寄存器，如果有的话。）换句话说，这些寄存器将包含函数调用后留下的*垃圾*：被调用的函数可能已经使用了它们或调用了另一个函数。这就是为什么我们说寄存器 `r0`–`r3` 是*调用破坏*的。另一个*调用破坏*的寄存器是 `r14` 或 `lr`。它被“调用”指令 `bl` 的设计破坏，该指令用返回地址覆盖了 `lr`。另一个*调用破坏*的寄存器是 `r12` 或 `ip`，它被链接器生成的包装器破坏。

相比之下，所有其他寄存器都是*调用保留*。换句话说，每个函数在调用返回时都有责任保留这些寄存器中的值。函数能否修改它们？是的，但应该在返回调用之前确保恢复这些值。

如果*调用破坏*寄存器适合作为参数，那么*调用保留*寄存器适合作为变量。寄存器 `r4` 到 `r10` 有时被称为*变量寄存器*。其他*调用保留*寄存器包括：帧指针和栈指针（`r11` 或 `fp` 和 `r13` 或 `sp`）。（我们稍后会谈到帧指针。）换句话说，预期栈顶将与调用之前的地址相同。程序计数器寄存器（`r15` 或 `pc`）是一个特殊的寄存器，但你可以将其视为也是调用保留：当调用返回时，`pc` 将恢复到之前的值。

ARM 寄存器角色和习惯用法

| 寄存器 | 角色 | 习惯用法 |
| --- | --- | --- |
| `r0` | 参数/返回寄存器 | *调用破坏* |
| `r1` | 参数寄存器 | *调用破坏* |
| `r2` | 参数寄存器 | *调用破坏* |
| `r3` | 参数寄存器 | *调用破坏* |
| `r4` | 变量寄存器 | *调用保留* |
| `r5` | 变量寄存器 | *调用保留* |
| `r6` | 变量寄存器 | *调用保留* |
| `r7` | 变量寄存器 | *调用保留* |
| `r8` | 变量寄存器 | *调用保留* |
| `r9` | 变量寄存器 | *调用保留* |
| `r10` | 变量寄存器 | *调用保留* |
| `r11` 或 `fp` | 帧指针 | *调用保留* |
| `r12` 或 `ip` | 程序内临时寄存器 | *调用破坏* |
| `r13` 或 `sp` | 栈指针 | *调用保留* |
| `r14` 或 `lr` | 链接寄存器 | *调用破坏* |
| `r15` 或 `pc` | 程序计数器 | *调用保留* |

那么，我们如何在实践中保留调用保留寄存器的值？当调用开始时，我们决定要使用哪些调用保留寄存器，因此我们将它们推入栈中。然后我们继续使用它们。然后在返回调用之前，我们将它们从栈中弹出。也有人说是我们在栈上*保存*这些寄存器。

因此，术语*调用破坏*和*调用保留*有另一种术语：*被调用者保留*和*调用者保留*。这指的是调用哪一侧负责将寄存器保存到堆栈上，*如果它们希望保留它们的话*。所以这也是另一种看待它的方式。

## 帧指针

我们还没有讨论的最后一个是表示为`r11`或`fp`的*帧指针*。一个函数的*帧*是该函数分配的堆栈区域。它也被称为*堆栈帧*、*调用帧*或*活动记录*。当它被使用时，*帧指针*被设置为指向帧的*基*，换句话说，指向函数被调用时堆栈指针曾经指向的地址。堆栈指针和帧指针之间的堆栈区域是当前函数的堆栈帧。帧指针是一个调用保留寄存器。按照惯例，我们将帧指针保存在新帧指针指向的同一个堆栈槽中。这样，帧指针寄存器为堆栈帧的*链表*提供了一个起点，其中中间链接是调用者的堆栈保存帧指针。请参见下面的图示。

![多个帧的堆栈示例](img/971ca69bb22b0810708dc5617639c234.png)

多个帧的堆栈示例

与图中的情况不同，每个堆栈帧通常具有不同的大小，这取决于局部变量和中间值的数量。

以这种方式使用帧指针和维持堆栈帧的链表都是可选的。然而，调试器、内省工具可能会使用它，并且对于某些语言特性，如异常处理和非局部跳转语句，可能也是必要的。由于函数调用后帧指针不会改变，因此在从堆栈帧中加载数据时，如局部变量，它是一个方便的指针。你知道`fp + 4`始终指向同一个堆栈槽，可以存储变量。同时，相对于堆栈指针加载局部变量要复杂一些：堆栈指针经常改变其值，但这当然是可以做到的。

## 函数定义

我们之前已经定义了一些函数，`main`和`addFourtyTwo`。后者看起来相当简单：

```js
addFourtyTwo:
 add r0, r0, #42
 bx lr
```

调用此函数根本不会分配任何堆栈！既不是用于中间值，也不是用于保存寄存器。返回地址是通过`lr`寄存器传递的。而且它不需要保存任何寄存器，因为它不使用任何调用保留寄存器。

当你想要定义一个调用另一个函数的函数时，比如我们之前看到的`main`函数，这一切都会改变：

```js
.global main
main:
 push {ip, lr}
 ldr r0, =hello
 bl printf
 mov r0, #41
 add r0, r0, #1
 pop {ip, lr}
 bx lr
```

由于它调用了`printf`，这个调用可能会破坏所有被调用破坏的寄存器，特别是：返回地址`lr`。如果我们想从`main`函数返回，我们最好将这个寄存器保存到栈上。这正是我们在`main`定义中通过`push {ip, lr}`所做的事情。我们还保存了一个虚拟的`ip`寄存器以保持栈对齐。

现在，如果我们想保持帧指针和帧的链表，我们会做不同的事情。我们会将`lr`和`fp`都推入栈中，然后设置新的帧指针以匹配栈指针。现在我们可以推入和弹出栈，我们仍然会在`fp`中有一个稳定的参考框架来访问局部变量。使用`fp`也使得释放帧变得容易。你可以在函数结束时使用`mov sp, fp`来完成它。或者，你也可以尝试匹配所有的推入和弹出，但这可能很棘手。所有这些繁琐的工作都有一个名字，或者确切地说，有两个名字：函数的*前置部分*和*后置部分*。

```js
.global main
main:
 push {fp, lr}  // Function's
 mov fp, sp     // prologue
 …
 mov sp, fp     // Function's
 pop {ip, lr}   // epilogue
 bx lr          //
```

函数的前置部分保存了被调用保留的寄存器，如果需要，设置帧指针。函数的后置部分则反转这一过程并退出函数。

在这个序言中，我们使用`pop`指令恢复寄存器，并通过`bx lr`返回。如果你还记得，在这种情况下，`bx lr`与`mov pc, lr`是相同的。那么，为什么不直接将返回地址弹出到`pc`，而不是`lr`呢？这样，我们可以使我们的序言更短、更高效：

```js
 mov sp, fp     // Function's
 pop {ip, pc}   // epilogue
```

这是在 ARM 中组织函数前置部分和后置部分的常见方式。

## 堆

另一个内存段被称为*堆*或*动态内存*。它是动态的，因为程序可以在运行时请求操作系统分配或释放新的内存区域。这通常是通过调用`libc`函数（`malloc`和`free`）来完成的，这些函数最终为你执行系统调用。`malloc`函数在`r0`中接受一个参数，指定我们想要分配多少字节。它返回一个在`r0`中的指针，该指针指向新分配的内存区域。`free`函数接受这样的指针作为其单个参数在`r0`中，并释放该内存区域。之后，你不能使用这个区域，操作系统将把它用于其他地方。

这里有一个汇编代码片段，它在堆上分配一个单字，将数字`42`存储进去，然后释放它。

```js
.global main
main:
 push {ip, lr}     // Prologue

 mov r0, #4        // Allocate four
 bl malloc         // bytes (one word)

 mov r3, #42       // Store 42 into
 str r3, [r0, #0]  // that word

 bl free           // Free/deallocate

 pop {ip, pc}      // Epilogue
```

高级语言通常会在堆上分配大多数对象和数据结构，而函数只传递和返回这些对象的指针。

* * *

关于 ARM 汇编和汇编编程还有很多要讨论的内容。但这一章应该足以让你对它有一个扎实的掌握。而且，对于完成编译器的第二遍来说，绰绰有余。

下一章：第八章 第二遍：代码生成

* * *
