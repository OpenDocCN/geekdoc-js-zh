# 第十五章：垃圾回收

> 原文：[`keleshev.com/compiling-to-assembly-from-scratch/15-garbage-collection`](https://keleshev.com/compiling-to-assembly-from-scratch/15-garbage-collection)

从头开始编译汇编

由 Vladimir Keleshev

到目前为止，我们使用 `malloc` 来动态分配内存，但我们从未将其释放回操作系统。你需要调用 `free` 来实现这一点，否则你的程序内存消耗只会增长。

当程序员需要手动释放内存时，这被称为 *手动内存管理*。对于某些语言来说，这可能很合适。然而，大多数语言以 *垃圾回收* 的形式提供 *自动内存管理*。

> **实际上，**
> 
> 垃圾回收是自动内存管理中的一种方法。其他方法包括 *引用计数* 和 *基于区域的内存管理*。

将垃圾回收器集成到你的编译器中最简单的方法是使用现成的组件，例如 Bohm–Demers–Weiser 垃圾回收器（或 Bohm GC），它作为一个库可用。你可以链接这个库，并将所有对 `malloc` 的调用替换为 Bohm GC 中的 `GC_malloc`，然后你就完成了！

但你在这里不是为了寻找简单的答案，对吧？对！那么，让我们从头开始实现一个简单的垃圾回收器。

## Cheney 算法

我们将实现一个名为 Cheney 算法的垃圾回收算法，该算法以 Chris J. Cheney 命名。以下是它的简化描述。我们将在接下来的章节中了解更多细节。

在程序启动时，会分配一个大的内存区域（例如，使用 `libc` 中的 `malloc`）。这个区域被称为 *半空间*。你很快就会明白为什么。我们现有的使用 `malloc` 分配数组的方式被一个新的函数所取代，我们称之为 `allocate`，它将分配（也称为 *块*）一个接一个地放置在半空间中。一旦半空间中没有足够的内存进行分配，就会运行一个我们称之为 `collect` 的函数。它分配一个新的半空间，并将旧半空间中的仅 *活动* 对象复制到那里。旧半空间被称为 *from-space*，新的一半空间被称为 *to-space*。如果对象可以从所谓的 *根*（通过指针）访问，则它们是 *活动* 的。*根* 是指向我们事先知道想要保留的对象的指针。这样的指针示例包括堆栈中的指针和全局变量中的指针。当所有活动对象都复制到 to-space 中时，from-space 就会被丢弃（例如，使用 `free`）。

当我们再次用完空间时，我们 `malloc` 一个新的半空间。现在，之前作为 to-space 的旧半空间变成了 from-space，然后这个过程重复。

第一个挑战是确定哪些对象是活动的。另一个挑战是，当我们复制块时，它们的地址会改变，这意味着我们需要更新指向那些对象的指针。

## 分配和收集

我们将首先编写一个自定义分配器函数来替换我们当前对`malloc`的使用。我们不会为每次分配调用`malloc`，而是分配一个更大的内存区域，然后在其中分配许多数组（或其他对象）。这样的内存区域通常——令人困惑地——被称为*堆*，但在 Cheney 算法的上下文中，它通常被称为*半空间*。

当谈论垃圾收集器时，我们称内存的各个跨度为*块*。我们的平坦、不可调整的数组恰好是每个块。尽管如此，更复杂的数据结构（例如我们也曾提到的可调整大小的数组）可以通过指针连接的多个块来实现。在本章中，我们将使用术语*块*，尽管对于我们的简单语言来说，它与数组同义。

在程序启动时，我们使用`malloc`分配一个大的空间。我们需要管理三个指针：

+   `malloc`返回的指针，我们将称之为*半空间起始*。

+   指向一个空间中第一个未被块占据的字的*分配指针*。

+   指向半空间末尾的指针（即*半空间起始*加上空间的大小），我们将称之为*半空间末尾*。

我们可以在程序的`.data`部分存储这些指针。我们也可以将其中之一或两个存储在调用保留寄存器中。

![程序启动时的状态](img/dbff5fe86ab437619200b560c34e1c48.png)

程序启动时的状态

> **注意**
> 
> 我们还没有讨论过以这种方式使用调用保留寄存器，但它们可以用来存储全局变量。例如，我们可以预留，比如说`r10`来存储特定的全局变量。我们可以同意在我们的代码生成器中不会使用这个寄存器做其他任何事情。外函数也会保持它的位置，因为它是调用保留寄存器。寄存器是一种宝贵的资源，但有时为某些重要的事情预留一个寄存器是有意义的。将*分配指针*分配给寄存器的方式是常见的。

在我们创建一个新的空间之前，起始和结束指针不会改变。然而，分配指针会随着每次分配而改变。它最初指向与半空间起始相同的地址，并且随着每次分配而向半空间末尾移动。

现在，我们可以实现`allocate`函数。当它被调用（带有要分配的字节数）时，我们检查分配指针和空间末尾之间的区域是否足够容纳它。然后，我们将分配指针增加请求的字节数，并返回分配指针的前一个值作为结果。换句话说，每次分配时，我们从半空间起始到半空间末尾依次打包块。

经过几次分配后，我们程序的状态可能如图下一页所示。

![程序的状态：栈和堆](img/97b13acd62b7ef4f41925233b236478d.png)

程序的状态：栈和堆

这里，我们有一个包含三个帧分配的栈。帧通过帧指针连接。帧包含指向之前在半空间中分配的块的几个指针。这些块之间有指针（例如，嵌套数组）。指针可能有循环（数组元素指向数组本身）。非指针字（左侧空白）持有一些标量数据，如数字或布尔值（在栈中和半空间中都有）。

块的长度作为第一个单词（就像我们对数组所做的那样）。我们称块中的这样的单词为**头部**。（头部通常占用一个或两个单词，可以包含更多数据，例如对象类型。）在图中，我们用字母“`H`”表示每个头部，并使用圆角将同一块中的单词分组，这样我们就可以看到块的长度。从图中，你可以看到我们分配了五个块，长度为两个和三个单词。

![两个半空间及其指针](img/f2101d60b53cccab5cc30e0eb66e180f.png)

两个半空间及其指针

假设程序现在想要分配一个包含四个单词的块。然而，半空间中（从分配指针到半空间末尾）没有足够的空间。当`allocate`函数运行时，这个条件必须触发垃圾回收。

我们首先分配一个新的半空间，称为**to-space**，同时我们将旧的称为**from-space**。它们之所以这样命名，是因为在收集过程中块是从 from-space**复制到**to-space 的。在图中，你可以看到两个半空间。它们都使用三个指针：**start**、**allocation**和**end**指针。

我们将逐帧向下走栈，查看帧中的每个单词：它是指针还是不是？使用我们现有的标记方案，我们可以很容易地区分指针和标量。这个过程被称为**扫描**，我们使用**扫描指针**来跟踪我们现在在扫描过程中的位置。

在图中，你可以看到扫描指针和新建的**to-space**。

![扫描栈：第一个指针](img/48edf3a9fd85838b6d62457c9553d68e.png)

扫描栈：第一个指针

当我们向下扫描栈时，我们遇到了第一个指针。我们将相应的块复制到 to-space，并增加 to-space 分配指针的值。在图中，你可以看到复制到 to-space 的两个单词块。栈上的指针被更新以指向新的块。（指针的先前值用虚线表示。）我们还更新了 from-space 中的相同块：我们用所谓的**转发指针**（以灰色显示）替换了头部单词。

如果在未来我们遇到指向我们刚刚移动的块的另一个指针，我们需要更新它们。这就是为什么我们在指向新块的旧块中存储转发指针。这就像当你搬到一个新地址并在旧地址留下便条，以便你的邮件可以转发一样。当我们到达一个块时，我们也可以使用我们的标记方案来区分它是从头部（一个数字）开始还是从转发指针（一个指针）开始。当然，块长度丢失了，但我们不会需要它来处理旧块。

![扫描栈：第二个指针](img/1051f8807113e427054a781d03f97099.png)

扫描栈：第二个指针

在相同的框架中，我们跳过一个包含标量的单词，遇到另一个指针。通过跟随那个指针，我们发现它以一个转发指针而不是头部开始。你可以认出那正是我们刚刚移动过的同一个块。这次，我们并没有复制这个块。相反，我们用转发指针的值更新栈上的值。

栈还保存了保存的链接寄存器的值。我们知道它们的位置在保存的帧指针旁边，可以忽略它们。或者，在我们的情况下，我们不需要对它们进行特殊处理：因为链接寄存器没有标记，它们将被解释为标量并跳过。

另一个问题是我们应该扫描栈多深？在某个时候，我们需要停止。在程序的开始，在`main`函数中，我们可以在栈上分配一个零字并让帧指针指向那里。这样，我们可以找出我们程序中的最后一个帧并停止。也有没有使用帧指针实现这一点的办法。

![扫描栈：第三个指针](img/caf8af2e3bc1ee4b51cf606f2b528d8c.png)

扫描栈：第三个指针

我们移动到下一个（也是最后一个）帧并再次开始扫描。我们在栈上遇到了我们的最后一个指针。和之前一样，我们将指向的块从源空间复制到目标空间，并用转发指针替换旧块的头。

我们已经扫描了整个栈，我们也应该以类似的方式扫描其他根，例如全局变量和寄存器。为了扫描寄存器，我们可以在扫描栈之前将它们保存在栈上。

然而，我们还没有完成：在目标空间中有一个块指向源空间中的另一个块。

![扫描目标空间：第一个指针](img/26fc50931eb7a56435fda8daa4877676.png)

扫描目标空间：第一个指针

类似于我们扫描栈的方式，我们现在开始通过逐个查看一个单词并检查它是否是一个指针来扫描目标空间。如果它是指向头部的指针——我们将块复制到目标空间。如果它是指向转发指针的指针，我们更新那个指针的值。

当我们扫描时，我们遇到了第一个指针。我们在 to-space 上分配了指向的块，更新指针以指向新分配的块，并在旧块中存储一个转发指针（灰色）。

你可以看到，当我们继续扫描 to-space 时，它增加了一个块，所以我们现在有更多的扫描要做。

![扫描 to-space：第二个指针](img/131b0fef04457ffc112deee299e8e144.png)

扫描 to-space：第二个指针

当我们扫描新复制的块时，我们遇到了另一个指针。它指向一个在 from-space 中的块，该块有一个转发指针，所以我们只需更新指针到新值，而不需要复制，因为该块已经被复制。一旦我们完成这个，就没有更多的块要扫描了——我们已经完成了收集阶段。

我们可以看到 from-space 中有两个块（现在突出显示为灰色）没有被复制。这意味着它们是垃圾。现在我们可以处理 from-space（使用`free`），最后，分配我们最初在收集开始之前想要分配的四个字节的块。程序现在可以继续运行。

在最后一个图中，你可以看到收集完成后程序的状态以及 from-space 已经被释放。

![我们的程序收集后的状态](img/365b84365b481b5981270033b1217149.png)

我们程序收集后的状态

## 标签

我们已经使用标记来区分标量值和指向块的指针。如果我们没有使用标记，我们可以检查一个单词的数值是否在 from-space 的开始和结束之间。如果是这个范围内的，我们可以得出结论，这个值是一个指针；如果不是——我们将其视为标量。这并不总是精确的：我们的程序可能处理一些恰好在这个范围内的数值。在这种情况下，算法可能会在内存中保留垃圾块。在实践中，这通常不是问题。不精确的垃圾收集器被称为*保守型*。Boehm GC 就是这样一个收集器的例子。

## 头部

我们在块的第一词中存储了块长度，即头部，与我们的数组布局相匹配。然而，通常头部会为垃圾收集器持有额外的数据。例如，头部中的一个标签可以表示整个块只包含标量，并且应该被收集器跳过以节省时间。这对于处理大型字符串来说很重要。

此外，当不使用指针标记时，每个块（和帧）都可以包含一个字段，其中包含有关哪个单词是指针以及哪个不是指针的信息。这可以通过位图的形式完成，每个单词一个位。换句话说，标记位可以从每个单词移动到块中的中央位置。

## 讨论

在这个例子中，我们的半空间只有 16 个单词或 64 个字节。实际上，我们需要分配更大的区域，而且区域越大，我们收集垃圾的次数就越少。

现在我们对 Cheney 算法有了深入的了解，让我们讨论一下这种垃圾收集器的某些特性。

首先，它提供了快速的分配。大多数时候，分配只需要检查是否有足够的空间，然后增加分配指针——就这样！这可以通过少量指令实现，如果分配指针被分配了一个专用的调用保留寄存器，还可以使其更快。相比之下，`malloc`的典型实现需要执行 50 到 200 条指令才能返回。

其次，它是一个*压缩*或*移动*收集器。在收集阶段之后，所有块都是依次分配的，没有空隙或碎片。这对数据局部性和缓存性能有利。

但这个算法并不完美。

它是一个*停止世界*，*非并发*收集器。当发生收集时，程序会暂停，直到收集完成。在并发收集器中，收集会在每次分配时一点点发生，以避免长时间的暂停。

这个算法的另一个特性是在收集期间，当两个半空间都分配时，消耗的内存量是两倍。

我们的收集器也是*非代*的。

## 代垃圾收集

观察到新块往往很快变成垃圾。然后一些块会长时间存在。我们希望更频繁地扫描新块以回收内存，并更少地扫描旧块，因为它们不太可能变成垃圾。这可以通过*代*收集器实现。

例如，具有两个代 G0 和 G1 的收集器可能有两个堆或空间：一个较小的用于 G0，一个较大的用于 G1。G0 中的收集发生得更频繁，而 G1 中的收集则更少。它们也可以使用不同的算法。所有新对象都在 G0 中分配，G0 收集发生后，剩余的块会被复制到 G1。

由于快速分配和它是移动收集器，Cheney 算法非常适合 G0 收集器。在这样的代收集器中，我们会将块复制到 G1 堆中，而不是另一个半空间。

* * *

有了这些，我们的旅程就结束了。我们学习了解析器组合器并为我们自己的语言创建了一个解析器；学习了 ARM 汇编以实现代码生成器；涉足静态和动态类型，还学习了一个垃圾收集算法。

我们希望你喜欢这次旅程，而且——谁知道呢——也许我们还会再次见面！

![](img/)
