# 第一章：简介

> 原文：[`keleshev.com/compiling-to-assembly-from-scratch/01-introduction`](https://keleshev.com/compiling-to-assembly-from-scratch/01-introduction)

从头开始编译汇编

由 Vladimir Keleshev

不是神创造了我们的罐子

*古谚语*

欢迎加入编写你自己的编译器的奇妙之旅！

拿起这本书，你可能已经非常确信你想要了解编译器是如何工作的，甚至可能想要编写一个。尽管如此，这里列出了做这件事的一些原因：

+   编写编译器是理解计算机工作原理以及它们如何执行我们的程序这一过程的最终步骤。

+   通过编写一个小型编译器，你可以看到它们就像其他程序一样，它们不是由神创造的魔法。

+   通过理解汇编以及编译器如何将你的程序转换为汇编，你可以更好地掌握你编写的程序的性能。

+   它将使你更清晰地看到不同语言特性的权衡，因此你在决定何时以及如何有效使用它们时将更加了解。

+   了解解析将帮助你处理非结构化数据，如抓取数据，或者处理没有库的数据格式。

+   它还将为你在必要时创建自己的领域特定语言，完成手头的任务做好准备。

+   这可能是进入编译器工程领域的第一步，一份既有利可图又令人兴奋的工作。

+   最后，它将让你体验创造和实验你自己的语言带来的乐趣和兴奋！

编译器构造的主题是计算机科学中研究最深入的主题。没有其他主题能与之相比。因此，编译器文献中有大量的有用技术和算法。而且，事实证明，其中很多非常适合我们日常编程。还有一种观点认为，最终，可能所有程序都是编译器。也许我们不是在编写 Web 应用，而是在编写从 DOM 节点到 JSON，从 JSON 到 SQL 的编译器，谁知道呢！

## 书的结构

本书描述了使用 TypeScript 编写的编译器的设计和实现，该编译器将一个小型语言编译成 32 位 ARM 汇编。

本书分为两部分。

*第一部分* 详细描述了最小 *基线编译器* 的设计和开发。我们称之为 *基线编译器*，因为它为在 *第二部分* 中引入的更高级功能奠定了基础。编译器的 *实现语言* 是 TypeScript。但编译器的 *源语言* 或 *输入语言* 是 TypeScript 的一个 *子集*（或是一个简化的版本）。这个子集包括任何实用编程语言的共同点，而不是 TypeScript 特有的：算术和比较运算符、整数、函数、条件语句和循环、局部变量和赋值。我们称这种语言为 *基线语言*。它可以表达简单的程序和函数，例如：

```js
function factorial(n) {
 var result = 1;
 while (n != 1) {
 result = result * n;
 n = n - 1;
 }
 return result;
}
```

*第二部分* 建立在 *基线编译器* 的基础上，并简要描述了各种 *编译器扩展*。这些扩展通常是相互排斥的（例如静态类型和动态类型），但它们都使用基线编译器作为基础。

*附录 A* 描述了如何运行编译器生成的 ARM 汇编代码。如果你在基于 ARM 处理器且运行 32 位操作系统（如 Raspberry Pi OS，以前称为 Raspbian）的计算机上开发编译器，你可以跳过这部分。然而，如果你运行的是 Intel 和 AMD 等公司的 x86-64 系统，你需要查看 *附录 A*。

*附录 B* 描述了两种主流 ARM 汇编语法的差异：GNU 汇编器（GAS）语法和传统的 ARMASM 语法。

## 为什么是 ARM？

在许多方面，ARM 指令集是这本书成为可能的原因。

与 Intel x86-64 相比，ARM 指令集是一件艺术品。

Intel x86-64 是从 8 位处理器，到 16 位，再到 32 位，最后到 64 位的演变结果。在演变的每个阶段，它都积累了复杂性和冗余。在每一个阶段，它都试图满足相互冲突的要求。

+   Intel x86-64 基于 *复杂指令集架构* (CISC)，最初是为了手动编写汇编代码而优化的。

+   另一方面，ARM 基于 *精简指令集架构* (RISC)，它优化了编写编译器的过程。

*猜猜哪一个对编译器来说更容易成为目标？*

如果这本书的目标是 x86-64 而不是 ARM，它将会是两倍长，而且更有可能永远不会被写成书。此外，考虑到 *数百* 亿的设备已经发货，我们最好习惯这样一个事实：ARM 是今天占主导地位的指令集架构。

换句话说，ARM 是一个好的起点。学习它之后，你将更有能力迁移到 x86-64 或更新的 ARM64。

## 为什么是 TypeScript？

本书描述了用 TypeScript 编写的编译器的设计和开发，该编译器编译了一种也使用 TypeScript 语法的较小语言。

编译器不必用 TypeScript 编写。它可以是用任何语言编写的，但我必须选择。我使用了 TypeScript 的一个简单子集来编写示例，以便让任何了解一种或多种主流语言的人都能阅读。

下一章，*TypeScript 基础知识*，为您提供了该语言的快速概述。

## 如何阅读这本书

*第一部分*的结构是线性的，每一章都是基于前一章的。然而，如果您已经熟悉某个主题，跳过章节也没有关系。

如果您计划跟随本书（或类似书籍）中描述的编译器进行实现，我建议首先在不编写任何代码的情况下阅读*第一部分*。然后您可以回到开始处，在浏览*第一部分*的同时开始实现编译器。

本书使用*解析器组合器*方法创建解析器；然而，如果您知道不同的技术，请随意使用它。

书中还穿插了三种类型的注释。

> **注意**
> 
> 这些是通用注释。

* * *

> **探索**
> 
> **探索**注释包含建议和尝试自己动手实践的方法。您可能会发现它们对练习和建立信心很有用，或者您可能会觉得先有一个最小的工作编译器更合适，然后才可选地回到这些内容。

* * *

> **实际上，……**
> 
> 这些包含了一些与主题无关的繁琐注释，但如果没有它们，这本书将不完整。

我们还将在代码片段中使用*代码折叠*。我们将使用省略号（`…`）来表示片段中省略了一些代码，通常是因为这些代码之前已经展示过了。

```js
function factorial(n) {
 var result = 1;
 while (n != 1) {…}  // Here
 return result;
}
```

*第二部分*主要分为独立的部分。您可以自由地只阅读您感兴趣的部分。如果您只想专注于静态类型或动态类型中的一个，就没有必要同时阅读关于这两个主题的内容。

下一章：第二章 TypeScript 基础知识

* * *
