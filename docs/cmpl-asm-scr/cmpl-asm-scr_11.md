# 第九章：第二部分简介

> 原文：[`keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2`](https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2)

从头开始编译汇编

by 弗拉基米尔·凯列舍夫

在扩展编译器之前，让我们讨论一下我们迄今为止实现的语言。

我们的编程语言是内存安全的吗？内存安全究竟是什么意思？简单来说，如果一种语言不允许你编写导致段错误的程序，那么这种语言就是内存安全的。如果我们只调用我们自己定义的函数，那么基本语言就是内存安全的。然而，我们的调用约定允许我们调用任意的`libc`函数。你可以找到一些创造性的方法来调用这些函数，这会导致段错误（尝试`free(42)`）。所以，除非我们对此采取措施，否则基本语言不是内存安全的。

解决这个问题的一种方法是为函数标签引入一个前缀。例如，一个名为`factorial`的函数可以被编译为标签`ts$factorial:`，对`factorial`的调用可以被编译为跳转到`ts$factorial`。这样，你只能调用在源语言中定义的函数，或者那些在汇编中明确编写的包装器。这些包装器可以由编译器自动生成，并在必要时处理类型转换。

我们的编程语言是动态类型还是静态类型？既是又是都不是！基本语言只支持整数类型。所以，它可以被认为是一种只有一种数据类型的动态类型语言，或者是一种只有一种静态类型的静态类型语言。但我们很快就要改变这一点。

然而，在我们探索静态和动态类型之前，我们的语言需要支持多种数据类型。我们将从介绍布尔值、未定义和数组开始。首先，我们将以不安全/无类型的方式介绍它们，然后我们将对它们应用静态/动态处理。

下一章：第十章 基本标量数据类型

* * *
