# 什么是 Node.js 实际上是什么

> 原文：[`www.thenodebook.com/node-arch/what-is-nodejs#the-ecosystem`](https://www.thenodebook.com/node-arch/what-is-nodejs#the-ecosystem)

# 什么是 Node.js 实际上是什么

所以，你是来 *真正* 理解 Node.js 的。很好。

也许你已经使用了一段时间。你用 Express 构建了 API，你与 `npm install` 过招，你也看到了你应得的 `callback is not a function`。你知道它是“异步”和“非阻塞”的，你可以在睡梦中编写 `async` 函数。

但有一种令人烦恼的感觉，不是吗？一种感觉，在引擎盖下，有一个你从未真正见过的整个机械世界。真正的事件循环是什么？当人们说 Node 是“单线程”时，他们实际上是什么意思，为什么你的服务器能同时处理数千个用户？一个 JavaScript 文件，以前只是运行在浏览器中，突然有了写入文件和打开网络套接字的能力？

这章是我们进入那个引擎室的大门。我们不仅将定义 Node.js。我们将剖析它。我们将查看导致其创建的历史偶然事件，检查使其运转的核心组件，并理解围绕其产生的文化现象——生态系统。

我的目的是不仅仅给你事实。我要给你一个 *心智模型*。到这一步结束时，当你编写 `fs.readFile()` 时，我希望你能看到这个请求的旅程：从你的 JavaScript，通过 C++ 绑定，进入 libuv 库，传递给操作系统，然后响应通过事件循环一路冒泡回来。

在我们深入之前，我将假设一些关于你的事情。别担心，这不是考试。这只是为了帮助我们专注于深入的内容。

| 前置条件（≤5） | 为什么它很重要/需要略读 |
| --- | --- |
| JavaScript `async/await` 和 Promises | 我们的示例将使用现代异步语法；如果你生疏了，只需要快速复习一下即可。 |
| 基本的终端和 Shell 命令 | 我们将运行 `node`、`npm` 和简单的性能工具（`curl`、`htop`）等命令。 |
| 熟悉 Web 框架（例如，Express） | 了解构建 API 的基础知识有助于理解 Node 的性能模型为何重要。 |
| I/O（输入/输出）的概念 | 我们将大量讨论文件 I/O 和网络 I/O。只需知道它意味着“与外界交流”。 |

如果你在这方面很扎实，你就准备好了。让我们动手吧。

## TL;DR

对于那些现在需要关键要点，稍后再阅读详细内容的人：

Node.js 不是一个语言、框架或库；它是一个 **运行时**。它是一个在浏览器之外执行你的 JavaScript 代码的程序。它由三个主要部分组成：

1.  **V8 JavaScript 引擎**。来自 Google Chrome 的相同高性能引擎。它将你的 JS 编译成原生机器代码。

1.  **`libuv` 库**。一个提供异步、非阻塞 I/O 模型的 C 库。这里发生了事件循环和线程池的魔法。这是 Node 的秘密武器。

1.  **C++ 绑定与 Node.js 核心 API**。这是连接你的 JavaScript (`require('fs')`) 到底层 C++ 和 `libuv` 功能的“胶水”，允许你访问文件系统、网络等。

**其核心哲学是非阻塞 I/O**。Node 的创建是为了解决 Web 服务器因慢速操作（如数据库查询或文件读取）而卡住的问题。而不是等待，Node 的事件循环允许它启动一个 I/O 操作，注册一个回调，并立即转到服务其他请求。这使得它在处理大量并发连接时非常高效，同时内存使用最小。

**它在特定意义上是“单线程”的**。你的 JavaScript 代码在一个主线程上运行。你不必担心应用程序逻辑中的锁或竞争条件。然而，对于重负载（一些文件 I/O、加密等），`libuv` 维护一个小型的后台线程池。所以，尽管你的代码看到一个线程，Node 在底层使用几个线程来避免阻塞。

**生态系统与运行时一样重要**。Node 的核心故意保持最小。它的力量来自于 **npm**（Node 包管理器），这是世界上最大的软件注册库。这种小型、可重用模块的文化允许快速开发，但也引入了依赖管理、供应链安全等挑战（正如我们将在 `left-pad` 事件中看到的那样）。

**你的心智模型应该是“事件驱动”的**。将 Node 视为一个超级高效的协调者。它接收请求，将慢速任务委托给操作系统或其线程池，并保留一个“任务完成时要做的事情”的列表。它几乎不花费时间等待，几乎所有的时间都在工作或委托。

⚠️警告

你的 JavaScript 应用程序逻辑在一个主线程上运行，这避免了传统线程锁定问题，但你仍然必须考虑对共享状态的并发访问。异步回调、多个 Node 进程、worker_threads、本地插件以及任何共享内存的使用（例如，SharedArrayBuffer）都引入了并发问题和潜在的竞争条件 - 设计为不可变状态、原子更新，或在需要时使用适当的同步。别担心，我们将更详细地介绍每一个。

* * *

## **运行时 - 内部导览**

### 为什么阻塞 I/O 是一个每个人都讨厌的派对

要理解 Node.js 为什么是这个样子，你必须追溯到 2009 年。当时，Web 服务器领域由 Apache 等巨头主导。如果你在构建 Web 应用程序，标准模型可能如下所示：

1.  用户请求到来。

1.  服务器（Apache）为处理该请求分配一个线程（或整个进程）。

1.  你的应用程序代码运行在那个线程上。

1.  如果你的代码需要执行一些慢速操作——比如查询数据库、从磁盘读取文件或调用另一个 API——那么这个线程就会……停止。它坐在那里，阻塞着，占用着内存和 CPU 资源，等待慢速操作完成。

1.  一旦慢速操作完成，线程就会醒来，完成响应的生成，将其发送回去，最后可以自由地处理另一个请求。

这个模型简单易懂。每个请求都是一个整洁的、线性的步骤序列。但它有一个致命的缺陷。

ℹ️注意

重要的是要注意，这描述的是经典模型；现代的多线程服务器和语言运行时已经随着混合事件驱动/线程模型和更有效的线程实现而显著发展，以减轻这些原始的扩展问题。

想象一家热门的咖啡店。他们的模式是每个顾客一个咖啡师，从开始到结束。你走进去，咖啡师 A 接收你的订单，走到机器旁，磨豆，抽出浓缩咖啡，加热牛奶，最后给你拿铁。在整个五分钟的过程中，咖啡师 A 是你的咖啡师。他们不能帮助其他人。如果同时进来十个人，你需要十个咖啡师和十个浓缩咖啡机。如果进来一千个人？你将面临一个庞大且昂贵的难题。

这就是旧式 Web 服务器的“每个请求一个线程”模型。线程很昂贵。它们消耗内存（用于栈）和 CPU 时间（用于上下文切换）。处理数千个并发用户意味着运行数千个线程，这非常低效。这被称为[C10k 问题](http://www.kegel.com/c10k.html)——在单个服务器上处理十万个并发连接的挑战。

**“啊哈！”时刻**

一位名叫 Ryan Dahl 的开发者看到了这个问题，并认为它从根本上是有缺陷的。他看到任何 Web 应用中最慢的部分总是 I/O 操作——等待网络，等待磁盘。CPU 本身在线程阻塞时常常处于空闲状态。

他研究了高性能服务器如 Nginx 是如何解决这个问题：采用**事件驱动、非阻塞架构**。而不是为每个顾客分配一个工作者，如果只有一个超级快的咖啡师（事件循环）来接收订单会怎样？

1.  顾客 1 想要一杯拿铁。咖啡师在票上写下订单，递给机器（操作系统/内核），然后立即转向下一个顾客。

1.  顾客 2 想要一杯滴滤咖啡。咖啡师写下订单，递给另一台机器，然后立即又可用。

咖啡师从不等待。他们只是处理事件（“新订单”）并将慢速工作委托出去。当饮品准备好时，铃声响起（事件被触发）。咖啡师拿起完成的饮品，递给正确的顾客，然后继续工作。

这就是 Node.js 的核心思想。

Dahl 看到 JavaScript，一个在浏览器中诞生的语言，非常适合这种模式。为什么？因为基于浏览器的 JavaScript 已经是事件驱动的。你不会写代码说“等待 5 秒钟，直到用户点击这个按钮”。你会写 `button.addEventListener('click', function() { ... })`。你为事件注册一个回调，并让环境（浏览器）在事件发生时通知你。

因此，他选择了他能找到的最快的 JavaScript 引擎 - 来自 Chrome 浏览器的 Google 开源 V8 引擎 - 并结合了他编写的新 C 库（最终被更健壮的 `libuv` 所取代）来处理这个异步 I/O。他创建了一个运行时环境，可以在服务器上执行 JavaScript，但它的核心是一个强大、事件驱动、非阻塞的 I/O 模型。

ℹ️注意

早期的 Node 原型依赖于现有的事件库（libev/libeio）进行内核集成；后来项目转向了 libuv - 一个跨平台的 C 库（主要由 Ben Noordhuis 和其他贡献者维护），它统一了事件循环、异步文件系统、线程池和平台抽象。

他在 2009 年的一次会议上展示了这个新创作品，“Node.js”。演示简单但深刻。他展示了一个服务器，它可以处理大量的并发连接，但内存占用很小，所有这一切都是因为它从不等待。这是对 C10k 问题的直接解决方案，它改变了一代开发者对构建网络服务的思考方式。

这个历史非常重要，因为它已经融入了 Node 的 DNA。每一个设计决策，每一个 API，都是围绕这个核心前提构建的：**永远不要阻塞主线程**。这就是为什么默认的文件读取方法 `fs.readFile` 使用回调。这就是为什么你使用 Promises 和 `async/await`。你总是，总是告诉 Node，“嘿，去做这个慢活，完成的时候告诉我。我还有其他工作要做。”

ℹ️注意

历史上 `fs.readFile` 使用回调；现代代码应优先考虑在适当的情况下使用 `fs.promises` 与 async/await 或流式 API。

### 核心组件 - V8、libuv 和粘合剂

当你输入 `node my_app.js` 并按回车键时，你不仅仅是在运行一个 JavaScript 解释器。你正在启动一个复杂、精心调校的软件。让我们一层层揭开它的面纱。

从高层次来看，Node.js 的架构看起来大致如下：

*Node.js 运行时的层级，从你的代码到操作系统。*

ℹ️注意

图表已简化：确切的内部结构根据 API 和平台而异 - 例如，网络使用内核就绪 API，一些文件系统/DNS 调用由 libuv 的线程池处理，并且 libuv 可能根据平台和 libuv 版本使用不同的内核功能（epoll/kqueue/IOCP/io_uring）。

让我们分解每个主要组件。

**V8: JavaScript 引擎**

这是大多数人所知道的部分。V8 是 Google 的开源、高性能 JavaScript 和 WebAssembly 引擎，用 C++编写。它是驱动 Google Chrome 的引擎。当 Node.js 开始时，使用 V8 是一个绝妙的举措。这意味着 Node 免费获得了一个世界级的、极其快速且不断改进的 JS 引擎。

但“引擎”实际上做什么呢？

它不仅仅是一行一行地读取你的 JavaScript 代码。它将其编译成高度优化的本地机器代码。这个过程称为即时（JIT）编译。

**V8 的编译管道：** 当 V8 看到你的 JS 代码时，它首先使用一个基线编译器称为**Ignition**，快速将其转换为字节码。随着代码的运行，V8 的剖析器会监视“热点”函数——经常被执行的代码。然后，这些热点函数被传递给优化编译器**TurboFan**，它会对你的代码做出假设（例如，“这个变量始终是一个数字”）以生成极快的机器代码。如果这些假设有任何错误，V8 将执行“去优化”并回退到较慢的字节码。（我们将在**第二十一章**中深入探讨 V8 的内部结构和如何编写优化友好型代码。）

目前，关键要点是：**V8 使得 JavaScript 在服务器上运行足够快。**它将动态的、解释型语言转化为可以与传统服务器端语言相媲美的性能。

但 V8 对文件、网络或定时器一无所知。它是一个纯 JavaScript 引擎。如果你在一个普通的 V8 实例中尝试运行`require('fs')`，它会抛出一个错误。它生活在沙盒中。要在服务器上做任何有用的事情，V8 需要帮助。

**libuv**

这是 Node.js 的默默无闻的英雄。`libuv`是一个 C 库，最初是为 Node.js 编写的，它提供了核心的异步、事件驱动功能。它是使 Node...成为*Node*的组件。

它的主要职责包括：

1.  **事件循环。** 这是核心机制。它是一个无限循环，处理来自队列的事件。当你调用`setTimeout`、`fs.readFile`或`http.createServer`时，你实际上是在注册一个事件处理器。循环持续不断地询问操作系统：“我等待的事情有什么发生吗？”（例如，“那个文件是否已经读取完成？” “是否有新的连接在这个套接字上？”）。当操作系统回答是时，事件循环会从你的代码中取出相应的回调函数并执行它。我们将在稍后详细剖析事件循环的阶段，但就目前而言，可以将其视为不知疲倦的协调者。

1.  **异步 I/O**。`libuv`抽象了底层操作系统的非阻塞 I/O 能力。在 Linux 上，它使用`epoll`。在 macOS/BSD 上，它使用`kqueue`。在 Windows 上，它使用`IOCP`（I/O 完成端口）。作为 Node 开发者，您不需要关心这些。您只需编写 JavaScript，`libuv`会根据其运行的平台选择最佳策略，以确保 I/O 操作不会阻塞主线程。

1.  **线程池**。等等，我以为 Node 是单线程的？这是最常见的混淆点。您的 JavaScript 代码在一个线程上运行（事件循环线程）。但是，一些操作不能由操作系统以非阻塞方式异步执行。如果这些操作在主线程上运行，它们会阻塞事件循环，从而违背了 Node 的整个目的。这包括大多数文件系统 API 和像`crypto`和`zlib`模块这样的 CPU 密集型任务。

    为了解决这个问题，`libuv`维护了一个小型、固定大小的**线程池**（默认为 4 个线程，但在创建池之前可以通过`UV_THREADPOOL_SIZE`进行配置；最大约为`1024`）。当您调用一个在操作系统级别没有非阻塞等价物的函数时（如`fs.readFile`），`libuv`会将工作调度到其线程池。关键的是，网络 I/O 直接由操作系统的非阻塞机制（如 epoll、kqueue、IOCP）处理，并且不使用线程池，允许单个线程处理数万个并发连接。

    ℹ️注意

    大多数网络套接字 I/O 是通过操作系统的不阻塞 I/O 设施（epoll/kqueue/IOCP）处理的，并且不使用 libuv 工作池。存在例外：主机名查找（例如，dns.lookup 使用 getaddrinfo）和许多文件系统操作被卸载到 libuv 线程池 - 这些任务确实消耗工作线程。

    一旦线程池中的线程完成其任务，它会通知事件循环，然后执行您的 JavaScript 回调并返回结果。

    因此，从您的角度来看，Node.js *是* 单线程的，但它底层使用几个线程来处理特定类型的工作。这是一个重要的区别。（我们在第二十三章深入探讨了`libuv`的内部结构、事件循环阶段和线程池。）

**C++绑定与 Node.js 核心 API：桥梁**

因此，我们有 V8（用于运行 JS）和`libuv`（用于异步 I/O）。它们是如何互相通信的呢？

这就是 C++绑定的作用。

当您编写`const fs = require('fs');`时，您并不是得到一个纯 JavaScript 对象。您得到的是一个具有“绑定”到底层 C++代码的 JavaScript 模块。当您调用`fs.readFile('/path/to/file', callback)`时，以下序列发生：

1.  Node 的`fs`核心模块中的 JavaScript `readFile`函数被调用。

1.  此函数通过绑定调用到 C++函数。

1.  C++代码准备请求，然后将其传递给`libuv`，并说“请读取这个文件。”

1.  `libuv`获取请求并将其提交给其线程池以执行。

1.  关键的是，你的 JavaScript 代码会立即继续执行。`readFile`调用返回了`undefined`。

1.  在某个时候，线程池中的一个线程完成了文件的读取。它通知`libuv`任务已完成。

1.  `libuv`然后将结果和相关回调放入事件循环的队列中处理。

1.  在事件循环的下一个 tick 中，它看到队列中完成的任务并执行你提供的原始 JavaScript 回调，传入数据或错误。

这个桥梁使得 Node.js 成为一个统一的运行时环境。它通过一个干净、易于使用的 JavaScript API 暴露了像`libuv`这样的低级库的强大功能。`http`、`crypto`、`path`和其他核心模块都是这个层的一部分。

### 让我们看看实际效果 - 一个微小的测量实验

理论是伟大的，但眼见为实。让我们通过一个简单的实验来展示阻塞和非阻塞 I/O 模型之间的深刻差异。

我们将创建两个微型的 Web 服务器：

1.  **Python 服务器**。我们将使用 Flask，一个流行的 Web 框架。为了模拟慢速的数据库查询或 API 调用，我们将在每个请求上让它暂停 2 秒。这是一个经典的**阻塞**操作。

    📌重要

    这个例子使用 Flask 的内置开发服务器（单线程）来展示阻塞；在生产环境中，你不会使用这个开发服务器。生产 Python 服务通常在 WSGI/ASGI 服务器（Gunicorn、uWSGI 或 uvicorn）下运行，具有多个工作者或异步事件循环 - 这改变了并发模型。因此，这个演示只展示了简单的对比，而不是关于 Python 能力的全面声明。

1.  **Node.js 服务器**。我们将使用内置的`http`模块。为了模拟相同的慢速操作，我们将在响应前使用`setTimeout`延迟 2 秒。这是一个**非阻塞**操作。

然后，我们将对这两个服务器发起 10 个并发请求，并观察其行为。

**阻塞服务器（Python/Flask**）

首先，请确保你已经安装了 Python 和 Flask。`pip install Flask`

将此代码保存为`blocking_server.py`：

```js
import time
from flask import Flask
 app = Flask(__name__)
 @app.route("/")
def hello_world():
 print("Request received. Starting 2-second 'work'...")
 time.sleep(2) # This BLOCKS the entire process!
 print("Work finished. Sending response.")
 return "<p>Hello from the blocking server!</p>"
 if __name__ == '__main__':
 # Flask's dev server is single-threaded by default
 app.run(port=5000, threaded=False)
```

这个服务器被设计成简单的。`time.sleep(2)`调用完全冻结了服务器。在这两秒钟过去之前，它绝对不能做其他任何事情。

运行它：`python blocking_server.py`

**非阻塞服务器（Node.js**）

将此代码保存为`non_blocking_server.js`：

```js
// @noErrors
import http from "http";
 const server = http.createServer((req, res) => {
 // @log: Request received. Scheduling 2-second 'work'...
 console.log("Request received. Scheduling 2-second 'work'...");
 // This is NON-BLOCKING. It schedules the work and returns immediately.
 setTimeout(() => {
 // @log: Work finished. Sending response.
 console.log("Work finished. Sending response.");
 res.writeHead(200, { "Content-Type": "text/html" });
 res.end("<p>Hello from the non-blocking server!</p>");
 }, 2000);
});
 server.listen(5001, () => {
 // @log: Server running on http://localhost:5001/
 console.log("Server running on http://localhost:5001/");
});
```文本

> [!NOTE]
> 
> 重要的是要注意，`setTimeout`代表一个“完全空闲”的等待，不消耗任何系统资源。虽然这个实验巧妙地展示了事件循环的非阻塞特性，但在现实世界中处理 10 个并发数据库查询的应用程序仍然会为每个连接的 I/O 缓冲区打开 10 个套接字并使用内存。Node.js 的魔法并不是它使 I/O 工作免费，而是它防止主线程在 I/O 操作进行时被阻塞。

> [!IMPORTANT]

> 定时器为事件循环的将来轮次安排一个回调；与 CPU 工作相比，它较轻量，但仍分配了一个句柄，并且可以保持进程活跃（除非你在定时器上调用.unref()）。定时器不是免费的——创建大量定时器或依赖定时器作为并发原语可能会增加内存和调度开销。

在这里，`setTimeout`不会暂停执行。它告诉 Node.js 运行时，“大约 2000 毫秒后，请运行这个函数。”主线程立即被释放，以便处理更多的传入请求。

运行它：`node non_blocking_server.js`

**测试**

现在，让我们使用一个简单的命令行工具，`curl`，来模拟大约同时有 10 个用户撞击我们的服务器。打开一个新的终端。

首先，让我们测试一下**阻塞服务器**。快速连续运行这 10 个`curl`命令。`&`使得每个命令在后台运行。`time`命令将显示所花费的总实际时间。

```jsbash
time ( \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ & \
 curl http://localhost:5000/ \
)
```text

**观察（阻塞服务器）：**

查看文件`blocking_server.py`的控制台输出。你会看到类似以下内容：

```jsansi
Request received. Starting 2-second 'work'...
Work finished. Sending response.
Request received. Starting 2-second 'work'...
Work finished. Sending response.
... (and so on, 10 times) ...
```text

注意其顺序性。它在开始处理下一个请求之前，会先完全处理一个请求。

`time`命令报告的总时间将是**大约 20 秒**（10 个请求 \* 每个请求 2 秒）。

现在，让我们测试一下**非阻塞服务器**。

```jsbash
time ( \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ & \
 curl http://localhost:5001/ \
)
```text

**观察（非阻塞服务器）：**

查看文件`non_blocking_server.js`的控制台输出。你会看到截然不同的内容：

```jsansi
Request received. Scheduling 2-second 'work'...
Request received. Scheduling 2-second 'work'...
Request received. Scheduling 2-second 'work'...
... (10 times, almost instantly) ...
 Work finished. Sending response.
Work finished. Sending response.
Work finished. Sending response.
... (10 times, about 2 seconds after the first batch) ...
```

服务器立即接受了所有 10 个请求，安排了所有 10 个超时，然后大约两秒后，所有 10 个定时器触发并发送了它们的响应。

`time`命令报告的总时间将是**略超过 2 秒**。

这就是它。这就是魔法。Node 服务器在 Python 服务器处理一个请求的时间内，处理了 10 个并发的“慢速”操作。它不是通过 10 个线程实现的这种并发，而是一个单一、高效的事件循环。如果你在它运行时检查进程列表（使用像`htop`或`ps`这样的工具），你会看到一个内存占用很小的单个`node`进程，愉快地同时处理所有请求。相比之下，阻塞服务器会被单个请求完全占用。

这个简单的实验是你可以拥有的最重要的 Node.js 性能心智模型。

* * *

## **生态系统**

讨论 Node.js 时，不能不提及其生态系统。运行时本身功能强大，但只是基础。Node.js 的真正力量来自于社区以及建立在它之上的开源包的宇宙。

如果 Node.js 是引擎，那么**npm**就是生产你所需所有可能部件的工厂，从小螺丝到整个传动系统。

### npm - 世界上最大（有时也是最嘈杂）的玩具箱

当 Node.js 首次推出时，没有标准的方式来共享代码。如果你想使用某人的库，你可能需要复制粘贴或者使用 git 子模块。这很混乱。

2010 年，Isaac Z. Schlueter 创建了**npm**（Node 包管理器）。这是一个简单的命令行工具，用于下载和管理 Node 项目的依赖项。从 2011 年开始，它捆绑在 Node.js 中，这个决定改变了所有的一切。

它使得代码的共享和重用变得极其容易。有一个有用的函数？`npm publish`。需要一个 Web 框架？`npm install express`。这种易用性，加上 Node.js 日益增长的流行度，导致了包的爆炸式增长。

出现的哲学受到了 Unix 哲学的强烈影响：**“编写只做一件事并且做得好的程序。”**这导致了非常小、专注的模块文化。需要填充字符串？有相应的包。需要检查一个数字是否为奇数？也有相应的包。

这既有优点也有缺点：

+   **优点**：你可以通过连接这些小型、经过良好测试的组件来非常快速地组合复杂的应用程序。你不必重新发明轮子。

+   **缺点**：你的项目的`node_modules`目录可以迅速变成一个庞然大物，包含作为依赖项的依赖项的数千个包。一个简单的`npm install`可能感觉像是下载了半个互联网。

现在，npm 注册表是世界上[最大的软件注册表](https://www.npmjs.com/package/all-the-packages)，拥有数百万个包。毫无疑问，这是 Node.js 最伟大的优势之一。它也是一些最大头痛的来源。多年来，像`yarn`和`pnpm`这样的竞争对手出现了，以解决 npm 的性能、安全和依赖解析问题，推动官方 npm 客户端变得更好。（我们将在**第三十七章**中介绍包管理、锁文件以及选择 npm/yarn/pnpm 的实际操作。）

### `left-pad`打破互联网的那一天

一段时间里，“小型模块”文化被颂扬为代码重用的巅峰。然后，在 2016 年 3 月 22 日，世界看到了它的负面影响。

这个故事现在在开发者社区中已经成为传奇。一位名叫 Azer Koçulu 的开发者已经在 npm 上发布了超过 250 个包。其中之一是一个名为`left-pad`的微小、11 行的函数，它确实做了它听起来像的事情：在字符串的左侧填充字符。这是一个简单的实用工具，但它被成千上万的其它项目使用，包括像 Babel（JavaScript 工具链的核心部分）这样非常流行的项目。

Azer 与另一家公司 Kik 就不同的包发生了命名争议。作为抗议，他从 npm 下架了所有包，包括`left-pad`。

这种影响是立即且灾难性的。

全球范围内的 CI/CD 管道开始失败。试图为他们的项目安装依赖的开发者看到他们的构建因错误而中断：`404 Not Found: left-pad`。因为 Babel 依赖于 `left-pad`，而数千个项目依赖于 Babel，JavaScript 生态系统的大部分突然完全崩溃。

我清楚地记得那天。我们团队的 Slack 频道亮了起来。“CI 全部变红了。”“是 AWS 吗？S3 又出故障了？”有人发布了错误。“...‘left-pad’未找到？什么鬼是 left-pad？”

丑陋的事实是，我们的价值数百万美元的软件平台依赖于一位开发者编写的 11 行代码，他可以随心所欲地移除它。这对整个行业来说是一个巨大的警钟，揭示了开源供应链的脆弱性。

NPM 最终采取了前所未有的步骤，将软件包“重新发布”，以解决眼前的危机。但损害已经造成，教训已经吸取：

1.  **依赖是一个负担。** 每次执行 `npm install` 都是一种信任行为。你正在运行陌生人在你机器上编写的代码。

1.  **传递依赖很重要。** 你可能没有直接依赖于 `left-pad`，但你的某个依赖项却依赖了它。你对整个依赖树负有责任。

1.  **工具和治理至关重要。** 这起事件促使开发了更好的工具，如锁文件（`package-lock.json`、`yarn.lock`）以确保可重复构建，以及安全审计工具（`npm audit`）以扫描漏洞。

`left-pad` 事件完美地概括了 Node 生态系统双重性质：其惊人的速度和协作精神，以及其潜在的混乱和供应链风险。（我们将在**第十九章**中介绍现代安全实践、依赖项审计和供应链卫生。）

### Node 遍布各地——它不仅仅是为服务器而存在

虽然 Node 是作为可扩展 Web 服务器的解决方案而诞生的，但其成功已经远远超出了最初的使用场景。它为在本地机器上执行 JavaScript 提供了一个强大的环境，这使得它成为大量工具和平台的基础。

当你今天想到“Node.js”时，你不应该只想到“后端 API”。你应该将其视为一个通用的 JavaScript 平台。

+   **构建工具和前端开发：** 这可以说是增长最大的领域。像 [Webpack](https://webpack.js.org/)、[esbuild](https://esbuild.github.io/)、[Vite](https://vitejs.dev/) 和 TypeScript 编译器等工具都是 Node.js 应用程序。如果你曾经参与过现代前端项目（React、Vue、Angular 等），你肯定广泛使用了 Node.js，即使你从未编写过任何后端代码。整个开发工作流程——打包、转译、代码检查、运行开发服务器——都是由 Node 运行时驱动的。

+   **桌面应用程序：** 类似于 [Electron](https://www.electronjs.org/)（为 VS Code、Slack、Discord 和 Figma 提供动力）和 [Tauri](https://tauri.app/) 的框架允许你使用 Web 技术构建跨平台桌面应用程序（HTML、CSS、JavaScript）。它们通过将浏览器渲染引擎（Chromium）与 Node.js 运行时捆绑在一起来实现这一点，使你的 JavaScript 代码能够访问宿主操作系统的全部功能。

+   **命令行界面（CLI）工具：** Node 是构建快速且强大的 CLI 工具的绝佳选择。npm 注册表中有大量此类工具，从项目脚手架如 `create-react-app` 到云基础设施工具如 AWS CDK。其跨平台特性和丰富的生态系统使得构建复杂的命令行应用程序变得容易。

+   **无服务器和边缘计算：** Node 快速启动时间和低内存占用使其非常适合 AWS Lambda、Google Cloud Functions 和 Vercel 等无服务器平台。你可以部署小型、单一用途的函数，这些函数启动、处理事件然后关闭，只需为使用的部分付费。这种部署模型是 Node 事件驱动哲学的自然扩展。

    ⚠️警告

    Node 的快速启动通常与无服务器工作负载很好地匹配，但要注意具有大型依赖树或重初始化的函数的冷启动。边缘运行时（V8 独立）和无服务器函数容器是不同的：边缘函数通常限制 API、内存和 CPU 时间。

重点是，即使你的主要工作不是编写 Node.js 后端服务，你几乎肯定每天都在与 Node.js 运行时及其生态系统互动。理解其架构不再是后端工程师的利基技能；它已成为任何现代 Web 或软件开发者的基础技能。

## 实用清单与收获

这是一章内容密集的章节。如果你没有其他收获，请将这些想法铭记在心。这是你的核心思维模型。

+   **Node 是一个运行时，而不是一种语言。** 它使用 V8 引擎执行 JavaScript，并通过 `libuv` 库赋予它服务器端功能（如文件和网络访问）。

+   **任务：不要阻塞事件循环。** Node 中的每个设计选择都推动你朝着异步、非阻塞的模式发展。阻塞的循环意味着你的服务器将陷入停滞，无法处理新的请求。

+   **你的 JavaScript 是单线程的；运行时不是。** 你在单个主线程上编写应用程序代码，这简化了并发。但 `libuv` 在后台使用一个小型线程池来执行某些重操作，以保护主线程不被阻塞。

+   **以事件为导向，而不是以序列为导向。** Node 应用程序不是线性脚本，而是一组等待由事件循环触发的处理程序（回调、Promise）。你的任务是正确设置这些监听器。

+   **生态系统（`npm`）既是你的最大资产，也是潜在的风险。**它给你带来惊人的速度，但你必须注意你的依赖树。虔诚地使用锁文件和安全审计工具。

+   **Node 不仅仅是一个后端。**它是推动现代前端开发、桌面应用程序、命令行界面和无服务器计算的动力引擎。理解它是成为现代开发者的基础。

## 结束语

我们已经覆盖了很多内容——从网络服务器的历史问题到运行时架构及其生态系统文化。

你可以从这里获得的最重要的事情是一个强大的心智模型。不要把 Node 仅仅看作是“服务器上的 JavaScript”。

想象它是一个**异步事件驱动的 I/O 平台，恰好使用 JavaScript 作为其脚本语言**。

这话听起来很多，但每个词都很重要。

+   **异步：**它不会等待缓慢的事情。

+   **事件驱动：**它在事件完成时做出反应。

+   **I/O 平台：**其特色在于以极高的效率在各个地方之间移动数据——从网络到磁盘再到数据库。

V8 让它变得快速。`libuv`让它异步。生态系统赋予它范围。这三个元素共同创造了一个从根本上改变了我们在网络上构建方式的平台。

现在我们有了 30,000 英尺的概览，是时候放大视角了。在下一章中，我们将深入探讨 Node.js 最基本的概念之一——v8 编译器（`Ignition`、`SparkPlug`和`Turbofan`）。
