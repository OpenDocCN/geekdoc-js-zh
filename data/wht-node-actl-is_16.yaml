- en: What Node.js Actually Is
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»€ä¹ˆæ˜¯ Node.js å®é™…ä¸Šæ˜¯ä»€ä¹ˆ
- en: åŸæ–‡ï¼š[https://www.thenodebook.com/node-arch/what-is-nodejs#the-ecosystem](https://www.thenodebook.com/node-arch/what-is-nodejs#the-ecosystem)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://www.thenodebook.com/node-arch/what-is-nodejs#the-ecosystem](https://www.thenodebook.com/node-arch/what-is-nodejs#the-ecosystem)
- en: What Node.js Actually Is
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»€ä¹ˆæ˜¯ Node.js å®é™…ä¸Šæ˜¯ä»€ä¹ˆ
- en: So, you're here to *really* understand Node.js. Good.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œä½ æ˜¯æ¥ *çœŸæ­£* ç†è§£ Node.js çš„ã€‚å¾ˆå¥½ã€‚
- en: Maybe you've used it for a while. Youâ€™ve built an API with Express, youâ€™ve wrestled
    with `npm install`, and youâ€™ve seen your fair share of `callback is not a function`.
    You know itâ€™s "asynchronous" and "non-blocking," and you can write an `async`
    function in your sleep.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ä¹Ÿè®¸ä½ å·²ç»ä½¿ç”¨äº†ä¸€æ®µæ—¶é—´ã€‚ä½ ç”¨ Express æ„å»ºäº† APIï¼Œä½ ä¸ `npm install` è¿‡æ‹›ï¼Œä½ ä¹Ÿçœ‹åˆ°äº†ä½ åº”å¾—çš„ `callback is not
    a function`ã€‚ä½ çŸ¥é“å®ƒæ˜¯â€œå¼‚æ­¥â€å’Œâ€œéé˜»å¡â€çš„ï¼Œä½ å¯ä»¥åœ¨ç¡æ¢¦ä¸­ç¼–å†™ `async` å‡½æ•°ã€‚
- en: But thereâ€™s this nagging feeling, isnâ€™t there? A sense that under the hood,
    thereâ€™s a whole world of machinery youâ€™ve never quite seen. What *is* the event
    loop, really? When people say Node is "single-threaded," what do they actually
    mean, and why does your server handle thousands of users at once? How does a JavaScript
    file, something that used to just run in a browser, suddenly have the power to
    write to files and open network sockets?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æœ‰ä¸€ç§ä»¤äººçƒ¦æ¼çš„æ„Ÿè§‰ï¼Œä¸æ˜¯å—ï¼Ÿä¸€ç§æ„Ÿè§‰ï¼Œåœ¨å¼•æ“ç›–ä¸‹ï¼Œæœ‰ä¸€ä¸ªä½ ä»æœªçœŸæ­£è§è¿‡çš„æ•´ä¸ªæœºæ¢°ä¸–ç•Œã€‚çœŸæ­£çš„äº‹ä»¶å¾ªç¯æ˜¯ä»€ä¹ˆï¼Ÿå½“äººä»¬è¯´ Node æ˜¯â€œå•çº¿ç¨‹â€æ—¶ï¼Œä»–ä»¬å®é™…ä¸Šæ˜¯ä»€ä¹ˆæ„æ€ï¼Œä¸ºä»€ä¹ˆä½ çš„æœåŠ¡å™¨èƒ½åŒæ—¶å¤„ç†æ•°åƒä¸ªç”¨æˆ·ï¼Ÿä¸€ä¸ª
    JavaScript æ–‡ä»¶ï¼Œä»¥å‰åªæ˜¯è¿è¡Œåœ¨æµè§ˆå™¨ä¸­ï¼Œçªç„¶æœ‰äº†å†™å…¥æ–‡ä»¶å’Œæ‰“å¼€ç½‘ç»œå¥—æ¥å­—çš„èƒ½åŠ›ï¼Ÿ
- en: This chapter is our entry point into that engine room. Weâ€™re not just going
    to define Node.js. Weâ€™re going to dissect it. Weâ€™ll look at the historical accident
    that led to its creation, inspect the core components that make it tick, and understand
    the cultural phenomenon - the ecosystem - that grew around it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç« æ˜¯æˆ‘ä»¬è¿›å…¥é‚£ä¸ªå¼•æ“å®¤çš„å¤§é—¨ã€‚æˆ‘ä»¬ä¸ä»…å°†å®šä¹‰ Node.jsã€‚æˆ‘ä»¬å°†å‰–æå®ƒã€‚æˆ‘ä»¬å°†æŸ¥çœ‹å¯¼è‡´å…¶åˆ›å»ºçš„å†å²å¶ç„¶äº‹ä»¶ï¼Œæ£€æŸ¥ä½¿å…¶è¿è½¬çš„æ ¸å¿ƒç»„ä»¶ï¼Œå¹¶ç†è§£å›´ç»•å…¶äº§ç”Ÿçš„æ–‡åŒ–ç°è±¡â€”â€”ç”Ÿæ€ç³»ç»Ÿã€‚
- en: 'My goal isn''t just to give you facts. It''s to give you a *mental model*.
    By the end of this, when you write `fs.readFile()`, I want you to see the journey
    that request takes: from your JavaScript, through the C++ bindings, into the libuv
    library, handed off to the operating system, and the response bubbling all the
    way back up through the event loop.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çš„ç›®çš„æ˜¯ä¸ä»…ä»…ç»™ä½ äº‹å®ã€‚æˆ‘è¦ç»™ä½ ä¸€ä¸ª *å¿ƒæ™ºæ¨¡å‹*ã€‚åˆ°è¿™ä¸€æ­¥ç»“æŸæ—¶ï¼Œå½“ä½ ç¼–å†™ `fs.readFile()` æ—¶ï¼Œæˆ‘å¸Œæœ›ä½ èƒ½çœ‹åˆ°è¿™ä¸ªè¯·æ±‚çš„æ—…ç¨‹ï¼šä»ä½ çš„
    JavaScriptï¼Œé€šè¿‡ C++ ç»‘å®šï¼Œè¿›å…¥ libuv åº“ï¼Œä¼ é€’ç»™æ“ä½œç³»ç»Ÿï¼Œç„¶åå“åº”é€šè¿‡äº‹ä»¶å¾ªç¯ä¸€è·¯å†’æ³¡å›æ¥ã€‚
- en: Before we dive in, I'm going to assume a few things about you. Don't worry,
    this isn't a test. It just helps us stay focused on the deep stuff.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬æ·±å…¥ä¹‹å‰ï¼Œæˆ‘å°†å‡è®¾ä¸€äº›å…³äºä½ çš„äº‹æƒ…ã€‚åˆ«æ‹…å¿ƒï¼Œè¿™ä¸æ˜¯è€ƒè¯•ã€‚è¿™åªæ˜¯ä¸ºäº†å¸®åŠ©æˆ‘ä»¬ä¸“æ³¨äºæ·±å…¥çš„å†…å®¹ã€‚
- en: '| Prerequisite (â‰¤5) | Why it matters / what to skim |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| å‰ç½®æ¡ä»¶ï¼ˆâ‰¤5ï¼‰ | ä¸ºä»€ä¹ˆå®ƒå¾ˆé‡è¦/éœ€è¦ç•¥è¯» |'
- en: '| --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| JavaScript `async/await` and Promises | Our examples will use modern async
    syntax; a quick refresher is all you need if you''re rusty. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| JavaScript `async/await` å’Œ Promises | æˆ‘ä»¬çš„ç¤ºä¾‹å°†ä½¿ç”¨ç°ä»£å¼‚æ­¥è¯­æ³•ï¼›å¦‚æœä½ ç”Ÿç–äº†ï¼Œåªéœ€è¦å¿«é€Ÿå¤ä¹ ä¸€ä¸‹å³å¯ã€‚
    |'
- en: '| Basic Terminal & Shell Commands | We''ll be running commands like `node`,
    `npm`, and simple performance tools (`curl`, `htop`). |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| åŸºæœ¬çš„ç»ˆç«¯å’Œ Shell å‘½ä»¤ | æˆ‘ä»¬å°†è¿è¡Œ `node`ã€`npm` å’Œç®€å•çš„æ€§èƒ½å·¥å…·ï¼ˆ`curl`ã€`htop`ï¼‰ç­‰å‘½ä»¤ã€‚ |'
- en: '| Familiarity with a web framework (e.g., Express) | Knowing the basics of
    building an API helps contextualize why Node''s performance model matters. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| ç†Ÿæ‚‰ Web æ¡†æ¶ï¼ˆä¾‹å¦‚ï¼ŒExpressï¼‰ | äº†è§£æ„å»º API çš„åŸºç¡€çŸ¥è¯†æœ‰åŠ©äºç†è§£ Node çš„æ€§èƒ½æ¨¡å‹ä¸ºä½•é‡è¦ã€‚ |'
- en: '| The concept of I/O (Input/Output) | We''ll talk a lot about file I/O and
    network I/O. Just know it means "talking to the outside world." |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| I/Oï¼ˆè¾“å…¥/è¾“å‡ºï¼‰çš„æ¦‚å¿µ | æˆ‘ä»¬å°†å¤§é‡è®¨è®ºæ–‡ä»¶ I/O å’Œç½‘ç»œ I/Oã€‚åªéœ€çŸ¥é“å®ƒæ„å‘³ç€â€œä¸å¤–ç•Œäº¤æµâ€ã€‚ |'
- en: If youâ€™re solid on those, youâ€™re ready. Let's get our hands dirty.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ åœ¨è¿™æ–¹é¢å¾ˆæ‰å®ï¼Œä½ å°±å‡†å¤‡å¥½äº†ã€‚è®©æˆ‘ä»¬åŠ¨æ‰‹å§ã€‚
- en: TL;DR
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TL;DR
- en: 'For those who need the key takeaways right now and will read the details later:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºé‚£äº›ç°åœ¨éœ€è¦å…³é”®è¦ç‚¹ï¼Œç¨åå†é˜…è¯»è¯¦ç»†å†…å®¹çš„äººï¼š
- en: 'Node.js is not a language, framework or library; it''s a **runtime**. It''s
    a program that executes your JavaScript code outside of a web browser. It''s composed
    of three main parts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js ä¸æ˜¯ä¸€ä¸ªè¯­è¨€ã€æ¡†æ¶æˆ–åº“ï¼›å®ƒæ˜¯ä¸€ä¸ª **è¿è¡Œæ—¶**ã€‚å®ƒæ˜¯ä¸€ä¸ªåœ¨æµè§ˆå™¨ä¹‹å¤–æ‰§è¡Œä½ çš„ JavaScript ä»£ç çš„ç¨‹åºã€‚å®ƒç”±ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ç»„æˆï¼š
- en: '**The V8 JavaScript Engine.** The same high-performance engine from Google
    Chrome. It compiles your JS into native machine code.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**V8 JavaScript å¼•æ“**ã€‚æ¥è‡ª Google Chrome çš„ç›¸åŒé«˜æ€§èƒ½å¼•æ“ã€‚å®ƒå°†ä½ çš„ JS ç¼–è¯‘æˆåŸç”Ÿæœºå™¨ä»£ç ã€‚'
- en: '**The `libuv` Library.** A C library that provides the asynchronous, non-blocking
    I/O model. This is where the magic of the event loop and the worker thread pool
    happens. This is Node''s secret weapon.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`libuv` åº“**ã€‚ä¸€ä¸ªæä¾›å¼‚æ­¥ã€éé˜»å¡ I/O æ¨¡å‹çš„ C åº“ã€‚è¿™é‡Œå‘ç”Ÿäº†äº‹ä»¶å¾ªç¯å’Œçº¿ç¨‹æ± çš„é­”æ³•ã€‚è¿™æ˜¯ Node çš„ç§˜å¯†æ­¦å™¨ã€‚'
- en: '**C++ Bindings & Node.js Core APIs.** The "glue" that connects your JavaScript
    (`require(''fs'')`) to the underlying C++ and `libuv` functionality, allowing
    you to access the filesystem, network, etc.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**C++ ç»‘å®šä¸ Node.js æ ¸å¿ƒAPI**ã€‚è¿™æ˜¯è¿æ¥ä½ çš„ JavaScript (`require(''fs'')`) åˆ°åº•å±‚ C++ å’Œ `libuv`
    åŠŸèƒ½çš„â€œèƒ¶æ°´â€ï¼Œå…è®¸ä½ è®¿é—®æ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œç­‰ã€‚'
- en: '**Its core philosophy is non-blocking I/O.** Node was created to solve the
    problem of web servers getting stuck waiting for slow operations (like database
    queries or file reads). Instead of waiting, Node''s event loop allows it to start
    an I/O operation, register a callback, and immediately move on to serving other
    requests. This makes it incredibly efficient at handling many concurrent connections
    with minimal memory.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**å…¶æ ¸å¿ƒå“²å­¦æ˜¯éé˜»å¡ I/O**ã€‚Node çš„åˆ›å»ºæ˜¯ä¸ºäº†è§£å†³ Web æœåŠ¡å™¨å› æ…¢é€Ÿæ“ä½œï¼ˆå¦‚æ•°æ®åº“æŸ¥è¯¢æˆ–æ–‡ä»¶è¯»å–ï¼‰è€Œå¡ä½çš„é—®é¢˜ã€‚è€Œä¸æ˜¯ç­‰å¾…ï¼ŒNode
    çš„äº‹ä»¶å¾ªç¯å…è®¸å®ƒå¯åŠ¨ä¸€ä¸ª I/O æ“ä½œï¼Œæ³¨å†Œä¸€ä¸ªå›è°ƒï¼Œå¹¶ç«‹å³è½¬åˆ°æœåŠ¡å…¶ä»–è¯·æ±‚ã€‚è¿™ä½¿å¾—å®ƒåœ¨å¤„ç†å¤§é‡å¹¶å‘è¿æ¥æ—¶éå¸¸é«˜æ•ˆï¼ŒåŒæ—¶å†…å­˜ä½¿ç”¨æœ€å°ã€‚'
- en: '**It''s "single-threaded" in a specific way.** Your JavaScript code runs on
    a single main thread. You don''t have to worry about locks or race conditions
    in your application logic. However, for heavy lifting (some file I/O, crypto,
    etc.), `libuv` maintains a small pool of background threads. So, while your code
    sees one thread, Node uses a few threads under the hood to avoid blocking.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**å®ƒåœ¨ç‰¹å®šæ„ä¹‰ä¸Šæ˜¯â€œå•çº¿ç¨‹â€çš„**ã€‚ä½ çš„ JavaScript ä»£ç åœ¨ä¸€ä¸ªä¸»çº¿ç¨‹ä¸Šè¿è¡Œã€‚ä½ ä¸å¿…æ‹…å¿ƒåº”ç”¨ç¨‹åºé€»è¾‘ä¸­çš„é”æˆ–ç«äº‰æ¡ä»¶ã€‚ç„¶è€Œï¼Œå¯¹äºé‡è´Ÿè½½ï¼ˆä¸€äº›æ–‡ä»¶
    I/Oã€åŠ å¯†ç­‰ï¼‰ï¼Œ`libuv` ç»´æŠ¤ä¸€ä¸ªå°å‹çš„åå°çº¿ç¨‹æ± ã€‚æ‰€ä»¥ï¼Œå°½ç®¡ä½ çš„ä»£ç çœ‹åˆ°ä¸€ä¸ªçº¿ç¨‹ï¼ŒNode åœ¨åº•å±‚ä½¿ç”¨å‡ ä¸ªçº¿ç¨‹æ¥é¿å…é˜»å¡ã€‚'
- en: '**The ecosystem is as important as the runtime.** Node''s core is intentionally
    minimal. Its power comes from **npm** (Node Package Manager), the largest software
    registry in the world. This culture of small, reusable modules allows for rapid
    development but also introduces challenges like dependency management and supply
    chain security (as we''ll see with the `left-pad` incident).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç”Ÿæ€ç³»ç»Ÿä¸è¿è¡Œæ—¶ä¸€æ ·é‡è¦**ã€‚Node çš„æ ¸å¿ƒæ•…æ„ä¿æŒæœ€å°ã€‚å®ƒçš„åŠ›é‡æ¥è‡ªäº **npm**ï¼ˆNode åŒ…ç®¡ç†å™¨ï¼‰ï¼Œè¿™æ˜¯ä¸–ç•Œä¸Šæœ€å¤§çš„è½¯ä»¶æ³¨å†Œåº“ã€‚è¿™ç§å°å‹ã€å¯é‡ç”¨æ¨¡å—çš„æ–‡åŒ–å…è®¸å¿«é€Ÿå¼€å‘ï¼Œä½†ä¹Ÿå¼•å…¥äº†ä¾èµ–ç®¡ç†ã€ä¾›åº”é“¾å®‰å…¨ç­‰æŒ‘æˆ˜ï¼ˆæ­£å¦‚æˆ‘ä»¬å°†åœ¨
    `left-pad` äº‹ä»¶ä¸­çœ‹åˆ°çš„é‚£æ ·ï¼‰ã€‚'
- en: '**Your mental model should be that of an "evented" system.** Think of Node
    as a hyper-efficient event coordinator. It takes requests, delegates slow tasks
    to the OS or its thread pool, and keeps a list of "things to do when those tasks
    are done." It spends almost no time waiting and almost all its time working or
    delegating.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä½ çš„å¿ƒæ™ºæ¨¡å‹åº”è¯¥æ˜¯â€œäº‹ä»¶é©±åŠ¨â€çš„**ã€‚å°† Node è§†ä¸ºä¸€ä¸ªè¶…çº§é«˜æ•ˆçš„åè°ƒè€…ã€‚å®ƒæ¥æ”¶è¯·æ±‚ï¼Œå°†æ…¢é€Ÿä»»åŠ¡å§”æ‰˜ç»™æ“ä½œç³»ç»Ÿæˆ–å…¶çº¿ç¨‹æ± ï¼Œå¹¶ä¿ç•™ä¸€ä¸ªâ€œä»»åŠ¡å®Œæˆæ—¶è¦åšçš„äº‹æƒ…â€çš„åˆ—è¡¨ã€‚å®ƒå‡ ä¹ä¸èŠ±è´¹æ—¶é—´ç­‰å¾…ï¼Œå‡ ä¹æ‰€æœ‰çš„æ—¶é—´éƒ½åœ¨å·¥ä½œæˆ–å§”æ‰˜ã€‚'
- en: âš ï¸Warning
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸è­¦å‘Š
- en: Your JavaScript application logic runs on a single main thread which avoids
    many traditional thread-locking problems, but you still must think about concurrent
    access to shared state. Asynchronous callbacks, multiple Node processes, worker_threads,
    native addons, and any use of shared memory (e.g., SharedArrayBuffer) introduce
    concurrency concerns and potential race conditions - design for immutable state,
    atomic updates, or use appropriate synchronization when needed. Don't worry, we're
    going to cover each one of those in greater details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„ JavaScript åº”ç”¨ç¨‹åºé€»è¾‘åœ¨ä¸€ä¸ªä¸»çº¿ç¨‹ä¸Šè¿è¡Œï¼Œè¿™é¿å…äº†ä¼ ç»Ÿçº¿ç¨‹é”å®šé—®é¢˜ï¼Œä½†ä½ ä»ç„¶å¿…é¡»è€ƒè™‘å¯¹å…±äº«çŠ¶æ€çš„å¹¶å‘è®¿é—®ã€‚å¼‚æ­¥å›è°ƒã€å¤šä¸ª Node è¿›ç¨‹ã€worker_threadsã€æœ¬åœ°æ’ä»¶ä»¥åŠä»»ä½•å…±äº«å†…å­˜çš„ä½¿ç”¨ï¼ˆä¾‹å¦‚ï¼ŒSharedArrayBufferï¼‰éƒ½å¼•å…¥äº†å¹¶å‘é—®é¢˜å’Œæ½œåœ¨çš„ç«äº‰æ¡ä»¶
    - è®¾è®¡ä¸ºä¸å¯å˜çŠ¶æ€ã€åŸå­æ›´æ–°ï¼Œæˆ–åœ¨éœ€è¦æ—¶ä½¿ç”¨é€‚å½“çš„åŒæ­¥ã€‚åˆ«æ‹…å¿ƒï¼Œæˆ‘ä»¬å°†æ›´è¯¦ç»†åœ°ä»‹ç»æ¯ä¸€ä¸ªã€‚
- en: '* * *'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**The Runtime - A Guided Tour Under the Hood**'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**è¿è¡Œæ—¶ - å†…éƒ¨å¯¼è§ˆ**'
- en: Why Blocking I/O Was a Party Everyone Hated
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆé˜»å¡ I/O æ˜¯ä¸€ä¸ªæ¯ä¸ªäººéƒ½è®¨åŒçš„æ´¾å¯¹
- en: 'To understand *why* Node.js is the way it is, you have to go back to 2009\.
    The web server landscape was dominated by giants like Apache. If you were building
    a web application, the standard model was something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: è¦ç†è§£ Node.js ä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªæ ·å­ï¼Œä½ å¿…é¡»è¿½æº¯åˆ° 2009 å¹´ã€‚å½“æ—¶ï¼ŒWeb æœåŠ¡å™¨é¢†åŸŸç”± Apache ç­‰å·¨å¤´ä¸»å¯¼ã€‚å¦‚æœä½ åœ¨æ„å»º Web åº”ç”¨ç¨‹åºï¼Œæ ‡å‡†æ¨¡å‹å¯èƒ½å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: A user's request comes in.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç”¨æˆ·è¯·æ±‚åˆ°æ¥ã€‚
- en: The server (Apache) dedicates a thread (or a whole process) to handle that request.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æœåŠ¡å™¨ï¼ˆApacheï¼‰ä¸ºå¤„ç†è¯¥è¯·æ±‚åˆ†é…ä¸€ä¸ªçº¿ç¨‹ï¼ˆæˆ–æ•´ä¸ªè¿›ç¨‹ï¼‰ã€‚
- en: Your application code runs on that thread.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½ çš„åº”ç”¨ç¨‹åºä»£ç è¿è¡Œåœ¨é‚£ä¸ªçº¿ç¨‹ä¸Šã€‚
- en: If your code needs to do something slow - like query a database, read a file
    from disk, or call another API - that thread justâ€¦ stops. It sits there, blocked,
    holding onto memory and CPU resources, waiting for the slow thing to finish.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœä½ çš„ä»£ç éœ€è¦æ‰§è¡Œä¸€äº›æ…¢é€Ÿæ“ä½œâ€”â€”æ¯”å¦‚æŸ¥è¯¢æ•°æ®åº“ã€ä»ç£ç›˜è¯»å–æ–‡ä»¶æˆ–è°ƒç”¨å¦ä¸€ä¸ªAPIâ€”â€”é‚£ä¹ˆè¿™ä¸ªçº¿ç¨‹å°±ä¼šâ€¦â€¦åœæ­¢ã€‚å®ƒååœ¨é‚£é‡Œï¼Œé˜»å¡ç€ï¼Œå ç”¨ç€å†…å­˜å’ŒCPUèµ„æºï¼Œç­‰å¾…æ…¢é€Ÿæ“ä½œå®Œæˆã€‚
- en: Once the slow thing is done, the thread wakes up, finishes generating the response,
    sends it back, and is finally free to handle another request.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æ…¢é€Ÿæ“ä½œå®Œæˆï¼Œçº¿ç¨‹å°±ä¼šé†’æ¥ï¼Œå®Œæˆå“åº”çš„ç”Ÿæˆï¼Œå°†å…¶å‘é€å›å»ï¼Œæœ€åå¯ä»¥è‡ªç”±åœ°å¤„ç†å¦ä¸€ä¸ªè¯·æ±‚ã€‚
- en: This model is simple to reason about. Each request is a neat, linear sequence
    of steps. But it has a fatal flaw.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ¨¡å‹ç®€å•æ˜“æ‡‚ã€‚æ¯ä¸ªè¯·æ±‚éƒ½æ˜¯ä¸€ä¸ªæ•´æ´çš„ã€çº¿æ€§çš„æ­¥éª¤åºåˆ—ã€‚ä½†å®ƒæœ‰ä¸€ä¸ªè‡´å‘½çš„ç¼ºé™·ã€‚
- en: â„¹ï¸Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: It's important to note that this describes the classic model; modern multi-threaded
    servers and language runtimes have evolved significantly with hybrid event-driven/threaded
    models and more efficient threading implementations to mitigate these original
    scaling issues.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œè¿™æè¿°çš„æ˜¯ç»å…¸æ¨¡å‹ï¼›ç°ä»£çš„å¤šçº¿ç¨‹æœåŠ¡å™¨å’Œè¯­è¨€è¿è¡Œæ—¶å·²ç»éšç€æ··åˆäº‹ä»¶é©±åŠ¨/çº¿ç¨‹æ¨¡å‹å’Œæ›´æœ‰æ•ˆçš„çº¿ç¨‹å®ç°è€Œæ˜¾è‘—å‘å±•ï¼Œä»¥å‡è½»è¿™äº›åŸå§‹çš„æ‰©å±•é—®é¢˜ã€‚
- en: Imagine a popular coffee shop. Their model is one barista per customer, from
    start to finish. You walk in, Barista A takes your order, walks over to the machine,
    grinds the beans, pulls the espresso shot, steams the milk, and finally gives
    you your latte. During that entire five-minute process, Barista A is *your* barista.
    They can't help anyone else. If ten people walk in at once, you need ten baristas
    and ten espresso machines. If a thousand people walk in? You have a big, expensive
    problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä¸€å®¶çƒ­é—¨çš„å’–å•¡åº—ã€‚ä»–ä»¬çš„æ¨¡å¼æ˜¯æ¯ä¸ªé¡¾å®¢ä¸€ä¸ªå’–å•¡å¸ˆï¼Œä»å¼€å§‹åˆ°ç»“æŸã€‚ä½ èµ°è¿›å»ï¼Œå’–å•¡å¸ˆAæ¥æ”¶ä½ çš„è®¢å•ï¼Œèµ°åˆ°æœºå™¨æ—ï¼Œç£¨è±†ï¼ŒæŠ½å‡ºæµ“ç¼©å’–å•¡ï¼ŒåŠ çƒ­ç‰›å¥¶ï¼Œæœ€åç»™ä½ æ‹¿é“ã€‚åœ¨æ•´ä¸ªäº”åˆ†é’Ÿçš„è¿‡ç¨‹ä¸­ï¼Œå’–å•¡å¸ˆAæ˜¯ä½ çš„å’–å•¡å¸ˆã€‚ä»–ä»¬ä¸èƒ½å¸®åŠ©å…¶ä»–äººã€‚å¦‚æœåŒæ—¶è¿›æ¥åä¸ªäººï¼Œä½ éœ€è¦åä¸ªå’–å•¡å¸ˆå’Œåä¸ªæµ“ç¼©å’–å•¡æœºã€‚å¦‚æœè¿›æ¥ä¸€åƒä¸ªäººï¼Ÿä½ å°†é¢ä¸´ä¸€ä¸ªåºå¤§ä¸”æ˜‚è´µçš„éš¾é¢˜ã€‚
- en: This is the "thread-per-request" model of old web servers. Threads are expensive.
    They consume memory (for their stack) and CPU time (for context switching). Handling
    thousands of concurrent users meant running thousands of threads, which was incredibly
    inefficient. This was known as the [C10k problem](http://www.kegel.com/c10k.html)
    - the challenge of handling ten thousand concurrent connections on a single server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æ—§å¼WebæœåŠ¡å™¨çš„â€œæ¯ä¸ªè¯·æ±‚ä¸€ä¸ªçº¿ç¨‹â€æ¨¡å‹ã€‚çº¿ç¨‹å¾ˆæ˜‚è´µã€‚å®ƒä»¬æ¶ˆè€—å†…å­˜ï¼ˆç”¨äºæ ˆï¼‰å’ŒCPUæ—¶é—´ï¼ˆç”¨äºä¸Šä¸‹æ–‡åˆ‡æ¢ï¼‰ã€‚å¤„ç†æ•°åƒä¸ªå¹¶å‘ç”¨æˆ·æ„å‘³ç€è¿è¡Œæ•°åƒä¸ªçº¿ç¨‹ï¼Œè¿™éå¸¸ä½æ•ˆã€‚è¿™è¢«ç§°ä¸º[C10ké—®é¢˜](http://www.kegel.com/c10k.html)â€”â€”åœ¨å•ä¸ªæœåŠ¡å™¨ä¸Šå¤„ç†åä¸‡ä¸ªå¹¶å‘è¿æ¥çš„æŒ‘æˆ˜ã€‚
- en: '**The "Aha!" Moment**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**â€œå•Šå“ˆï¼â€æ—¶åˆ»**'
- en: A developer named Ryan Dahl was looking at this problem and thought it was fundamentally
    broken. He saw that the slowest parts of any web application were always the I/O
    operations - waiting for the network, waiting for the disk. The CPU itself was
    often just sitting idle while the thread was blocked.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä½åå«Ryan Dahlçš„å¼€å‘è€…çœ‹åˆ°äº†è¿™ä¸ªé—®é¢˜ï¼Œå¹¶è®¤ä¸ºå®ƒä»æ ¹æœ¬ä¸Šæ˜¯æœ‰ç¼ºé™·çš„ã€‚ä»–çœ‹åˆ°ä»»ä½•Webåº”ç”¨ä¸­æœ€æ…¢çš„éƒ¨åˆ†æ€»æ˜¯I/Oæ“ä½œâ€”â€”ç­‰å¾…ç½‘ç»œï¼Œç­‰å¾…ç£ç›˜ã€‚CPUæœ¬èº«åœ¨çº¿ç¨‹é˜»å¡æ—¶å¸¸å¸¸å¤„äºç©ºé—²çŠ¶æ€ã€‚
- en: 'He looked at how high-performance servers like Nginx solved this: with an **event-driven,
    non-blocking architecture**. Instead of dedicating a worker to each customer,
    what if you had one super-fast barista (the event loop) who just took orders?'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–ç ”ç©¶äº†é«˜æ€§èƒ½æœåŠ¡å™¨å¦‚Nginxæ˜¯å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼šé‡‡ç”¨**äº‹ä»¶é©±åŠ¨ã€éé˜»å¡æ¶æ„**ã€‚è€Œä¸æ˜¯ä¸ºæ¯ä¸ªé¡¾å®¢åˆ†é…ä¸€ä¸ªå·¥ä½œè€…ï¼Œå¦‚æœåªæœ‰ä¸€ä¸ªè¶…çº§å¿«çš„å’–å•¡å¸ˆï¼ˆäº‹ä»¶å¾ªç¯ï¼‰æ¥æ¥æ”¶è®¢å•ä¼šæ€æ ·ï¼Ÿ
- en: Customer 1 wants a latte. The barista writes the order on a ticket, hands it
    to a machine (the OS/kernel), and immediately turns to the next customer.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é¡¾å®¢1æƒ³è¦ä¸€æ¯æ‹¿é“ã€‚å’–å•¡å¸ˆåœ¨ç¥¨ä¸Šå†™ä¸‹è®¢å•ï¼Œé€’ç»™æœºå™¨ï¼ˆæ“ä½œç³»ç»Ÿ/å†…æ ¸ï¼‰ï¼Œç„¶åç«‹å³è½¬å‘ä¸‹ä¸€ä¸ªé¡¾å®¢ã€‚
- en: Customer 2 wants a drip coffee. The barista writes the order, hands it to another
    machine, and is instantly available again.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é¡¾å®¢2æƒ³è¦ä¸€æ¯æ»´æ»¤å’–å•¡ã€‚å’–å•¡å¸ˆå†™ä¸‹è®¢å•ï¼Œé€’ç»™å¦ä¸€å°æœºå™¨ï¼Œç„¶åç«‹å³åˆå¯ç”¨ã€‚
- en: The barista never waits. They just process events ("new order") and delegate
    the slow work. When a drink is ready, a bell rings (an event is emitted). The
    barista grabs the finished drink, hands it to the right customer, and moves on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å’–å•¡å¸ˆä»ä¸ç­‰å¾…ã€‚ä»–ä»¬åªæ˜¯å¤„ç†äº‹ä»¶ï¼ˆâ€œæ–°è®¢å•â€ï¼‰å¹¶å°†æ…¢é€Ÿå·¥ä½œå§”æ‰˜å‡ºå»ã€‚å½“é¥®å“å‡†å¤‡å¥½æ—¶ï¼Œé“ƒå£°å“èµ·ï¼ˆäº‹ä»¶è¢«è§¦å‘ï¼‰ã€‚å’–å•¡å¸ˆæ‹¿èµ·å®Œæˆçš„é¥®å“ï¼Œé€’ç»™æ­£ç¡®çš„é¡¾å®¢ï¼Œç„¶åç»§ç»­å·¥ä½œã€‚
- en: This is the core idea of Node.js.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯Node.jsçš„æ ¸å¿ƒæ€æƒ³ã€‚
- en: Dahl saw that JavaScript, a language born in the browser, was perfectly suited
    for this model. Why? Because browser-based JavaScript is already event-driven.
    You don't write code that says `wait for 5 seconds for the user to click this
    button`. You write `button.addEventListener('click', function() { ... })`. You
    register a callback for an event and let the environment (the browser) notify
    you when it happens.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Dahl çœ‹åˆ°JavaScriptï¼Œä¸€ä¸ªåœ¨æµè§ˆå™¨ä¸­è¯ç”Ÿçš„è¯­è¨€ï¼Œéå¸¸é€‚åˆè¿™ç§æ¨¡å¼ã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºåŸºäºæµè§ˆå™¨çš„ JavaScript å·²ç»æ˜¯äº‹ä»¶é©±åŠ¨çš„ã€‚ä½ ä¸ä¼šå†™ä»£ç è¯´â€œç­‰å¾…5ç§’é’Ÿï¼Œç›´åˆ°ç”¨æˆ·ç‚¹å‡»è¿™ä¸ªæŒ‰é’®â€ã€‚ä½ ä¼šå†™
    `button.addEventListener('click', function() { ... })`ã€‚ä½ ä¸ºäº‹ä»¶æ³¨å†Œä¸€ä¸ªå›è°ƒï¼Œå¹¶è®©ç¯å¢ƒï¼ˆæµè§ˆå™¨ï¼‰åœ¨äº‹ä»¶å‘ç”Ÿæ—¶é€šçŸ¥ä½ ã€‚
- en: So, he took the fastest JavaScript engine he could find - Google's open-source
    V8 engine from the Chrome browser - and combined it with a new C library he wrote
    (which would eventually be replaced by the more robust `libuv`) to handle this
    asynchronous I/O. He created a runtime environment that could execute JavaScript
    on a server, but with this powerful, event-driven, non-blocking I/O model at its
    core.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä»–é€‰æ‹©äº†ä»–èƒ½æ‰¾åˆ°çš„æœ€å¿«çš„ JavaScript å¼•æ“ - æ¥è‡ª Chrome æµè§ˆå™¨çš„ Google å¼€æº V8 å¼•æ“ - å¹¶ç»“åˆäº†ä»–ç¼–å†™çš„æ–° C
    åº“ï¼ˆæœ€ç»ˆè¢«æ›´å¥å£®çš„ `libuv` æ‰€å–ä»£ï¼‰æ¥å¤„ç†è¿™ä¸ªå¼‚æ­¥ I/Oã€‚ä»–åˆ›å»ºäº†ä¸€ä¸ªè¿è¡Œæ—¶ç¯å¢ƒï¼Œå¯ä»¥åœ¨æœåŠ¡å™¨ä¸Šæ‰§è¡Œ JavaScriptï¼Œä½†å®ƒçš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¼ºå¤§ã€äº‹ä»¶é©±åŠ¨ã€éé˜»å¡çš„
    I/O æ¨¡å‹ã€‚
- en: â„¹ï¸Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: Early Node prototypes relied on existing event libraries (libev/libeio) for
    the kernel integration; later the project transitioned to libuv - a cross-platform
    C library (primarily maintained by contributors such as Ben Noordhuis and others)
    that unified event loop, async filesystem, threadpool, and platform abstractions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æ—©æœŸçš„ Node åŸå‹ä¾èµ–äºç°æœ‰çš„äº‹ä»¶åº“ï¼ˆlibev/libeioï¼‰è¿›è¡Œå†…æ ¸é›†æˆï¼›åæ¥é¡¹ç›®è½¬å‘äº† libuv - ä¸€ä¸ªè·¨å¹³å°çš„ C åº“ï¼ˆä¸»è¦ç”± Ben
    Noordhuis å’Œå…¶ä»–è´¡çŒ®è€…ç»´æŠ¤ï¼‰ï¼Œå®ƒç»Ÿä¸€äº†äº‹ä»¶å¾ªç¯ã€å¼‚æ­¥æ–‡ä»¶ç³»ç»Ÿã€çº¿ç¨‹æ± å’Œå¹³å°æŠ½è±¡ã€‚
- en: He presented this new creation, "Node.js," at a conference in 2009\. The demo
    was simple but profound. He showed a server that could handle a huge number of
    concurrent connections with a tiny memory footprint, all because it never waited.
    It was a direct solution to the C10k problem, and it changed the way a generation
    of developers thought about building web services.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–åœ¨2009å¹´çš„ä¸€æ¬¡ä¼šè®®ä¸Šå±•ç¤ºäº†è¿™ä¸ªæ–°åˆ›ä½œå“ï¼Œâ€œNode.jsâ€ã€‚æ¼”ç¤ºç®€å•ä½†æ·±åˆ»ã€‚ä»–å±•ç¤ºäº†ä¸€ä¸ªæœåŠ¡å™¨ï¼Œå®ƒå¯ä»¥å¤„ç†å¤§é‡çš„å¹¶å‘è¿æ¥ï¼Œä½†å†…å­˜å ç”¨å¾ˆå°ï¼Œæ‰€æœ‰è¿™ä¸€åˆ‡éƒ½æ˜¯å› ä¸ºå®ƒä»ä¸ç­‰å¾…ã€‚è¿™æ˜¯å¯¹
    C10k é—®é¢˜çš„ç›´æ¥è§£å†³æ–¹æ¡ˆï¼Œå®ƒæ”¹å˜äº†ä¸€ä»£å¼€å‘è€…å¯¹æ„å»ºç½‘ç»œæœåŠ¡çš„æ€è€ƒæ–¹å¼ã€‚
- en: 'This history is crucial because it''s baked into Node''s DNA. Every design
    decision, every API, is built around this central premise: **never block the main
    thread**. Itâ€™s why the default file reading method, `fs.readFile`, takes a callback.
    Itâ€™s why you use Promises and `async/await`. You are always, always telling Node,
    "Hey, go do this slow thing, and just let me know when you''re done. I''ve got
    other work to do."'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå†å²éå¸¸é‡è¦ï¼Œå› ä¸ºå®ƒå·²ç»èå…¥äº† Node çš„ DNAã€‚æ¯ä¸€ä¸ªè®¾è®¡å†³ç­–ï¼Œæ¯ä¸€ä¸ª APIï¼Œéƒ½æ˜¯å›´ç»•è¿™ä¸ªæ ¸å¿ƒå‰ææ„å»ºçš„ï¼š**æ°¸è¿œä¸è¦é˜»å¡ä¸»çº¿ç¨‹**ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆé»˜è®¤çš„æ–‡ä»¶è¯»å–æ–¹æ³•
    `fs.readFile` ä½¿ç”¨å›è°ƒã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ä½¿ç”¨ Promises å’Œ `async/await`ã€‚ä½ æ€»æ˜¯ï¼Œæ€»æ˜¯å‘Šè¯‰ Nodeï¼Œâ€œå˜¿ï¼Œå»åšè¿™ä¸ªæ…¢æ´»ï¼Œå®Œæˆçš„æ—¶å€™å‘Šè¯‰æˆ‘ã€‚æˆ‘è¿˜æœ‰å…¶ä»–å·¥ä½œè¦åšã€‚â€
- en: â„¹ï¸Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: Historically `fs.readFile` used callbacks; modern code should prefer `fs.promises`
    with async/await or streaming APIs when appropriate.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: å†å²ä¸Š `fs.readFile` ä½¿ç”¨å›è°ƒï¼›ç°ä»£ä»£ç åº”ä¼˜å…ˆè€ƒè™‘åœ¨é€‚å½“çš„æƒ…å†µä¸‹ä½¿ç”¨ `fs.promises` ä¸ async/await æˆ–æµå¼ APIã€‚
- en: The Core Components - V8, libuv, and the Glue
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æ ¸å¿ƒç»„ä»¶ - V8ã€libuv å’Œç²˜åˆå‰‚
- en: When you type `node my_app.js` and hit enter, you're not just running a JavaScript
    interpreter. You are starting a complex, finely-tuned piece of software. Let's
    peel back the layers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ è¾“å…¥ `node my_app.js` å¹¶æŒ‰å›è½¦é”®æ—¶ï¼Œä½ ä¸ä»…ä»…æ˜¯åœ¨è¿è¡Œä¸€ä¸ª JavaScript è§£é‡Šå™¨ã€‚ä½ æ­£åœ¨å¯åŠ¨ä¸€ä¸ªå¤æ‚ã€ç²¾å¿ƒè°ƒæ ¡çš„è½¯ä»¶ã€‚è®©æˆ‘ä»¬ä¸€å±‚å±‚æ­å¼€å®ƒçš„é¢çº±ã€‚
- en: 'At a high level, the Node.js architecture looks something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ä»é«˜å±‚æ¬¡æ¥çœ‹ï¼ŒNode.js çš„æ¶æ„çœ‹èµ·æ¥å¤§è‡´å¦‚ä¸‹ï¼š
- en: '*The layers of the Node.js runtime, from your code down to the OS.*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node.js è¿è¡Œæ—¶çš„å±‚çº§ï¼Œä»ä½ çš„ä»£ç åˆ°æ“ä½œç³»ç»Ÿã€‚*'
- en: â„¹ï¸Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: 'Diagram is simplified: exact internals differ by API and platform - e.g. networking
    uses kernel readiness APIs, some filesystem/DNS calls are handled by libuvâ€™s threadpool,
    and libuv may use different kernel features (epoll/kqueue/IOCP/io_uring) depending
    on platform and libuv version.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾è¡¨å·²ç®€åŒ–ï¼šç¡®åˆ‡çš„å†…éƒ¨ç»“æ„æ ¹æ® API å’Œå¹³å°è€Œå¼‚ - ä¾‹å¦‚ï¼Œç½‘ç»œä½¿ç”¨å†…æ ¸å°±ç»ª APIï¼Œä¸€äº›æ–‡ä»¶ç³»ç»Ÿ/DNS è°ƒç”¨ç”± libuv çš„çº¿ç¨‹æ± å¤„ç†ï¼Œå¹¶ä¸” libuv
    å¯èƒ½æ ¹æ®å¹³å°å’Œ libuv ç‰ˆæœ¬ä½¿ç”¨ä¸åŒçš„å†…æ ¸åŠŸèƒ½ï¼ˆepoll/kqueue/IOCP/io_uringï¼‰ã€‚
- en: Let's break down each major component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ†è§£æ¯ä¸ªä¸»è¦ç»„ä»¶ã€‚
- en: '**V8: The JavaScript Engine**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**V8: JavaScript å¼•æ“**'
- en: This is the piece that most people know about. V8 is Google's open-source, high-performance
    JavaScript and WebAssembly engine, written in C++. It's the engine that powers
    Google Chrome. When Node.js started, using V8 was a brilliant move. It meant Node
    got a world-class, incredibly fast, and constantly improving JS engine for free.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å¤§å¤šæ•°äººæ‰€çŸ¥é“çš„éƒ¨åˆ†ã€‚V8æ˜¯Googleçš„å¼€æºã€é«˜æ€§èƒ½JavaScriptå’ŒWebAssemblyå¼•æ“ï¼Œç”¨C++ç¼–å†™ã€‚å®ƒæ˜¯é©±åŠ¨Google Chromeçš„å¼•æ“ã€‚å½“Node.jså¼€å§‹æ—¶ï¼Œä½¿ç”¨V8æ˜¯ä¸€ä¸ªç»å¦™çš„ä¸¾æªã€‚è¿™æ„å‘³ç€Nodeå…è´¹è·å¾—äº†ä¸€ä¸ªä¸–ç•Œçº§çš„ã€æå…¶å¿«é€Ÿä¸”ä¸æ–­æ”¹è¿›çš„JSå¼•æ“ã€‚
- en: But what does an "engine" actually do?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†â€œå¼•æ“â€å®é™…ä¸Šåšä»€ä¹ˆå‘¢ï¼Ÿ
- en: It doesn't just read your JavaScript line by line. It compiles it into highly-optimized
    native machine code. This process is called Just-In-Time (JIT) compilation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¸ä»…ä»…æ˜¯ä¸€è¡Œä¸€è¡Œåœ°è¯»å–ä½ çš„JavaScriptä»£ç ã€‚å®ƒå°†å…¶ç¼–è¯‘æˆé«˜åº¦ä¼˜åŒ–çš„æœ¬åœ°æœºå™¨ä»£ç ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºå³æ—¶ï¼ˆJITï¼‰ç¼–è¯‘ã€‚
- en: '**V8''s Compilation Pipeline:** When V8 sees your JS code, it first uses a
    baseline compiler called **Ignition** to quickly turn it into bytecode. As your
    code runs, V8''s profiler watches for "hot" functions - code that gets executed
    frequently. These hot functions are then passed to the optimizing compiler, **TurboFan**,
    which makes assumptions about your code (e.g., "this variable will always be a
    number") to generate blazing-fast machine code. If those assumptions ever prove
    false, V8 performs a "de-optimization" and falls back to the slower bytecode.
    *(We''ll do a much deeper dive into V8 internals and how to write optimization-friendly
    code in **Chapter 21**.)*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**V8çš„ç¼–è¯‘ç®¡é“ï¼š** å½“V8çœ‹åˆ°ä½ çš„JSä»£ç æ—¶ï¼Œå®ƒé¦–å…ˆä½¿ç”¨ä¸€ä¸ªåŸºçº¿ç¼–è¯‘å™¨ç§°ä¸º**Ignition**ï¼Œå¿«é€Ÿå°†å…¶è½¬æ¢ä¸ºå­—èŠ‚ç ã€‚éšç€ä»£ç çš„è¿è¡Œï¼ŒV8çš„å‰–æå™¨ä¼šç›‘è§†â€œçƒ­ç‚¹â€å‡½æ•°â€”â€”ç»å¸¸è¢«æ‰§è¡Œçš„ä»£ç ã€‚ç„¶åï¼Œè¿™äº›çƒ­ç‚¹å‡½æ•°è¢«ä¼ é€’ç»™ä¼˜åŒ–ç¼–è¯‘å™¨**TurboFan**ï¼Œå®ƒä¼šå¯¹ä½ çš„ä»£ç åšå‡ºå‡è®¾ï¼ˆä¾‹å¦‚ï¼Œâ€œè¿™ä¸ªå˜é‡å§‹ç»ˆæ˜¯ä¸€ä¸ªæ•°å­—â€ï¼‰ä»¥ç”Ÿæˆæå¿«çš„æœºå™¨ä»£ç ã€‚å¦‚æœè¿™äº›å‡è®¾æœ‰ä»»ä½•é”™è¯¯ï¼ŒV8å°†æ‰§è¡Œâ€œå»ä¼˜åŒ–â€å¹¶å›é€€åˆ°è¾ƒæ…¢çš„å­—èŠ‚ç ã€‚ï¼ˆæˆ‘ä»¬å°†åœ¨**ç¬¬21ç« **ä¸­æ·±å…¥æ¢è®¨V8çš„å†…éƒ¨ç»“æ„å’Œå¦‚ä½•ç¼–å†™ä¼˜åŒ–å‹å¥½å‹ä»£ç ã€‚ï¼‰'
- en: 'For now, the key takeaway is this: **V8 is what makes JavaScript fast enough
    for the server.** It takes a dynamic, interpreted language and gives it performance
    that can compete with more traditional server-side languages.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰ï¼Œå…³é”®è¦ç‚¹æ˜¯ï¼š**V8ä½¿å¾—JavaScriptåœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œè¶³å¤Ÿå¿«ã€‚**å®ƒå°†åŠ¨æ€çš„ã€è§£é‡Šå‹è¯­è¨€è½¬åŒ–ä¸ºå¯ä»¥ä¸ä¼ ç»ŸæœåŠ¡å™¨ç«¯è¯­è¨€ç›¸åª²ç¾çš„æ€§èƒ½ã€‚
- en: But V8 knows nothing about files, networks, or timers. It's a pure JavaScript
    engine. If you tried to run `require('fs')` inside a plain V8 instance, it would
    throw an error. It lives in a sandbox. To do anything useful on a server, V8 needs
    help.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†V8å¯¹æ–‡ä»¶ã€ç½‘ç»œæˆ–å®šæ—¶å™¨ä¸€æ— æ‰€çŸ¥ã€‚å®ƒæ˜¯ä¸€ä¸ªçº¯JavaScriptå¼•æ“ã€‚å¦‚æœä½ åœ¨ä¸€ä¸ªæ™®é€šçš„V8å®ä¾‹ä¸­å°è¯•è¿è¡Œ`require('fs')`ï¼Œå®ƒä¼šæŠ›å‡ºä¸€ä¸ªé”™è¯¯ã€‚å®ƒç”Ÿæ´»åœ¨æ²™ç›’ä¸­ã€‚è¦åœ¨æœåŠ¡å™¨ä¸Šåšä»»ä½•æœ‰ç”¨çš„äº‹æƒ…ï¼ŒV8éœ€è¦å¸®åŠ©ã€‚
- en: '**libuv**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**libuv**'
- en: This is the unsung hero of Node.js. `libuv` is a C library, originally written
    for Node.js, that provides the core asynchronous, event-driven functionality.
    It's the component that makes Node... well, *Node*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯Node.jsçš„é»˜é»˜æ— é—»çš„è‹±é›„ã€‚`libuv`æ˜¯ä¸€ä¸ªCåº“ï¼Œæœ€åˆæ˜¯ä¸ºNode.jsç¼–å†™çš„ï¼Œå®ƒæä¾›äº†æ ¸å¿ƒçš„å¼‚æ­¥ã€äº‹ä»¶é©±åŠ¨åŠŸèƒ½ã€‚å®ƒæ˜¯ä½¿Node...æˆä¸º*Node*çš„ç»„ä»¶ã€‚
- en: 'Its main responsibilities are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒçš„ä¸»è¦èŒè´£åŒ…æ‹¬ï¼š
- en: '**The Event Loop.** This is the central mechanism. It''s an endless loop that
    processes events from a queue. When you call `setTimeout`, `fs.readFile`, or `http.createServer`,
    you are essentially registering an event handler. The loop continuously asks the
    operating system, "Has anything happened with the things I''m waiting for?" (e.g.,
    "Has that file finished reading?" "Has a new connection come in on this socket?").
    When the OS says yes, the event loop takes the corresponding callback function
    from your code and executes it. We will dissect the event loop''s phases in detail
    later, but for now, think of it as the tireless coordinator.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**äº‹ä»¶å¾ªç¯ã€‚** è¿™æ˜¯æ ¸å¿ƒæœºåˆ¶ã€‚å®ƒæ˜¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œå¤„ç†æ¥è‡ªé˜Ÿåˆ—çš„äº‹ä»¶ã€‚å½“ä½ è°ƒç”¨`setTimeout`ã€`fs.readFile`æˆ–`http.createServer`æ—¶ï¼Œä½ å®é™…ä¸Šæ˜¯åœ¨æ³¨å†Œä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨ã€‚å¾ªç¯æŒç»­ä¸æ–­åœ°è¯¢é—®æ“ä½œç³»ç»Ÿï¼šâ€œæˆ‘ç­‰å¾…çš„äº‹æƒ…æœ‰ä»€ä¹ˆå‘ç”Ÿå—ï¼Ÿâ€ï¼ˆä¾‹å¦‚ï¼Œâ€œé‚£ä¸ªæ–‡ä»¶æ˜¯å¦å·²ç»è¯»å–å®Œæˆï¼Ÿâ€
    â€œæ˜¯å¦æœ‰æ–°çš„è¿æ¥åœ¨è¿™ä¸ªå¥—æ¥å­—ä¸Šï¼Ÿâ€ï¼‰ã€‚å½“æ“ä½œç³»ç»Ÿå›ç­”æ˜¯æ—¶ï¼Œäº‹ä»¶å¾ªç¯ä¼šä»ä½ çš„ä»£ç ä¸­å–å‡ºç›¸åº”çš„å›è°ƒå‡½æ•°å¹¶æ‰§è¡Œå®ƒã€‚æˆ‘ä»¬å°†åœ¨ç¨åè¯¦ç»†å‰–æäº‹ä»¶å¾ªç¯çš„é˜¶æ®µï¼Œä½†å°±ç›®å‰è€Œè¨€ï¼Œå¯ä»¥å°†å…¶è§†ä¸ºä¸çŸ¥ç–²å€¦çš„åè°ƒè€…ã€‚'
- en: '**Asynchronous I/O.** `libuv` abstracts the non-blocking I/O capabilities of
    the underlying operating system. On Linux, it uses `epoll`. On macOS/BSD, it uses
    `kqueue`. On Windows, it uses `IOCP` (I/O Completion Ports). You, the Node developer,
    don''t have to care about any of this. You just write JavaScript, and `libuv`
    picks the best strategy for the platform it''s running on to ensure I/O operations
    don''t block the main thread.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å¼‚æ­¥I/O**ã€‚`libuv`æŠ½è±¡äº†åº•å±‚æ“ä½œç³»ç»Ÿçš„éé˜»å¡I/Oèƒ½åŠ›ã€‚åœ¨Linuxä¸Šï¼Œå®ƒä½¿ç”¨`epoll`ã€‚åœ¨macOS/BSDä¸Šï¼Œå®ƒä½¿ç”¨`kqueue`ã€‚åœ¨Windowsä¸Šï¼Œå®ƒä½¿ç”¨`IOCP`ï¼ˆI/Oå®Œæˆç«¯å£ï¼‰ã€‚ä½œä¸ºNodeå¼€å‘è€…ï¼Œæ‚¨ä¸éœ€è¦å…³å¿ƒè¿™äº›ã€‚æ‚¨åªéœ€ç¼–å†™JavaScriptï¼Œ`libuv`ä¼šæ ¹æ®å…¶è¿è¡Œçš„å¹³å°é€‰æ‹©æœ€ä½³ç­–ç•¥ï¼Œä»¥ç¡®ä¿I/Oæ“ä½œä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹ã€‚'
- en: '**The Thread Pool.** Wait, I thought Node was single-threaded? Here''s the
    most common point of confusion. Your JavaScript code runs on a single thread (the
    event loop thread). But some operations can''t be done asynchronously by the OS
    in a non-blocking way. If these ran on the main thread, they would block the event
    loop, defeating the entire purpose of Node. This includes most file system APIs
    and CPU-intensive tasks like in the `crypto` and `zlib` modules.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**çº¿ç¨‹æ± **ã€‚ç­‰ç­‰ï¼Œæˆ‘ä»¥ä¸ºNodeæ˜¯å•çº¿ç¨‹çš„ï¼Ÿè¿™æ˜¯æœ€å¸¸è§çš„æ··æ·†ç‚¹ã€‚æ‚¨çš„JavaScriptä»£ç åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸Šè¿è¡Œï¼ˆäº‹ä»¶å¾ªç¯çº¿ç¨‹ï¼‰ã€‚ä½†æ˜¯ï¼Œä¸€äº›æ“ä½œä¸èƒ½ç”±æ“ä½œç³»ç»Ÿä»¥éé˜»å¡æ–¹å¼å¼‚æ­¥æ‰§è¡Œã€‚å¦‚æœè¿™äº›æ“ä½œåœ¨ä¸»çº¿ç¨‹ä¸Šè¿è¡Œï¼Œå®ƒä»¬ä¼šé˜»å¡äº‹ä»¶å¾ªç¯ï¼Œä»è€Œè¿èƒŒäº†Nodeçš„æ•´ä¸ªç›®çš„ã€‚è¿™åŒ…æ‹¬å¤§å¤šæ•°æ–‡ä»¶ç³»ç»ŸAPIå’Œåƒ`crypto`å’Œ`zlib`æ¨¡å—è¿™æ ·çš„CPUå¯†é›†å‹ä»»åŠ¡ã€‚'
- en: To solve this, `libuv` maintains a small, fixed-size **thread pool** (defaulting
    to 4 threads, but configurable via `UV_THREADPOOL_SIZE` before the pool is created;
    max â‰ˆ `1024`). When you call a function that lacks a non-blocking equivalent at
    the OS level (like `fs.readFile`), `libuv` dispatches the work to its thread pool.
    Critically, network I/O is handled directly by the OS's non-blocking mechanisms
    (like epoll, kqueue, IOCP) and does *not* use the thread pool, allowing a single
    thread to handle tens of thousands of concurrent connections.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œ`libuv`ç»´æŠ¤äº†ä¸€ä¸ªå°å‹ã€å›ºå®šå¤§å°çš„**çº¿ç¨‹æ± **ï¼ˆé»˜è®¤ä¸º4ä¸ªçº¿ç¨‹ï¼Œä½†åœ¨åˆ›å»ºæ± ä¹‹å‰å¯ä»¥é€šè¿‡`UV_THREADPOOL_SIZE`è¿›è¡Œé…ç½®ï¼›æœ€å¤§çº¦ä¸º`1024`ï¼‰ã€‚å½“æ‚¨è°ƒç”¨ä¸€ä¸ªåœ¨æ“ä½œç³»ç»Ÿçº§åˆ«æ²¡æœ‰éé˜»å¡ç­‰ä»·ç‰©çš„å‡½æ•°æ—¶ï¼ˆå¦‚`fs.readFile`ï¼‰ï¼Œ`libuv`ä¼šå°†å·¥ä½œè°ƒåº¦åˆ°å…¶çº¿ç¨‹æ± ã€‚å…³é”®çš„æ˜¯ï¼Œç½‘ç»œI/Oç›´æ¥ç”±æ“ä½œç³»ç»Ÿçš„éé˜»å¡æœºåˆ¶ï¼ˆå¦‚epollã€kqueueã€IOCPï¼‰å¤„ç†ï¼Œå¹¶ä¸”ä¸ä½¿ç”¨çº¿ç¨‹æ± ï¼Œå…è®¸å•ä¸ªçº¿ç¨‹å¤„ç†æ•°ä¸‡ä¸ªå¹¶å‘è¿æ¥ã€‚
- en: â„¹ï¸Note
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: 'Most network socket I/O is handled via the OSâ€™s non-blocking I/O facilities
    (epoll/kqueue/IOCP) and doesnâ€™t use the libuv worker pool. Exceptions exist: hostname
    lookups (e.g. dns.lookup which uses getaddrinfo) and many filesystem operations
    are offloaded to the libuv threadpool - those tasks do consume worker threads.'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°ç½‘ç»œå¥—æ¥å­—I/Oæ˜¯é€šè¿‡æ“ä½œç³»ç»Ÿçš„ä¸é˜»å¡I/Oè®¾æ–½ï¼ˆepoll/kqueue/IOCPï¼‰å¤„ç†çš„ï¼Œå¹¶ä¸”ä¸ä½¿ç”¨libuvå·¥ä½œæ± ã€‚å­˜åœ¨ä¾‹å¤–ï¼šä¸»æœºåæŸ¥æ‰¾ï¼ˆä¾‹å¦‚ï¼Œdns.lookupä½¿ç”¨getaddrinfoï¼‰å’Œè®¸å¤šæ–‡ä»¶ç³»ç»Ÿæ“ä½œè¢«å¸è½½åˆ°libuvçº¿ç¨‹æ± 
    - è¿™äº›ä»»åŠ¡ç¡®å®æ¶ˆè€—å·¥ä½œçº¿ç¨‹ã€‚
- en: Once a thread in the pool finishes its task, it informs the event loop, which
    then executes your JavaScript callback with the result.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ä¸€æ—¦çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹å®Œæˆå…¶ä»»åŠ¡ï¼Œå®ƒä¼šé€šçŸ¥äº‹ä»¶å¾ªç¯ï¼Œç„¶åæ‰§è¡Œæ‚¨çš„JavaScriptå›è°ƒå¹¶è¿”å›ç»“æœã€‚
- en: So, Node.js *is* single-threaded from your perspective, but it uses a few threads
    under the hood to handle specific types of work. This is a crucial distinction.
    *(We dive deep into `libuv`'s internals, the event loop phases, and the thread
    pool in **Chapter 23**.)*
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä»æ‚¨çš„è§’åº¦æ¥çœ‹ï¼ŒNode.js *æ˜¯* å•çº¿ç¨‹çš„ï¼Œä½†å®ƒåº•å±‚ä½¿ç”¨å‡ ä¸ªçº¿ç¨‹æ¥å¤„ç†ç‰¹å®šç±»å‹çš„å·¥ä½œã€‚è¿™æ˜¯ä¸€ä¸ªé‡è¦çš„åŒºåˆ«ã€‚ï¼ˆæˆ‘ä»¬åœ¨ç¬¬23ç« æ·±å…¥æ¢è®¨äº†`libuv`çš„å†…éƒ¨ç»“æ„ã€äº‹ä»¶å¾ªç¯é˜¶æ®µå’Œçº¿ç¨‹æ± ã€‚ï¼‰
- en: '**C++ Bindings & Node.js Core APIs: The Bridge**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ç»‘å®šä¸Node.jsæ ¸å¿ƒAPIï¼šæ¡¥æ¢**'
- en: So we have V8 (for running JS) and `libuv` (for async I/O). How do they talk
    to each other?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬æœ‰V8ï¼ˆç”¨äºè¿è¡ŒJSï¼‰å’Œ`libuv`ï¼ˆç”¨äºå¼‚æ­¥I/Oï¼‰ã€‚å®ƒä»¬æ˜¯å¦‚ä½•äº’ç›¸é€šä¿¡çš„å‘¢ï¼Ÿ
- en: That's the job of the C++ bindings.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯C++ç»‘å®šçš„ä½œç”¨ã€‚
- en: 'When you write `const fs = require(''fs'');`, you are not getting a pure JavaScript
    object. You''re getting a JavaScript module that has "bindings" to underlying
    C++ code. When you call `fs.readFile(''/path/to/file'', callback)`, the following
    sequence happens:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æ‚¨ç¼–å†™`const fs = require('fs');`æ—¶ï¼Œæ‚¨å¹¶ä¸æ˜¯å¾—åˆ°ä¸€ä¸ªçº¯JavaScriptå¯¹è±¡ã€‚æ‚¨å¾—åˆ°çš„æ˜¯ä¸€ä¸ªå…·æœ‰â€œç»‘å®šâ€åˆ°åº•å±‚C++ä»£ç çš„JavaScriptæ¨¡å—ã€‚å½“æ‚¨è°ƒç”¨`fs.readFile('/path/to/file',
    callback)`æ—¶ï¼Œä»¥ä¸‹åºåˆ—å‘ç”Ÿï¼š
- en: The JavaScript `readFile` function in Node's core `fs` module is called.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Nodeçš„`fs`æ ¸å¿ƒæ¨¡å—ä¸­çš„JavaScript `readFile`å‡½æ•°è¢«è°ƒç”¨ã€‚
- en: This function calls down into a C++ function via the bindings.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æ­¤å‡½æ•°é€šè¿‡ç»‘å®šè°ƒç”¨åˆ°C++å‡½æ•°ã€‚
- en: The C++ code prepares the request and then passes it to `libuv`, saying "please
    read this file."
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ä»£ç å‡†å¤‡è¯·æ±‚ï¼Œç„¶åå°†å…¶ä¼ é€’ç»™`libuv`ï¼Œå¹¶è¯´â€œè¯·è¯»å–è¿™ä¸ªæ–‡ä»¶ã€‚â€
- en: '`libuv` gets the request and submits it to its thread pool for execution.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`libuv`è·å–è¯·æ±‚å¹¶å°†å…¶æäº¤ç»™å…¶çº¿ç¨‹æ± ä»¥æ‰§è¡Œã€‚'
- en: Crucially, your JavaScript code continues executing immediately. The `readFile`
    call has returned `undefined`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å…³é”®çš„æ˜¯ï¼Œä½ çš„JavaScriptä»£ç ä¼šç«‹å³ç»§ç»­æ‰§è¡Œã€‚`readFile`è°ƒç”¨è¿”å›äº†`undefined`ã€‚
- en: Sometime later, a thread in the pool finishes reading the file. It informs `libuv`
    of the completion.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨æŸä¸ªæ—¶å€™ï¼Œçº¿ç¨‹æ± ä¸­çš„ä¸€ä¸ªçº¿ç¨‹å®Œæˆäº†æ–‡ä»¶çš„è¯»å–ã€‚å®ƒé€šçŸ¥`libuv`ä»»åŠ¡å·²å®Œæˆã€‚
- en: '`libuv` then places the result and the associated callback into a queue for
    the event loop to process.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`libuv`ç„¶åå°†ç»“æœå’Œç›¸å…³å›è°ƒæ”¾å…¥äº‹ä»¶å¾ªç¯çš„é˜Ÿåˆ—ä¸­å¤„ç†ã€‚'
- en: During a future tick of the event loop, it sees the completed job in the queue
    and executes the original JavaScript callback you provided, passing in the data
    or error.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨äº‹ä»¶å¾ªç¯çš„ä¸‹ä¸€ä¸ªtickä¸­ï¼Œå®ƒçœ‹åˆ°é˜Ÿåˆ—ä¸­å®Œæˆçš„ä»»åŠ¡å¹¶æ‰§è¡Œä½ æä¾›çš„åŸå§‹JavaScriptå›è°ƒï¼Œä¼ å…¥æ•°æ®æˆ–é”™è¯¯ã€‚
- en: This bridge is what makes Node.js a cohesive runtime. It exposes the power of
    low-level libraries like `libuv` through a clean, easy-to-use JavaScript API.
    The `http`, `crypto`, `path`, and other core modules are all part of this layer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ¡¥æ¢ä½¿å¾—Node.jsæˆä¸ºä¸€ä¸ªç»Ÿä¸€çš„è¿è¡Œæ—¶ç¯å¢ƒã€‚å®ƒé€šè¿‡ä¸€ä¸ªå¹²å‡€ã€æ˜“äºä½¿ç”¨çš„JavaScript APIæš´éœ²äº†åƒ`libuv`è¿™æ ·çš„ä½çº§åº“çš„å¼ºå¤§åŠŸèƒ½ã€‚`http`ã€`crypto`ã€`path`å’Œå…¶ä»–æ ¸å¿ƒæ¨¡å—éƒ½æ˜¯è¿™ä¸ªå±‚çš„ä¸€éƒ¨åˆ†ã€‚
- en: Let's See It in Action - A Tiny Measurement Experiment
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å®é™…æ•ˆæœ - ä¸€ä¸ªå¾®å°çš„æµ‹é‡å®éªŒ
- en: Theory is great, but seeing is believing. Let's demonstrate the profound difference
    between a blocking and a non-blocking I/O model with a simple experiment.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ç†è®ºæ˜¯ä¼Ÿå¤§çš„ï¼Œä½†çœ¼è§ä¸ºå®ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„å®éªŒæ¥å±•ç¤ºé˜»å¡å’Œéé˜»å¡I/Oæ¨¡å‹ä¹‹é—´çš„æ·±åˆ»å·®å¼‚ã€‚
- en: 'We will create two tiny web servers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†åˆ›å»ºä¸¤ä¸ªå¾®å‹çš„WebæœåŠ¡å™¨ï¼š
- en: '**A Python server.** We''ll use Flask, a popular web framework. To simulate
    a slow database query or API call, we''ll make it sleep for 2 seconds on every
    request. This is a classic **blocking** operation.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**PythonæœåŠ¡å™¨**ã€‚æˆ‘ä»¬å°†ä½¿ç”¨Flaskï¼Œä¸€ä¸ªæµè¡Œçš„Webæ¡†æ¶ã€‚ä¸ºäº†æ¨¡æ‹Ÿæ…¢é€Ÿçš„æ•°æ®åº“æŸ¥è¯¢æˆ–APIè°ƒç”¨ï¼Œæˆ‘ä»¬å°†åœ¨æ¯ä¸ªè¯·æ±‚ä¸Šè®©å®ƒæš‚åœ2ç§’ã€‚è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„**é˜»å¡**æ“ä½œã€‚'
- en: ğŸ“ŒImportant
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ğŸ“Œé‡è¦
- en: The example uses Flaskâ€™s built-in development server (single-threaded) to illustrate
    blocking; you do not use the dev server in production. Production Python services
    typically run under a WSGI/ASGI server (Gunicorn, uWSGI, or uvicorn) with multiple
    workers or async event loops - which change the concurrency model. Thus the demo
    only shows a simple contrast, not a blanket statement about Pythonâ€™s capabilities.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: è¿™ä¸ªä¾‹å­ä½¿ç”¨Flaskçš„å†…ç½®å¼€å‘æœåŠ¡å™¨ï¼ˆå•çº¿ç¨‹ï¼‰æ¥å±•ç¤ºé˜»å¡ï¼›åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œä½ ä¸ä¼šä½¿ç”¨è¿™ä¸ªå¼€å‘æœåŠ¡å™¨ã€‚ç”Ÿäº§PythonæœåŠ¡é€šå¸¸åœ¨WSGI/ASGIæœåŠ¡å™¨ï¼ˆGunicornã€uWSGIæˆ–uvicornï¼‰ä¸‹è¿è¡Œï¼Œå…·æœ‰å¤šä¸ªå·¥ä½œè€…æˆ–å¼‚æ­¥äº‹ä»¶å¾ªç¯
    - è¿™æ”¹å˜äº†å¹¶å‘æ¨¡å‹ã€‚å› æ­¤ï¼Œè¿™ä¸ªæ¼”ç¤ºåªå±•ç¤ºäº†ç®€å•çš„å¯¹æ¯”ï¼Œè€Œä¸æ˜¯å…³äºPythonèƒ½åŠ›çš„å…¨é¢å£°æ˜ã€‚
- en: '**A Node.js server.** We''ll use the built-in `http` module. To simulate the
    same slow operation, we''ll use `setTimeout` for 2 seconds before responding.
    This is a **non-blocking** operation.'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Node.jsæœåŠ¡å™¨**ã€‚æˆ‘ä»¬å°†ä½¿ç”¨å†…ç½®çš„`http`æ¨¡å—ã€‚ä¸ºäº†æ¨¡æ‹Ÿç›¸åŒçš„æ…¢é€Ÿæ“ä½œï¼Œæˆ‘ä»¬å°†åœ¨å“åº”å‰ä½¿ç”¨`setTimeout`å»¶è¿Ÿ2ç§’ã€‚è¿™æ˜¯ä¸€ä¸ª**éé˜»å¡**æ“ä½œã€‚'
- en: Then, we'll hit both servers with 10 concurrent requests and observe the behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å°†å¯¹è¿™ä¸¤ä¸ªæœåŠ¡å™¨å‘èµ·10ä¸ªå¹¶å‘è¯·æ±‚ï¼Œå¹¶è§‚å¯Ÿå…¶è¡Œä¸ºã€‚
- en: '**The Blocking Server (Python/Flask)**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**é˜»å¡æœåŠ¡å™¨ï¼ˆPython/Flask**ï¼‰'
- en: First, make sure you have Python and Flask installed. `pip install Flask`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè¯·ç¡®ä¿ä½ å·²ç»å®‰è£…äº†Pythonå’ŒFlaskã€‚`pip install Flask`
- en: 'Save this code as `blocking_server.py`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç ä¿å­˜ä¸º`blocking_server.py`ï¼š
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This server is designed to be naive. The `time.sleep(2)` call completely freezes
    the server. It can do absolutely nothing else until those two seconds are up.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæœåŠ¡å™¨è¢«è®¾è®¡æˆç®€å•çš„ã€‚`time.sleep(2)`è°ƒç”¨å®Œå…¨å†»ç»“äº†æœåŠ¡å™¨ã€‚åœ¨è¿™ä¸¤ç§’é’Ÿè¿‡å»ä¹‹å‰ï¼Œå®ƒç»å¯¹ä¸èƒ½åšå…¶ä»–ä»»ä½•äº‹æƒ…ã€‚
- en: 'Run it: `python blocking_server.py`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œå®ƒï¼š`python blocking_server.py`
- en: '**The Non-Blocking Server (Node.js)**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**éé˜»å¡æœåŠ¡å™¨ï¼ˆNode.js**ï¼‰'
- en: 'Save this code as `non_blocking_server.js`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æ­¤ä»£ç ä¿å­˜ä¸º`non_blocking_server.js`ï¼š
- en: '[PRE1]text'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE1]æ–‡æœ¬'
- en: '[!NOTE]'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[!NOTE]'
- en: '>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: It is crucial to note that setTimeout represents a 'perfectly idle' wait, consuming
    no system resources. While this experiment brilliantly demonstrates the non-blocking
    nature of the event loop, a real-world application handling 10 concurrent database
    queries would still open 10 sockets and use memory for each connection's I/O buffers.
    The magic of Node.js is not that it makes I/O work free, but that it prevents
    the main thread from being blocked while that work is in flight.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯è¦æ³¨æ„ï¼Œ`setTimeout`ä»£è¡¨ä¸€ä¸ªâ€œå®Œå…¨ç©ºé—²â€çš„ç­‰å¾…ï¼Œä¸æ¶ˆè€—ä»»ä½•ç³»ç»Ÿèµ„æºã€‚è™½ç„¶è¿™ä¸ªå®éªŒå·§å¦™åœ°å±•ç¤ºäº†äº‹ä»¶å¾ªç¯çš„éé˜»å¡ç‰¹æ€§ï¼Œä½†åœ¨ç°å®ä¸–ç•Œä¸­å¤„ç†10ä¸ªå¹¶å‘æ•°æ®åº“æŸ¥è¯¢çš„åº”ç”¨ç¨‹åºä»ç„¶ä¼šä¸ºæ¯ä¸ªè¿æ¥çš„I/Oç¼“å†²åŒºæ‰“å¼€10ä¸ªå¥—æ¥å­—å¹¶ä½¿ç”¨å†…å­˜ã€‚Node.jsçš„é­”æ³•å¹¶ä¸æ˜¯å®ƒä½¿I/Oå·¥ä½œå…è´¹ï¼Œè€Œæ˜¯å®ƒé˜²æ­¢ä¸»çº¿ç¨‹åœ¨I/Oæ“ä½œè¿›è¡Œæ—¶è¢«é˜»å¡ã€‚
- en: '> [!IMPORTANT]'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '> [!IMPORTANT]'
- en: '>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: A timer schedules a callback for a future turn of the event loop; it is lightweight
    compared to CPU work but still allocates a handle and can keep the process alive
    (unless you call .unref() on the timer). Timers are not free - creating large
    numbers of timers or relying on timers as a concurrency primitive can increase
    memory and scheduling overhead.
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: å®šæ—¶å™¨ä¸ºäº‹ä»¶å¾ªç¯çš„å°†æ¥è½®æ¬¡å®‰æ’ä¸€ä¸ªå›è°ƒï¼›ä¸CPUå·¥ä½œç›¸æ¯”ï¼Œå®ƒè¾ƒè½»é‡ï¼Œä½†ä»åˆ†é…äº†ä¸€ä¸ªå¥æŸ„ï¼Œå¹¶ä¸”å¯ä»¥ä¿æŒè¿›ç¨‹æ´»è·ƒï¼ˆé™¤éä½ åœ¨å®šæ—¶å™¨ä¸Šè°ƒç”¨.unref()ï¼‰ã€‚å®šæ—¶å™¨ä¸æ˜¯å…è´¹çš„â€”â€”åˆ›å»ºå¤§é‡å®šæ—¶å™¨æˆ–ä¾èµ–å®šæ—¶å™¨ä½œä¸ºå¹¶å‘åŸè¯­å¯èƒ½ä¼šå¢åŠ å†…å­˜å’Œè°ƒåº¦å¼€é”€ã€‚
- en: Here, `setTimeout` doesn't pause execution. It tells the Node.js runtime, "In
    about 2000 milliseconds, please run this function." The main thread is immediately
    freed up to handle more incoming requests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œ`setTimeout`ä¸ä¼šæš‚åœæ‰§è¡Œã€‚å®ƒå‘Šè¯‰Node.jsè¿è¡Œæ—¶ï¼Œâ€œå¤§çº¦2000æ¯«ç§’åï¼Œè¯·è¿è¡Œè¿™ä¸ªå‡½æ•°ã€‚â€ä¸»çº¿ç¨‹ç«‹å³è¢«é‡Šæ”¾ï¼Œä»¥ä¾¿å¤„ç†æ›´å¤šçš„ä¼ å…¥è¯·æ±‚ã€‚
- en: 'Run it: `node non_blocking_server.js`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œå®ƒï¼š`node non_blocking_server.js`
- en: '**The Test**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**æµ‹è¯•**'
- en: Now, let's use a simple command-line tool, `curl`, to simulate 10 users hitting
    our servers at roughly the same time. Open a new terminal.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç®€å•çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œ`curl`ï¼Œæ¥æ¨¡æ‹Ÿå¤§çº¦åŒæ—¶æœ‰10ä¸ªç”¨æˆ·æ’å‡»æˆ‘ä»¬çš„æœåŠ¡å™¨ã€‚æ‰“å¼€ä¸€ä¸ªæ–°çš„ç»ˆç«¯ã€‚
- en: First, let's test the **blocking server**. Run these 10 `curl` commands in quick
    succession. The `&` makes each command run in the background. The `time` command
    will show us the total real time it took.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œè®©æˆ‘ä»¬æµ‹è¯•ä¸€ä¸‹**é˜»å¡æœåŠ¡å™¨**ã€‚å¿«é€Ÿè¿ç»­è¿è¡Œè¿™10ä¸ª`curl`å‘½ä»¤ã€‚`&`ä½¿å¾—æ¯ä¸ªå‘½ä»¤åœ¨åå°è¿è¡Œã€‚`time`å‘½ä»¤å°†æ˜¾ç¤ºæ‰€èŠ±è´¹çš„æ€»å®é™…æ—¶é—´ã€‚
- en: '[PRE2]text'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE2]text'
- en: '**Observation (Blocking Server):**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**è§‚å¯Ÿï¼ˆé˜»å¡æœåŠ¡å™¨ï¼‰ï¼š**'
- en: 'Look at the console output of `blocking_server.py`. You''ll see something like
    this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹æ–‡ä»¶`blocking_server.py`çš„æ§åˆ¶å°è¾“å‡ºã€‚ä½ ä¼šçœ‹åˆ°ç±»ä¼¼ä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE3]text'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]text'
- en: Notice the sequential nature. It processes one request _completely_ before even
    _starting_ the next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„å…¶é¡ºåºæ€§ã€‚å®ƒåœ¨å¼€å§‹å¤„ç†ä¸‹ä¸€ä¸ªè¯·æ±‚ä¹‹å‰ï¼Œä¼šå…ˆå®Œå…¨å¤„ç†ä¸€ä¸ªè¯·æ±‚ã€‚
- en: The total time reported by the `time` command will be **approximately 20 seconds**
    (10 requests \* 2 seconds/request).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`å‘½ä»¤æŠ¥å‘Šçš„æ€»æ—¶é—´å°†æ˜¯**å¤§çº¦20ç§’**ï¼ˆ10ä¸ªè¯·æ±‚ \* æ¯ä¸ªè¯·æ±‚2ç§’ï¼‰ã€‚'
- en: Now, let's test the **non-blocking server**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬æµ‹è¯•ä¸€ä¸‹**éé˜»å¡æœåŠ¡å™¨**ã€‚
- en: '[PRE4]text'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]text'
- en: '**Observation (Non-Blocking Server):**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**è§‚å¯Ÿï¼ˆéé˜»å¡æœåŠ¡å™¨ï¼‰ï¼š**'
- en: 'Look at the console output of `non_blocking_server.js`. You''ll see something
    dramatically different:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æŸ¥çœ‹æ–‡ä»¶`non_blocking_server.js`çš„æ§åˆ¶å°è¾“å‡ºã€‚ä½ ä¼šçœ‹åˆ°æˆªç„¶ä¸åŒçš„å†…å®¹ï¼š
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The server accepted *all 10 requests* immediately, scheduled all 10 timeouts,
    and then, about two seconds later, all 10 timers fired and sent their responses.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: æœåŠ¡å™¨ç«‹å³æ¥å—äº†æ‰€æœ‰10ä¸ªè¯·æ±‚ï¼Œå®‰æ’äº†æ‰€æœ‰10ä¸ªè¶…æ—¶ï¼Œç„¶åå¤§çº¦ä¸¤ç§’åï¼Œæ‰€æœ‰10ä¸ªå®šæ—¶å™¨è§¦å‘å¹¶å‘é€äº†å®ƒä»¬çš„å“åº”ã€‚
- en: The total time reported by the `time` command will be **just over 2 seconds**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`å‘½ä»¤æŠ¥å‘Šçš„æ€»æ—¶é—´å°†æ˜¯**ç•¥è¶…è¿‡2ç§’**ã€‚'
- en: This is it. This is the magic. The Node server handled 10 concurrent "slow"
    operations in the time it took the Python server to handle just one. It achieved
    this concurrency not with 10 threads, but with one single, efficient event loop.
    If you were to check the process list while this is running (using a tool like
    `htop` or `ps`), you'd see a single `node` process with a tiny memory footprint,
    happily juggling all the requests at once. The blocking server, by contrast, would
    be completely saturated by a single request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯å®ƒã€‚è¿™å°±æ˜¯é­”æ³•ã€‚NodeæœåŠ¡å™¨åœ¨PythonæœåŠ¡å™¨å¤„ç†ä¸€ä¸ªè¯·æ±‚çš„æ—¶é—´å†…ï¼Œå¤„ç†äº†10ä¸ªå¹¶å‘çš„â€œæ…¢é€Ÿâ€æ“ä½œã€‚å®ƒä¸æ˜¯é€šè¿‡10ä¸ªçº¿ç¨‹å®ç°çš„è¿™ç§å¹¶å‘ï¼Œè€Œæ˜¯ä¸€ä¸ªå•ä¸€ã€é«˜æ•ˆçš„äº‹ä»¶å¾ªç¯ã€‚å¦‚æœä½ åœ¨å®ƒè¿è¡Œæ—¶æ£€æŸ¥è¿›ç¨‹åˆ—è¡¨ï¼ˆä½¿ç”¨åƒ`htop`æˆ–`ps`è¿™æ ·çš„å·¥å…·ï¼‰ï¼Œä½ ä¼šçœ‹åˆ°ä¸€ä¸ªå†…å­˜å ç”¨å¾ˆå°çš„å•ä¸ª`node`è¿›ç¨‹ï¼Œæ„‰å¿«åœ°åŒæ—¶å¤„ç†æ‰€æœ‰è¯·æ±‚ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œé˜»å¡æœåŠ¡å™¨ä¼šè¢«å•ä¸ªè¯·æ±‚å®Œå…¨å ç”¨ã€‚
- en: This simple experiment is the most important mental model you can have for Node.js
    performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç®€å•çš„å®éªŒæ˜¯ä½ å¯ä»¥æ‹¥æœ‰çš„æœ€é‡è¦çš„Node.jsæ€§èƒ½å¿ƒæ™ºæ¨¡å‹ã€‚
- en: '* * *'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**The Ecosystem**'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**ç”Ÿæ€ç³»ç»Ÿ**'
- en: You cannot talk about Node.js without talking about its ecosystem. The runtime
    itself is powerful, but it's just a foundation. The true force of Node comes from
    the community and the universe of open-source packages built on top of it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: è®¨è®ºNode.jsæ—¶ï¼Œä¸èƒ½ä¸æåŠå…¶ç”Ÿæ€ç³»ç»Ÿã€‚è¿è¡Œæ—¶æœ¬èº«åŠŸèƒ½å¼ºå¤§ï¼Œä½†åªæ˜¯åŸºç¡€ã€‚Node.jsçš„çœŸæ­£åŠ›é‡æ¥è‡ªäºç¤¾åŒºä»¥åŠå»ºç«‹åœ¨å®ƒä¹‹ä¸Šçš„å¼€æºåŒ…çš„å®‡å®™ã€‚
- en: If Node.js is the engine, then **npm** is the factory that produces every conceivable
    part you might need, from tiny screws to entire transmissions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœNode.jsæ˜¯å¼•æ“ï¼Œé‚£ä¹ˆ**npm**å°±æ˜¯ç”Ÿäº§ä½ æ‰€éœ€æ‰€æœ‰å¯èƒ½éƒ¨ä»¶çš„å·¥å‚ï¼Œä»å°èºä¸åˆ°æ•´ä¸ªä¼ åŠ¨ç³»ç»Ÿã€‚
- en: npm - The World's Biggest (and Sometimes Loudest) Toybox
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: npm - ä¸–ç•Œä¸Šæœ€å¤§ï¼ˆæœ‰æ—¶ä¹Ÿæ˜¯æœ€å˜ˆæ‚ï¼‰çš„ç©å…·ç®±
- en: When Node.js first came out, there was no standard way to share code. If you
    wanted to use someone's library, you'd probably copy-paste it or use a git submodule.
    It was messy.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: å½“Node.jsé¦–æ¬¡æ¨å‡ºæ—¶ï¼Œæ²¡æœ‰æ ‡å‡†çš„æ–¹å¼æ¥å…±äº«ä»£ç ã€‚å¦‚æœä½ æƒ³ä½¿ç”¨æŸäººçš„åº“ï¼Œä½ å¯èƒ½éœ€è¦å¤åˆ¶ç²˜è´´æˆ–è€…ä½¿ç”¨gitå­æ¨¡å—ã€‚è¿™å¾ˆæ··ä¹±ã€‚
- en: In 2010, Isaac Z. Schlueter created **npm** (Node Package Manager). It was a
    simple command-line tool to download and manage dependencies for Node projects.
    It was bundled with Node.js starting in 2011, and this decision changed everything.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 2010å¹´ï¼ŒIsaac Z. Schlueteråˆ›å»ºäº†**npm**ï¼ˆNodeåŒ…ç®¡ç†å™¨ï¼‰ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œç”¨äºä¸‹è½½å’Œç®¡ç†Nodeé¡¹ç›®çš„ä¾èµ–é¡¹ã€‚ä»2011å¹´å¼€å§‹ï¼Œå®ƒæ†ç»‘åœ¨Node.jsä¸­ï¼Œè¿™ä¸ªå†³å®šæ”¹å˜äº†æ‰€æœ‰çš„ä¸€åˆ‡ã€‚
- en: It made sharing and reusing code ridiculously easy. Had a useful function? `npm
    publish`. Needed a web framework? `npm install express`. This ease of use, combined
    with the growing popularity of Node, led to an explosion of packages.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä½¿å¾—ä»£ç çš„å…±äº«å’Œé‡ç”¨å˜å¾—æå…¶å®¹æ˜“ã€‚æœ‰ä¸€ä¸ªæœ‰ç”¨çš„å‡½æ•°ï¼Ÿ`npm publish`ã€‚éœ€è¦ä¸€ä¸ªWebæ¡†æ¶ï¼Ÿ`npm install express`ã€‚è¿™ç§æ˜“ç”¨æ€§ï¼ŒåŠ ä¸ŠNode.jsæ—¥ç›Šå¢é•¿çš„æµè¡Œåº¦ï¼Œå¯¼è‡´äº†åŒ…çš„çˆ†ç‚¸å¼å¢é•¿ã€‚
- en: 'The philosophy that emerged was heavily influenced by the Unix philosophy:
    **"Write programs that do one thing and do it well."** This led to a culture of
    very small, focused modules. Need to pad a string? Thereâ€™s a package for that.
    Need to check if a number is odd? Thereâ€™s a package for that.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: å‡ºç°çš„å“²å­¦å—åˆ°äº†Unixå“²å­¦çš„å¼ºçƒˆå½±å“ï¼š**â€œç¼–å†™åªåšä¸€ä»¶äº‹å¹¶ä¸”åšå¾—å¥½çš„ç¨‹åºã€‚â€**è¿™å¯¼è‡´äº†éå¸¸å°ã€ä¸“æ³¨çš„æ¨¡å—æ–‡åŒ–ã€‚éœ€è¦å¡«å……å­—ç¬¦ä¸²ï¼Ÿæœ‰ç›¸åº”çš„åŒ…ã€‚éœ€è¦æ£€æŸ¥ä¸€ä¸ªæ•°å­—æ˜¯å¦ä¸ºå¥‡æ•°ï¼Ÿä¹Ÿæœ‰ç›¸åº”çš„åŒ…ã€‚
- en: 'This has pros and cons:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ—¢æœ‰ä¼˜ç‚¹ä¹Ÿæœ‰ç¼ºç‚¹ï¼š
- en: '**Pro:** You can compose complex applications very quickly by plugging together
    these small, well-tested pieces. You don''t have to reinvent the wheel.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä¼˜ç‚¹**ï¼šä½ å¯ä»¥é€šè¿‡è¿æ¥è¿™äº›å°å‹ã€ç»è¿‡è‰¯å¥½æµ‹è¯•çš„ç»„ä»¶æ¥éå¸¸å¿«é€Ÿåœ°ç»„åˆå¤æ‚çš„åº”ç”¨ç¨‹åºã€‚ä½ ä¸å¿…é‡æ–°å‘æ˜è½®å­ã€‚'
- en: '**Con:** Your project''s `node_modules` directory can quickly become a behemoth,
    containing thousands of packages pulled in as dependencies of dependencies. A
    simple `npm install` can feel like downloading half the internet.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç¼ºç‚¹**ï¼šä½ çš„é¡¹ç›®çš„`node_modules`ç›®å½•å¯ä»¥è¿…é€Ÿå˜æˆä¸€ä¸ªåºç„¶å¤§ç‰©ï¼ŒåŒ…å«ä½œä¸ºä¾èµ–é¡¹çš„ä¾èµ–é¡¹çš„æ•°åƒä¸ªåŒ…ã€‚ä¸€ä¸ªç®€å•çš„`npm install`å¯èƒ½æ„Ÿè§‰åƒæ˜¯ä¸‹è½½äº†åŠä¸ªäº’è”ç½‘ã€‚'
- en: Today, the npm registry is the [largest software registry in the world](https://www.npmjs.com/package/all-the-packages),
    with millions of packages. It is, without a doubt, one of Node's greatest strengths.
    It's also the source of some of its biggest headaches. Over the years, competitors
    like `yarn` and `pnpm` emerged to solve problems with npm's performance, security,
    and dependency resolution, pushing the official npm client to get better. *(We'll
    cover the practicalities of package management, lockfiles, and choosing between
    npm/yarn/pnpm in **Chapter 37**.)*
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œnpmæ³¨å†Œè¡¨æ˜¯ä¸–ç•Œä¸Š[æœ€å¤§çš„è½¯ä»¶æ³¨å†Œè¡¨](https://www.npmjs.com/package/all-the-packages)ï¼Œæ‹¥æœ‰æ•°ç™¾ä¸‡ä¸ªåŒ…ã€‚æ¯«æ— ç–‘é—®ï¼Œè¿™æ˜¯Node.jsæœ€ä¼Ÿå¤§çš„ä¼˜åŠ¿ä¹‹ä¸€ã€‚å®ƒä¹Ÿæ˜¯ä¸€äº›æœ€å¤§å¤´ç—›çš„æ¥æºã€‚å¤šå¹´æ¥ï¼Œåƒ`yarn`å’Œ`pnpm`è¿™æ ·çš„ç«äº‰å¯¹æ‰‹å‡ºç°äº†ï¼Œä»¥è§£å†³npmçš„æ€§èƒ½ã€å®‰å…¨å’Œä¾èµ–è§£æé—®é¢˜ï¼Œæ¨åŠ¨å®˜æ–¹npmå®¢æˆ·ç«¯å˜å¾—æ›´å¥½ã€‚ï¼ˆæˆ‘ä»¬å°†åœ¨**ç¬¬37ç« **ä¸­ä»‹ç»åŒ…ç®¡ç†ã€é”æ–‡ä»¶ä»¥åŠé€‰æ‹©npm/yarn/pnpmçš„å®é™…æ“ä½œã€‚ï¼‰
- en: The Day `left-pad` Broke the Internet
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`left-pad`æ‰“ç ´äº’è”ç½‘çš„é‚£ä¸€å¤©'
- en: For a while, the "small modules" culture was celebrated as the pinnacle of code
    reuse. Then, on March 22, 2016, the world saw the downside.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ®µæ—¶é—´é‡Œï¼Œâ€œå°å‹æ¨¡å—â€æ–‡åŒ–è¢«é¢‚æ‰¬ä¸ºä»£ç é‡ç”¨çš„å·…å³°ã€‚ç„¶åï¼Œåœ¨2016å¹´3æœˆ22æ—¥ï¼Œä¸–ç•Œçœ‹åˆ°äº†å®ƒçš„è´Ÿé¢å½±å“ã€‚
- en: 'The story is now legendary in the developer community. A developer named Azer
    KoÃ§ulu had published over 250 packages to npm. One of them was a tiny, 11-line
    function called `left-pad`, which did exactly what it sounds like: it padded a
    string with characters on the left. It was a simple utility, but it was used by
    thousands of other projects, including hugely popular ones like Babel (a core
    part of the JavaScript toolchain).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªæ•…äº‹ç°åœ¨åœ¨å¼€å‘è€…ç¤¾åŒºä¸­å·²ç»æˆä¸ºä¼ å¥‡ã€‚ä¸€ä½åå«Azer KoÃ§uluçš„å¼€å‘è€…å·²ç»åœ¨npmä¸Šå‘å¸ƒäº†è¶…è¿‡250ä¸ªåŒ…ã€‚å…¶ä¸­ä¹‹ä¸€æ˜¯ä¸€ä¸ªåä¸º`left-pad`çš„å¾®å°ã€11è¡Œçš„å‡½æ•°ï¼Œå®ƒç¡®å®åšäº†å®ƒå¬èµ·æ¥åƒçš„äº‹æƒ…ï¼šåœ¨å­—ç¬¦ä¸²çš„å·¦ä¾§å¡«å……å­—ç¬¦ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å®ç”¨å·¥å…·ï¼Œä½†å®ƒè¢«æˆåƒä¸Šä¸‡çš„å…¶å®ƒé¡¹ç›®ä½¿ç”¨ï¼ŒåŒ…æ‹¬åƒBabelï¼ˆJavaScriptå·¥å…·é“¾çš„æ ¸å¿ƒéƒ¨åˆ†ï¼‰è¿™æ ·éå¸¸æµè¡Œçš„é¡¹ç›®ã€‚
- en: Azer got into a naming dispute with another company, Kik, over a different package.
    In protest, he unpublished *all* of his packages from npm, including `left-pad`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Azerä¸å¦ä¸€å®¶å…¬å¸Kikå°±ä¸åŒçš„åŒ…å‘ç”Ÿäº†å‘½åäº‰è®®ã€‚ä½œä¸ºæŠ—è®®ï¼Œä»–ä»npmä¸‹æ¶äº†æ‰€æœ‰åŒ…ï¼ŒåŒ…æ‹¬`left-pad`ã€‚
- en: The effect was immediate and catastrophic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å½±å“æ˜¯ç«‹å³ä¸”ç¾éš¾æ€§çš„ã€‚
- en: 'Across the globe, CI/CD pipelines started failing. Developers trying to install
    dependencies for their projects saw their builds break with an error: `404 Not
    Found: left-pad`. Because Babel depended on `left-pad`, and thousands of projects
    depended on Babel, a huge portion of the JavaScript ecosystem was suddenly, completely
    broken.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'å…¨çƒèŒƒå›´å†…çš„ CI/CD ç®¡é“å¼€å§‹å¤±è´¥ã€‚è¯•å›¾ä¸ºä»–ä»¬çš„é¡¹ç›®å®‰è£…ä¾èµ–çš„å¼€å‘è€…çœ‹åˆ°ä»–ä»¬çš„æ„å»ºå› é”™è¯¯è€Œä¸­æ–­ï¼šâ€œ404 Not Found: left-padâ€ã€‚å› ä¸º
    Babel ä¾èµ–äº `left-pad`ï¼Œè€Œæ•°åƒä¸ªé¡¹ç›®ä¾èµ–äº Babelï¼ŒJavaScript ç”Ÿæ€ç³»ç»Ÿçš„å¤§éƒ¨åˆ†çªç„¶å®Œå…¨å´©æºƒã€‚'
- en: I remember that day clearly. Our team's Slack channel lit up. "CI is red across
    the board." "Is it AWS? Did S3 go down again?" Someone posted the error. "...'left-pad'
    not found? What the hell is a left-pad?"
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ¸…æ¥šåœ°è®°å¾—é‚£å¤©ã€‚æˆ‘ä»¬å›¢é˜Ÿçš„ Slack é¢‘é“äº®äº†èµ·æ¥ã€‚â€œCI å…¨éƒ¨å˜çº¢äº†ã€‚â€â€œæ˜¯ AWS å—ï¼ŸS3 åˆå‡ºæ•…éšœäº†ï¼Ÿâ€æœ‰äººå‘å¸ƒäº†é”™è¯¯ã€‚â€œ...â€˜left-padâ€™æœªæ‰¾åˆ°ï¼Ÿä»€ä¹ˆé¬¼æ˜¯
    left-padï¼Ÿâ€
- en: The ugly truth was that our multi-million dollar software platform relied on
    an 11-line piece of code written by a single developer, who could remove it on
    a whim. It was a massive wake-up call for the entire industry about the fragility
    of the open-source supply chain.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‘é™‹çš„äº‹å®æ˜¯ï¼Œæˆ‘ä»¬çš„ä»·å€¼æ•°ç™¾ä¸‡ç¾å…ƒçš„è½¯ä»¶å¹³å°ä¾èµ–äºä¸€ä½å¼€å‘è€…ç¼–å†™çš„ 11 è¡Œä»£ç ï¼Œä»–å¯ä»¥éšå¿ƒæ‰€æ¬²åœ°ç§»é™¤å®ƒã€‚è¿™å¯¹æ•´ä¸ªè¡Œä¸šæ¥è¯´æ˜¯ä¸€ä¸ªå·¨å¤§çš„è­¦é’Ÿï¼Œæ­ç¤ºäº†å¼€æºä¾›åº”é“¾çš„è„†å¼±æ€§ã€‚
- en: 'NPM eventually took the unprecedented step of "un-unpublishing" the package
    to fix the immediate crisis. But the damage was done, and the lessons were learned:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: NPM æœ€ç»ˆé‡‡å–äº†å‰æ‰€æœªæœ‰çš„æ­¥éª¤ï¼Œå°†è½¯ä»¶åŒ…â€œé‡æ–°å‘å¸ƒâ€ï¼Œä»¥è§£å†³çœ¼å‰çš„å±æœºã€‚ä½†æŸå®³å·²ç»é€ æˆï¼Œæ•™è®­å·²ç»å¸å–ï¼š
- en: '**Dependencies are a liability.** Every `npm install` is an act of trust. You
    are running code written by strangers on your machine.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ä¾èµ–æ˜¯ä¸€ä¸ªè´Ÿæ‹…ã€‚** æ¯æ¬¡æ‰§è¡Œ `npm install` éƒ½æ˜¯ä¸€ç§ä¿¡ä»»è¡Œä¸ºã€‚ä½ æ­£åœ¨è¿è¡Œé™Œç”Ÿäººåœ¨ä½ æœºå™¨ä¸Šç¼–å†™çš„ä»£ç ã€‚'
- en: '**Transitive dependencies matter.** You might not have directly depended on
    `left-pad`, but one of your dependencies did. You are responsible for your entire
    dependency tree.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ä¼ é€’ä¾èµ–å¾ˆé‡è¦ã€‚** ä½ å¯èƒ½æ²¡æœ‰ç›´æ¥ä¾èµ–äº `left-pad`ï¼Œä½†ä½ çš„æŸä¸ªä¾èµ–é¡¹å´ä¾èµ–äº†å®ƒã€‚ä½ å¯¹æ•´ä¸ªä¾èµ–æ ‘è´Ÿæœ‰è´£ä»»ã€‚'
- en: '**Tooling and governance are critical.** The incident spurred the development
    of better tools like lockfiles (`package-lock.json`, `yarn.lock`) to ensure reproducible
    builds, and security auditing tools (`npm audit`) to scan for vulnerabilities.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å·¥å…·å’Œæ²»ç†è‡³å…³é‡è¦ã€‚** è¿™èµ·äº‹ä»¶ä¿ƒä½¿å¼€å‘äº†æ›´å¥½çš„å·¥å…·ï¼Œå¦‚é”æ–‡ä»¶ï¼ˆ`package-lock.json`ã€`yarn.lock`ï¼‰ä»¥ç¡®ä¿å¯é‡å¤æ„å»ºï¼Œä»¥åŠå®‰å…¨å®¡è®¡å·¥å…·ï¼ˆ`npm
    audit`ï¼‰ä»¥æ‰«ææ¼æ´ã€‚'
- en: 'The `left-pad` incident is the perfect encapsulation of the Node ecosystem''s
    dual nature: its incredible velocity and collaborative spirit, paired with its
    potential for chaos and supply chain risk. *(We''ll cover modern security practices,
    dependency auditing, and supply chain hygiene in **Chapter 19**.)*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`left-pad` äº‹ä»¶å®Œç¾åœ°æ¦‚æ‹¬äº† Node ç”Ÿæ€ç³»ç»ŸåŒé‡æ€§è´¨ï¼šå…¶æƒŠäººçš„é€Ÿåº¦å’Œåä½œç²¾ç¥ï¼Œä»¥åŠå…¶æ½œåœ¨çš„æ··ä¹±å’Œä¾›åº”é“¾é£é™©ã€‚ï¼ˆæˆ‘ä»¬å°†åœ¨**ç¬¬ 19 ç« **ä¸­ä»‹ç»ç°ä»£å®‰å…¨å®è·µã€ä¾èµ–é¡¹å®¡è®¡å’Œä¾›åº”é“¾å«ç”Ÿã€‚ï¼‰'
- en: Node Is Everywhere - It's Not Just for Servers Anymore
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Node éå¸ƒå„åœ°â€”â€”å®ƒä¸ä»…ä»…æ˜¯ä¸ºæœåŠ¡å™¨è€Œå­˜åœ¨
- en: While Node was born as a solution for scalable web servers, its success has
    propelled it far beyond that initial use case. The fact that it provides a powerful
    environment for executing JavaScript on a local machine has made it the foundation
    for a staggering number of tools and platforms.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶ Node æ˜¯ä½œä¸ºå¯æ‰©å±• Web æœåŠ¡å™¨çš„è§£å†³æ–¹æ¡ˆè€Œè¯ç”Ÿçš„ï¼Œä½†å…¶æˆåŠŸå·²ç»è¿œè¿œè¶…å‡ºäº†æœ€åˆçš„ä½¿ç”¨åœºæ™¯ã€‚å®ƒä¸ºåœ¨æœ¬åœ°æœºå™¨ä¸Šæ‰§è¡Œ JavaScript æä¾›äº†ä¸€ä¸ªå¼ºå¤§çš„ç¯å¢ƒï¼Œè¿™ä½¿å¾—å®ƒæˆä¸ºå¤§é‡å·¥å…·å’Œå¹³å°çš„åŸºç¡€ã€‚
- en: When you think "Node.js" today, you shouldn't just think "backend API." You
    should think of it as a general-purpose JavaScript platform.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ ä»Šå¤©æƒ³åˆ°â€œNode.jsâ€æ—¶ï¼Œä½ ä¸åº”è¯¥åªæƒ³åˆ°â€œåç«¯ APIâ€ã€‚ä½ åº”è¯¥å°†å…¶è§†ä¸ºä¸€ä¸ªé€šç”¨çš„ JavaScript å¹³å°ã€‚
- en: '**Build Tooling and Frontend Development:** This is arguably the biggest area
    of growth. Tools like [Webpack](https://webpack.js.org/), [esbuild](https://esbuild.github.io/),
    [Vite](https://vitejs.dev/), and the TypeScript compiler are all Node.js applications.
    If you''ve ever worked on a modern frontend project (React, Vue, Angular, etc.),
    you have used Node.js extensively, even if you never wrote a single line of backend
    code. The entire development workflow - bundling, transpiling, code-linting, running
    a dev server - is powered by the Node runtime.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ„å»ºå·¥å…·å’Œå‰ç«¯å¼€å‘ï¼š** è¿™å¯ä»¥è¯´æ˜¯å¢é•¿æœ€å¤§çš„é¢†åŸŸã€‚åƒ [Webpack](https://webpack.js.org/)ã€[esbuild](https://esbuild.github.io/)ã€[Vite](https://vitejs.dev/)
    å’Œ TypeScript ç¼–è¯‘å™¨ç­‰å·¥å…·éƒ½æ˜¯ Node.js åº”ç”¨ç¨‹åºã€‚å¦‚æœä½ æ›¾ç»å‚ä¸è¿‡ç°ä»£å‰ç«¯é¡¹ç›®ï¼ˆReactã€Vueã€Angular ç­‰ï¼‰ï¼Œä½ è‚¯å®šå¹¿æ³›ä½¿ç”¨äº†
    Node.jsï¼Œå³ä½¿ä½ ä»æœªç¼–å†™è¿‡ä»»ä½•åç«¯ä»£ç ã€‚æ•´ä¸ªå¼€å‘å·¥ä½œæµç¨‹â€”â€”æ‰“åŒ…ã€è½¬è¯‘ã€ä»£ç æ£€æŸ¥ã€è¿è¡Œå¼€å‘æœåŠ¡å™¨â€”â€”éƒ½æ˜¯ç”± Node è¿è¡Œæ—¶é©±åŠ¨çš„ã€‚'
- en: '**Desktop Applications:** Frameworks like [Electron](https://www.electronjs.org/)
    (which powers VS Code, Slack, Discord, and Figma) and [Tauri](https://tauri.app/)
    allow you to build cross-platform desktop applications using web technologies
    (HTML, CSS, JavaScript). They do this by bundling a browser rendering engine (Chromium)
    with the Node.js runtime, giving your JavaScript code access to the full capabilities
    of the host operating system.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ¡Œé¢åº”ç”¨ç¨‹åºï¼š** ç±»ä¼¼äº [Electron](https://www.electronjs.org/)ï¼ˆä¸º VS Codeã€Slackã€Discord
    å’Œ Figma æä¾›åŠ¨åŠ›ï¼‰å’Œ [Tauri](https://tauri.app/) çš„æ¡†æ¶å…è®¸ä½ ä½¿ç”¨ Web æŠ€æœ¯æ„å»ºè·¨å¹³å°æ¡Œé¢åº”ç”¨ç¨‹åºï¼ˆHTMLã€CSSã€JavaScriptï¼‰ã€‚å®ƒä»¬é€šè¿‡å°†æµè§ˆå™¨æ¸²æŸ“å¼•æ“ï¼ˆChromiumï¼‰ä¸
    Node.js è¿è¡Œæ—¶æ†ç»‘åœ¨ä¸€èµ·æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œä½¿ä½ çš„ JavaScript ä»£ç èƒ½å¤Ÿè®¿é—®å®¿ä¸»æ“ä½œç³»ç»Ÿçš„å…¨éƒ¨åŠŸèƒ½ã€‚'
- en: '**Command-Line Interface (CLI) Tools:** Node is an excellent choice for building
    fast and powerful CLI tools. The npm registry is full of them, from project scaffolder''s
    like `create-react-app` to cloud infrastructure tools like the AWS CDK. Its cross-platform
    nature and rich ecosystem make it easy to build complex command-line applications.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å‘½ä»¤è¡Œç•Œé¢ï¼ˆCLIï¼‰å·¥å…·ï¼š** Node æ˜¯æ„å»ºå¿«é€Ÿä¸”å¼ºå¤§çš„ CLI å·¥å…·çš„ç»ä½³é€‰æ‹©ã€‚npm æ³¨å†Œè¡¨ä¸­æœ‰å¤§é‡æ­¤ç±»å·¥å…·ï¼Œä»é¡¹ç›®è„šæ‰‹æ¶å¦‚ `create-react-app`
    åˆ°äº‘åŸºç¡€è®¾æ–½å·¥å…·å¦‚ AWS CDKã€‚å…¶è·¨å¹³å°ç‰¹æ€§å’Œä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿä½¿å¾—æ„å»ºå¤æ‚çš„å‘½ä»¤è¡Œåº”ç”¨ç¨‹åºå˜å¾—å®¹æ˜“ã€‚'
- en: '**Serverless and Edge Computing:** Node''s fast startup time and low memory
    footprint make it a perfect fit for serverless platforms like AWS Lambda, Google
    Cloud Functions, and Vercel. You can deploy small, single-purpose functions that
    spin up, handle an event, and spin down, paying only for what you use. This deployment
    model is a natural extension of Node''s event-driven philosophy.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ— æœåŠ¡å™¨å’Œè¾¹ç¼˜è®¡ç®—ï¼š** Node å¿«é€Ÿå¯åŠ¨æ—¶é—´å’Œä½å†…å­˜å ç”¨ä½¿å…¶éå¸¸é€‚åˆ AWS Lambdaã€Google Cloud Functions å’Œ
    Vercel ç­‰æ— æœåŠ¡å™¨å¹³å°ã€‚ä½ å¯ä»¥éƒ¨ç½²å°å‹ã€å•ä¸€ç”¨é€”çš„å‡½æ•°ï¼Œè¿™äº›å‡½æ•°å¯åŠ¨ã€å¤„ç†äº‹ä»¶ç„¶åå…³é—­ï¼Œåªéœ€ä¸ºä½¿ç”¨çš„éƒ¨åˆ†ä»˜è´¹ã€‚è¿™ç§éƒ¨ç½²æ¨¡å‹æ˜¯ Node äº‹ä»¶é©±åŠ¨å“²å­¦çš„è‡ªç„¶æ‰©å±•ã€‚'
- en: âš ï¸Warning
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: âš ï¸è­¦å‘Š
- en: 'Nodeâ€™s fast startup often matches serverless workloads well, but beware cold
    starts for functions with large dependency trees or heavy initialization. Edge
    runtimes (V8 isolates) and serverless function containers are different: edge
    functions often limit APIs, memory, and CPU time.'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Node çš„å¿«é€Ÿå¯åŠ¨é€šå¸¸ä¸æ— æœåŠ¡å™¨å·¥ä½œè´Ÿè½½å¾ˆå¥½åœ°åŒ¹é…ï¼Œä½†è¦æ³¨æ„å…·æœ‰å¤§å‹ä¾èµ–æ ‘æˆ–é‡åˆå§‹åŒ–çš„å‡½æ•°çš„å†·å¯åŠ¨ã€‚è¾¹ç¼˜è¿è¡Œæ—¶ï¼ˆV8 ç‹¬ç«‹ï¼‰å’Œæ— æœåŠ¡å™¨å‡½æ•°å®¹å™¨æ˜¯ä¸åŒçš„ï¼šè¾¹ç¼˜å‡½æ•°é€šå¸¸é™åˆ¶
    APIã€å†…å­˜å’Œ CPU æ—¶é—´ã€‚
- en: The point is, even if your primary job isn't writing Node.js backend services,
    you are almost certainly interacting with the Node.js runtime and its ecosystem
    on a daily basis. Understanding its architecture is no longer a niche skill for
    backend engineers; it's a foundational skill for any modern web or software developer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: é‡ç‚¹æ˜¯ï¼Œå³ä½¿ä½ çš„ä¸»è¦å·¥ä½œä¸æ˜¯ç¼–å†™ Node.js åç«¯æœåŠ¡ï¼Œä½ å‡ ä¹è‚¯å®šæ¯å¤©éƒ½åœ¨ä¸ Node.js è¿è¡Œæ—¶åŠå…¶ç”Ÿæ€ç³»ç»Ÿäº’åŠ¨ã€‚ç†è§£å…¶æ¶æ„ä¸å†æ˜¯åç«¯å·¥ç¨‹å¸ˆçš„åˆ©åŸºæŠ€èƒ½ï¼›å®ƒå·²æˆä¸ºä»»ä½•ç°ä»£
    Web æˆ–è½¯ä»¶å¼€å‘è€…çš„åŸºç¡€æŠ€èƒ½ã€‚
- en: Practical Checklist & Takeaways
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å®ç”¨æ¸…å•ä¸æ”¶è·
- en: This was a dense chapter. If you walk away with nothing else, burn these ideas
    into your brain. This is your core mental model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ç« å†…å®¹å¯†é›†çš„ç« èŠ‚ã€‚å¦‚æœä½ æ²¡æœ‰å…¶ä»–æ”¶è·ï¼Œè¯·å°†è¿™äº›æƒ³æ³•é“­è®°åœ¨å¿ƒã€‚è¿™æ˜¯ä½ çš„æ ¸å¿ƒæ€ç»´æ¨¡å‹ã€‚
- en: '**Node is a runtime, not a language.** It executes JavaScript using the V8
    engine and gives it server-side powers (like file and network access) through
    the `libuv` library.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶ï¼Œè€Œä¸æ˜¯ä¸€ç§è¯­è¨€ã€‚** å®ƒä½¿ç”¨ V8 å¼•æ“æ‰§è¡Œ JavaScriptï¼Œå¹¶é€šè¿‡ `libuv` åº“èµ‹äºˆå®ƒæœåŠ¡å™¨ç«¯åŠŸèƒ½ï¼ˆå¦‚æ–‡ä»¶å’Œç½‘ç»œè®¿é—®ï¼‰ã€‚'
- en: '**The mission: Don''t Block The Event Loop.** Every design choice in Node pushes
    you towards an asynchronous, non-blocking pattern. A blocked loop means your server
    is dead in the water, unable to handle new requests.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä»»åŠ¡ï¼šä¸è¦é˜»å¡äº‹ä»¶å¾ªç¯ã€‚** Node ä¸­çš„æ¯ä¸ªè®¾è®¡é€‰æ‹©éƒ½æ¨åŠ¨ä½ æœç€å¼‚æ­¥ã€éé˜»å¡çš„æ¨¡å¼å‘å±•ã€‚é˜»å¡çš„å¾ªç¯æ„å‘³ç€ä½ çš„æœåŠ¡å™¨å°†é™·å…¥åœæ»ï¼Œæ— æ³•å¤„ç†æ–°çš„è¯·æ±‚ã€‚'
- en: '**Your JS is single-threaded; the runtime is not.** You write your application
    code on a single main thread, which simplifies concurrency. But `libuv` uses a
    small thread pool in the background for certain heavy operations to protect the
    main thread from blocking.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä½ çš„ JavaScript æ˜¯å•çº¿ç¨‹çš„ï¼›è¿è¡Œæ—¶ä¸æ˜¯ã€‚** ä½ åœ¨å•ä¸ªä¸»çº¿ç¨‹ä¸Šç¼–å†™åº”ç”¨ç¨‹åºä»£ç ï¼Œè¿™ç®€åŒ–äº†å¹¶å‘ã€‚ä½† `libuv` åœ¨åå°ä½¿ç”¨ä¸€ä¸ªå°å‹çº¿ç¨‹æ± æ¥æ‰§è¡ŒæŸäº›é‡æ“ä½œï¼Œä»¥ä¿æŠ¤ä¸»çº¿ç¨‹ä¸è¢«é˜»å¡ã€‚'
- en: '**Think in events, not sequences.** Instead of a linear script, a Node application
    is a collection of event handlers (callbacks, Promises) waiting to be triggered
    by the event loop. Your job is to set up these listeners correctly.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä»¥äº‹ä»¶ä¸ºå¯¼å‘ï¼Œè€Œä¸æ˜¯ä»¥åºåˆ—ä¸ºå¯¼å‘ã€‚** Node åº”ç”¨ç¨‹åºä¸æ˜¯çº¿æ€§è„šæœ¬ï¼Œè€Œæ˜¯ä¸€ç»„ç­‰å¾…ç”±äº‹ä»¶å¾ªç¯è§¦å‘çš„å¤„ç†ç¨‹åºï¼ˆå›è°ƒã€Promiseï¼‰ã€‚ä½ çš„ä»»åŠ¡æ˜¯æ­£ç¡®è®¾ç½®è¿™äº›ç›‘å¬å™¨ã€‚'
- en: '**The ecosystem (`npm`) is both your greatest asset and a potential liability.**
    It gives you incredible speed, but you must be mindful of your dependency tree.
    Use lockfiles and security auditing tools religiously.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç”Ÿæ€ç³»ç»Ÿï¼ˆ`npm`ï¼‰æ—¢æ˜¯ä½ çš„æœ€å¤§èµ„äº§ï¼Œä¹Ÿæ˜¯æ½œåœ¨çš„é£é™©ã€‚**å®ƒç»™ä½ å¸¦æ¥æƒŠäººçš„é€Ÿåº¦ï¼Œä½†ä½ å¿…é¡»æ³¨æ„ä½ çš„ä¾èµ–æ ‘ã€‚è™”è¯šåœ°ä½¿ç”¨é”æ–‡ä»¶å’Œå®‰å…¨å®¡è®¡å·¥å…·ã€‚'
- en: '**Node is bigger than the backend.** It''s the engine driving modern frontend
    development, desktop apps, CLIs, and serverless computing. Understanding it is
    fundamental to being a modern developer.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nodeä¸ä»…ä»…æ˜¯ä¸€ä¸ªåç«¯ã€‚**å®ƒæ˜¯æ¨åŠ¨ç°ä»£å‰ç«¯å¼€å‘ã€æ¡Œé¢åº”ç”¨ç¨‹åºã€å‘½ä»¤è¡Œç•Œé¢å’Œæ— æœåŠ¡å™¨è®¡ç®—çš„åŠ¨åŠ›å¼•æ“ã€‚ç†è§£å®ƒæ˜¯æˆä¸ºç°ä»£å¼€å‘è€…çš„åŸºç¡€ã€‚'
- en: Closing Thoughts
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“æŸè¯­
- en: We've covered a lot of ground - from a historical problem with web servers to
    the architecture of the runtime and the culture of its ecosystem.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»è¦†ç›–äº†å¾ˆå¤šå†…å®¹â€”â€”ä»ç½‘ç»œæœåŠ¡å™¨çš„å†å²é—®é¢˜åˆ°è¿è¡Œæ—¶æ¶æ„åŠå…¶ç”Ÿæ€ç³»ç»Ÿæ–‡åŒ–ã€‚
- en: The most important thing you can take from this is a robust mental model. Don't
    think of Node as just "JavaScript on the server."
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ä»è¿™é‡Œè·å¾—çš„æœ€é‡è¦çš„äº‹æƒ…æ˜¯ä¸€ä¸ªå¼ºå¤§çš„å¿ƒæ™ºæ¨¡å‹ã€‚ä¸è¦æŠŠNodeä»…ä»…çœ‹ä½œæ˜¯â€œæœåŠ¡å™¨ä¸Šçš„JavaScriptâ€ã€‚
- en: Think of it as an **asynchronous event-driven I/O platform that happens to use
    JavaScript as its scripting language.**
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡å®ƒæ˜¯ä¸€ä¸ª**å¼‚æ­¥äº‹ä»¶é©±åŠ¨çš„I/Oå¹³å°ï¼Œæ°å¥½ä½¿ç”¨JavaScriptä½œä¸ºå…¶è„šæœ¬è¯­è¨€**ã€‚
- en: That's a mouthful, but every word matters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¯å¬èµ·æ¥å¾ˆå¤šï¼Œä½†æ¯ä¸ªè¯éƒ½å¾ˆé‡è¦ã€‚
- en: '**Asynchronous:** It doesn''t wait for slow things.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¼‚æ­¥ï¼š**å®ƒä¸ä¼šç­‰å¾…ç¼“æ…¢çš„äº‹æƒ…ã€‚'
- en: '**Event-driven:** It reacts to events as they complete.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**äº‹ä»¶é©±åŠ¨ï¼š**å®ƒåœ¨äº‹ä»¶å®Œæˆæ—¶åšå‡ºååº”ã€‚'
- en: '**I/O platform:** Its specialty is shuffling data around - from networks to
    disks to databases - with extreme efficiency.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I/Oå¹³å°ï¼š**å…¶ç‰¹è‰²åœ¨äºä»¥æé«˜çš„æ•ˆç‡åœ¨å„ä¸ªåœ°æ–¹ä¹‹é—´ç§»åŠ¨æ•°æ®â€”â€”ä»ç½‘ç»œåˆ°ç£ç›˜å†åˆ°æ•°æ®åº“ã€‚'
- en: V8 makes it fast. `libuv` makes it asynchronous. The ecosystem gives it reach.
    Together, these three elements created a platform that fundamentally changed how
    we build for the web.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: V8è®©å®ƒå˜å¾—å¿«é€Ÿã€‚`libuv`è®©å®ƒå¼‚æ­¥ã€‚ç”Ÿæ€ç³»ç»Ÿèµ‹äºˆå®ƒèŒƒå›´ã€‚è¿™ä¸‰ä¸ªå…ƒç´ å…±åŒåˆ›é€ äº†ä¸€ä¸ªä»æ ¹æœ¬ä¸Šæ”¹å˜äº†æˆ‘ä»¬åœ¨ç½‘ç»œä¸Šæ„å»ºæ–¹å¼çš„å¹³å°ã€‚
- en: Now that we have the 30,000-foot overview, it's time to zoom in. In the next
    chapter, we're going to get our hands dirty with one of the most fundamental concepts
    of Node.js - the v8 compiler (`Ignition`, `SparkPlug` and `Turbofan`).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†30,000è‹±å°ºçš„æ¦‚è§ˆï¼Œæ˜¯æ—¶å€™æ”¾å¤§è§†è§’äº†ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ·±å…¥æ¢è®¨Node.jsæœ€åŸºæœ¬çš„æ¦‚å¿µä¹‹ä¸€â€”â€”v8ç¼–è¯‘å™¨ï¼ˆ`Ignition`ã€`SparkPlug`å’Œ`Turbofan`ï¼‰ã€‚
