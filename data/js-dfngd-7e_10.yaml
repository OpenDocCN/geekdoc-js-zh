- en: Chapter 10\. Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 模块
- en: The goal of modular programming is to allow large programs to be assembled using
    modules of code from disparate authors and sources and for all of that code to
    run correctly even in the presence of code that the various module authors did
    not anticipate. As a practical matter, modularity is mostly about encapsulating
    or hiding private implementation details and keeping the global namespace tidy
    so that modules cannot accidentally modify the variables, functions, and classes
    defined by other modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程的目标是允许从不同作者和来源的代码模块组装大型程序，并且所有这些代码在各个模块作者未预料到的代码存在的情况下仍能正确运行。 从实际角度来看，模块化主要是关于封装或隐藏私有实现细节，并保持全局命名空间整洁，以便模块不会意外修改其他模块定义的变量、函数和类。
- en: Until recently, JavaScript had no built-in support for modules, and programmers
    working on large code bases did their best to use the weak modularity available
    through classes, objects, and closures. Closure-based modularity, with support
    from code-bundling tools, led to a practical form of modularity based on a `require()`
    function, which was adopted by Node. `require()`-based modules are a fundamental
    part of the Node programming environment but were never adopted as an official
    part of the JavaScript language. Instead, ES6 defines modules using `import` and
    `export` keywords. Although `import` and `export` have been part of the language
    for years, they were only implemented by web browsers and Node relatively recently.
    And, as a practical matter, JavaScript modularity still depends on code-bundling
    tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，JavaScript没有内置模块支持，而在大型代码库上工作的程序员尽力利用类、对象和闭包提供的弱模块化。基于闭包的模块化，结合代码捆绑工具的支持，形成了一种基于`require()`函数的实用模块化形式，这被Node所采用。
    基于`require()`的模块是Node编程环境的基本组成部分，但从未被正式纳入JavaScript语言的一部分。 相反，ES6使用`import`和`export`关键字定义模块。
    尽管`import`和`export`多年来一直是语言的一部分，但它们最近才被Web浏览器和Node实现。 作为一个实际问题，JavaScript模块化仍然依赖于代码捆绑工具。
- en: 'The sections that follow cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节涵盖：
- en: Do-it-yourself modules with classes, objects, and closures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类、对象和闭包自行创建模块
- en: Node modules using `require()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`require()`的Node模块
- en: ES6 modules using `export`, `import`, and `import()`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`export`、`import`和`import()`的ES6模块
- en: 10.1 Modules with Classes, Objects, and Closures
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.1 使用类、对象和闭包的模块
- en: 'Though it may be obvious, it is worth pointing out that one of the important
    features of classes is that they act as modules for their methods. Think back
    to [Example 9-8](ch09.xhtml#sets.js). That example defined a number of different
    classes, all of which had a method named `has()`. But you would have no problem
    writing a program that used multiple set classes from that example: there is no
    danger that the implementation of `has()` from SingletonSet will overwrite the
    `has()` method of BitSet, for example.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能是显而易见的，但值得指出的是，类的一个重要特性是它们作为其方法的模块。 回想一下[示例 9-8](ch09.xhtml#sets.js)。 该示例定义了许多不同的类，所有这些类都有一个名为`has()`的方法。
    但是，您可以毫无问题地编写一个使用该示例中多个集合类的程序：例如，SingletonSet的`has()`方法不会覆盖BitSet的`has()`方法。
- en: 'The reason that the methods of one class are independent of the methods of
    other, unrelated classes is that the methods of each class are defined as properties
    of independent prototype objects. The reason that classes are modular is that
    objects are modular: defining a property in a JavaScript object is a lot like
    declaring a variable, but adding properties to objects does not affect the global
    namespace of a program, nor does it affect the properties of other objects. JavaScript
    defines quite a few mathematical functions and constants, but instead of defining
    them all globally, they are grouped as properties of a single global Math object.
    This same technique could have been used in [Example 9-8](ch09.xhtml#sets.js).
    Instead of defining global classes with names like SingletonSet and BitSet, that
    example could have been written to define only a single global Sets object, with
    properties referencing the various classes. Users of this Sets library could then
    refer to the classes with names like `Sets.Singleton` and `Sets.Bit`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的方法独立于其他不相关类的方法的原因是，每个类的方法被定义为独立原型对象的属性。 类是模块化的原因是对象是模块化的：在JavaScript对象中定义属性很像声明变量，但向对象添加属性不会影响程序的全局命名空间，也不会影响其他对象的属性。
    JavaScript定义了相当多的数学函数和常量，但是不是将它们全部定义为全局的，而是将它们作为单个全局Math对象的属性分组。 这种技术可以在[示例 9-8](ch09.xhtml#sets.js)中使用。
    该示例可以被编写为仅定义一个名为Sets的全局对象，其属性引用各种类。 使用此Sets库的用户可以使用类似`Sets.Singleton`和`Sets.Bit`��名称引用类。
- en: Using classes and objects for modularity is a common and useful technique in
    JavaScript programming, but it doesn’t go far enough. In particular, it doesn’t
    offer us any way to hide internal implementation details inside the module. Consider
    [Example 9-8](ch09.xhtml#sets.js) again. If we were writing that example as a
    module, maybe we would have wanted to keep the various abstract classes internal
    to the module, only making the concrete subclasses available to users of the module.
    Similarly, in the BitSet class, the `_valid()` and `_has()` methods are internal
    utilities that should not really be exposed to users of the class. And `BitSet.bits`
    and `BitSet.masks` are implementation details that would be better off hidden.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript编程中，使用类和对象进行模块化是一种常见且有用的技术，但这还不够。 特别是，它没有提供任何隐藏模块内部实现细节的方法。 再次考虑[示例
    9-8](ch09.xhtml#sets.js)。 如果我们将该示例编写为一个模块，也许我们希望将各种抽象类保留在模块内部，只将具体子类提供给模块的用户。
    同样，在BitSet类中，`_valid()`和`_has()`方法是内部实用程序，不应该真正暴露给类的用户。 `BitSet.bits`和`BitSet.masks`是最好隐藏的实现细节。
- en: 'As we saw in [§8.6](ch08.xhtml#closures), local variables and nested functions
    declared within a function are private to that function. This means that we can
    use immediately invoked function expressions to achieve a kind of modularity by
    leaving the implementation details and utility functions hidden within the enclosing
    function but making the public API of the module the return value of the function.
    In the case of the BitSet class, we might structure the module like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [§8.6](ch08.xhtml#closures) 中看到的，函数内声明的局部变量和嵌套函数对该函数是私有的。这意味着我们可以使用立即调用的函数表达式通过将实现细节和实用函数隐藏在封闭函数中，使模块的公共
    API 成为函数的返回值来实现一种模块化。对于 BitSet 类，我们可以将模块结构化如下：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This approach to modularity becomes a little more interesting when the module
    has more than one item in it. The following code, for example, defines a mini
    statistics module that exports `mean()` and `stddev()` functions while leaving
    the implementation details hidden:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块中有多个项时，这种模块化方法变得更加有趣。例如，以下代码定义了一个迷你统计模块，导出 `mean()` 和 `stddev()` 函数，同时隐藏了实现细节：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 10.1.1 Automating Closure-Based Modularity
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1.1 自动化基于闭包的模块化
- en: Note that it is a fairly mechanical process to transform a file of JavaScript
    code into this kind of module by inserting some text at the beginning and end
    of the file. All that is needed is some convention for the file of JavaScript
    code to indicate which values are to be exported and which are not.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将 JavaScript 代码文件转换为这种模块的过程是一个相当机械化的过程，只需在文件开头和结尾插入一些文本即可。所需的只是一些约定，用于指示哪些值要导出，哪些不要导出。
- en: 'Imagine a tool that takes a set of files, wraps the content of each of those
    files within an immediately invoked function expression, keeps track of the return
    value of each function, and concatenates everything into one big file. The result
    might look something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个工具，它接受一组文件，将每个文件的内容包装在立即调用的函数表达式中，跟踪每个函数的返回值，并将所有内容连接成一个大文件。结果可能看起来像这样：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With modules bundled up into a single file like the one shown in the preceding
    example, you can imagine writing code like the following to make use of those
    modules:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块捆绑成一个单一文件，就像前面示例中所示的那样，你可以想象编写以下代码来利用这些模块：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is a rough sketch of how code-bundling tools (such as webpack and
    Parcel) for web browsers work, and it’s also a simple introduction to the `require()`
    function like the one used in Node programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是对代码捆绑工具（如 webpack 和 Parcel）在 web 浏览器中的工作原理的粗略草图，也是对类似于 Node 程序中使用的 `require()`
    函数的简单介绍。
- en: 10.2 Modules in Node
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.2 Node 模块
- en: In Node programming, it is normal to split programs into as many files as seems
    natural. These files of JavaScript code are assumed to all live on a fast filesystem.
    Unlike web browsers, which have to read files of JavaScript over a relatively
    slow network connection, there is no need or benefit to bundling a Node program
    into a single JavaScript file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 编程中，将程序分割为尽可能多的文件是很正常的。这些 JavaScript 代码文件都假定存在于一个快速的文件系统上。与 web 浏览器不同，后者必须通过相对较慢的网络连接读取
    JavaScript 文件，将 Node 程序捆绑成一个单一的 JavaScript 文件既没有必要也没有好处。
- en: In Node, each file is an independent module with a private namespace. Constants,
    variables, functions, and classes defined in one file are private to that file
    unless the file exports them. And values exported by one module are only visible
    in another module if that module explicitly imports them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，每个文件都是具有私有命名空间的独立模块。在一个文件中定义的常量、变量、函数和类对该文件是私有的，除非文件导出它们。一个模块导出的值只有在另一个模块明确导入它们时才能看到。
- en: Node modules import other modules with the `require()` function and export their
    public API by setting properties of the Exports object or by replacing the `module.exports`object
    entirely.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node 模块通过 `require()` 函数导入其他模块，并通过设置 Exports 对象的属性或完全替换 `module.exports` 对象来导出它们的公共
    API。
- en: 10.2.1 Node Exports
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.1 Node 导出
- en: 'Node defines a global `exports` object that is always defined. If you are writing
    a Node module that exports multiple values, you can simply assign them to the
    properties of this object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node 定义了一个全局的 `exports` 对象，它总是被定义。如果你正在编写一个导出多个值的 Node 模块，你可以简单地将它们分配给这个对象的属性：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Often, however, you want to define a module that exports only a single function
    or class rather than an object full of functions or classes. To do this, you simply
    assign the single value you want to export to `module.exports`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，你可能只想定义一个仅导出单个函数或类的模块，而不是一个充满函数或类的对象。为此，你只需将要导出的单个值分配给 `module.exports`：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The default value of `module.exports` is the same object that `exports` refers
    to. In the previous stats module, we could have assigned the mean function to
    `module.exports.mean` instead of `exports.mean`. Another approach with modules
    like the stats module is to export a single object at the end of the module rather
    than exporting functions one by one as you go:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.exports` 的默认值是 `exports` 所指向的相同对象。在之前的 stats 模块中，我们可以将 mean 函数分配给 `module.exports.mean`
    而不是 `exports.mean`。像 stats 模块这样的模块的另一种方法是在模块末尾导出一个单一对象，而不是在导出函数时逐个导出：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 10.2.2 Node Imports
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.2 Node 导入
- en: A Node module imports another module by calling the `require()` function. The
    argument to this function is the name of the module to be imported, and the return
    value is whatever value (typically a function, class, or object) that module exports.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node 模块通过调用 `require()` 函数来导入另一个模块。这个函数的参数是要导入的模块的名称，返回值是该模块导出的任何值（通常是一个函数、类或对象）。
- en: 'If you want to import a system module built in to Node or a module that you
    have installed on your system via a package manager, then you simply use the unqualified
    name of the module, without any “/” characters that would turn it into a filesystem
    path:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想导入 Node 内置的系统模块或通过包管理器在系统上安装的模块，那么你只需使用模块的未限定名称，不需要任何将其转换为文件系统路径的“/”字符：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you want to import a module of your own code, the module name should be
    the path to the file that contains that code, relative to the current module’s
    file. It is legal to use absolute paths that begin with a */* character, but typically,
    when importing modules that are part of your own program, the module names will
    begin with *./* or sometimes *../* to indicate that they are relative to the current
    directory or the parent directory. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要导入自己代码的模块时，模块名称应该是包含该代码的文件的路径，相对于当前模块文件。使用以*/*字符开头的绝对路径是合法的，但通常，当导入属于您自己程序的模块时，模块名称将以*./
    *或有时是*../ *开头，以指示它们相对于当前目录或父目录。例如：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (You can also omit the *.js* suffix on the files you’re importing and Node will
    still find the files, but it is common to see these file extensions explicitly
    included.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: （您也可以省略导入文件的*.js*后缀，Node仍然可以找到这些文件，但通常会看到这些文件扩展名明确包含在内。）
- en: 'When a module exports just a single function or class, all you have to do is
    require it. When a module exports an object with multiple properties, you have
    a choice: you can import the entire object, or just import the specific properties
    (using destructuring assignment) of the object that you plan to use. Compare these
    two approaches:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块只导出一个函数或类时，您只需导入它。当一个模块导出一个具有多个属性的对象时，您可以选择：您可以导入整个对象，或者只导入您打算使用的对象的特定属性（使用解构赋值）。比较这两种方法：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 10.2.3 Node-Style Modules on the Web
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2.3 Web上的Node风格模块
- en: Modules with an Exports object and a `require()` function are built in to Node.
    But if you’re willing to process your code with a bundling tool like webpack,
    then it is also possible to use this style of modules for code that is intended
    to run in web browsers. Until recently, this was a very common thing to do, and
    you may see lots of web-based code that still does it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 具有Exports对象和`require()`函数的模块内置于Node中。但是，如果您愿意使用像webpack这样的捆绑工具处理您的代码，那么也可以将这种模块样式用于旨在在Web浏览器中运行的代码。直到最近，这是一种非常常见的做法，您可能会看到许多仍在这样做的基于Web的代码。
- en: Now that JavaScript has its own standard module syntax, however, developers
    who use bundlers are more likely to use the official JavaScript modules with `import`
    and `export` statements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在JavaScript有了自己的标准模块语法，然而，使用捆绑工具的开发人员更有可能使用带有`import`和`export`语句的官方JavaScript模块。
- en: 10.3 Modules in ES6
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.3 ES6中的模块
- en: 'ES6 adds `import` and `export` keywords to JavaScript and finally supports
    real modularity as a core language feature. ES6 modularity is conceptually the
    same as Node modularity: each file is its own module, and constants, variables,
    functions, and classes defined within a file are private to that module unless
    they are explicitly exported. Values that are exported from one module are available
    for use in modules that explicitly import them. ES6 modules differ from Node modules
    in the syntax used for exporting and importing and also in the way that modules
    are defined in web browsers. The sections that follow explain these things in
    detail.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ES6为JavaScript添加了`import`和`export`关键字，最终将真正的模块化支持作为核心语言特性。ES6的模块化在概念上与Node的模块化相同：每个文件都是自己的模块，文件中定义的常量、变量、函数和类除非明确导出，否则都是私有于该模块。从一个模块导出的值可以在明确导入它们的模块中使用。ES6模块在导出和导入的语法以及在Web浏览器中定义模块的方式上与Node模块不同。接下来的部分将详细解释这些内容。
- en: 'First, though, note that ES6 modules are also different from regular JavaScript
    “scripts” in some important ways. The most obvious difference is the modularity
    itself: in regular scripts, top-level declarations of variables, functions, and
    classes go into a single global context shared by all scripts. With modules, each
    file has its own private context and can use the `import` and `export` statements,
    which is the whole point, after all. But there are other differences between modules
    and scripts as well. Code inside an ES6 module (like code inside any ES6 `class`
    definition) is automatically in strict mode (see [§5.6.3](ch05.xhtml#strictmode)).
    This means that, when you start using ES6 modules, you’ll never have to write
    `"use strict"` again. And it means that code in modules cannot use the `with`
    statement or the `arguments` object or undeclared variables. ES6 modules are even
    slightly stricter than strict mode: in strict mode, in functions invoked as functions,
    `this` is `undefined`. In modules, `this` is `undefined` even in top-level code.
    (By contrast, scripts in web browsers and Node set `this` to the global object.)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，ES6模块在某些重要方面也与常规JavaScript“脚本”不同。最明显的区别是模块化本身：在常规脚本中，变量、函数和类的顶级声明进入由所有脚本共享的单个全局上下文中。使用模块后，每个文件都有自己的私有上下文，并且可以使用`import`和`export`语句，这毕竟是整个重点。但模块和脚本之间还有其他区别。ES6模块中的代码（就像ES6
    `class`定义内的代码一样）自动处于严格模式（参见[§5.6.3](ch05.xhtml#strictmode)）。这意味着，当您开始使用ES6模块时，您将永远不必再编写`"use
    strict"`。这意味着模块中的代码不能使用`with`语句或`arguments`对象或未声明的变量。ES6模块甚至比严格模式稍微严格：在严格模式中，作为函数调用的函数中，`this`是`undefined`。在模块中，即使在顶级代码中，`this`也是`undefined`。（相比之下，Web浏览器和Node中的脚本将`this`设置为全局对象。）
- en: ES6 Modules on the Web and in Node
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web上和Node中的ES6模块
- en: ES6 modules have been in use on the web for years with the help of code bundlers
    like webpack, which combine independent modules of JavaScript code into large,
    non-modular bundles suitable for inclusion into web pages. At the time of this
    writing, however, ES6 modules are finally supported natively by all web browsers
    other than Internet Explorer. When used natively, ES6 modules are added into HTML
    pages with a special `<script type="module">` tag, described later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，借助像webpack这样的代码捆绑工具，ES6模块已经在Web上得到了应用，这些工具将独立的JavaScript代码模块组合成大型、非模块化的捆绑包，适合包含在网页中。然而，在撰写本文时，除了Internet
    Explorer之外，所有Web浏览器终于原生支持ES6模块。在原生支持时，ES6模块通过特殊的`<script type="module">`标签添加到HTML页面中，本章后面将对此进行描述。
- en: And meanwhile, having pioneered JavaScript modularity, Node finds itself in
    the awkward position of having to support two not entirely compatible module systems.
    Node 13 supports ES6 modules, but for now, the vast majority of Node programs
    still use Node modules.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，作为JavaScript模块化的先驱，Node发现自己处于一个尴尬的位置，必须支持两种不完全兼容的模块系统。Node 13支持ES6模块，但目前，绝大多数Node程序仍然使用Node模块。
- en: 10.3.1 ES6 Exports
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.1 ES6导出
- en: 'To export a constant, variable, function, or class from an ES6 module, simply
    add the keyword `export` before the declaration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要从ES6模块中导出常量、变量、函数或类，只需在声明之前添加关键字`export`：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As an alternative to scattering `export` keywords throughout your module, you
    can define your constants, variables, functions, and classes as you normally would,
    with no `export` statement, and then (typically at the end of your module) write
    a single `export` statement that declares exactly what is exported in a single
    place. So instead of writing three individual exports in the preceding code, we
    could have equivalently written a single line at the end:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在模块中散布`export`关键字的替代方案，你可以像通常一样定义常量、变量、函数和类，不写任何`export`语句，然后（通常在模块的末尾）写一个单独的`export`语句，声明在一个地方精确地导出了什么。因此，与在前面的代码中写三个单独的导出相反，我们可以在末尾写一行等效的代码：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This syntax looks like the `export` keyword followed by an object literal (using
    shorthand notation). But in this case, the curly braces do not actually define
    an object literal. This export syntax simply requires a comma-separated list of
    identifiers within curly braces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来像是`export`关键字后跟一个对象字面量（使用简写表示法）。但在这种情况下，花括号实际上并没有定义一个对象字面量。这种导出语法只需要在花括号内写一个逗号分隔的标识符列表。
- en: 'It is common to write modules that export only one value (typically a function
    or class), and in this case, we usually use `export default` instead of `export`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编写只导出一个值（通常是函数或类）的模块很常见，在这种情况下，我们通常使用`export default`而不是`export`：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Default exports are slightly easier to import than non-default exports, so when
    there is only one exported value, using `export default` makes things easier for
    the modules that use your exported value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导出比非默认导出稍微容易导入，因此当只有一个导出值时，使用`export default`会使使用你导出值的模块更容易。
- en: Regular exports with `export` can only be done on declarations that have a name.
    Default exports with `export default` can export any expression including anonymous
    function expressions and anonymous class expressions. This means that if you use
    `export default`, you can export object literals. So unlike the `export` syntax,
    if you see curly braces after `export default`, it really is an object literal
    that is being exported.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`export`进行常规导出只能用于具有名称的声明。使用`export default`进行默认导出可以导出任何表达式，包括匿名函数表达式和匿名类表达式。这意味着如果你使用`export
    default`，你可以导出对象字面量。因此，与`export`语法不同，如果你在`export default`后看到花括号，那么实际上导出的是一个对象字面量。
- en: It is legal, but somewhat uncommon, for modules to have a set of regular exports
    and also a default export. If a module has a default export, it can only have
    one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块既有一组常规导出又有默认导出是合法的，但有些不太常见。如果一个模块有默认导出，它只���有一个。
- en: 'Finally, note that the `export` keyword can only appear at the top level of
    your JavaScript code. You may not export a value from within a class, function,
    loop, or conditional. (This is an important feature of the ES6 module system and
    enables static analysis: a modules export will be the same on every run, and the
    symbols exported can be determined before the module is actually run.)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意`export`关键字只能出现在你的JavaScript代码的顶层。你不能从类、函数、循环或条件语句中导出值。（这是ES6模块系统的一个重要特性，它实现了静态分析：模块的导出在每次运行时都是相同的，并且可以在模块实际运行之前确定导出的符号。）
- en: 10.3.2 ES6 Imports
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.2 ES6导入
- en: 'You import values that have been exported by other modules with the `import`
    keyword. The simplest form of import is used for modules that define a default
    export:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`import`关键字导入其他模块导出的值。最简单的导入形式用于定义默认导出的模块：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the `import` keyword, followed by an identifier, followed by the `from`
    keyword, followed by a string literal that names the module whose default export
    we are importing. The default export value of the specified module becomes the
    value of the specified identifier in the current module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`import`关键字，后面跟着一个标识符，然后是`from`关键字，后面是一个字符串字面量，命名了我们要导入默认导出的模块。指定模块的默认导出值成为当前模块中指定标识符的值。
- en: 'The identifier to which the imported value is assigned is a constant, as if
    it had been declared with the `const` keyword. Like exports, imports can only
    appear at the top level of a module and are not allowed within classes, functions,
    loops, or conditionals. By near-universal convention, the imports needed by a
    module are placed at the start of the module. Interestingly, however, this is
    not required: like function declarations, imports are “hoisted” to the top, and
    all imported values are available for any of the module’s code runs.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 导入值分配给的标识符是一个常量，就好像它已经用`const`关键字声明过一样。与导出一样，导入只能出现在模块的顶层，不允许在类、函数、循环或条件语句中。根据普遍惯例，模块所需的导入应放在模块的开头。然而有趣的是，这并非必须：像函数声明一样，导入被“提升”到顶部，所有导入的值在模块的任何代码运行时都可用。
- en: The module from which a value is imported is specified as a constant string
    literal in single quotes or double quotes. (You may not use a variable or other
    expression whose value is a string, and you may not use a string within backticks
    because template literals can interpolate variables and do not always have constant
    values.) In web browsers, this string is interpreted as a URL relative to the
    location of the module that is doing the importing. (In Node, or when using a
    bundling tool, the string is interpreted as a filename relative to the current
    module, but this makes little difference in practice.) A *module specifier* string
    must be an absolute path starting with “/”, or a relative path starting with “./”
    or “../”, or a complete URL a with protocol and hostname. The ES6 specification
    does not allow unqualified module specifier strings like “util.js” because it
    is ambiguous whether this is intended to name a module in the same directory as
    the current one or some kind of system module that is installed in some special
    location. (This restriction against “bare module specifiers” is not honored by
    code-bundling tools like webpack, which can easily be configured to find bare
    modules in a library directory that you specify.) A future version of the language
    may allow “bare module specifiers,” but for now, they are not allowed. If you
    want to import a module from the same directory as the current one, simply place
    “./” before the module name and import from “./util.js” instead of “util.js”.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 导入值的模块被指定为一个常量字符串文字，用单引号或双引号括起来。（您不能使用值为字符串的变量或其他表达式，也不能在反引号内使用字符串，因为模板文字可以插入变量并且不总是具有常量值。）在Web浏览器中，此字符串被解释为相对于执行导入操作的模块的位置的URL。（在Node中，或者使用捆绑工具时，该字符串被解释为相对于当前模块的文件名，但在实践中这几乎没有区别。）*模块规范符*字符串必须是以“/”开头的绝对路径，或以“./”或“../”开头的相对路径，或具有协议和主机名的完整URL。ES6规范不允许未经限定的模块规范符字符串，如“util.js”，因为不清楚这是否意味着要命名与当前目录中的模块或某种安装在某个特殊位置的系统模块。
    （这个对“裸模块规范符”的限制不被像webpack这样的代码捆绑工具所遵守，它可以很容易地配置为在您指定的库目录中找到裸模块。）语言的未来版本可能允许“裸模块规范符”，但目前不允许。如果要从与当前目录相同的目录导入模块，只需在模块名称前加上“./”，并从“./util.js”而不是“util.js”导入。
- en: 'So far, we’ve only considered the case of importing a single value from a module
    that uses `export default`. To import values from a module that exports multiple
    values, we use a slightly different syntax:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只考虑了从使用`export default`的模块导入单个值的情况。要从���出多个值的模块导入值，我们使用稍微不同的语法：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Recall that default exports do not need to have a name in the module that defines
    them. Instead, we provide a local name when we import those values. But non-default
    exports of a module do have names in the exporting module, and when we import
    those values, we refer to them by those names. The exporting module can export
    any number of named value. An `import` statement that references that module can
    import any subset of those values simply by listing their names within curly braces.
    The curly braces make this kind of `import` statement look something like a destructuring
    assignment, and destructuring assignment is actually a good analogy for what this
    style of import is doing. The identifiers within curly braces are all hoisted
    to the top of the importing module and behave like constants.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认导出在定义它们的模块中不需要名称。相反，当我们导入这些值时，我们提供一个本地名称。但是，模块的非默认导出在导出模块中有名称，当我们导入这些值时，我们通过这些名称引用它们。导出模块可以导出任意数量的命名值。引用该模块的`import`语句可以通过在花括号内列出它们的名称来导入这些值的任意子集。花括号使这种`import`语句看起来有点像解构赋值，实际上，解构赋值是这种导入样式在做的事情的一个很好的类比。花括号内的标识符都被提升到导入模块的顶部，并且行为像常量。
- en: 'Style guides sometimes recommend that you explicitly import every symbol that
    your module will use. When importing from a module that defines many exports,
    however, you can easily import everything with an `import` statement like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 样式指南有时建议您明确导入模块将使用的每个符号。但是，当从定义许多导出的模块导入时，您可以轻松地使用像这样的`import`语句导入所有内容：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'An `import` statement like this creates an object and assigns it to a constant
    named `stats`. Each of the non-default exports of the module being imported becomes
    a property of this `stats` object. Non-default exports always have names, and
    those are used as property names within the object. Those properties are effectively
    constants: they cannot be overwritten or deleted. With the wildcard import shown
    in the previous example, the importing module would use the imported `mean()`
    and `stddev()` functions through the `stats` object, invoking them as `stats.mean()`
    and `stats.stddev()`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的`import`语句会创建一个对象，并将其赋值给名为`stats`的常量。被导入模块的每个非默认导出都成为这个`stats`对象的属性。非默认导出始终有名称，并且这些名称在对象内部用作属性名称。这些属性实际上是常量：它们不能被覆盖或删除。在前面示例中显示的通配符导入中，导入模块将通过`stats`对象使用导入的`mean()`和`stddev()`函数，调用它们为`stats.mean()`和`stats.stddev()`。
- en: 'Modules typically define either one default export or multiple named exports.
    It is legal, but somewhat uncommon, for a module to use both `export` and `export
    default`. But when a module does that, you can import both the default value and
    the named values with an `import` statement like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模块通常定义一个默认导出或多个命名导出。一个模块同时使用`export`和`export default`是合法的，但有点不常见。但是当一个模块这样做时，您可以使用像这样的`import`语句同时导入默认值和命名值：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So far, we’ve seen how to import from modules with a default export and from
    modules with non-default or named exports. But there is one other form of the
    `import` statement that is used with modules that have no exports at all. To include
    a no-exports module into your program, simply use the `import` keyword with the
    module specifier:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何从具有默认导出的模块和具有非默认或命名导出的模块导入。但是还有一种`import`语句的形式，用于没有任何导出的模块。要将没有任何导出的模块包含到您的程序中，只需使用`import`关键字与模块规范符：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A module like this runs the first time it is imported. (And subsequent imports
    do nothing.) A module that just defines functions is only useful if it exports
    at least one of those functions. But if a module runs some code, then it can be
    useful to import even without symbols. An analytics module for a web application
    might run code to register various event handlers and then use those event handlers
    to send telemetry data back to the server at appropriate times. The module is
    self-contained and does not need to export anything, but we still need to `import`
    it so that it does actually run as part of our program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模块在第一次导入时运行。（随后的导入不会执行任何操作。）一个仅定义函数的模块只有在导出其中至少一个函数时才有用。但是，如果一个模块运行一些代码，那么即使没有符号，导入它也是有用的。一个用于
    Web 应用程序的分析模块可能会运行代码来注册各种事件处理程序，然后在适当的时候使用这些事件处理程序将遥测数据发送回服务器。该模块是自包含的，不需要导出任何内容，但我们仍然需要`import`它，以便它实际上作为我们程序的一部分运行。
- en: Note that you can use this import-nothing `import` syntax even with modules
    that do have exports. If a module defines useful behavior independent of the values
    it exports, and if your program does not need any of those exported values, you
    can still import the module . just for that default behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使有导出的模块，您也可以使用这种导入空内容的`import`语法。如果一个模块定义了独立于其导出值的有用行为，并且您的程序不需要任何这些导出值，您仍然可以导入该模块。只是为了那个默认行为。
- en: 10.3.3 Imports and Exports with Renaming
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.3 导入和重命名导出
- en: 'If two modules export two different values using the same name and you want
    to import both of those values, you will have to rename one or both of the values
    when you import it. Similarly, if you want to import a value whose name is already
    in use in your module, you will need to rename the imported value. You can use
    the `as` keyword with named imports to rename them as you import them:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个模块使用相同名称导出两个不同的值，并且您想要导入这两个值，那么在导入时您将需要重命名其中一个或两个值。同样，如果您想要导入一个名称已在您的模块中使用的值，那么您将需要重命名导入的值。您可以使用带有命名导入的`as`关键字来重命名它们：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These lines import two functions into the current module. The functions are
    both named `render()` in the modules that define them but are imported with the
    more descriptive and disambiguating names `renderImage()` and `renderUI()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将两个函数导入当前模块。这两个函数在定义它们的模块中都被命名为`render()`，但在导入时使用更具描述性和消除歧义的名称`renderImage()`和`renderUI()`。
- en: Recall that default exports do not have a name. The importing module always
    chooses the name when importing a default export. So there is no need for a special
    syntax for renaming in that case.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认导出没有名称。导入模块在导入默认导出时总是选择名称。因此，在这种情况下不需要特殊的重命名语法。
- en: 'Having said that, however, the possibility of renaming on import provides another
    way of importing from modules that define both a default export and named exports.
    Recall the “./histogram-stats.js” module from the previous section. Here is another
    way to import both the default and named exports of that module:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，但在导入时重命名的可能性提供了另一种从定义默认导出和命名导出的模块中导入的方式。回想一下前一节中的“./histogram-stats.js”模块。以下是导入该模块的默认导出和命名导出的另一种方式：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, the JavaScript keyword `default` serves as a placeholder and allows
    us to indicate that we want to import and provide a name for the default export
    of the module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，JavaScript 关键字`default`充当占位符，并允许我们指示我们要导入并为模块���默认导出提供名称。
- en: 'It is also possible to rename values as you export them, but only when using
    the curly brace variant of the `export` statement. It is not common to need to
    do this, but if you chose short, succinct names for use inside your module, you
    might prefer to export your values with more descriptive names that are less likely
    to conflict with other modules. As with imports, you use the `as` keyword to do
    this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在导出时重命名值，但只能在使用花括号变体的`export`语句时。通常不需要这样做，但如果您在模块内选择了简短、简洁的名称，您可能更喜欢使用更具描述性的名称导出值，这样就不太可能与其他模块发生冲突。与导入一样，您可以使用`as`关键字来执行此操作：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Keep in mind that, although the curly braces look something like object literals,
    they are not, and the `export` keyword expects a single identifier before the
    `as`, not an expression. This means, unfortunately, that you cannot use export
    renaming like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，尽管花括号看起来有点像对象文字，但它们并不是，`export`关键字在`as`之前期望一个标识符，而不是一个表达式。这意味着不幸的是，您不能像这样使用导出重命名：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 10.3.4 Re-Exports
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.4 重新导出
- en: Throughout this chapter, we’ve discussed a hypothetical “./stats.js” module
    that exports `mean()` and `stddev()` functions. If we were writing such a module
    and we thought that many users of the module would want only one function or the
    other, then we might want to define `mean()` in a “./stats/mean.js” module and
    define `stddev()` in “./stats/stddev.js”. That way, programs only need to import
    exactly the functions they need and are not bloated by importing code they do
    not need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一个假设的“./stats.js”模块，该模块导出`mean()`和`stddev()`函数。如果我们正在编写这样一个模块，并且我们认为该模块的许多用户只想要其中一个函数，那么我们可能希望在“./stats/mean.js”模块中定义`mean()`，在“./stats/stddev.js”中定义`stddev()`。这样，程序只需要导入它们需要的函数，而不会因导入不需要的代码而臃肿。
- en: Even if we had defined these statistical functions in individual modules, however,
    we might expect that there would be plenty of programs that want both functions
    and would appreciate a convenient “./stats.js” module from which they could import
    both on one line.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将这些统计函数定义在单独的模块中，我们可能仍然希望有很多程序需要这两个函数，并且希望有一个方便的“./stats.js”模块，可以在一行中导入这两个函数。
- en: 'Given that the implementations are now in separate files, defining this “./stat.js”
    module is simple:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于现在实现在单独的文件中，定义这个“./stat.js”模块很简单：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'ES6 modules anticipate this use case and provide a special syntax for it. Instead
    of importing a symbol simply to export it again, you can combine the import and
    the export steps into a single “re-export” statement that uses the `export` keyword
    and the `from` keyword:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块预期这种用法并为其提供了特殊的语法。不再简单地导入一个符号再导出它，你可以将导入和导出步骤合并为一个单独的“重新导出”语句，使用`export`关键字和`from`关键字：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the names `mean` and `stddev` are not actually used in this code.
    If we are not being selective with a re-export and simply want to export all of
    the named values from another module, we can use a wildcard:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码中实际上没有使用`mean`和`stddev`这两个名称。如果我们不选择性地重新导出并且只想从另一个模块导出所有命名值，我们可以使用通配符：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Re-export syntax allows renaming with `as` just as regular `import` and `export`
    statements do. Suppose we wanted to re-export the `mean()` function but also define
    `average()` as another name for the function. We could do that like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重新导出语法允许使用`as`进行重命名，就像常规的`import`和`export`语句一样。假设我们想要重新导出`mean()`函数，但同时为该函数定义`average()`作为另一个名称。我们可以这样做：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All of the re-exports in this example assume that the “./stats/mean.js” and
    “./stats/stddev.js” modules export their functions using `export` instead of `export
    default`. In fact, however, since these are modules with only a single export,
    it would have made sense to define them with `export default`. If we had done
    so, then the re-export syntax is a little more complicated because it needs to
    define a name for the unnamed default exports. We can do that like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ���示例中的所有重新导出都假定“./stats/mean.js”和“./stats/stddev.js”模块使用`export`而不是`export
    default`导出它们的函数。实际上，由于这些是只有一个导出的模块，定义为`export default`是有意义的。如果我们这样做了，那么重新导出语法会稍微复杂一些，因为它需要为未命名的默认导出定义一个名称。我们可以这样做：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want to re-export a named symbol from another module as the default
    export of your module, you could do an `import` followed by an `export default`,
    or you could combine the two statements like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将另一个模块的命名符号重新导出为你的模块的默认导出，你可以进行`import`，然后进行`export default`，或者你可以将这两个语句结合起来，像这样：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And finally, to re-export the default export of another module as the default
    export of your module (though it is unclear why you would want to do this, since
    users could simply import the other module directly), you can write:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要将另一个模块的默认导出重新导出为你的模块的默认导出（尽管不清楚为什么要这样做，因为用户可以直接导入另一个模块），你可以这样写：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 10.3.5 JavaScript Modules on the Web
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.5 Web上的JavaScript模块
- en: The preceding sections have described ES6 modules and their `import` and `export`
    declarations in a somewhat abstract manner. In this section and the next, we’ll
    be discussing how they actually work in web browsers, and if you are not already
    an experienced web developer, you may find the rest of this chapter easier to
    understand after you have read [Chapter 15](ch15.xhtml#clientside).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节以一种相对抽象的方式描述了ES6模块及其`import`和`export`声明。在本节和下一节中，我们将讨论它们在Web浏览器中的实际工作方式，如果你还不是一名经验丰富的Web开发人员，你可能会发现在阅读[第15章](ch15.xhtml#clientside)之后更容易理解本章的其余内容。
- en: As of early 2020, production code using ES6 modules is still generally bundled
    with a tool like webpack. There are trade-offs to doing this,^([1](ch10.xhtml#idm46198529362824))
    but on the whole, code bundling tends to give better performance. That may well
    change in the future as network speeds grow and browser vendors continue to optimize
    their ES6 module implementations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2020年初，使用ES6模块的生产代码仍然通常与类似webpack的工具捆绑在一起。这样做存在一些权衡之处，^([1](ch10.xhtml#idm46198529362824))但总体上，代码捆绑往往能提供更好的性能。随着网络速度的增长和浏览器厂商继续优化他们的ES6模块实现，这种情况可能会发生变化。
- en: Even though bundling tools may still be desirable in production, they are no
    longer required in development since all current browsers provide native support
    for JavaScript modules. Recall that modules use strict mode by default, `this`
    does not refer to a global object, and top-level declarations are not shared globally
    by default. Since modules must be executed differently than legacy non-module
    code, their introduction requires changes to HTML as well as JavaScript. If you
    want to natively use `import` directives in a web browser, you must tell the web
    browser that your code is a module by using a `<script type="module">` tag.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管捆绑工具在生产中仍然可取，但在开发中不再需要，因为所有当前的浏览器都提供了对JavaScript模块的原生支持。请记住，模块默认使用严格模式，`this`不指向全局对象，并且顶级声明默认情况下不会在全局范围内共享。由于模块必须以与传统非模块代码不同的方式执行，它们的引入需要对HTML和JavaScript进行更改。如果你想在Web浏览器中原生使用`import`指令，你必须通过使用`<script
    type="module">`标签告诉Web浏览器你的代码是一个模块。
- en: 'One of the nice features of ES6 modules is that each module has a static set
    of imports. So given a single starting module, a web browser can load all of its
    imported modules and then load all of the modules imported by that first batch
    of modules, and so on, until a complete program has been loaded. We’ve seen that
    the module specifier in an `import` statement can be treated as a relative URL.
    A `<script type="module">` tag marks the starting point of a modular program.
    None of the modules it imports are expected to be in `<script>` tags, however:
    instead, they are loaded on demand as regular JavaScript files and are executed
    in strict mode as regular ES6 modules. Using a `<script type="module">` tag to
    define the main entry point for a modular JavaScript program can be as simple
    as this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块的一个很好的特性是每个模块都有一个静态的导入集合。因此，给定一个起始模块，Web浏览器可以加载所有导入的模块，然后加载第一批模块导入的所有模块，依此类推，直到完整的程序被加载。我们已经看到`import`语句中的模块指示符可以被视为相对URL。`<script
    type="module">`标签标记了模块化程序的起点。然而，它导入的模块都不应该在`<script>`标签中，而是按需作为常规JavaScript文件加载，并像常规ES6模块一样以严格模式执行。使用`<script
    type="module">`标签来定义模块化JavaScript程序的主入口点可以像这样简单：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Code inside an inline `<script type="module">` tag is an ES6 module, and as
    such can use the `export` statement. There is not any point in doing so, however,
    because the HTML `<script>` tag syntax does not provide any way to define a name
    for inline modules, so even if such a module does export a value, there is no
    way for another module to import it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 内联`<script type="module">`标签中的代码是ES6模块，因此可以使用`export`语句。然而，这样做没有任何意义，因为HTML
    `<script>`标签语法没有提供任何定义内联模块名称的方式，因此，即使这样的模块导出一个值，也没有办法让另一个模块导入它。
- en: Scripts with the `type="module"` attribute are loaded and executed like scripts
    with the `defer` attribute. Loading of the code begins as soon as the HTML parser
    encounters the `<script>` tag (in the case of modules, this code-loading step
    may be a recursive process that loads multiple JavaScript files). But code execution
    does not begin until HTML parsing is complete. And once HTML parsing is complete,
    scripts (both modular and non) are executed in the order in which they appear
    in the HTML document.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`type="module"`属性的脚本会像带有`defer`属性的脚本一样加载和执行。代码加载会在HTML解析器遇到`<script>`标签时开始（在模块的情况下，这个代码加载步骤可能是一个递归过程，加载多个JavaScript文件）。但是代码执行直到HTML解析完成才开始。一旦HTML解析完成，脚本（模块和非模块）将按照它们在HTML文档中出现的顺序执行。
- en: You can modify the execution time of modules with the `async` attribute, which
    works the same way for modules that it does for regular scripts. An `async` module
    will execute as soon as the code is loaded, even if HTML parsing is not complete
    and even if this changes the relative ordering of the scripts.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`async`属性修改模块的执行时间，这对于模块和常规脚本的工作方式是相同的。`async`模块将在代码加载后立即执行，即使HTML解析尚未完成，即使这会改变脚本的相对顺序。
- en: Web browsers that support `<script type="module">` must also support `<script
    nomodule>`. Browsers that are module-aware ignore any script with the `nomodule`
    attribute and will not execute it. Browsers that do not support modules will not
    recognize the `nomodule` attribute, so they will ignore it and run the script.
    This provides a powerful technique for dealing with browser compatibility issues.
    Browsers that support ES6 modules also support other modern JavaScript features
    like classes, arrow functions, and the `for/of` loop. If you write modern JavaScript
    and load it with `<script type="module">`, you know that it will only be loaded
    by browsers that can support it. And as a fallback for IE11 (which, in 2020, is
    effectively the only remaining browser that does not support ES6), you can use
    tools like Babel and webpack to transform your code into non-modular ES5 code,
    then load that less-efficient transformed code via `<script nomodule>`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 支持`<script type="module">`的Web浏览器也必须支持`<script nomodule>`。了解模块的浏览器会忽略带有`nomodule`属性的任何脚本并且不会执行它。不支持模块的浏览器将不识别`nomodule`属性，因此它们会忽略它并运行脚本。这为处理浏览器兼容性问题提供了一个强大的技术。支持ES6模块的浏览器还支持其他现代JavaScript特性，如类、箭头函数和`for/of`循环。如果您编写现代JavaScript并使用`<script
    type="module">`加载它，您知道它只会被支持的浏览器加载。作为IE11的备用方案（在2020年，实际上是唯一一个不支持ES6的浏览器），您可以使用类似Babel和webpack的工具将您的代码转换为非模块化的ES5代码，然后通过`<script
    nomodule>`加载这些效率较低的转换代码。
- en: Another important difference between regular scripts and module scripts has
    to do with cross-origin loading. A regular `<script>` tag will load a file of
    JavaScript code from any server on the internet, and the internet’s infrastructure
    of advertising, analytics, and tracking code depends on that fact. But `<script
    type="module">` provides an opportunity to tighten this up, and modules can only
    be loaded from the same origin as the containing HTML document or when proper
    CORS headers are in place to securely allow cross-origin loads. An unfortunate
    side effect of this new security restriction is that it makes it difficult to
    test ES6 modules in development mode using `file:` URLs. When using ES6 modules,
    you will likely need to set up a static web server for testing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 常规脚本和模块脚本之间的另一个重要区别与跨域加载有关。常规的`<script>`标签将从互联网上的任何服务器加载JavaScript代码文件，互联网的广告、分析和跟踪代码基础设施依赖于这一事实。但是`<script
    type="module">`提供了一种加强这一点的机会，模块只能从包含HTML文档的同一源加载，或者在适当的CORS标头放置以安全地允许跨源加载时才能加载。这种新的安全限制的一个不幸副作用是，它使得使用`file:`
    URL在开发模式下测试ES6模块变得困难。使用ES6模块时，您可能需要设置一个静态Web服务器进行测试。
- en: Some programmers like to use the filename extension `.mjs` to distinguish their
    modular JavaScript files from their regular, non-modular JavaScript files with
    the traditional `.js` extension. For the purposes of web browsers and `<script>`
    tags, the file extension is actually irrelevant. (The MIME type is relevant, however,
    so if you use `.mjs` files, you may need to configure your web server to serve
    them with the same MIME type as `.js` files.) Node’s support for ES6 does use
    the filename extension as a hint to distinguish which module system is used by
    each file it loads. So if you are writing ES6 modules and want them to be usable
    with Node, then it may be helpful to adopt the `.mjs` naming convention.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员喜欢使用文件扩展名`.mjs`来区分他们的模块化JavaScript文件和传统`.js`��展名的常规非模块化JavaScript文件。对于Web浏览器和`<script>`标签来说，文件扩展名实际上是无关紧要的。（但MIME类型是相关的，因此如果您使用`.mjs`文件，您可能需要配置您的Web服务器以相同的MIME类型提供它们，如`.js`文件。）Node对ES6的支持确实使用文件扩展名作为提示来区分它加载的每个文件使用的模块系统。因此，如果您编写ES6模块并希望它们能够在Node中使用，采用`.mjs`命名约定可能会有所帮助。
- en: 10.3.6 Dynamic Imports with import()
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.6 使用import()进行动态导入
- en: We’ve seen that the ES6 `import` and `export` directives are completely static
    and enable JavaScript interpreters and other JavaScript tools to determine the
    relationships between modules with simple text analysis while the modules are
    being loaded without having to actually execute any of the code in the modules.
    With statically imported modules, you are guaranteed that the values you import
    into a module will be ready for use before any of the code in your module begins
    to run.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 ES6 的 `import` 和 `export` 指令是完全静态的，并且使 JavaScript 解释器和其他 JavaScript 工具能够在加载模块时通过简单的文本分析确定模块之间的关系，而无需实际执行模块中的任何代码。使用静态导入的模块，你可以确保导入到模块中的值在你的模块中的任何代码开始运行之前就已经准备好供使用。
- en: On the web, code has to be transferred over a network instead of being read
    from the filesystem. And once transfered, that code is often executed on mobile
    devices with relatively slow CPUs. This is not the kind of environment where static
    module imports—which require an entire program to be loaded before any of it runs—make
    a lot of sense.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 上，代码必须通过网络传输，而不是从文件系统中读取。一旦传输，该代码通常在相对较慢的移动设备上执行。这不是静态模块导入（需要在任何代码运行之前加载整个程序）有很多意义的环境。
- en: It is common for web applications to initially load only enough of their code
    to render the first page displayed to the user. Then, once the user has some preliminary
    content to interact with, they can begin to load the often much larger amount
    of code needed for the rest of the web app. Web browsers make it easy to dynamically
    load code by using the DOM API to inject a new `<script>` tag into the current
    HTML document, and web apps have been doing this for many years.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序通常只加载足够的代码来渲染用户看到的第一页。然后，一旦用户有一些初步内容可以交互，它们就可以开始加载通常需要更多的代码来完成网页应用程序的其余部分。Web
    浏览器通过使用 DOM API 将新的 `<script>` 标签注入到当前 HTML 文档中，使动态加载代码变得容易，而 Web 应用程序多年来一直在这样做。
- en: Although dynamic loading has been possible for a long time, it has not been
    part of the language itself. That changes with the introduction of `import()`
    in ES2020 (as of early 2020, dynamic import is supported by all browsers that
    support ES6 modules). You pass a module specifier to `import()` and it returns
    a Promise object that represents the asynchronous process of loading and running
    the specified module. When the dynamic import is complete, the Promise is “fulfilled”
    (see [Chapter 13](ch13.xhtml#async) for complete details on asynchronous programming
    and Promises) and produces an object like the one you would get with the `import
    * as` form of the static import statement.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管动态加载已经很久了，但它并不是语言本身的一部分。这在 ES2020 中发生了变化（截至 2020 年初，支持 ES6 模块的所有浏览器都支持动态导入）。你将一个模块规范传递给
    `import()`，它将返回一个代表加载和运行指定模块的异步过程的 Promise 对象。当动态导入完成时，Promise 将“完成”（请参阅 [第 13
    章](ch13.xhtml#async) 了解有关异步编程和 Promise 的完整细节），并产生一个对象，就像你使用静态导入语句的 `import * as`
    形式一样。
- en: 'So instead of importing the “./stats.js” module statically, like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以像这样静态导入“./stats.js”模块：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'we might import it and use it dynamically, like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样动态导入并使用它：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, in an `async` function (again, you may need to read [Chapter 13](ch13.xhtml#async)
    before you’ll understand this code), we can simplify the code with `await`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在一个 `async` 函数中（再次，你可能需要在理解这段代码之前阅读 [第 13 章](ch13.xhtml#async)），我们可以用 `await`
    简化代码：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The argument to `import()` should be a module specifier, exactly like one you’d
    use with a static `import` directive. But with `import()`, you are not constrained
    to use a constant string literal: any expression that evaluates to a string in
    the proper form will do.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()` 的参数应该是一个模块规范，就像你会在静态 `import` 指令中使用的那样。但是使用 `import()`，你不受限于使用常量字符串文字：任何表达式只要以正确形式评估为字符串即可。'
- en: Dynamic `import()` looks like a function invocation, but it actually is not.
    Instead, `import()` is an operator and the parentheses are a required part of
    the operator syntax. The reason for this unusual bit of syntax is that `import()`
    needs to be able to resolve module specifiers as URLs relative to the currently
    running module, and this requires a bit of implementation magic that would not
    be legal to put in a JavaScript function. The function versus operator distinction
    rarely makes a difference in practice, but you’ll notice it if you try writing
    code like `console.log(import);` or `let require = import;`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 `import()` 看起来像一个函数调用，但实际上不是。相反，`import()` 是一个操作符，括号是操作符语法的必需部分。这种不寻常的语法之所以存在是因为
    `import()` 需要能够将模块规范解析为相对于当前运行模块的 URL，这需要一些实现魔法，这是不合法的放在 JavaScript 函数中的。在实践中，函数与操作符的区别很少有影响，但如果尝试编写像
    `console.log(import);` 或 `let require = import;` 这样的代码，你会注意到这一点。
- en: Finally, note that dynamic `import()` is not just for web browsers. Code-packaging
    tools like webpack can also make good use of it. The most straightforward way
    to use a code bundler is to tell it the main entry point for your program and
    let it find all the static `import` directives and assemble everything into one
    large file. By strategically using dynamic `import()` calls, however, you can
    break that one monolithic bundle up into a set of smaller bundles that can be
    loaded on demand.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意动态 `import()` 不仅适用于 Web 浏览器。代码打包工具如 webpack 也可以很好地利用它。使用代码捆绑器的最简单方法是告诉它程序的主入口点，让它找到所有静态
    `import` 指令并将所有内容组装成一个大文件。然而，通过策略性地使用动态 `import()` 调用，你可以将这个单一的庞大捆绑拆分成一组可以按需加载的较小捆绑。
- en: 10.3.7 import.meta.url
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3.7 import.meta.url
- en: There is one final feature of the ES6 module system to discuss. Within an ES6
    module (but not within a regular `<script>` or a Node module loaded with `require()`),
    the special syntax `import.meta` refers to an object that contains metadata about
    the currently executing module. The `url` property of this object is the URL from
    which the module was loaded. (In Node, this will be a `file://` URL.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 模块系统的最后一个特性需要讨论。在 ES6 模块中（但不在常规的 `<script>` 或使用 `require()` 加载的 Node 模块中），特殊语法
    `import.meta` 指的是一个包含有关当前执行模块的元数据的对象。该对象的 `url` 属性是加载模块的 URL。（在 Node 中，这将是一个 `file://`
    URL。）
- en: 'The primary use case of `import.meta.url` is to be able to refer to images,
    data files, or other resources that are stored in the same directory as (or relative
    to) the module. The `URL()` constructor makes it easy to resolve a relative URL
    against an absolute URL like `import.meta.url`. Suppose, for example, that you
    have written a module that includes strings that need to be localized and that
    the localization files are stored in an `l10n/` directory, which is in the same
    directory as the module itself. Your module could load its strings using a URL
    created with a function, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`import.meta.url` 的主要用例是能够引用存储在与模块相同目录中（或相对于模块）的图像、数据文件或其他资源。`URL()` 构造函数使得相对
    URL 相对于绝对 URL（如 `import.meta.url`）容易解析。例如，假设你编写了一个模块，其中包含需要本地化的字符串，并且本地化文件存储在与模块本身相同目录中的
    `l10n/` 目录中。你的模块可以使用类似这样的函数创建的 URL 加载其字符串：'
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 10.4 Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10.4 总结
- en: 'The goal of modularity is to allow programmers to hide the implementation details
    of their code so that chunks of code from various sources can be assembled into
    large programs without worrying that one chunk will overwrite functions or variables
    of another. This chapter has explained three different JavaScript module systems:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化的目标是允许程序员隐藏其代码的实现细节，以便来自各种来源的代码块可以组装成大型程序，而不必担心一个代码块会覆盖另一个的函数或变量。本章已经解释了三种不同的
    JavaScript 模块系统：
- en: In the early days of JavaScript, modularity could only be achieved through the
    clever use of immediately invoked function expressions.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 JavaScript 的早期，模块化只能通过巧妙地使用立即调用的函数表达式来实现。
- en: Node added its own module system on top of the JavaScript language. Node modules
    are imported with `require()` and define their exports by setting properties of
    the Exports object, or by setting the `module.exports` property.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 在 JavaScript 语言之上添加了自己的模块系统。Node 模块通过 `require()` 导入，并通过设置 Exports 对象的属性或设置
    `module.exports` 属性来定义它们的导出。
- en: In ES6, JavaScript finally got its own module system with `import` and `export`
    keywords, and ES2020 is adding support for dynamic imports with `import()`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 ES6 中，JavaScript 终于拥有了自己的模块系统，使用 `import` 和 `export` 关键字，而 ES2020 正在添加对使用
    `import()` 进行动态导入的支持。
- en: '^([1](ch10.xhtml#idm46198529362824-marker)) For example: web apps that have
    frequent incremental updates and users who make frequent return visits may find
    that using small modules instead of large bundles can result in better average
    load times because of better utilization of the user’s browser cache.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#idm46198529362824-marker)) 例如：经常进行增量更新并且用户频繁返回访问的 Web 应用程序可能会发现，使用小模块而不是大捆绑包可以更好地利用用户浏览器缓存，从而导致更好的平均加载时间。
