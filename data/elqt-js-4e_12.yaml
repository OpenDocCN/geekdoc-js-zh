- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: ASYNCHRONOUS PROGRAMMING
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步编程
- en: The central part of a computer, the part that carries out the individual steps
    that make up our programs, is called the *processor*. The programs we have seen
    so far will keep the processor busy until they have finished their work. The speed
    at which something like a loop that manipulates numbers can be executed depends
    pretty much entirely on the speed of the computer’s processor and memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的核心部分，即执行构成我们程序的各个步骤的部分，被称为*处理器*。到目前为止我们看到的程序将在它们完成工作之前一直占用处理器。像处理数字的循环那样的操作执行速度几乎完全依赖于计算机的处理器和内存的速度。
- en: But many programs interact with things outside of the processor. For example,
    they may communicate over a computer network or request data from the hard disk—which
    is a lot slower than getting it from memory.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但许多程序与处理器外部的事物进行交互。例如，它们可能通过计算机网络进行通信，或请求硬盘上的数据——这比从内存获取数据要慢得多。
- en: When such a thing is happening, it would be a shame to let the processor sit
    idle—there might be some other work it could do in the meantime. In part, this
    is handled by your operating system, which will switch the processor between multiple
    running programs. But that doesn’t help when we want a *single* program to be
    able to make progress while it is waiting for a network request.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，让处理器闲置将是一个遗憾——在此期间可能还有其他工作可以完成。这部分由你的操作系统处理，它会在多个运行中的程序之间切换处理器。但当我们希望一个*单一*程序在等待网络请求时仍能进展时，这并没有帮助。
- en: Asynchronicity
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步性
- en: In a *synchronous* programming model, things happen one at a time. When you
    call a function that performs a long-running action, it returns only when the
    action has finished and it can return the result. This stops your program for
    the time the action takes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*同步*编程模型中，事情是一个接一个发生的。当你调用一个执行长时间运行的操作的函数时，它只有在操作完成并能返回结果时才会返回。这会在操作所需时间内停止你的程序。
- en: An *asynchronous* model allows multiple things to happen at the same time. When
    you start an action, your program continues to run. When the action finishes,
    the program is informed and gets access to the result (for example, the data read
    from disk).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步*模型允许多个事情同时发生。当你启动一个操作时，你的程序会继续运行。当操作完成时，程序会收到通知并访问结果（例如，从磁盘读取的数据）。'
- en: 'We can compare synchronous and asynchronous programming using a small example:
    a program that makes two requests over the network and then combines the results.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个小例子来比较同步和异步编程：一个程序在网络上发出两个请求，然后合并结果。
- en: In a synchronous environment, where the request function returns only after
    it has done its work, the easiest way to perform this task is to make the requests
    one after the other. This has the drawback that the second request will be started
    only when the first has finished. The total time taken will be at least the sum
    of the two response times.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步环境中，请求函数在完成工作之前不会返回，因此执行此任务的最简单方法是一个接一个地发出请求。这有一个缺点，即第二个请求只有在第一个请求完成后才会启动。总耗时至少是两个响应时间的总和。
- en: The solution to this problem, in a synchronous system, is to start additional
    threads of control. A *thread* is another running program whose execution may
    be interleaved with other programs by the operating system— since most modern
    computers contain multiple processors, multiple threads may even run at the same
    time, on different processors. A second thread could start the second request,
    and then both threads wait for their results to come back, after which they resynchronize
    to combine their results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步系统中，解决这个问题的方法是启动额外的控制线程。一个*线程*是另一个正在运行的程序，它的执行可能与操作系统中的其他程序交错进行——由于大多数现代计算机包含多个处理器，因此多个线程甚至可以在不同的处理器上同时运行。第二个线程可以启动第二个请求，然后两个线程等待结果返回，之后它们重新同步以合并结果。
- en: In the following diagram, the thick lines represent time the program spends
    running normally, and the thin lines represent time spent waiting for the network.
    In the synchronous model, the time taken by the network is *part* of the timeline
    for a given thread of control. In the asynchronous model, starting a network action
    allows the program to continue running while the network communication happens
    alongside it, notifying the program when it is finished.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，粗线代表程序正常运行所花费的时间，细线代表等待网络的时间。在同步模型中，网络所需的时间是特定控制线程的时间线的*一部分*。在异步模型中，启动网络操作允许程序继续运行，同时进行网络通信，并在完成时通知程序。
- en: synchronous, single thread of control
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 同步，单线程控制
- en: '![Image](../images/f0176-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0176-01.jpg)'
- en: synchronous, two threads of control
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同步，两条控制线程
- en: '![Image](../images/f0176-02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0176-02.jpg)'
- en: asynchronous
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 异步
- en: '![Image](../images/f0176-03.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0176-03.jpg)'
- en: Another way to describe the difference is that waiting for actions to finish
    is *implicit* in the synchronous model, while it is *explicit*—under our control—in
    the asynchronous one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 描述这种差异的另一种方式是，在同步模型中，等待操作完成是*隐式*的，而在异步模型中，它是*显式*的——在我们的控制之下。
- en: Asynchronicity cuts both ways. It makes expressing programs that do not fit
    the straight-line model of control easier, but it can also make expressing programs
    that do follow a straight line more awkward. We’ll see some ways to reduce this
    awkwardness later in the chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 异步性有双重作用。它使表达不符合直线控制模型的程序变得更容易，但它也可能使表达遵循直线的程序变得更为笨拙。我们将在本章稍后看到一些减少这种笨拙感的方法。
- en: Both prominent JavaScript programming platforms—browsers and Node.js—make operations
    that might take a while asynchronous, rather than relying on threads. Since programming
    with threads is notoriously hard (understanding what a program does is much more
    difficult when it’s doing multiple things at once), this is generally considered
    a good thing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 两大主要JavaScript编程平台——浏览器和Node.js——使可能需要一段时间的操作异步，而不是依赖线程。由于使用线程编程 notoriously
    hard（理解一个程序的行为在它同时执行多个任务时更加困难），这通常被认为是一件好事。
- en: Callbacks
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回调
- en: One approach to asynchronous programming is to make functions that need to wait
    for something take an extra argument, a *callback function*. The asynchronous
    function starts a process, sets things up so that the callback function is called
    when the process finishes, and then returns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一种异步编程的方法是让需要等待某些事情的函数接受一个额外的参数，即*回调函数*。异步函数启动一个进程，设置好当进程完成时调用回调函数的条件，然后返回。
- en: As an example, the setTimeout function, available both in Node.js and in browsers,
    waits a given number of milliseconds and then calls a function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个例子，setTimeout函数在Node.js和浏览器中都可用，它等待给定的毫秒数，然后调用一个函数。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Waiting is not generally important work, but it can be very useful when you
    need to arrange for something to happen at a certain time or check whether some
    action is taking longer than expected.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 等待通常不是重要的工作，但当你需要安排某件事情在特定时间发生或检查某个操作是否比预期耗时更长时，这可以非常有用。
- en: Another example of a common asynchronous operation is reading a file from a
    device’s storage. Imagine you have a function readTextFile that reads a file’s
    content as a string and passes it to a callback function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见异步操作的例子是从设备存储中读取文件。想象一下，你有一个函数readTextFile，它将文件的内容读取为字符串并传递给回调函数。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The readTextFile function is not part of standard JavaScript. We will see how
    to read files in the browser and in Node.js in later chapters.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: readTextFile函数不是标准JavaScript的一部分。我们将在后面的章节中看到如何在浏览器和Node.js中读取文件。
- en: 'Performing multiple asynchronous actions in a row using callbacks means that
    you have to keep passing new functions to handle the continuation of the computation
    after the actions. An asynchronous function that compares two files and produces
    a Boolean indicating whether their content is the same might look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调在一系列异步操作中执行多个操作意味着你必须不断传递新的函数来处理在这些操作之后计算的继续。一个比较两个文件并生成一个布尔值，指示它们的内容是否相同的异步函数可能看起来像这样：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This style of programming is workable, but the indentation level increases with
    each asynchronous action because you end up in another function. Doing more complicated
    things, such as wrapping asynchronous actions in a loop, can get awkward.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格是可行的，但每进行一次异步操作，缩进级别就会增加，因为你进入了另一个函数。进行更复杂的操作，比如将异步操作包装在循环中，可能会变得很尴尬。
- en: In a way, asynchronicity is *contagious*. Any function that calls a function
    that works asynchronously must itself be asynchronous, using a callback or similar
    mechanism to deliver its result. Calling a callback is somewhat more involved
    and error prone than simply returning a value, so needing to structure large parts
    of your program that way is not great.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，异步性是*具有传染性的*。任何调用异步函数的函数本身必须是异步的，使用回调或类似机制来传递结果。调用回调比简单返回值更复杂且容易出错，因此需要以这种方式结构化程序的较大部分并不好。
- en: Promises
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺
- en: A slightly different way to build an asynchronous program is to have asynchronous
    functions return an object that represents its (future) result instead of passing
    around callback functions. This way, such functions actually return something
    meaningful, and the shape of the program more closely resembles that of synchronous
    programs.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构建异步程序的另一种稍微不同的方法是让异步函数返回一个表示其（未来）结果的对象，而不是传递回调函数。这样，这些函数实际上返回一些有意义的东西，程序的结构与同步程序更为相似。
- en: This is what the standard class Promise is for. A *promise* is a receipt representing
    a value that may not be available yet. It provides a then method that allows you
    to register a function that should be called when the action for which it is waiting
    finishes. When the promise is *resolved*, meaning its value becomes available,
    such functions (there can be multiple) are called with the result value. It is
    possible to call then on a promise that has already resolved— your function will
    still be called.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是标准类`Promise`的用途。*承诺*是表示可能尚不可用的值的收据。它提供了一个`then`方法，允许你注册一个在它等待的操作完成时应被调用的函数。当承诺被*解析*时，即其值变得可用，这些函数（可能有多个）会被调用并传入结果值。可以在已经解析的承诺上调用`then`——你的函数仍然会被调用。
- en: The easiest way to create a promise is by calling Promise.resolve. This function
    ensures that the value you give it is wrapped in a promise. If it’s already a
    promise, it is simply returned. Otherwise, you get a new promise that immediately
    resolves with your value as its result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建承诺的最简单方法是调用`Promise.resolve`。这个函数确保你提供的值被包装在一个承诺中。如果它已经是一个承诺，则直接返回。否则，你将得到一个新的承诺，它立即以你的值作为结果解析。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create a promise that does not immediately resolve, you can use Promise
    as a constructor. It has a somewhat odd interface: the constructor expects a function
    as its argument, which it immediately calls, passing it a function that it can
    use to resolve the promise.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个不会立即解析的承诺，可以使用`Promise`作为构造函数。它的接口有些奇怪：构造函数期望一个函数作为参数，并立即调用它，传递一个可以用来解析承诺的函数。
- en: 'For example, this is how you could create a promise-based interface for the
    readTextFile function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这就是如何为`readTextFile`函数创建一个基于承诺的接口：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how, in contrast to callback-style functions, this asynchronous function
    returns a meaningful value—a promise to give you the contents of the file at some
    point in the future.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与回调风格的函数相比，这个异步函数返回了一个有意义的值——一个承诺，承诺在未来某个时刻提供文件的内容。
- en: A useful thing about the then method is that it itself returns another promise.
    This one resolves to the value returned by the callback function or, if that returned
    value is a promise, to the value that promise resolves to. Thus, you can “chain”
    multiple calls to then together to set up a sequence of asynchronous actions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`方法的一个有用之处在于，它本身返回另一个承诺。这个承诺解析为回调函数返回的值，或者如果该返回值是一个承诺，则解析为该承诺所解析的值。因此，你可以将多个对`then`的调用“链式”连接在一起，以建立一系列异步操作。'
- en: 'This function, which reads a file full of filenames and returns the content
    of a random file in that list, shows this kind of asynchronous promise pipeline:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数读取一个包含文件名的文件，并返回该列表中随机文件的内容，展示了这种异步承诺管道：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function returns the result of this chain of then calls. The initial promise
    fetches the list of files as a string. The first then call transforms that string
    into an array of lines, producing a new promise. The second then call picks a
    random line from that, producing a third promise that yields a single filename.
    The final then call reads this file, so the result of the function as a whole
    is a promise that returns the content of a random file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回这一系列 then 调用的结果。初始 promise 以字符串形式获取文件列表。第一次 then 调用将该字符串转换为行数组，从而产生一个新的
    promise。第二次 then 调用从中随机选择一行，产生一个返回单个文件名的第三个 promise。最终的 then 调用读取这个文件，因此该函数的整体结果是一个返回随机文件内容的
    promise。
- en: In this code, the functions used in the first two then calls return a regular
    value that will immediately be passed into the promise returned by then when the
    function returns. The last then call returns a promise (textFile (filename)),
    making it an actual asynchronous step.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，前两个 then 调用中使用的函数返回一个常规值，该值将在函数返回时立即传递给 then 返回的 promise。最后一次 then 调用返回一个
    promise（textFile (filename)），使其成为一个实际的异步步骤。
- en: It would also have been possible to perform all these steps inside a single
    then callback, since only the last step is actually asynchronous. But the kind
    of then wrappers that only do some synchronous data transformation are often useful,
    such as when you want to return a promise that produces a processed version of
    some asynchronous result.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在单个 then 回调中执行所有这些步骤，因为实际上只有最后一步是异步的。但那种仅执行某些同步数据转换的 then 包装器通常是有用的，例如，当你想返回一个生成某些异步结果处理版本的
    promise 时。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Generally, it is useful to think of a promise as a device that lets code ignore
    the question of when a value is going to arrive. A normal value has to actually
    exist before we can reference it. A promised value is a value that *might* already
    be there or might appear at some point in the future. Computations defined in
    terms of promises, by wiring them together with then calls, are executed asynchronously
    as their inputs become available.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将 promise 视为一种设备是有益的，它使代码可以忽略值何时到达的问题。正常值必须在我们引用它之前实际存在。承诺的值是一个*可能*已经存在或者可能在未来某个时刻出现的值。通过将它们与
    then 调用连接在一起定义的基于 promise 的计算，随着输入变得可用而异步执行。
- en: Failure
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败
- en: Regular JavaScript computations can fail by throwing an exception. Asynchronous
    computations often need something like that. A network request may fail, a file
    may not exist, or some code that is part of the asynchronous computation may throw
    an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的 JavaScript 计算可能通过抛出异常而失败。异步计算通常需要类似的机制。网络请求可能失败，文件可能不存在，或者某个属于异步计算的代码可能抛出异常。
- en: One of the most pressing problems with the callback style of asynchronous programming
    is that it makes it extremely difficult to ensure failures are properly reported
    to the callbacks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回调风格的异步编程面临的最紧迫问题之一是，它使得确保失败正确报告给回调变得极其困难。
- en: A common convention is to use the first argument to the callback to indicate
    that the action failed, and the second to pass the value produced by the action
    when it was successful.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的约定是使用回调的第一个参数来指示操作失败，第二个参数用来传递操作成功时产生的值。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Such callback functions must always check whether they received an exception
    and make sure that any problems they cause, including exceptions thrown by functions
    they call, are caught and given to the right function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的回调函数必须始终检查是否收到异常，并确保它们引起的任何问题，包括它们调用的函数抛出的异常，都被捕获并传递给正确的函数。
- en: Promises make this easier. They can be either resolved (the action finished
    successfully) or rejected (it failed). Resolve handlers (as registered with then)
    are called only when the action is successful, and rejections are propagated to
    the new promise returned by then. When a handler throws an exception, this automatically
    causes the promise produced by its then call to be rejected. If any element in
    a chain of asynchronous actions fails, the outcome of the whole chain is marked
    as rejected, and no success handlers are called beyond the point where it failed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Promises 使这变得更简单。它们可以被解决（操作成功完成）或被拒绝（失败）。解决处理程序（如通过 then 注册的）仅在操作成功时调用，而拒绝会传播到
    then 返回的新 promise。当处理程序抛出异常时，这会自动导致其 then 调用生成的 promise 被拒绝。如果异步操作链中的任何元素失败，整个链的结果将被标记为拒绝，并且在失败点之后不会调用任何成功处理程序。
- en: Much like resolving a promise provides a value, rejecting one also provides
    a value, usually called the *reason* of the rejection. When an exception in a
    handler function causes the rejection, the exception value is used as the reason.
    Similarly, when a handler returns a promise that is rejected, that rejection flows
    into the next promise. There’s a Promise.reject function that creates a new, immediately
    rejected promise.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 就像解析承诺提供一个值一样，拒绝承诺也提供一个值，通常称为拒绝的*原因*。当处理程序函数中的异常导致拒绝时，异常值被用作原因。同样，当处理程序返回一个被拒绝的承诺时，该拒绝会流入下一个承诺。有一个Promise.reject函数，可以创建一个新的、立即被拒绝的承诺。
- en: To explicitly handle such rejections, promises have a catch method that registers
    a handler to be called when the promise is rejected, similar to how then handlers
    handle normal resolution. It’s also very much like then in that it returns a new
    promise, which resolves to the original promise’s value when that resolves normally
    and to the result of the catch handler otherwise. If a catch handler throws an
    error, the new promise is also rejected.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显式处理这样的拒绝，承诺有一个catch方法，用于注册在承诺被拒绝时调用的处理程序，类似于then处理程序处理正常解析的方式。它也非常像then，因为它返回一个新的承诺，该承诺在原承诺正常解析时解析为原承诺的值，而在其他情况下解析为catch处理程序的结果。如果catch处理程序抛出错误，新的承诺也会被拒绝。
- en: 'As a shorthand, then also accepts a rejection handler as a second argument,
    so you can install both types of handlers in a single method call: .then(acceptHandler,
    rejectHandler).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种简写，then也接受一个拒绝处理程序作为第二个参数，因此你可以在一次方法调用中安装两种类型的处理程序：.then(acceptHandler,
    rejectHandler)。
- en: A function passed to the Promise constructor receives a second argument, alongside
    the resolve function, which it can use to reject the new promise.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给Promise构造函数的函数接收第二个参数，除了resolve函数外，它可以用来拒绝新的承诺。
- en: When our readTextFile function encounters a problem, it passes the error to
    its callback function as a second argument. Our textFile wrapper should actually
    check that argument so that a failure causes the promise it returns to be rejected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的readTextFile函数遇到问题时，它将错误作为第二个参数传递给回调函数。我们的textFile包装器实际上应该检查该参数，以确保失败导致返回的承诺被拒绝。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The chains of promise values created by calls to then and catch thus form a
    pipeline through which asynchronous values or failures move. Since such chains
    are created by registering handlers, each link has a success handler or a rejection
    handler (or both) associated with it. Handlers that don’t match the type of outcome
    (success or failure) are ignored. Handlers that do match are called, and their
    outcome determines what kind of value comes next— success when they return a non-promise
    value, rejection when they throw an exception, and the outcome of the promise
    when they return a promise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用then和catch创建的承诺值链形成了一条管道，异步值或失败通过这条管道传递。由于这样的链是通过注册处理程序创建的，因此每个链接都有一个成功处理程序或拒绝处理程序（或两者都有）。不匹配结果类型（成功或失败）的处理程序会被忽略。匹配的处理程序会被调用，其结果决定了接下来是什么样的值——当它们返回非承诺值时为成功，当它们抛出异常时为拒绝，而当它们返回一个承诺时则为承诺的结果。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first then handler function isn’t called because at that point of the pipeline
    the promise holds a rejection. The catch handler handles that rejection and returns
    a value, which is given to the second then handler function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个then处理程序函数没有被调用，因为在管道的那个点上，承诺持有一个拒绝。catch处理程序处理该拒绝并返回一个值，该值被传递给第二个then处理程序函数。
- en: Much like an uncaught exception is handled by the environment, Java-Script environments
    can detect when a promise rejection isn’t handled and will report this as an error.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像未捕获的异常由环境处理一样，JavaScript环境可以检测到承诺拒绝未被处理的情况，并将其报告为错误。
- en: Carla
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卡拉
- en: It’s a sunny day in Berlin. The runway of the old, decommissioned airport is
    teeming with cyclists and inline skaters. In the grass near a garbage container,
    a flock of crows noisily mills about, trying to convince a group of tourists to
    part with their sandwiches.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在柏林是一个阳光明媚的日子。废弃机场的跑道上挤满了骑自行车和滑轮滑的运动员。在一个垃圾容器附近的草地上，一群乌鸦吵闹地聚在一起，试图说服一群游客放弃他们的三明治。
- en: One of the crows stands out—a large scruffy female with a few white feathers
    in her right wing. She is baiting people with a skill and confidence that suggest
    she’s been doing this for a long time. When an elderly man is distracted by the
    antics of another crow, she casually swoops in, snatches his half-eaten bun from
    his hand, and sails away.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一只乌鸦十分显眼——一只毛发蓬乱的大雌鸟，右翅膀上有几根白色羽毛。她用一种技巧和自信吸引人们，似乎已经做了很长时间。当一位老年人被另一只乌鸦的 antics
    分散注意力时，她悄然俯冲而下，从他手中抢走半个吃剩的面包，飞走了。
- en: Contrary to the rest of the group, who look like they are happy to spend the
    day goofing around here, the large crow looks purposeful. Carrying her loot, she
    flies straight toward the roof of the hangar building, disappearing into an air
    vent.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他看似乐于在这里消磨时间的鸟儿不同，这只大乌鸦显得目标明确。她带着战利品，径直飞向机库的屋顶，消失在通风口中。
- en: Inside the building, you can hear an odd tapping sound—soft, but persistent.
    It comes from a narrow space under the roof of an unfinished stairwell. The crow
    is sitting there, surrounded by her stolen snack, half a dozen smartphones (several
    of which are turned on), and a mess of cables. She rapidly taps the screen of
    one of the phones with her beak. Words are appearing on it. If you didn’t know
    better, you’d think she was typing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在大楼内部，你可以听到一种奇怪的敲击声——柔和而持续。声音来自一个未完工楼梯间屋顶下的狭小空间。乌鸦坐在那里，周围是一堆偷来的零食，半打智能手机（其中几部已经开机），以及一堆电缆。她用嘴快速敲击其中一部手机的屏幕。字词正在上面出现。如果你不太了解，你可能会认为她在打字。
- en: This crow is known to her peers as “cāāw-krö.” But since those sounds are poorly
    suited for human vocal chords, we’ll refer to her as Carla.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这只乌鸦在同伴中被称为“cāāw-krö”。但由于这些声音不适合人类的声带，我们就称她为卡拉。
- en: Carla is a somewhat peculiar crow. In her youth, she was fascinated by human
    language, eavesdropping on people until she had a good grasp of what they were
    saying. Later in life, her interest shifted to human technology, and she started
    stealing phones to study them. Her current project is learning to program. The
    text she is typing in her hidden lab is, in fact, a piece of asynchronous JavaScript
    code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 卡拉是一只有些特别的乌鸦。年轻时，她对人类语言着迷，常常偷听人们的谈话，直到她很好地掌握了他们在说什么。后来，她的兴趣转向了人类技术，开始偷手机来研究。她目前的项目是学习编程。她在隐秘实验室中输入的文本实际上是一段异步
    JavaScript 代码。
- en: Breaking In
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破门而入
- en: Carla loves the internet. Annoyingly, the phone she is working on is about to
    run out of prepaid data. The building has a wireless network, but it requires
    a code to access.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 卡拉喜欢上网。令人烦恼的是，她正在使用的手机即将耗尽预付数据。大楼内有无线网络，但需要密码才能访问。
- en: Fortunately, the wireless routers in the building are 20 years old and poorly
    secured. Doing some research, Carla finds out that the network authentication
    mechanism has a flaw she can use. When joining the network, a device must send
    along the correct six-digit passcode. The access point will reply with a success
    or failure message depending on whether the right code is provided. However, when
    sending a partial code (say, only three digits), the response is different based
    on whether those digits are the correct start of the code or not. Sending incorrect
    numbers immediately returns a failure message. When sending the correct ones,
    the access point waits for more digits.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，大楼里的无线网络路由器已有20年历史，并且安全性差。经过一些研究，卡拉发现网络认证机制有一个她可以利用的漏洞。当加入网络时，设备必须发送正确的六位数密码。接入点会根据提供的密码是否正确来回复成功或失败的消息。然而，当发送部分密码（例如，仅三个数字）时，响应会根据这些数字是否为密码的正确开头而不同。发送错误的数字会立即返回失败消息。发送正确的数字时，接入点会等待更多的数字。
- en: This makes it possible to greatly speed up the guessing of the number. Carla
    can find the first digit by trying each number in turn, until she finds one that
    doesn’t immediately return failure. Having one digit, she can find the second
    digit in the same way, and so on, until she knows the entire passcode.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得大大加快猜测数字的速度成为可能。卡拉可以通过逐个尝试每个数字来找到第一个数字，直到找到一个不会立即返回失败的数字。得知一个数字后，她可以用同样的方法找到第二个数字，依此类推，直到她知道整个密码。
- en: Assume Carla has a joinWifi function. Given the network name and the passcode
    (as a string), the function tries to join the network, returning a promise that
    resolves if successful and rejects if the authentication failed. The first thing
    she needs is a way to wrap a promise so that it automatically rejects after it
    takes too much time, to allow the program to quickly move on if the access point
    doesn’t respond.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Carla 有一个 joinWifi 函数。给定网络名称和密码（作为字符串），该函数尝试加入网络，返回一个如果成功则解析的 Promise，如果身份验证失败则拒绝的
    Promise。她需要的第一件事是一个包装 Promise 的方法，以便在耗时过长后自动拒绝，这样如果接入点没有响应，程序就能迅速继续。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This makes use of the fact that a promise can be resolved or rejected only once.
    If the promise given as its argument resolves or rejects first, that result will
    be the result of the promise returned by withTimeout. If, on the other hand, the
    setTimeout fires first, rejecting the promise, any further resolve or reject calls
    are ignored.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了 Promise 只能被解析或拒绝一次的事实。如果作为参数传入的 Promise 先解析或拒绝，那么该结果将是 withTimeout 返回的
    Promise 的结果。另一方面，如果 setTimeout 先触发并拒绝了 Promise，那么任何进一步的解析或拒绝调用都会被忽略。
- en: To find the whole passcode, the program needs to repeatedly look for the next
    digit by trying each digit. If authentication succeeds, we know we have found
    what we are looking for. If it immediately fails, we know that digit was wrong
    and must try the next digit. If the request times out, we have found another correct
    digit and must continue by adding another digit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到整个密码，程序需要通过尝试每个数字来反复寻找下一个数字。如果身份验证成功，我们知道找到了我们要找的。如果立即失败，我们知道该数字是错误的，必须尝试下一个数字。如果请求超时，我们找到了另一个正确的数字，必须继续添加另一个数字。
- en: Because you cannot wait for a promise inside a for loop, Carla uses a recursive
    function to drive this process. On each call, this function gets the code as we
    know it so far, as well as the next digit to try. Depending on what happens, it
    may return a finished code or call through to itself, to either start cracking
    the next position in the code or to try again with another digit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你不能在 for 循环内等待一个 Promise，Carla 使用一个递归函数来驱动这个过程。在每次调用中，这个函数获取当前已知的代码以及要尝试的下一个数字。根据发生的情况，它可能返回一个完成的代码，或者再次调用自己，开始破解代码的下一个位置，或用另一个数字重试。
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The access point tends to respond to bad authentication requests in about 20
    milliseconds, so to be safe, this function waits for 50 milliseconds before timing
    out a request.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接入点通常在大约 20 毫秒内响应错误的身份验证请求，因此为了安全起见，该函数在请求超时前等待 50 毫秒。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Carla tilts her head and sighs. This would have been more satisfying if the
    code had been a bit harder to guess.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Carla 侧着头叹气。如果代码再难一些，她会觉得更满意。
- en: async Functions
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: async 函数
- en: Even with promises, this kind of asynchronous code is annoying to write. Promises
    often need to be tied together in verbose, arbitrary-looking ways. To create an
    asynchronous loop, Carla was forced to introduce a recursive function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了 Promise，这种异步代码依然令人厌烦。Promise 通常需要以冗长且看似任意的方式连接在一起。为了创建一个异步循环，Carla 被迫引入了递归函数。
- en: The thing the cracking function actually does is completely linear—it always
    waits for the previous action to complete before starting the next one. This would
    be straightforward to express in a synchronous programming model.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 破解函数实际上做的事情是完全线性的——它总是等待上一个操作完成后再开始下一个。这在同步编程模型中会非常简单地表达。
- en: The good news is that JavaScript allows you to write pseudosynchronous code
    to describe asynchronous computation. An async function implicitly returns a promise
    and can, in its body, await other promises in a way that *looks* synchronous.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 JavaScript 允许你编写伪同步代码来描述异步计算。async 函数隐式返回一个 Promise，并且可以在其主体中以 *看似* 同步的方式等待其他
    Promise。
- en: 'We can rewrite crackPasscode like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样重写 crackPasscode：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This version more clearly shows the double loop structure of the function (the
    inner loop tries digit 0 to 9 and the outer loop adds digits to the passcode).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更清楚地展示了函数的双重循环结构（内循环尝试数字 0 到 9，外循环向密码中添加数字）。
- en: An async function is marked by the word async before the function keyword. Methods
    can also be made async by writing async before their name. When such a function
    or method is called, it returns a promise. As soon as the function returns something,
    that promise is resolved. If the body throws an exception, the promise is rejected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个异步函数通过在函数关键字前加上**async**来标记。方法也可以通过在其名称前加上async来变为异步。当这样的函数或方法被调用时，它返回一个promise。只要函数返回某个值，该promise就会被解决。如果函数体抛出异常，promise将被拒绝。
- en: Inside an async function, the word await can be put in front of an expression
    to wait for a promise to resolve and only then continue the execution of the function.
    If the promise rejects, an exception is raised at the point of the await.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步函数内部，单词await可以放在一个表达式前面，以等待promise解决，然后再继续执行函数。如果promise被拒绝，则在await点会引发异常。
- en: Such a function no longer runs from start to completion in one go like a regular
    JavaScript function. Instead, it can be *frozen* at any point that has an await
    and can be resumed at a later time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数不再像常规JavaScript函数那样从开始到结束一次性运行。相反，它可以在任何有await的点被冻结，并在稍后的时间恢复执行。
- en: For most asynchronous code, this notation is more convenient than directly using
    promises. You do still need an understanding of promises, since in many cases
    you’ll still interact with them directly. But when wiring them together, async
    functions are generally more pleasant to write than chains of then calls.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数异步代码，这种记法比直接使用promises更方便。你仍然需要理解promises，因为在许多情况下你仍会直接与它们交互。但在将它们组合在一起时，异步函数通常比一连串的then调用更容易编写。
- en: Generators
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器
- en: This ability of functions to be paused and then resumed again is not exclusive
    to async functions. JavaScript also has a feature called *generator* functions.
    These are similar, but without the promises.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被暂停然后重新恢复的能力并不是异步函数所独有的。JavaScript还有一个称为*生成器*函数的特性。这些函数类似，但没有promises。
- en: When you define a function with function* (placing an asterisk after the word
    function), it becomes a generator. When you call a generator, it returns an iterator,
    which we already saw in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你用function*定义一个函数（在单词function后加上星号）时，它变成一个生成器。当你调用生成器时，它返回一个迭代器，这在[第6章](ch06.xhtml#ch06)中我们已经看到了。
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Initially, when you call powers, the function is frozen at its start. Every
    time you call next on the iterator, the function runs until it hits a yield expression,
    which pauses it and causes the yielded value to become the next value produced
    by the iterator. When the function returns (the one in the example never does),
    the iterator is done.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，当你调用powers时，函数在开始时被冻结。每次你在迭代器上调用next时，函数会运行直到遇到一个yield表达式，这会暂停它，并使得yield的值成为迭代器产生的下一个值。当函数返回时（示例中的函数从未返回），迭代器完成。
- en: 'Writing iterators is often much easier when you use generator functions. The
    iterator for the Group class (from the exercise in [Chapter 6](ch06.xhtml#ch06))
    can be written with this generator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用生成器函数时，编写迭代器通常要容易得多。Group类的迭代器（来自[第6章](ch06.xhtml#ch06)的练习）可以用这个生成器来编写：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There’s no longer a need to create an object to hold the iteration state— generators
    automatically save their local state every time they yield.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要创建一个对象来保存迭代状态——生成器会在每次yield时自动保存它们的局部状态。
- en: Such yield expressions may occur only directly in the generator function itself
    and not in an inner function you define inside of it. The state a generator saves,
    when yielding, is only its *local* environment and the position where it yielded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的yield表达式只能直接出现在生成器函数本身，而不能在你在其中定义的内部函数中。生成器在yield时保存的状态只是它的*局部*环境和它yield的那个位置。
- en: An async function is a special type of generator. It produces a promise when
    called, which is resolved when it returns (finishes) and rejected when it throws
    an exception. Whenever it yields (awaits) a promise, the result of that promise
    (value or thrown exception) is the result of the await expression.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数是一种特殊类型的生成器。它在被调用时产生一个promise，当它返回（完成）时，该promise被解决，当它抛出异常时，该promise被拒绝。每当它yield（await）一个promise时，该promise的结果（值或抛出的异常）就是await表达式的结果。
- en: A Corvid Art Project
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个科维德艺术项目
- en: One morning, Carla wakes up to unfamiliar noise from the tarmac outside of her
    hangar. Hopping onto the edge of the roof, she sees the humans are setting up
    for something. There’s a lot of electric cabling, a stage, and some kind of big
    black wall being built up.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一天早上，卡拉被机库外面陌生的噪音吵醒。她跳到屋顶边缘，看到人们正在为某个活动做准备。周围有很多电缆，一个舞台，还有一些正在搭建的巨大黑墙。
- en: Being a curious crow, Carla takes a closer look at the wall. It appears to consist
    of a number of large glass-fronted devices wired up to cables. On the back, the
    devices say “LedTec SIG-5030.”
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一只好奇的乌鸦，卡拉仔细观察这面墙。它似乎由许多大型带玻璃前面的设备组成，并连接到电缆上。设备背面标示着“LedTec SIG-5030”。
- en: A quick internet search turns up a user manual for these devices. They appear
    to be traffic signs, with a programmable matrix of amber LED lights. The intent
    of the humans is probably to display some kind of information on them during their
    event. Interestingly, the screens can be programmed over a wireless network. Could
    it be they are connected to the building’s local network?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一次快速的网络搜索找到了这些设备的用户手册。它们似乎是交通标志，配有可编程的琥珀色LED灯矩阵。人类的意图可能是在事件期间在上面显示某种信息。有趣的是，这些屏幕可以通过无线网络进行编程。它们是否连接到了建筑的本地网络？
- en: Each device on a network gets an *IP address*, which other devices can use to
    send it messages. We talk more about that in [Chapter 13](ch13.xhtml#ch13). Carla
    notices that her own phones all get addresses like 10.0.0.20 or 10.0.0.33. It
    might be worth trying to send messages to all such addresses and see if any one
    of them responds to the interface described in the manual for the signs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的每个设备都有一个*IP地址*，其他设备可以用它来向其发送消息。我们在[第13章](ch13.xhtml#ch13)中对此进行了更多讨论。卡拉注意到她自己的手机都获得了像10.0.0.20或10.0.0.33这样的地址。尝试向所有这些地址发送消息，看看是否有一个响应手册中描述的接口，可能值得一试。
- en: '[Chapter 18](ch18.xhtml#ch18) shows how to make real requests on real networks.
    In this chapter, we’ll use a simplified dummy function called request for network
    communication. This function takes two arguments—a network address and a message,
    which may be anything that can be sent as JSON—and returns a promise that either
    resolves to a response from the machine at the given address, or rejects it if
    there was a problem.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18章](ch18.xhtml#ch18)展示了如何在真实网络上发出真实请求。在这一章中，我们将使用一个名为request的简化虚拟函数进行网络通信。该函数接受两个参数——一个网络地址和一条消息，消息可以是任何可以作为JSON发送的内容——并返回一个承诺，要么解析为来自给定地址的机器的响应，要么在出现问题时拒绝。'
- en: 'According to the manual, you can change what is displayed on a SIG-5030 sign
    by sending it a message with content like {“command”: “display”, “data”: [0, 0,
    3, ...]}, where data holds one number per LED dot, providing its brightness—0
    means off, 3 means maximum brightness. Each sign is 50 lights wide and 30 lights
    high, so an update command should send 1,500 numbers.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '根据手册，通过向SIG-5030标志发送内容为{“command”: “display”, “data”: [0, 0, 3, ...]}的消息，可以改变显示的内容，其中数据为每个LED点提供一个数字，表示其亮度——0表示关闭，3表示最大亮度。每个标志宽50个灯，高30个灯，因此更新命令应该发送1,500个数字。'
- en: This code sends a display update message to all addresses on the local network,
    to see what sticks. Each of the numbers in an IP address can go from 0 to 255\.
    In the data it sends, it activates a number of lights corresponding to the network
    address’s last number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码向本地网络上的所有地址发送显示更新消息，以查看哪个有效。IP地址中的每个数字可以在0到255之间变化。在它发送的数据中，激活与网络地址最后一个数字对应的多个灯光。
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since most of these addresses won’t exist or will not accept such messages,
    the catch call makes sure network errors don’t crash the program. The requests
    are all sent out immediately, without waiting for other requests to finish, in
    order to not waste time when some of the machines don’t answer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数这些地址不存在或不接受此类消息，捕捉调用确保网络错误不会使程序崩溃。所有请求立即发送，而不等待其他请求完成，以免在某些机器未响应时浪费时间。
- en: 'Having fired off her network scan, Carla heads back outside to see the result.
    To her delight, all of the screens are now showing a stripe of light in their
    upper-left corners. They *are* on the local network, and they *do* accept commands.
    She quickly notes the numbers shown on each screen. There are nine screens, arranged
    three high and three wide. They have the following network addresses:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描网络后，卡拉回到外面查看结果。令她高兴的是，所有屏幕的左上角都显示了一条光带。它们*确实*在本地网络上，并且*确实*接受命令。她迅速记录下每个屏幕上显示的数字。有九个屏幕，排列成三行三列。它们的网络地址如下：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now this opens up possibilities for all kinds of shenanigans. She could show
    “crows rule, humans drool” on the wall in giant letters. But that feels a bit
    crude. Instead, she plans to show a video of a flying crow covering all of the
    screens at night.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这为各种捣蛋行为打开了可能性。她可以在墙上用巨大的字母展示“乌鸦统治，人类流口水”。但这感觉有点粗糙。相反，她计划在晚上展示一段飞翔的乌鸦视频，覆盖所有屏幕。
- en: Carla finds a fitting video clip in which a second and a half of footage can
    be repeated to create a looping video showing a crow’s wingbeat. To fit the nine
    screens (each of which can show 50*×*30 pixels), Carla cuts and resizes the videos
    to get a series of 150*×*90 images, 10 per second. Those are then each cut into
    nine rectangles and processed so that the dark spots on the video (where the crow
    is) show a bright light, and the light spots (no crow) are left dark, which should
    create the effect of an amber crow flying against a black background.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Carla找到了一段合适的视频剪辑，其中可以重复一秒半的镜头，以创建一个循环视频，展示乌鸦的翅膀拍打。为了适应九个屏幕（每个屏幕可以显示50*×*30像素），Carla裁剪并调整视频大小，得到一系列150*×*90的图像，每秒10帧。然后将这些图像切割成九个矩形，并进行处理，使视频中的黑暗区域（乌鸦所在处）显示明亮的光，而光亮区域（没有乌鸦）保持黑暗，这应该能产生乌鸦在黑色背景下飞翔的琥珀色效果。
- en: She has set up the clipImages variable to hold an array of frames, where each
    frame is represented with an array of nine sets of pixels—one for each screen—in
    the format that the signs expect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 她已设置clipImages变量，以保存一个帧的数组，其中每一帧由九组像素数组表示——每个屏幕一组——以所需的格式表示。
- en: To display a single frame of the video, Carla needs to send a request to all
    the screens at once. But she also needs to wait for the result of these requests,
    both in order to not start sending the next frame before the current one has been
    properly sent and in order to notice when requests are failing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示视频的单个帧，Carla需要同时向所有屏幕发送请求。但她还需要等待这些请求的结果，以便在当前帧正确发送之前不开始发送下一帧，并注意请求何时失败。
- en: Promise has a static method all that can be used to convert an array of promises
    into a single promise that resolves to an array of results. This provides a convenient
    way to have some asynchronous actions happen alongside each other, wait for them
    all to finish, and then do something with their results (or at least wait for
    them to make sure they don’t fail).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Promise有一个静态方法`all`，可以将一个promise数组转换为一个解析为结果数组的单一promise。这提供了一种方便的方式，使一些异步操作能够并行进行，等待它们全部完成，然后对它们的结果进行处理（或者至少等待它们以确保它们不会失败）。
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This maps over the images in frame (which is an array of display data arrays)
    to create an array of request promises. It then returns a promise that combines
    all of those.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这映射了帧中的图像（这是一个显示数据数组的数组），以创建一个请求promise的数组。然后它返回一个组合所有这些promise的promise。
- en: In order to be able to stop a playing video, the process is wrapped in a class.
    This class has an asynchronous play method that returns a promise that resolves
    only when the playback is stopped again via the stop method.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够停止正在播放的视频，该过程被封装在一个类中。这个类有一个异步的播放方法，返回一个仅在通过停止方法再次停止播放时才会解析的promise。
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The wait function wraps setTimeout in a promise that resolves after the given
    number of milliseconds. This is useful for controlling the speed of the playback.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait`函数将`setTimeout`包装在一个promise中，该promise在给定的毫秒数后解析。这对于控制播放速度非常有用。'
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the entire week that the screen wall stands, every evening, when it is dark,
    a huge glowing orange bird mysteriously appears on it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕墙存在的整个星期，每晚，当天黑时，一个巨大的发光橙色鸟神秘地出现在上面。
- en: The Event Loop
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环
- en: An asynchronous program starts by running its main script, which will often
    set up callbacks to be called later. That main script, as well as the callbacks,
    run to completion in one piece, uninterrupted. But between them, the program may
    sit idle, waiting for something to happen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个异步程序通过运行其主脚本开始，这通常会设置回调以便稍后调用。该主脚本以及回调会以一整块完成，不会被打断。但它们之间，程序可能会处于闲置状态，等待某些事情发生。
- en: So callbacks are not directly called by the code that scheduled them. If I call
    setTimeout from within a function, that function will have returned by the time
    the callback function is called. And when the callback returns, control does not
    go back to the function that scheduled it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回调并不是由调度它们的代码直接调用。如果我在一个函数中调用`setTimeout`，那么在回调函数被调用时，该函数将已经返回。当回调返回时，控制权不会返回到调度它的函数。
- en: Asynchronous behavior happens on its own empty function call stack. This is
    one of the reasons that, without promises, managing exceptions across asynchronous
    code is so hard. Since each callback starts with a mostly empty stack, your catch
    handlers won’t be on the stack when they throw an exception.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 异步行为发生在它自己空的函数调用栈上。这是没有 promise 时，跨异步代码管理异常如此困难的原因之一。由于每个回调开始时栈几乎是空的，当它们抛出异常时，你的
    catch 处理程序不会在栈上。
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No matter how closely together events—such as timeouts or incoming requests—happen,
    a JavaScript environment will run only one program at a time. You can think of
    this as it running a big loop *around* your program, called the *event loop*.
    When there’s nothing to be done, that loop is paused. But as events come in, they
    are added to a queue, and their code is executed one after the other. Because
    no two things run at the same time, slow-running code can delay the handling of
    other events.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 无论事件——如超时或传入请求——发生得多么紧密，JavaScript 环境一次只能运行一个程序。你可以把它看作是在你的程序周围运行一个大循环，称为 *事件循环*。当没有事情可做时，该循环会暂停。但是随着事件的到来，它们会被添加到队列中，代码会一个接一个地执行。因为没有两个事情可以同时运行，运行缓慢的代码可能会延迟处理其他事件。
- en: This example sets a timeout but then dallies until after the timeout’s intended
    point of time, causing the timeout to be late.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子设置了一个超时，但随后拖延，直到超时预定的时间点之后，导致超时变得迟到。
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Promises always resolve or reject as a new event. Even if a promise is already
    resolved, waiting for it will cause your callback to run after the current script
    finishes, rather than right away.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 总是作为一个新事件解析或拒绝。即使一个 promise 已经被解析，等待它也会导致你的回调在当前脚本完成后运行，而不是立即运行。
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In later chapters we’ll see various other types of events that run on the event
    loop.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将看到在事件循环上运行的各种其他类型的事件。
- en: Asynchronous Bugs
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步错误
- en: When your program runs synchronously, in a single go, there are no state changes
    happening except those that the program itself makes. For asynchronous programs
    this is different—they may have *gaps* in their execution during which other code
    can run.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序同步运行时，一次性完成，除了程序自身进行的状态变化之外，没有其他状态变化。对于异步程序来说，这种情况不同——它们在执行过程中可能会有 *空隙*，其他代码可以在这些空隙中运行。
- en: Let’s look at an example. This is a function that tries to report the size of
    each file in an array of files, making sure to read them all at the same time
    rather than in sequence.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。这是一个尝试报告数组中每个文件大小的函数，确保同时读取它们，而不是按顺序读取。
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The async fileName => part shows how arrow functions can also be made async
    by putting the word async in front of them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: async fileName => 部分展示了如何通过在箭头函数前面加上 async 关键字来使箭头函数也变为异步。
- en: The code doesn’t immediately look suspicious . . . it maps the async arrow function
    over the array of names, creating an array of promises, and then uses Promise.all
    to wait for all of these before returning the list they build up.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 代码乍一看并没有什么可疑之处……它对名称数组映射异步箭头函数，创建一个 promises 数组，然后使用 Promise.all 等待所有这些，才返回它们构建的列表。
- en: But this program is entirely broken. It’ll always return only a single line
    of output, listing the file that took the longest to read.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个程序完全有问题。它总是只返回一行输出，列出读取时间最长的文件。
- en: Can you work out why?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找出原因吗？
- en: The problem lies in the += operator, which takes the *current* value of list
    at the time the statement starts executing and then, when the await finishes,
    sets the list binding to be that value plus the added string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在 += 操作符上，它在语句开始执行时取 list 的 *当前* 值，然后在 await 完成时，将 list 绑定设置为该值加上添加的字符串。
- en: But between the time the statement starts executing and the time it finishes,
    there’s an asynchronous gap. The map expression runs before anything has been
    added to the list, so each of the += operators starts from an empty string and
    ends up, when its storage retrieval finishes, setting list to the result of adding
    its line to the empty string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但在语句开始执行和结束之间，有一个异步的空隙。映射表达式在列表中添加任何内容之前就运行，因此每个 += 操作符都是从一个空字符串开始，最后在存储检索完成时，将
    list 设置为将其行添加到空字符串的结果。
- en: This could have easily been avoided by returning the lines from the mapped promises
    and calling join on the result of Promise.all, instead of building up the list
    by changing a binding. As usual, computing new values is less error prone than
    changing existing values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这本可以通过返回映射 promises 的行并在 Promise.all 的结果上调用 join 来轻松避免，而不是通过更改绑定来构建列表。像往常一样，计算新值比更改现有值更不易出错。
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Mistakes like this are easy to make, especially when using await, and you should
    be aware of where the gaps in your code occur. An advantage of JavaScript’s *explicit*
    asynchronicity (whether through callbacks, promises, or await) is that spotting
    these gaps is relatively easy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的错误很容易出现，特别是在使用`await`时，你应该意识到代码中的漏洞所在。JavaScript的*显式*异步性（无论是通过回调、Promise还是await）的一大优点是，发现这些漏洞相对简单。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Asynchronous programming makes it possible to express waiting for long-running
    actions without freezing the whole program. JavaScript environments typically
    implement this style of programming using callbacks, functions that are called
    when the actions complete. An event loop schedules such callbacks to be called
    when appropriate, one after the other, so that their execution does not overlap.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程使得在不冻结整个程序的情况下，表达对长时间运行操作的等待成为可能。JavaScript环境通常使用回调实现这种编程风格，即在操作完成时调用的函数。事件循环会调度这些回调在合适的时候依次调用，以确保它们的执行不会重叠。
- en: Programming asynchronously is made easier by promises, objects that represent
    actions that might complete in the future, and async functions, which allow you
    to write an asynchronous program as if it were synchronous.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Promise使得异步编程变得更简单，Promise是代表可能在未来完成的操作的对象，而异步函数则允许你像同步程序一样编写异步程序。
- en: Exercises
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*Quiet Times*'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*安静的时光*'
- en: There’s a security camera near Carla’s lab that’s activated by a motion sensor.
    It is connected to the network and starts sending out a video stream when it is
    active. Because she’d rather not be discovered, Carla has set up a system that
    notices this kind of wireless network traffic and turns on a light in her lair
    whenever there is activity outside, so she knows when to keep quiet.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 卡拉实验室附近有一台通过运动传感器激活的监控摄像头。它连接到网络并在激活时开始发送视频流。因为她不想被发现，卡拉建立了一个系统，可以注意到这种无线网络流量，并在外面有活动时在她的巢穴中打开灯，以便她知道什么时候保持安静。
- en: She’s also been logging the times at which the camera is tripped for a while
    and wants to use this information to visualize which times, in an average week,
    tend to be quiet and which tend to be busy. The log is stored in files holding
    one time stamp number (as returned by Date.now()) per line.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 她还记录了摄像头被触发的时间一段时间，并希望利用这些信息来可视化一周内哪些时段通常比较安静，哪些时段则比较繁忙。日志存储在每行包含一个时间戳数字（由`Date.now()`返回）的文件中。
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The “camera_logs.txt” file holds a list of logfiles. Write an asynchronous function
    activityTable(day) that for a given day of the week returns an array of 24 numbers,
    one for each hour of the day, that hold the number of camera network traffic observations
    seen in that hour of the day. Days are identified by number using the system used
    by Date.getDay, where Sunday is 0 and Saturday is 6.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: “camera_logs.txt”文件保存了日志文件的列表。编写一个异步函数`activityTable(day)`，该函数为给定的星期几返回一个包含24个数字的数组，每个数字对应一天中的每个小时，表示该小时内观察到的摄像头网络流量。星期几通过数字标识，使用`Date.getDay`的方法，其中星期天是0，星期六是6。
- en: The activityGraph function, provided by the sandbox, summarizes such a table
    into a string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`activityGraph`函数，由沙盒提供，将这样的表汇总为一个字符串。'
- en: To read the files, use the textFile function defined earlier—given a filename,
    it returns a promise that resolves to the file’s content. Remember that new Date(*timestamp*)
    creates a Date object for that time, which has getDay and getHours methods returning
    the day of the week and the hour of the day.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，请使用前面定义的`textFile`函数——给定一个文件名，它返回一个解析为文件内容的Promise。记住，`new Date(*timestamp*)`会为该时间创建一个Date对象，该对象有`getDay`和`getHours`方法，分别返回星期几和小时。
- en: Both types of files—the list of logfiles and the logfiles themselves—have each
    piece of data on its own line, separated by newline (”\n”) characters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的文件——日志文件列表和日志文件本身——每一条数据都在自己的行上，通过换行符（"\n"）分隔。
- en: '*Real Promises*'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*真实的 Promise*'
- en: Rewrite the function from the previous exercise without async/await, using plain
    Promise methods.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重写之前练习中的函数，不使用`async/await`，使用普通的Promise方法。
- en: In this style, using Promise.all will be more convenient than trying to model
    a loop over the logfiles. In the async function, just using await in a loop is
    simpler. If reading a file takes some time, which of these two approaches will
    take the least time to run?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格下，使用`Promise.all`会比尝试对日志文件建模的循环更方便。在异步函数中，简单地在循环中使用`await`更为简单。如果读取文件需要一些时间，哪种方法运行所需的时间最少？
- en: If one of the files listed in the file list has a typo, and reading it fails,
    how does that failure end up in the Promise object that your function returns?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件列表中的某个文件有拼写错误，导致读取失败，这个失败是如何反映到你的函数返回的 Promise 对象中的？
- en: '*Building Promise.all*'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建 Promise.all*'
- en: As we saw, given an array of promises, Promise.all returns a promise that waits
    for all of the promises in the array to finish. It then succeeds, yielding an
    array of result values. If a promise in the array fails, the promise returned
    by all fails too, passing on the failure reason from the failing promise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，给定一个承诺数组，Promise.all返回一个承诺，等待数组中所有承诺完成。它然后成功，返回一个结果值数组。如果数组中的一个承诺失败，所有的承诺返回的承诺也会失败，并传递失败承诺的失败原因。
- en: Implement something like this yourself as a regular function called Promise_all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自己实现类似的功能，作为一个名为 Promise_all 的常规函数。
- en: Remember that after a promise has succeeded or failed, it can’t succeed or fail
    again, and further calls to the functions that resolve it are ignored. This can
    simplify the way you handle a failure of your promise.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在一个承诺成功或失败后，它无法再次成功或失败，对其解析的函数的进一步调用将被忽略。这可以简化你处理承诺失败的方式。
- en: '*The evaluator, which determines the meaning of expressions in a programming
    language, is just another program.*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*评估器，用于确定编程语言中表达式的含义，仅仅是另一个程序。*'
- en: —Hal Abelson and Gerald Sussman, *Structure and Interpretation of Computer Programs*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: —哈尔·阿贝尔森和杰拉尔德·萨斯曼，《计算机程序的结构与解释》
- en: '![Image](../images/f0194-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0194-01.jpg)'
