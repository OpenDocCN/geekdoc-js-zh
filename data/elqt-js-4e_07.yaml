- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: THE SECRET LIFE OF OBJECTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象的秘密生活
- en: '[Chapter 4](ch04.xhtml#ch04) introduced JavaScript’s objects as containers
    that hold other data. In programming culture, *object-oriented programming* is
    a set of techniques that use objects as the central principle of program organization.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](ch04.xhtml#ch04)介绍了JavaScript中的对象作为持有其他数据的容器。在编程文化中，*面向对象编程*是一套以对象为程序组织核心原则的技术。'
- en: Though no one really agrees on its precise definition, object-oriented programming
    has shaped the design of many programming languages, including JavaScript. This
    chapter describes the way these ideas can be applied in JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有人真正同意它的确切定义，面向对象编程已经塑造了许多编程语言的设计，包括JavaScript。本章描述了这些思想如何应用于JavaScript。
- en: Abstract Data Types
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象数据类型
- en: The main idea in object-oriented programming is to use objects, or rather *types*
    of objects, as the unit of program organization. Setting up a program as a number
    of strictly separated object types provides a way to think about its structure
    and thus to enforce some kind of discipline, preventing everything from becoming
    entangled.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的主要思想是将对象，或者更确切地说是*对象类型*，作为程序组织的单元。将程序设置为多个严格分离的对象类型提供了一种思考其结构的方式，从而实施某种纪律，防止所有内容交织在一起。
- en: The way to do this is to think of objects somewhat like you’d think of an electric
    mixer or other consumer appliance. The people who design and assemble mixers have
    to do specialized work requiring material science and understanding of electricity.
    They cover all that up in a smooth plastic shell so that the people who only want
    to mix pancake batter don’t have to worry about all that—they have to understand
    only the few knobs that the mixer can be operated with.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的方法是将对象视为电动搅拌机或其他消费电器。设计和组装搅拌机的人需要进行专业工作，要求材料科学和电力知识。他们将所有这些都隐藏在光滑的塑料外壳中，这样只想搅拌煎饼面糊的人就不必担心这些——他们只需理解搅拌机可以操作的几个旋钮。
- en: Similarly, an *abstract data type*, or *object class*, is a subprogram that
    may contain arbitrarily complicated code but exposes a limited set of methods
    and properties that people working with it are supposed to use. This allows large
    programs to be built up out of a number of appliance types, limiting the degree
    to which these different parts are entangled by requiring them to only interact
    with each other in specific ways.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，*抽象数据类型*或*对象类*是一个子程序，可能包含任意复杂的代码，但暴露出一组有限的方法和属性，供与之合作的人使用。这允许大型程序由多个电器类型构建，限制了这些不同部分交织的程度，要求它们仅以特定方式相互作用。
- en: If a problem is found in one such object class, it can often be repaired or
    even completely rewritten without impacting the rest of the program. Even better,
    it may be possible to use object classes in multiple different programs, avoiding
    the need to recreate their functionality from scratch. You can think of JavaScript’s
    built-in data structures, such as arrays and strings, as such reusable abstract
    data types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个对象类中发现问题，通常可以修复或甚至完全重写，而不会影响程序的其他部分。更好的是，可能在多个不同的程序中使用对象类，避免了从头开始重建其功能的需要。你可以将JavaScript的内置数据结构，如数组和字符串，视为这样的可重用抽象数据类型。
- en: Each abstract data type has an *interface*, the collection of operations that
    external code can perform on it. Any details beyond that interface are *encapsulated*,
    treated as internal to the type and of no concern to the rest of the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个抽象数据类型都有一个*接口*，这是外部代码可以对其执行的操作集合。超出该接口的任何细节都是*封装*的，视为该类型的内部内容，对程序的其他部分无关紧要。
- en: Even basic things like numbers can be thought of as an abstract data type whose
    interface allows us to add them, multiply them, compare them, and so on. In fact,
    the fixation on single *objects* as the main unit of organization in classical
    object-oriented programming is somewhat unfortunate, since useful pieces of functionality
    often involve a group of different object classes working closely together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至像数字这样的基本事物也可以被视为一个抽象数据类型，其接口允许我们对其进行加法、乘法、比较等操作。实际上，在经典的面向对象编程中，将单个*对象*作为主要组织单元的执着是有些不幸的，因为有用的功能片段通常涉及不同对象类紧密合作的情况。
- en: Methods
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'In JavaScript, methods are nothing more than properties that hold function
    values. This is a simple method:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，方法不过是持有函数值的属性。这是一个简单的方法：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Typically a method needs to do something with the object on which it was called.
    When a function is called as a method—looked up as a property and immediately
    called, as in object.method()—the binding called this in its body automatically
    points at the object on which it was called.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个方法需要对其被调用的对象执行某些操作。当一个函数被作为方法调用时——作为属性查找并立即调用，如 object.method()——在其主体内被称为
    this 的绑定自动指向其被调用的对象。
- en: You can think of this as an extra parameter that is passed to the function in
    a different way than regular parameters. If you want to provide it explicitly,
    you can use a function’s call method, which takes the this value as its first
    argument and treats further arguments as normal parameters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这看作是以不同于常规参数的方式传递给函数的额外参数。如果你想明确提供它，可以使用函数的 call 方法，该方法将 this 值作为第一个参数，并将后续参数视为常规参数。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since each function has its own this binding whose value depends on the way
    it is called, you cannot refer to the this of the wrapping scope in a regular
    function defined with the function keyword.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个函数都有自己的 this 绑定，其值取决于调用的方式，因此在用 function 关键字定义的常规函数中，你无法引用包装作用域的 this。
- en: 'Arrow functions are different—they do not bind their own this but can see the
    this binding of the scope around them. Thus, you can do something like the following
    code, which references this from inside a local function:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数是不同的——它们不会绑定自己的 this，但可以看到周围作用域的 this 绑定。因此，你可以执行如下代码，其中在局部函数内部引用了 this：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A property like find(array) in an object expression is a shorthand way of defining
    a method. It creates a property called find and gives it a function as its value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象表达式中，像 find(array) 这样的属性是定义方法的一种简写方式。它创建了一个名为 find 的属性，并将一个函数作为其值。
- en: If I had written the argument to some using the function keyword, this code
    wouldn’t work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用 function 关键字为某个参数编写了代码，那么这段代码将无法工作。
- en: Prototypes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原型
- en: One way to create a rabbit object type with a speak method would be to create
    a helper function that has a rabbit type as its parameter and returns an object
    holding that as its type property and our speak function in its speak property.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有说话方法的兔子对象类型的一种方法是创建一个助手函数，该函数将兔子类型作为参数，并返回一个将其作为类型属性的对象，并在其说话属性中包含我们的说话函数。
- en: All rabbits share that same method. Especially for types with many methods,
    it would be nice if there were a way to keep a type’s methods in a single place,
    rather than adding them to each object individually.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有兔子共享相同的方法。尤其对于具有多个方法的类型，如果能够以某种方式将类型的方法集中在一个地方，而不是逐个添加到每个对象中，那就太好了。
- en: In JavaScript, *prototypes* are the way to do that. Objects can be linked to
    other objects, to magically get all the properties that other object has. Plain
    old objects created with {} notation are linked to an object called Object.prototype.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，*原型* 是实现这一点的方法。对象可以链接到其他对象，以神奇的方式获取其他对象所具有的所有属性。使用 {} 表示法创建的普通对象链接到一个名为
    Object.prototype 的对象。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It looks like we just pulled a property out of an empty object. But in fact,
    toString is a method stored in Object.prototype, meaning it is available in most
    objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们只是从一个空对象中提取了一个属性。但实际上，toString 是存储在 Object.prototype 中的方法，意味着它在大多数对象中都是可用的。
- en: When an object gets a request for a property that it doesn’t have, its prototype
    will be searched for the property. If that doesn’t have it, the *prototype’s*
    prototype is searched, and so on until an object without prototype is reached
    (Object.prototype is such an object).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象请求它没有的属性时，将会搜索其原型。如果原型中没有该属性，则会继续搜索 *原型的* 原型，依此类推，直到找到一个没有原型的对象（Object.prototype就是这样的对象）。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you’d guess, Object.getPrototypeOf returns the prototype of an object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所猜的，Object.getPrototypeOf 返回一个对象的原型。
- en: Many objects don’t directly have Object.prototype as their prototype but instead
    have another object that provides a different set of default properties. Functions
    derive from Function.prototype and arrays derive from Array .prototype.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对象并不直接以 Object.prototype 作为它们的原型，而是拥有另一个提供不同默认属性集的对象。函数源自 Function.prototype，数组源自
    Array.prototype。
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Such a prototype object will itself have a prototype, often Object.prototype,
    so that it still indirectly provides methods like toString.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的原型对象本身也将拥有一个原型，通常是 Object.prototype，这样它仍然间接提供像 toString 这样的函数。
- en: You can use Object.create to create an object with a specific prototype.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Object.create 来创建一个具有特定原型的对象。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The “proto” rabbit acts as a container for the properties shared by all rabbits.
    An individual rabbit object, like the black rabbit, contains properties that apply
    only to itself—in this case its type—and derives shared properties from its prototype.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “proto”兔子作为所有兔子共享属性的容器。个别兔子对象，如黑兔，包含仅适用于它自己的属性——在这种情况下是它的类型——并从其原型继承共享属性。
- en: Classes
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: JavaScript’s prototype system can be interpreted as a somewhat free-form take
    on abstract data types or classes. A *class* defines the shape of a type of object—what
    methods and properties it has. Such an object is called an *instance* of the class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的原型系统可以被解释为一种自由形式的抽象数据类型或类。*类*定义了一种对象的形状——它具有哪些方法和属性。这样的对象称为该类的*实例*。
- en: Prototypes are useful for defining properties for which all instances of a class
    share the same value. Properties that differ per instance, such as our rabbits’
    type property, need to be stored directly in the objects themselves.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 原型对于定义所有类实例共享相同值的属性非常有用。每个实例不同的属性，例如我们的兔子的类型属性，需要直接存储在对象本身中。
- en: To create an instance of a given class, you have to make an object that derives
    from the proper prototype, but you *also* have to make sure it itself has the
    properties that instances of this class are supposed to have. This is what a *constructor*
    function does.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建给定类的实例，你必须生成一个从适当原型派生的对象，但你*还*需要确保该对象本身具有此类实例应该具备的属性。这就是*构造函数*的作用。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JavaScript’s class notation makes it easier to define this type of function,
    along with a prototype object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的类语法使定义这种类型的函数以及原型对象变得更容易。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The class keyword starts a class declaration, which allows us to define a constructor
    and a set of methods together. Any number of methods may be written inside the
    declaration’s braces. This code has the effect of defining a binding called Rabbit,
    which holds a function that runs the code in constructor and has a prototype property
    that holds the speak method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: class关键字开始一个类声明，这使我们能够一起定义构造函数和一组方法。声明的花括号内可以编写任意数量的方法。这段代码的效果是定义一个名为Rabbit的绑定，持有一个运行构造函数代码的函数，并具有一个持有speak方法的原型属性。
- en: This function cannot be called like a normal function. Constructors, in JavaScript,
    are called by putting the keyword new in front of them. Doing so creates a fresh
    instance object whose prototype is the object from the function’s prototype property,
    then runs the function with this bound to the new object, and finally returns
    the object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不能像普通函数那样调用。在JavaScript中，构造函数通过在前面加上关键字new来调用。这样做会创建一个新的实例对象，其原型是来自函数的原型属性的对象，然后运行该函数，将this绑定到新对象，最后返回该对象。
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In fact, class was only introduced in the 2015 edition of JavaScript. Any function
    can be used as a constructor, and before 2015, the way to define a class was to
    write a regular function and then manipulate its prototype property.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，类是在2015年版JavaScript中引入的。任何函数都可以用作构造函数，而在2015年之前，定义类的方法是编写一个常规函数，然后操作其原型属性。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this reason, all non-arrow functions start with a prototype property holding
    an empty object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有非箭头函数都以一个持有空对象的原型属性开头。
- en: By convention, the names of constructors are capitalized so that they can easily
    be distinguished from other functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，构造函数的名称首字母大写，以便能够与其他函数轻松区分。
- en: It is important to understand the distinction between the way a prototype is
    associated with a constructor (through its prototype property) and the way objects
    *have* a prototype (which can be found with Object.getPrototypeOf). The actual
    prototype of a constructor is Function.prototype since constructors are functions.
    The constructor function’s prototype *property* holds the prototype used for instances
    created through it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 理解原型与构造函数之间的关联方式（通过其原型属性）以及对象*拥有*原型的方式（可以通过Object.getPrototypeOf找到）之间的区别非常重要。构造函数的实际原型是Function.prototype，因为构造函数是函数。构造函数的原型*属性*保存通过它创建的实例所使用的原型。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Constructors will typically add some per-instance properties to this. It is
    also possible to declare properties directly in the class declaration. Unlike
    methods, such properties are added to instance objects and not the prototype.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通常会向此添加一些每个实例的属性。也可以在类声明中直接声明属性。与方法不同，这些属性是添加到实例对象中，而不是原型中。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like function, class can be used both in statements and in expressions. When
    used as an expression, it doesn’t define a binding but just produces the constructor
    as a value. You are allowed to omit the class name in a class expression.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数，类可以在语句和表达式中使用。当作为表达式使用时，它不会定义绑定，而只是将构造函数作为值生成。你可以在类表达式中省略类名。
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Private Properties
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有属性
- en: It is common for classes to define some properties and methods for internal
    use that are not part of their interface. These are called *private* properties,
    as opposed to *public* ones, which are part of the object’s external interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常会定义一些内部使用的属性和方法，这些不是它们接口的一部分。这些被称为*私有*属性，而与之相对的是*公共*属性，它们是对象外部接口的一部分。
- en: 'To declare a private method, put a # sign in front of its name. Such methods
    can be called only from inside the class declaration that defines them.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个私有方法，在其名称前加一个#号。这样的函数只能在定义它们的类声明内部调用。
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When a class does not declare a constructor, it will automatically get an empty
    one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类没有声明构造函数时，它将自动获得一个空的构造函数。
- en: 'If you try to call #getSecret from outside the class, you get an error. Its
    existence is entirely hidden inside the class declaration.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你试图从类外调用 #getSecret，会出现错误。它的存在完全隐藏在类声明内部。'
- en: To use private instance properties, you must declare them. Regular properties
    can be created by just assigning to them, but private properties *must* be declared
    in the class declaration to be available at all.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用私有实例属性，必须先声明它们。常规属性可以通过简单的赋值创建，但私有属性*必须*在类声明中声明，才能被使用。
- en: 'This class implements an appliance for getting a random whole number below
    a given maximum number. It has only one public property: getNumber.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该类实现了一种获取小于给定最大数的随机整数的工具。它只有一个公共属性：getNumber。
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Overriding Derived Properties
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写派生属性
- en: When you add a property to an object, whether it is present in the prototype
    or not, the property is added to the object *itself*. If there was already a property
    with the same name in the prototype, this property will no longer affect the object,
    as it is now hidden behind the object’s own property.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向一个对象添加属性时，无论它是否存在于原型中，该属性都会添加到对象*本身*。如果原型中已经有一个同名属性，那么这个属性将不再影响对象，因为它现在被对象自己的属性隐藏了。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The following diagram sketches the situation after this code has run. The Rabbit
    and Object prototypes lie behind killerRabbit as a kind of backdrop, where properties
    that are not found in the object itself can be looked up.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示描绘了这段代码运行后的情况。兔子和对象原型作为背景存在于killerRabbit后面，未在对象本身中找到的属性可以在这里查找。
- en: '![Image](../images/f0102-01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0102-01.jpg)'
- en: Overriding properties that exist in a prototype can be a useful thing to do.
    As the rabbit teeth example shows, overriding can be used to express exceptional
    properties in instances of a more generic class of objects while letting the nonexceptional
    objects take a standard value from their prototype.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重写存在于原型中的属性是一个有用的操作。正如兔子牙齿的例子所示，重写可以用来表达更通用对象类实例中的特殊属性，同时让非特殊对象从其原型中获取标准值。
- en: Overriding is also used to give the standard function and array prototypes a
    different toString method than the basic object prototype.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 重写还用于给标准函数和数组原型提供不同于基本对象原型的toString方法。
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Calling toString on an array gives a result similar to calling .join(“,”) on
    it—it puts commas between the values in the array. Directly calling Object .prototype.toString
    with an array produces a different string. That function doesn’t know about arrays,
    so it simply puts the word *object* and the name of the type between square brackets.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上调用toString的结果类似于调用.join(",")，它在数组中的值之间放置逗号。直接在数组上调用Object.prototype.toString会生成不同的字符串。该函数并不知道数组，因此它只是将单词*object*和类型名称放在方括号之间。
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Maps
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: We saw the word *map* used in the previous chapter for an operation that transforms
    a data structure by applying a function to its elements. Confusing as it is, in
    programming the same word is used for a related but rather different thing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一章中看到单词*映射*用于通过将函数应用于元素来转换数据结构的操作。虽然令人困惑，在编程中同样的词用于一个相关但不同的概念。
- en: A *map* (noun) is a data structure that associates values (the keys) with other
    values. For example, you might want to map names to ages. It is possible to use
    objects for this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*映射*（名词）是一种将值（键）与其他值关联的数据结构。例如，你可能想将名字映射到年龄。这是可以使用对象来实现的。'
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the object’s property names are the people’s names and the property values
    are their ages. But we certainly didn’t list anybody named toString in our map.
    Yet because plain objects derive from Object.prototype, it looks like the property
    is there.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，对象的属性名称是人名，属性值是他们的年龄。但我们确实没有在映射中列出任何名为 toString 的人。然而，由于普通对象继承自 Object.prototype，看起来这个属性是存在的。
- en: For this reason, using plain objects as maps is dangerous. There are several
    possible ways to avoid this problem. First, you can create objects with *no* prototype.
    If you pass null to Object.create, the resulting object will not derive from Object.prototype
    and can be safely used as a map.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，使用普通对象作为映射是危险的。有几种可能的方法可以避免这个问题。首先，你可以创建*没有*原型的对象。如果你将 null 传递给 Object.create，生成的对象将不继承自
    Object.prototype，可以安全地用作映射。
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Object property names must be strings. If you need a map whose keys can’t easily
    be converted to strings—such as objects—you cannot use an object as your map.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对象属性名称必须是字符串。如果你需要一个键无法轻易转换为字符串的映射—例如对象—你就无法使用对象作为映射。
- en: Fortunately, JavaScript comes with a class called Map that is written for this
    exact purpose. It stores a mapping and allows any type of keys.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript 提供了一个名为 Map 的类，正是为这个目的而编写。它存储一个映射，并允许任何类型的键。
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The methods set, get, and has are part of the interface of the Map object. Writing
    a data structure that can quickly update and search a large set of values isn’t
    easy, but we don’t have to worry about that. Someone else did it for us, and we
    can go through this simple interface to use their work.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: set、get 和 has 方法是 Map 对象接口的一部分。编写一个可以快速更新和搜索大量值的数据结构并不容易，但我们不必担心这个。有人为我们做了这件事，我们可以通过这个简单的接口使用他们的工作。
- en: If you do have a plain object that you need to treat as a map for some reason,
    it is useful to know that Object.keys returns only an object’s *own* keys, not
    those in the prototype. As an alternative to the in operator, you can use the
    Object.hasOwn function, which ignores the object’s prototype.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实有一个普通对象，出于某种原因需要将其视为映射，知道 Object.keys 仅返回对象的*自有*键，而不返回原型中的键是很有用的。作为 in
    运算符的替代，你可以使用 Object.hasOwn 函数，它会忽略对象的原型。
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Polymorphism
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态
- en: When you call the String function (which converts a value to a string) on an
    object, it will call the toString method on that object to try to create a meaningful
    string from it. I mentioned that some of the standard prototypes define their
    own version of toString so they can create a string that contains more useful
    information than “[object Object]”. You can also do that yourself.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象上调用 String 函数（将值转换为字符串）时，它将调用该对象的 toString 方法以尝试从中创建一个有意义的字符串。我提到过，某些标准原型定义了自己的
    toString 版本，以便创建一个包含比“[object Object]”更有用信息的字符串。你也可以自己做到这一点。
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a simple instance of a powerful idea. When a piece of code is written
    to work with objects that have a certain interface—in this case, a toString method—any
    kind of object that happens to support this interface can be plugged into the
    code and will be able to work with it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大理念的简单实例。当一段代码被编写用于处理具有特定接口的对象—在这种情况下是 toString 方法—任何恰好支持此接口的对象都可以插入代码中并能够与其一起工作。
- en: This technique is called *polymorphism*. Polymorphic code can work with values
    of different shapes, as long as they support the interface it expects.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为*多态*。多态代码可以与不同形状的值一起工作，只要它们支持它所期望的接口。
- en: An example of a widely used interface is that of array-like objects that have
    a length property holding a number and numbered properties for each of their elements.
    Both arrays and strings support this interface, as do various other objects, some
    of which we’ll see later in the chapters about the browser. Our implementation
    of forEach from [Chapter 5](ch05.xhtml#ch05) works on anything that provides this
    interface. In fact, so does Array.prototype.forEach.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广泛使用的接口示例是数组类对象，它们具有一个包含数字的 length 属性和每个元素的编号属性。数组和字符串都支持这个接口，还有其他各种对象，其中一些我们将在关于浏览器的章节中看到。我们在[第五章](ch05.xhtml#ch05)中的
    forEach 实现可以在任何提供此接口的对象上工作。实际上，Array.prototype.forEach 也是如此。
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Getters, Setters, and Statics
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取器、设置器和静态方法
- en: Interfaces often contain plain properties, not just methods. For example, Map
    objects have a size property that tells you how many keys are stored in them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接口通常包含普通属性，而不仅仅是方法。例如，Map对象有一个大小属性，它告诉你存储了多少个键。
- en: It is not necessary for such an object to compute and store such a property
    directly in the instance. Even properties that are accessed directly may hide
    a method call. Such methods are called *getters* and are defined by writing get
    in front of the method name in an object expression or class declaration.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的对象不必直接在实例中计算和存储这样的属性。即使是直接访问的属性也可能隐藏一个方法调用。这种方法称为*getter*，通过在对象表达式或类声明中的方法名前加上get来定义。
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whenever someone reads from this object’s size property, the associated method
    is called. You can do a similar thing when a property is written to, using a *setter*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每当有人读取这个对象的大小属性时，相关的方法就会被调用。当属性被写入时，你可以做类似的事情，使用一个*setter*。
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Temperature class allows you to read and write the temperature in either
    degrees Celsius or degrees Fahrenheit, but internally it stores only Celsius and
    automatically converts to and from Celsius in the fahrenheit getter and setter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Temperature类允许你以摄氏度或华氏度读取和写入温度，但内部只存储摄氏度，并在华氏度的getter和setter中自动进行摄氏度之间的转换。
- en: Sometimes you want to attach some properties directly to your constructor function
    rather than to the prototype. Such methods won’t have access to a class instance
    but can, for example, be used to provide additional ways to create instances.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你希望将某些属性直接附加到构造函数上，而不是附加到原型上。这种方法将无法访问类实例，但可以例如用于提供创建实例的其他方式。
- en: Inside a class declaration, methods or properties that have static written before
    their name are stored on the constructor. For example, the Temperature class allows
    you to write Temperature.fromFahrenheit(100) to create a temperature using degrees
    Fahrenheit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在类声明内部，方法或属性前面写有static的会存储在构造函数上。例如，Temperature类允许你使用Temperature.fromFahrenheit(100)来创建一个以华氏度表示的温度。
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Symbols
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号
- en: I mentioned in [Chapter 4](ch04.xhtml#ch04) that a for/of loop can loop over
    several kinds of data structures. This is another case of polymorphism—such loops
    expect the data structure to expose a specific interface, which arrays and strings
    do. And we can also add this interface to our own objects! But before we can do
    that, we need to briefly take a look at the symbol type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第4章](ch04.xhtml#ch04)中提到过，for/of循环可以遍历几种数据结构。这是多态性的另一个例子——这样的循环期望数据结构暴露特定的接口，而数组和字符串做到了。我们也可以将这个接口添加到我们自己的对象上！但在我们做到这一点之前，我们需要简要了解一下符号类型。
- en: It is possible for multiple interfaces to use the same property name for different
    things. For example, on array-like objects, length refers to the number of elements
    in the collection. But an object interface describing a hiking route could use
    length to provide the length of the route in meters. It would not be possible
    for an object to conform to both these interfaces.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 多个接口可以为不同的事物使用相同的属性名称是可能的。例如，在类似数组的对象上，length指的是集合中元素的数量。但描述徒步路线的对象接口可以使用length来提供路线的米数。一个对象不可能同时符合这两个接口。
- en: An object trying to be a route and array-like (maybe to enumerate its waypoints)
    is somewhat far-fetched, and this kind of problem isn’t that common in practice.
    For things like the iteration protocol, though, the language designers needed
    a type of property that *really* doesn’t conflict with any others. So in 2015,
    *symbols* were added to the language.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个试图成为路由和类似数组的对象（也许是为了枚举它的途径点）有些牵强，而这种问题在实践中并不常见。不过，对于像迭代协议这样的内容，语言设计者需要一种*真的*不会与其他属性冲突的属性。因此，在2015年，*符号*被添加到语言中。
- en: Most properties, including all those we have seen so far, are named with strings.
    But it is also possible to use symbols as property names. Symbols are values created
    with the Symbol function. Unlike strings, newly created symbols are unique—you
    cannot create the same symbol twice.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数属性，包括我们迄今为止看到的所有属性，都是用字符串命名的。但也可以使用符号作为属性名。符号是通过Symbol函数创建的值。与字符串不同，新创建的符号是唯一的——你不能创建同样的符号两次。
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The string you pass to Symbol is included when you convert it to a string and
    can make it easier to recognize a symbol when, for example, showing it in the
    console. But it has no meaning beyond that—multiple symbols may have the same
    name.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 Symbol 的字符串在转换为字符串时包含在内，并且可以在例如在控制台中显示时更容易识别符号。但除此之外没有其他意义——多个符号可能具有相同的名称。
- en: Being both unique and usable as property names makes symbols suitable for defining
    interfaces that can peacefully live alongside other properties, no matter what
    their names are.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 符号既唯一又可用作属性名，使其适合定义可以与其他属性和平共存的接口，无论其他属性的名称是什么。
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It is possible to include symbol properties in object expressions and classes
    by using square brackets around the property name. That causes the expression
    between the brackets to be evaluated to produce the property name, analogous to
    the square bracket property access notation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在属性名称周围使用方括号，可以在对象表达式和类中包含符号属性。这会导致方括号之间的表达式被求值以生成属性名称，类似于方括号属性访问表示法。
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Iterator Interface
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器接口
- en: The object given to a for/of loop is expected to be *iterable*. This means it
    has a method named with the Symbol.iterator symbol (a symbol value defined by
    the language, stored as a property of the Symbol function).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给 for/of 循环的对象预期是 *可迭代的*。这意味着它有一个以 Symbol.iterator 符号命名的方法（这是一个由语言定义的符号值，存储为
    Symbol 函数的属性）。
- en: When called, that method should return an object that provides a second interface,
    *iterator*. This is the actual thing that iterates. It has a next method that
    returns the next result. That result should be an object with a value property
    that provides the next value, if there is one, and a done property, which should
    be true when there are no more results and false otherwise.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当被调用时，该方法应该返回一个提供第二个接口的对象，*迭代器*。这实际上就是进行迭代的东西。它有一个 next 方法，返回下一个结果。该结果应该是一个具有
    value 属性的对象，提供下一个值（如果有的话），以及一个 done 属性，当没有更多结果时为 true，否则为 false。
- en: Note that the next, value, and done property names are plain strings, not symbols.
    Only Symbol.iterator, which is likely to be added to a *lot* of different objects,
    is an actual symbol.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，next、value 和 done 属性名是普通字符串，而不是符号。只有 Symbol.iterator 可能会被添加到许多不同对象中，是一个实际的符号。
- en: We can directly use this interface ourselves.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用这个接口。
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s implement an iterable data structure similar to the linked list from the
    exercise in [Chapter 4](ch04.xhtml#ch04). We’ll write the list as a class this
    time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个类似于第 [4 章](ch04.xhtml#ch04) 练习中链表的可迭代数据结构。这次我们将把列表写成一个类。
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that this, in a static method, points at the constructor of the class,
    not an instance—there is no instance around when a static method is called.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在静态方法中，这指向的是类的构造函数，而不是实例——在调用静态方法时没有实例存在。
- en: Iterating over a list should return all the list’s elements from start to end.
    We’ll write a separate class for the iterator.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表应该从头到尾返回所有列表元素。我们将为迭代器编写一个单独的类。
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The class tracks the progress of iterating through the list by updating its
    list property to move to the next list object whenever a value is returned and
    reports that it is done when that list is empty (null).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该类通过更新其列表属性来跟踪迭代列表的进度，以便在返回一个值时移动到下一个列表对象，并在该列表为空（null）时报告已完成。
- en: Let’s set up the List class to be iterable. Throughout this book, I’ll occasionally
    use after-the-fact prototype manipulation to add methods to classes so that the
    individual pieces of code remain small and self-contained. In a regular program,
    where there is no need to split the code into small pieces, you’d declare these
    methods directly in the class instead.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 List 类以便可以迭代。在本书中，我会偶尔使用事后原型操作来向类添加方法，以便各个代码片段保持小且自包含。在常规程序中，如果不需要将代码拆分成小片段，则可以直接在类中声明这些方法。
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can now loop over a list with for/of.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 for/of 循环遍历列表。
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The ... syntax in array notation and function calls similarly works with any
    iterable object. For example, you can use [...*value*] to create an array containing
    the elements in an arbitrary iterable object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 数组表示法和函数调用中的 ... 语法同样适用于任何可迭代对象。例如，你可以使用 [...*value*] 来创建一个包含任意可迭代对象中元素的数组。
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inheritance
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Imagine we need a list type much like the List class we saw before, but because
    we will be asking for its length all the time, we don’t want it to have to scan
    through its rest every time. Instead, we want to store the length in every instance
    for efficient access.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们需要一个与之前看到的 List 类非常相似的列表类型，但因为我们将一直请求它的长度，所以我们不希望每次都扫描它的其他部分。相反，我们希望在每个实例中存储长度以实现高效访问。
- en: JavaScript’s prototype system makes it possible to create a *new* class, much
    like the old class, but with new definitions for some of its properties. The prototype
    for the new class derives from the old prototype but adds a new definition for,
    say, the length getter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的原型系统使得创建一个*新*类成为可能，这个新类与旧类类似，但某些属性的定义不同。新类的原型源自旧原型，但为例如长度 getter
    添加了新的定义。
- en: In object-oriented programming terms, this is called *inheritance*. The new
    class inherits properties and behavior from the old class.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程术语中，这被称为*继承*。新类从旧类继承属性和行为。
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The use of the word extends indicates that this class shouldn’t be directly
    based on the default Object prototype but on some other class. This is called
    the *superclass*. The derived class is the *subclass*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 extends 这个词表明这个类不应该直接基于默认的 Object 原型，而应该基于其他类。这被称为*超类*。派生类是*子类*。
- en: To initialize a LengthList instance, the constructor calls the constructor of
    its superclass through the super keyword. This is necessary because if this new
    object is to behave (roughly) like a List, it is going to need the instance properties
    that lists have.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化一个 LengthList 实例，构造函数通过 super 关键字调用其超类的构造函数。这是必要的，因为如果这个新对象要（大致上）像一个 List
    行为，它需要列表所具有的实例属性。
- en: 'The constructor then stores the list’s length in a private property. If we
    had written this.length there, the class’s own getter would have been called,
    which doesn’t work yet, since #length hasn’t been filled in yet. We can use super.something
    to call methods and getters on the superclass’s prototype, which is often useful.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '然后构造函数将列表的长度存储在一个私有属性中。如果我们在那里写 this.length，类自己的 getter 将被调用，但这还不能工作，因为 #length
    还没有被填充。我们可以使用 super.something 调用超类原型上的方法和 getter，这通常很有用。'
- en: Inheritance allows us to build slightly different data types from existing data
    types with relatively little work. It is a fundamental part of the object-oriented
    tradition, alongside encapsulation and polymorphism. But while the latter two
    are now generally regarded as wonderful ideas, inheritance is more controversial.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 继承使我们能够在现有数据类型的基础上构建稍微不同的数据类型，工作量相对较小。它是面向对象传统的一个基本部分，与封装和多态并列。但虽然后两者现在通常被认为是很好的想法，继承则更具争议。
- en: Whereas encapsulation and polymorphism can be used to *separate* pieces of code
    from one another, reducing the tangledness of the overall program, inheritance
    fundamentally ties classes together, creating *more* tangle. When inheriting from
    a class, you usually have to know more about how it works than when simply using
    it. Inheritance can be a useful tool to make some types of programs more succinct,
    but it shouldn’t be the first tool you reach for, and you probably shouldn’t actively
    go looking for opportunities to construct class hierarchies (family trees of classes).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 封装和多态可以用来*分离*代码片段，减少整个程序的复杂度，而继承则根本上将类联系在一起，造成*更多*的纠缠。当从一个类继承时，你通常需要了解它的工作原理，比简单使用它时知道的要多。继承可以是使某些类型的程序更简洁的有用工具，但它不应该是你首先使用的工具，而且你可能不应该主动寻找构建类层次结构（类的家族树）的机会。
- en: The instanceof Operator
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: instanceof 操作符
- en: It is occasionally useful to know whether an object was derived from a specific
    class. For this, JavaScript provides a binary operator called instanceof.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有时了解一个对象是否是从特定类派生出来的很有用。为此，JavaScript 提供了一个名为 instanceof 的二元操作符。
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The operator will see through inherited types, so a LengthList is an instance
    of List. The operator can also be applied to standard constructors like Array.
    Almost every object is an instance of Object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符能够透视继承类型，因此 LengthList 是 List 的一个实例。该操作符也可以应用于像 Array 这样的标准构造函数。几乎每个对象都是
    Object 的一个实例。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Objects do more than just hold their own properties. They have prototypes, which
    are other objects. They’ll act as if they have properties they don’t have as long
    as their prototype has that property. Simple objects have Object .prototype as
    their prototype.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对象不仅仅是持有自己的属性。它们还有原型，原型是其他对象。只要它们的原型具有该属性，它们就会表现得像拥有那个属性一样。简单对象的原型是 Object.prototype。
- en: Constructors, which are functions whose names usually start with a capital letter,
    can be used with the new operator to create new objects. The new object’s prototype
    will be the object found in the prototype property of the constructor. You can
    make good use of this by putting the properties that all values of a given type
    share into their prototype. There’s a class notation that provides a clear way
    to define a constructor and its prototype.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是名称通常以大写字母开头的函数，可以与 new 操作符一起使用来创建新对象。新对象的原型将是构造函数的原型属性中找到的对象。您可以通过将所有给定类型的值共享的属性放入其原型来充分利用这一点。还有一种类的表示法，提供了一种清晰的方式来定义构造函数及其原型。
- en: You can define getters and setters to secretly call methods every time an object’s
    property is accessed. Static methods are methods stored in a class’s constructor
    rather than its prototype.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义 getters 和 setters，在每次访问对象的属性时秘密调用方法。静态方法是存储在类的构造函数中的方法，而不是其原型中的方法。
- en: The instanceof operator can, given an object and a constructor, tell you whether
    that object is an instance of that constructor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: instanceof 操作符可以根据一个对象和一个构造函数，告诉您该对象是否是该构造函数的实例。
- en: One useful thing to do with objects is to specify an interface for them and
    tell everybody that they are supposed to talk to your object only through that
    interface. The rest of the details that make up your object are now *encapsulated*,
    hidden behind the interface. You can use private properties to hide a part of
    your object from the outside world.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 处理对象时一个有用的做法是为它们指定一个接口，并告诉大家应该只通过该接口与您的对象交互。构成您对象的其余细节现在被 *封装*，隐藏在接口之后。您可以使用私有属性将对象的一部分隐藏于外部世界。
- en: More than one type may implement the same interface. Code written to use an
    interface automatically knows how to work with any number of different objects
    that provide the interface. This is called *polymorphism*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 多于一种类型可以实现相同的接口。为使用接口编写的代码自动知道如何处理任何数量的提供该接口的不同对象。这被称为 *多态*。
- en: When implementing multiple classes that differ in only some details, it can
    be helpful to write the new classes as *subclasses* of an existing class, *inheriting*
    part of its behavior.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现多个仅在某些细节上有所不同的类时，将新类作为现有类的 *子类* 编写，*继承* 其部分行为可能会很有帮助。
- en: Exercises
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*A Vector Type*'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*向量类型*'
- en: Write a class Vec that represents a vector in two-dimensional space. It takes
    x and y parameters (numbers) that it saves to properties of the same name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个类 Vec，表示二维空间中的向量。它接受 x 和 y 参数（数字），并将其保存到同名属性中。
- en: Give the Vec prototype two methods, plus and minus, that take another vector
    as a parameter and return a new vector that has the sum or difference of the two
    vectors’ (this and the parameter) *x* and *y* values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 给 Vec 原型添加两个方法，plus 和 minus，接受另一个向量作为参数，并返回一个新向量，该向量的 *x* 和 *y* 值是两个向量（当前向量和参数向量）之和或之差。
- en: Add a getter property length to the prototype that computes the length of the
    vector—that is, the distance of the point (*x*, *y*) from the origin (0, 0).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 向原型添加一个 getter 属性 length，用于计算向量的长度——即点 (*x*, *y*) 到原点 (0, 0) 的距离。
- en: '*Groups*'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*组*'
- en: The standard JavaScript environment provides another data structure called Set.
    Like an instance of Map, a set holds a collection of values. Unlike Map, it does
    not associate other values with those—it just tracks which values are part of
    the set. A value can be part of a set only once—adding it again doesn’t have any
    effect.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 标准 JavaScript 环境提供了另一种数据结构，称为 Set。像 Map 的实例一样，Set 保存一组值。与 Map 不同的是，它不将其他值与这些值关联——它仅跟踪哪些值是该集合的一部分。一个值在集合中只能出现一次——再次添加不会有任何效果。
- en: Write a class called Group (since Set is already taken). Like Set, it has add,
    delete, and has methods. Its constructor creates an empty group, add adds a value
    to the group (but only if it isn’t already a member), delete removes its argument
    from the group (if it was a member), and has returns a Boolean value indicating
    whether its argument is a member of the group.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 Group 的类（因为 Set 已经被占用了）。像 Set 一样，它具有 add、delete 和 has 方法。它的构造函数创建一个空的组，add
    方法将一个值添加到组中（但仅在该值不是成员时），delete 方法从组中移除其参数（如果它是成员的话），而 has 方法返回一个布尔值，指示其参数是否是组的成员。
- en: Use the === operator, or something equivalent such as indexOf, to determine
    whether two values are the same.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 === 运算符或其他等效的方法，例如 indexOf，来判断两个值是否相同。
- en: Give the class a static from method that takes an iterable object as its argument
    and creates a group that contains all the values produced by iterating over it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 给这个类添加一个静态 from 方法，该方法以可迭代对象作为参数，并创建一个包含通过迭代该对象生成的所有值的组。
- en: '*Iterable Groups*'
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*可迭代组*'
- en: Make the Group class from the previous exercise iterable. Refer to “The Iterator
    Interface” on [page 107](ch06.xhtml#ch06lev1sec11) if you aren’t clear on the
    exact form of the interface anymore.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使前一个练习中的 Group 类可迭代。如果你对接口的确切形式不清楚，请参考 [第 107 页](ch06.xhtml#ch06lev1sec11)上的“迭代器接口”。
- en: If you used an array to represent the group’s members, don’t just return the
    iterator created by calling the Symbol.iterator method on the array. That would
    work, but it defeats the purpose of this exercise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用数组来表示组的成员，不要仅仅返回通过调用数组的 Symbol.iterator 方法创建的迭代器。这虽然可行，但违背了本练习的目的。
- en: It is OK if your iterator behaves strangely when the group is modified during
    iteration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的迭代器在迭代过程中修改组时表现得很奇怪，也是可以的。
- en: '*The question of whether Machines Can Think [. . .] is about as relevant as
    the question of whether Submarines Can Swim.*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器是否能够思考的问题与潜艇是否能够游泳的问题一样相关。*'
- en: —Edsger Dijkstra, *The Threats to Computing Science*
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: —埃兹杰·迪克斯特拉，*计算机科学的威胁*
- en: '![Image](../images/f0114-01.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0114-01.jpg)'
