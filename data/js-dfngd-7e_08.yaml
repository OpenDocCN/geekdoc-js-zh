- en: Chapter 8\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 函数
- en: This chapter covers JavaScript functions. Functions are a fundamental building
    block for JavaScript programs and a common feature in almost all programming languages.
    You may already be familiar with the concept of a function under a name such as
    *subroutine* or *procedure*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了JavaScript函数。函数是JavaScript程序的基本构建块，也是几乎所有编程语言中的常见特性。您可能已经熟悉了类似于*子程序*或*过程*的函数概念。
- en: 'A *function* is a block of JavaScript code that is defined once but may be
    executed, or *invoked*, any number of times. JavaScript functions are *parameterized*:
    a function definition may include a list of identifiers, known as *parameters*,
    that work as local variables for the body of the function. Function invocations
    provide values, or *arguments*, for the function’s parameters. Functions often
    use their argument values to compute a *return value* that becomes the value of
    the function-invocation expression. In addition to the arguments, each invocation
    has another value—the *invocation context*—that is the value of the `this` keyword.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是一段JavaScript代码块，定义一次但可以执行或*调用*任意次数。JavaScript函数是*参数化*的：函数定义可能包括一个标识符列表，称为*参数*，它们在函数体内作为局部变量。函数调用为函数的参数提供值，或*参数*，函数通常使用它们的参数值来计算*返回值*，该返回值成为函数调用表达式的值。除了参数之外，每次调用还有另一个值—*调用上下文*—它是`this`关键字的值。'
- en: If a function is assigned to a property of an object, it is known as a *method*
    of that object. When a function is invoked *on* or *through* an object, that object
    is the invocation context or `this` value for the function. Functions designed
    to initialize a newly created object are called *constructors*. Constructors were
    described in [§6.2](ch06.xhtml#creatingobjects) and will be covered again in [Chapter 9](ch09.xhtml#classes).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数分配给对象的属性，则称为该对象的*方法*。当在对象上调用函数时，该对象是函数的调用上下文或`this`值。用于初始化新创建对象的函数称为*构造函数*。构造函数在[§6.2](ch06.xhtml#creatingobjects)中有描述，并将在[第9章](ch09.xhtml#classes)中再次介绍。
- en: In JavaScript, functions are objects, and they can be manipulated by programs.
    JavaScript can assign functions to variables and pass them to other functions,
    for example. Since functions are objects, you can set properties on them and even
    invoke methods on them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是对象，可以被程序操作。JavaScript可以将函数分配给变量并将它们传递给其他函数，例如。由于函数是对象，您可以在它们上设置属性，甚至在它们上调用方法。
- en: JavaScript function definitions can be nested within other functions, and they
    have access to any variables that are in scope where they are defined. This means
    that JavaScript functions are *closures*, and it enables important and powerful
    programming techniques.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数定义可以嵌套在其他函数中，并且可以访问在定义它们的作用域中的任何变量。这意味着JavaScript函数是*闭包*，并且它们可以实现重要且强大的编程技术。
- en: 8.1 Defining Functions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 定义函数
- en: 'The most straightforward way to define a JavaScript function is with the `function`
    keyword, which can be used as a declaration or as an expression. ES6 defines an
    important new way to define functions without the `function` keyword: “arrow functions”
    have a particularly compact syntax and are useful when passing one function as
    an argument to another function. The subsections that follow cover these three
    ways of defining functions. Note that some details of function definition syntax
    involving function parameters are deferred to [§8.3](#functionargumentsandparameters).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 定义JavaScript函数最直接的方法是使用`function`关键字，可以用作声明或表达式。ES6定义了一种重要的新定义函数的方式，即“箭头函数”没有`function`关键字：箭头函数具有特别简洁的语法，并且在将一个函数作为另一个函数的参数传递时非常有用。接下来的小节将介绍这三种定义函数的方式。请注意，涉及函数参数的函数定义语法的一些细节将推迟到[§8.3](#functionargumentsandparameters)中。
- en: In object literals and class definitions, there is a convenient shorthand syntax
    for defining methods. This shorthand syntax was covered in [§6.10.5](ch06.xhtml#object-literal-shorthand-methods)
    and is equivalent to using a function definition expression and assigning it to
    an object property using the basic `name:value` object literal syntax. In another
    special case, you can use keywords `get` and `set` in object literals to define
    special property getter and setter methods. This function definition syntax was
    covered in [§6.10.6](ch06.xhtml#gettersandsetters).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量和类定义中，有一种方便的简写语法用于定义方法。这种简写语法在[§6.10.5](ch06.xhtml#object-literal-shorthand-methods)中介绍过，相当于使用函数定义表达式并将其分配给对象属性，使用基本的`name:value`对象字面量语法。在另一种特殊情况下，您可以在对象字面量中使用关键字`get`和`set`来定义特殊的属性获取器和设置器方法。这种函数定义语法在[§6.10.6](ch06.xhtml#gettersandsetters)中介绍过。
- en: Note that functions can also be defined with the `Function()` constructor, which
    is the subject of [§8.7.7](#functionconstructor). Also, JavaScript defines some
    specialized kinds of functions. `function*` defines generator functions (see [Chapter 12](ch12.xhtml#itergene))
    and `async function` defines asynchronous functions (see [Chapter 13](ch13.xhtml#async)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数也可以使用`Function()`构造函数来定义，这是[§8.7.7](#functionconstructor)的主题。此外，JavaScript定义了一些特殊类型的函数。`function*`定义生成器函数（参见[第12章](ch12.xhtml#itergene)），而`async
    function`定义异步函数（参见[第13章](ch13.xhtml#async)）。
- en: 8.1.1 Function Declarations
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.1 函数声明
- en: 'Function declarations consist of the `function` keyword, followed by these
    components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明由`function`关键字后跟这些组件组成：
- en: 'An identifier that names the function. The name is a required part of function
    declarations: it is used as the name of a variable, and the newly defined function
    object is assigned to the variable.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于命名函数的标识符。名称是函数声明的必需部分：它用作变量的名称，并且新定义的函数对象分配给该变量。
- en: A pair of parentheses around a comma-separated list of zero or more identifiers.
    These identifiers are the parameter names for the function, and they behave like
    local variables within the body of the function.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对括号围绕着一个逗号分隔的零个或多个标识符列表。这些标识符是函数的参数名称，并且在函数体内部起到类似局部变量的作用。
- en: 'A pair of curly braces with zero or more JavaScript statements inside. These
    statements are the body of the function: they are executed whenever the function
    is invoked.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对大括号内包含零个或多个 JavaScript 语句。这些语句是函数的主体：每当调用函数时，它们都会被执行。
- en: 'Here are some example function declarations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例函数声明：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: One of the important things to understand about function declarations is that
    the name of the function becomes a variable whose value is the function itself.
    Function declaration statements are “hoisted” to the top of the enclosing script,
    function, or block so that functions defined in this way may be invoked from code
    that appears before the definition. Another way to say this is that all of the
    functions declared in a block of JavaScript code will be defined throughout that
    block, and they will be defined before the JavaScript interpreter begins to execute
    any of the code in that block.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于函数声明的重要事项之一是，函数的名称成为一个变量，其值为函数本身。函数声明语句被“提升”到封闭脚本、函数或块的顶部，以便以这种方式定义的函数可以从定义之前的代码中调用。另一种说法是，在
    JavaScript 代码块中声明的所有函数将在该块中定义，并且它们将在 JavaScript 解释器开始执行该块中的任何代码之前定义。
- en: The `distance()` and `factorial()` functions we’ve described are designed to
    compute a value, and they use `return` to return that value to their caller. The
    `return` statement causes the function to stop executing and to return the value
    of its expression (if any) to the caller. If the `return` statement does not have
    an associated expression, the return value of the function is `undefined`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述的 `distance()` 和 `factorial()` 函数旨在计算一个值，并使用 `return` 将该值返回给调用者。`return`
    语句导致函数停止执行并将其表达式的值（如果有）返回给调用者。如果 `return` 语句没有关联的表达式，则函数的返回值为 `undefined`。
- en: 'The `printprops()` function is different: its job is to output the names and
    values of an object’s properties. No return value is necessary, and the function
    does not include a `return` statement. The value of an invocation of the `printprops()`
    function is always `undefined`. If a function does not contain a `return` statement,
    it simply executes each statement in the function body until it reaches the end,
    and returns the `undefined` value to the caller.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`printprops()` 函数有所不同：它的作用是输出对象属性的名称和值。不需要返回值，并且函数不包括 `return` 语句。调用 `printprops()`
    函数的值始终为 `undefined`。如果函数不包含 `return` 语句，它只是执行函数体中的每个语句，直到达到结尾，并将 `undefined` 值返回给调用者。'
- en: Prior to ES6, function declarations were only allowed at the top level within
    a JavaScript file or within another function. While some implementations bent
    the rule, it was not technically legal to define functions inside the body of
    loops, conditionals, or other blocks. In the strict mode of ES6, however, function
    declarations are allowed within blocks. A function defined within a block only
    exists within that block, however, and is not visible outside the block.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前，只允许在 JavaScript 文件的顶层或另一个函数内部定义函数声明。虽然一些实现弯曲了规则，但在循环、条件语句或其他块的主体内定义函数实际上是不合法的。然而，在
    ES6 的严格模式下，允许在块内部声明函数。在块内定义的函数仅存在于该块内部，并且在块外部不可见。
- en: 8.1.2 Function Expressions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.2 函数表达式
- en: 'Function expressions look a lot like function declarations, but they appear
    within the context of a larger expression or statement, and the name is optional.
    Here are some example function expressions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式看起来很像函数声明，但它们出现在更大表达式或语句的上下文中，名称是可选的。这里是一些示例函数表达式：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that the function name is optional for functions defined as expressions,
    and most of the preceding function expressions we’ve shown omit it. A function
    declaration actually *declares* a variable and assigns a function object to it.
    A function expression, on the other hand, does not declare a variable: it is up
    to you to assign the newly defined function object to a constant or variable if
    you are going to need to refer to it multiple times. It is a good practice to
    use `const` with function expressions so you don’t accidentally overwrite your
    functions by assigning new values.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于定义为表达式的函数，函数名称是可选的，我们展示的大多数前面的函数表达式都省略了它。函数声明实际上 *声明* 了一个变量，并将函数对象分配给它。另一方面，函数表达式不声明变量：如果您需要多次引用它，您需要将新定义的函数对象分配给常量或变量。对于函数表达式，最好使用
    `const`，这样您不会意外地通过分配新值来覆盖函数。
- en: A name is allowed for functions, like the factorial function, that need to refer
    to themselves. If a function expression includes a name, the local function scope
    for that function will include a binding of that name to the function object.
    In effect, the function name becomes a local variable within the function. Most
    functions defined as expressions do not need names, which makes their definition
    more compact (though not nearly as compact as arrow functions, described below).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要引用自身的函数（如阶乘函数），允许为函数指定名称。如果函数表达式包含名称，则该函数的本地函数作用域将包括将该名称绑定到函数对象。实际上，函数名称成为函数内部的局部变量。大多数作为表达式定义的函数不需���名称，这使得它们的定义更加紧凑（尽管不像下面描述的箭头函数那样紧凑）。
- en: 'There is an important difference between defining a function `f()` with a function
    declaration and assigning a function to the variable `f` after creating it as
    an expression. When you use the declaration form, the function objects are created
    before the code that contains them starts to run, and the definitions are hoisted
    so that you can call these functions from code that appears above the definition
    statement. This is not true for functions defined as expressions, however: these
    functions do not exist until the expression that defines them are actually evaluated.
    Furthermore, in order to invoke a function, you must be able to refer to it, and
    you can’t refer to a function defined as an expression until it is assigned to
    a variable, so functions defined with expressions cannot be invoked before they
    are defined.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数声明定义函数`f()`与在创建后将函数分配给变量`f`之间有一个重要的区别。当使用声明形式时，函数对象在包含它们的代码开始运行之前就已经创建，并且定义被提升，以便您可以从出现在定义语句上方的代码中调用这些函数。然而，对于作为表达式定义的函数来说，情况并非如此：这些函数直到定义它们的表达式实际被评估之后才存在。此外，为了调用一个函数，您必须能够引用它，而在将函数定义为表达式之前，您不能引用一个函数，因此使用表达式定义的函数在定义之前不能被调用。
- en: 8.1.3 Arrow Functions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.3 箭头函数
- en: 'In ES6, you can define functions using a particularly compact syntax known
    as “arrow functions.” This syntax is reminiscent of mathematical notation and
    uses an `=>` “arrow” to separate the function parameters from the function body.
    The `function` keyword is not used, and, since arrow functions are expressions
    instead of statements, there is no need for a function name, either. The general
    form of an arrow function is a comma-separated list of parameters in parentheses,
    followed by the `=>` arrow, followed by the function body in curly braces:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，你可以使用一种特别简洁的语法来定义函数，称为“箭头函数”。这种语法类似于数学表示法，并使用`=>`“箭头”来分隔函数参数和函数主体。不使用`function`关键字，而且，由于箭头函数是表达式而不是语句，因此也不需要函数名称。箭头函数的一般形式是用括号括起来的逗号分隔的参数列表，后跟`=>`箭头，再后跟用花括号括起来的函数主体：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But arrow functions support an even more compact syntax. If the body of the
    function is a single `return` statement, you can omit the `return` keyword, the
    semicolon that goes with it, and the curly braces, and write the body of the function
    as the expression whose value is to be returned:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是箭头函数支持更紧凑的语法。如果函数的主体是一个单独的`return`语句，您可以省略`return`关键字、与之配套的分号和花括号，并将函数主体写成要返回其值的表达式：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Furthermore, if an arrow function has exactly one parameter, you can omit the
    parentheses around the parameter list:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果箭头函数只有一个参数，您可以省略参数列表周围的括号：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note, however, that an arrow function with no arguments at all must be written
    with an empty pair of parentheses:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个没有任何参��的箭头函数必须用一个空的括号对写成：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that, when writing an arrow function, you must not put a new line between
    the function parameters and the `=>` arrow. Otherwise, you could end up with a
    line like `const polynomial = x`, which is a syntactically valid assignment statement
    on its own.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在编写箭头函数时，不要在函数参数和`=>`箭头之间加入新行。否则，您可能会得到一行像`const polynomial = x`这样的行，这是一个语法上有效的赋值语句。
- en: 'Also, if the body of your arrow function is a single `return` statement but
    the expression to be returned is an object literal, then you have to put the object
    literal inside parentheses to avoid syntactic ambiguity between the curly braces
    of a function body and the curly braces of an object literal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果箭头函数的主体是一个单独的`return`语句，但要返回的表达式是一个对象字面量，则必须将对象字面量放在括号内，以避免在函数主体的花括号和对象字面量的花括号之间产生语法歧义：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the third line of this code, the function `h()` is truly ambiguous: the
    code you intended as an object literal can be parsed as a labeled statement, so
    a function that returns undefined is created. On the fourth line, however, the
    more complicated object literal is not a valid statement, and this illegal code
    causes a syntax error.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码的第三行中，函数`h()`确实是模棱两可的：您打算作为对象字面量的代码可以被解析为标记语句，因此创建了一个返回`undefined`的函数。然而，在第四行，更复杂的对象字面量不是一个有效的语句，这种非法代码会导致语法错误。
- en: 'The concise syntax of arrow functions makes them ideal when you need to pass
    one function to another function, which is a common thing to do with array methods
    like `map()`, `filter()`, and `reduce()` (see [§7.8.1](ch07.xhtml#arrayiteratormethods)),
    for example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数简洁的语法使它们在需要将一个函数传递给另一个函数时非常理想，这在像`map()`、`filter()`和`reduce()`这样的数组方法中是常见的做法（参见[§7.8.1](ch07.xhtml#arrayiteratormethods)）：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Arrow functions differ from functions defined in other ways in one critical
    way: they inherit the value of the `this` keyword from the environment in which
    they are defined rather than defining their own invocation context as functions
    defined in other ways do. This is an important and very useful feature of arrow
    functions, and we’ll return to it again later in this chapter. Arrow functions
    also differ from other functions in that they do not have a `prototype` property,
    which means that they cannot be used as constructor functions for new classes
    (see [§9.2](ch09.xhtml#classesandconstructors)).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数与其他方式定义的函数在一个关键方面有所不同：它们继承自定义它们的环境中的`this`关键字的值，而不是像其他方式定义的函数那样定义自己的调用上下文。这是箭头函数的一个重要且非常有用的特性，我们将在本章后面再次回到这个问题。箭头函数还与其他函数不同之处在于它们没有`prototype`属性，这意味着它们不能用作新类的构造函数（参见[§9.2](ch09.xhtml#classesandconstructors)）。
- en: 8.1.4 Nested Functions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.4 嵌套函数
- en: 'In JavaScript, functions may be nested within other functions. For example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数可以嵌套在其他函数中。例如：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The interesting thing about nested functions is their variable scoping rules:
    they can access the parameters and variables of the function (or functions) they
    are nested within. In the code shown here, for example, the inner function `square()`
    can read and write the parameters `a` and `b` defined by the outer function `hypotenuse()`.
    These scope rules for nested functions are very important, and we will consider
    them again in [§8.6](#closures).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套函数的有趣之处在于它们的变量作用域规则：它们可以访问嵌套在其中的函数（或函数）的参数和变量。例如，在这里显示的代码中，内部函数 `square()`
    可以读取和写入外部函数 `hypotenuse()` 定义的参数 `a` 和 `b`。嵌套函数的这些作用域规则非常重要，我们将在 [§8.6](#closures)
    中再次考虑它们。
- en: 8.2 Invoking Functions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 调用函数
- en: 'The JavaScript code that makes up the body of a function is not executed when
    the function is defined, but rather when it is invoked. JavaScript functions can
    be invoked in five ways:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数体组成的代码在定义函数时不会执行，而是在调用函数时执行。JavaScript 函数可以通过五种方式调用：
- en: As functions
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数
- en: As methods
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为方法
- en: As constructors
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为构造函数
- en: Indirectly through their `call()` and `apply()` methods
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过它们的 `call()` 和 `apply()` 方法间接调用
- en: Implicitly, via JavaScript language features that do not appear like normal
    function invocations
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式地，通过 JavaScript 语言特性，看起来不像正常函数调用
- en: 8.2.1 Function Invocation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.1 函数调用
- en: 'Functions are invoked as functions or as methods with an invocation expression
    ([§4.5](ch04.xhtml#invocationexprs)). An invocation expression consists of a function
    expression that evaluates to a function object followed by an open parenthesis,
    a comma-separated list of zero or more argument expressions, and a close parenthesis.
    If the function expression is a property-access expression—if the function is
    the property of an object or an element of an array—then it is a method invocation
    expression. That case will be explained in the following example. The following
    code includes a number of regular function invocation expressions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以作为函数或方法通过调用表达式调用（[§4.5](ch04.xhtml#invocationexprs)）。调用表达式由一个求值为函数对象的函数表达式、一个开括号、一个逗号分隔的零个或多个参数表达式和一个闭括号组成。如果函数表达式是一个属性访问表达式——如果函数是对象的属性或数组的元素——那么它就是一个方法调用表达式。这种情况将在下面的示例中解释。以下代码包含了许多常规函数调用表达式：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In an invocation, each argument expression (the ones between the parentheses)
    is evaluated, and the resulting values become the arguments to the function. These
    values are assigned to the parameters named in the function definition. In the
    body of the function, a reference to a parameter evaluates to the corresponding
    argument value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用中，每个参数表达式（括号之间的表达式）都会被求值，得到的值���为函数的参数。这些值被分配给函数定义中命名的参数。在函数体中，对参数的引用会求值为相应的参数值。
- en: For regular function invocation, the return value of the function becomes the
    value of the invocation expression. If the function returns because the interpreter
    reaches the end, the return value is `undefined`. If the function returns because
    the interpreter executes a `return` statement, then the return value is the value
    of the expression that follows the `return` or is `undefined` if the `return`
    statement has no value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规函数调用，函数的返回值成为调用表达式的值。如果函数返回是因为解释器到达末尾，返回值是 `undefined`。如果函数返回是因为解释器执行了 `return`
    语句，则返回值是跟在 `return` 后面的表达式的值，如果 `return` 语句没有值，则返回值是 `undefined`。
- en: 'For function invocation in non-strict mode, the invocation context (the `this`
    value) is the global object. In strict mode, however, the invocation context is
    `undefined`. Note that functions defined using the arrow syntax behave differently:
    they always inherit the `this` value that is in effect where they are defined.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格模式下进行函数调用时，调用上下文（`this` 值）是全局对象。然而，在严格模式下，调用上下文是 `undefined`。请注意，使用箭头语法定义的函数行为不同：它们始终继承在定义它们的地方生效的
    `this` 值。
- en: 'Functions written to be invoked as functions (and not as methods) do not typically
    use the `this` keyword at all. The keyword can be used, however, to determine
    whether strict mode is in effect:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了作为函数调用而编写的函数（而不是作为方法调用），通常根本不使用 `this` 关键字。然而，可以使用该关键字来确定是否启用了严格模式：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 8.2.2 Method Invocation
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.2 方法调用
- en: 'A *method* is nothing more than a JavaScript function that is stored in a property
    of an object. If you have a function `f` and an object `o`, you can define a method
    named `m` of `o` with the following line:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 只不过是存储在对象属性中的 JavaScript 函数。如果有一个函数 `f` 和一个对象 `o`，你可以用以下代码定义 `o` 的名为 `m`
    的方法：'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Having defined the method `m()` of the object `o`, invoke it like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了对象 `o` 的方法 `m()` 后，可以像这样调用它：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or, if `m()` expects two arguments, you might invoke it like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果 `m()` 预期有两个参数，你可以这样调用它：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code in this example is an invocation expression: it includes a function
    expression `o.m` and two argument expressions, `x` and `y`. The function expression
    is itself a property access expression, and this means that the function is invoked
    as a method rather than as a regular function.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的代码是一个调用表达式：它包括一个函数表达式 `o.m` 和两个参数表达式 `x` 和 `y`。函数表达式本身是一个属性访问表达式，这意味着该函数被作为方法而不是作为常规函数调用。
- en: 'The arguments and return value of a method invocation are handled exactly as
    described for regular function invocation. Method invocations differ from function
    invocations in one important way, however: the invocation context. Property access
    expressions consist of two parts: an object (in this case `o`) and a property
    name (`m`). In a method-invocation expression like this, the object `o` becomes
    the invocation context, and the function body can refer to that object by using
    the keyword `this`. Here is a concrete example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用的参数和返回值的处理方式与常规函数调用完全相同。然而，方法调用与函数调用有一个重要的区别：调用上下文。属性访问表达式由两部分组成：一个对象（在本例中是
    `o`）和一个属性名（`m`）。在这样的方法调用表达式中，对象 `o` 成为调用上下文，函数体可以通过关键字 `this` 引用该对象。以下是一个具体示例：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Most method invocations use the dot notation for property access, but property
    access expressions that use square brackets also cause method invocation. The
    following are both method invocations, for example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数方法调用使用点表示法进行属性访问，但使用方括号的属性访问表达式也会导致方法调用。例如，以下两者都是方法调用：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Method invocations may also involve more complex property access expressions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用也可能涉及更复杂的属性访问表达式：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Methods and the `this` keyword are central to the object-oriented programming
    paradigm. Any function that is used as a method is effectively passed an implicit
    argument—the object through which it is invoked. Typically, a method performs
    some sort of operation on that object, and the method-invocation syntax is an
    elegant way to express the fact that a function is operating on an object. Compare
    the following two lines:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 方法和`this`关键字是面向对象编程范式的核心。任何用作方法的函数���际上都会传递一个隐式参数——通过它被调用的对象。通常，方法在该对象上执行某种操作，而方法调用语法是一种优雅地表达函数正在操作对象的方式。比较以下两行：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The hypothetical functions invoked in these two lines of code may perform exactly
    the same operation on the (hypothetical) object `rect`, but the method-invocation
    syntax in the first line more clearly indicates the idea that it is the object
    `rect` that is the primary focus of the operation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两行代码中调用的假设函数可能对（假设的）对象`rect`执行完全相同的操作，但第一行中的方法调用语法更清楚地表明了对象`rect`是操作的主要焦点。
- en: Note that `this` is a keyword, not a variable or property name. JavaScript syntax
    does not allow you to assign a value to `this`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`this`是一个关键字，不是变量或属性名。JavaScript语法不允许您为`this`赋值。
- en: 'The `this` keyword is not scoped the way variables are, and, except for arrow
    functions, nested functions do not inherit the `this` value of the containing
    function. If a nested function is invoked as a method, its `this` value is the
    object it was invoked on. If a nested function (that is not an arrow function)
    is invoked as a function, then its `this` value will be either the global object
    (non-strict mode) or `undefined` (strict mode). It is a common mistake to assume
    that a nested function defined within a method and invoked as a function can use
    `this` to obtain the invocation context of the method. The following code demonstrates
    the problem:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字的作用域不同于变量，除了箭头函数外，嵌套函数不会继承包含函数的`this`值。如果嵌套函数被作为方法调用，其`this`值将是调用它的对象。如果嵌套函数（不是箭头函数）被作为函数调用，那么其`this`值将是全局对象（非严格模式）或`undefined`（严格模式）。假设在方法内部定义的嵌套函数并作为函数调用时可以使用`this`获取方法的调用上下文是一个常见的错误。以下代码演示了这个问题：'
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Inside the nested function `f()`, the `this` keyword is not equal to the object
    `o`. This is widely considered to be a flaw in the JavaScript language, and it
    is important to be aware of it. The code above demonstrates one common workaround.
    Within the method `m`, we assign the `this` value to a variable `self`, and within
    the nested function `f`, we can use `self` instead of `this` to refer to the containing
    object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套函数`f()`内部，`this`关键字不等于对象`o`。这被广泛认为是JavaScript语言的一个缺陷，因此重要的是要意识到这一点。上面的代码演示了一个常见的解决方法。在方法`m`内部，我们将`this`值分配给变量`self`，在嵌套函数`f`内部，我们可以使用`self`而不是`this`来引用包含的对象。
- en: 'In ES6 and later, another workaround to this issue is to convert the nested
    function `f` into an arrow function, which will properly inherit the `this` value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6及更高版本中，另一个解决此问题的方法是将嵌套函数`f`转换为箭头函数，这样将正确继承`this`值。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Functions defined as expressions instead of statements are not hoisted, so in
    order to make this code work, the function definition for `f` will need to be
    moved within the method `m` so that it appears before it is invoked.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数定义为表达式而不是语句的方式不会被提升，因此为了使这段代码正常工作，函数`f`的定义需要移动到方法`m`内部，以便在调用之前出现。
- en: 'Another workaround is to invoke the `bind()` method of the nested function
    to define a new function that is implicitly invoked on a specified object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方法是调用嵌套函数的`bind()`方法来定义一个新函数，该函数将隐式在指定对象上调用：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We’ll talk more about `bind()` in [§8.7.5](#bind).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[§8.7.5](#bind)中更详细地讨论`bind()`。
- en: 8.2.3 Constructor Invocation
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.3 构造函数调用
- en: If a function or method invocation is preceded by the keyword `new`, then it
    is a constructor invocation. (Constructor invocations were introduced in [§4.6](ch04.xhtml#newexprs)
    and [§6.2.2](ch06.xhtml#creatingobjectswithnew), and constructors will be covered
    in more detail in [Chapter 9](ch09.xhtml#classes).) Constructor invocations differ
    from regular function and method invocations in their handling of arguments, invocation
    context, and return value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数或方法调用之前带有关键字`new`，那么这是一个构造函数调用。（构造函数调用在[§4.6](ch04.xhtml#newexprs)和[§6.2.2](ch06.xhtml#creatingobjectswithnew)中介绍过，并且构造函数将在[第9章](ch09.xhtml#classes)中更详细地讨论。）构造函数调用在处理参数、调用上下文和返回值方面与常规函数和方法调用不同。
- en: 'If a constructor invocation includes an argument list in parentheses, those
    argument expressions are evaluated and passed to the function in the same way
    they would be for function and method invocations. It is not common practice,
    but you can omit a pair of empty parentheses in a constructor invocation. The
    following two lines, for example, are equivalent:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构造函数调用包括括号中的参数列表，则这些参数表达式将被计算并传递给函数，方式与函数和方法调用相同。虽然不常见，但您可以在构造函数调用中省略一对空括号。例如，以下两行是等价的：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A constructor invocation creates a new, empty object that inherits from the
    object specified by the `prototype` property of the constructor. Constructor functions
    are intended to initialize objects, and this newly created object is used as the
    invocation context, so the constructor function can refer to it with the `this`
    keyword. Note that the new object is used as the invocation context even if the
    constructor invocation looks like a method invocation. That is, in the expression
    `new o.m()`, `o` is not used as the invocation context.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用创建一个新的空对象，该对象继承自构造函数的`prototype`属性指定的对象。构造函数旨在初始化对象，这个新创建的对象被用作调用上下文，因此构造函数可以使用`this`关键字引用它。请注意，即使构造函数调用看起来像方法调用，新对象也被用作调用上下文。也就是说，在表达式`new
    o.m()`中，`o`不被用作调用上下文。
- en: Constructor functions do not normally use the `return` keyword. They typically
    initialize the new object and then return implicitly when they reach the end of
    their body. In this case, the new object is the value of the constructor invocation
    expression. If, however, a constructor explicitly uses the `return` statement
    to return an object, then that object becomes the value of the invocation expression.
    If the constructor uses `return` with no value, or if it returns a primitive value,
    that return value is ignored and the new object is used as the value of the invocation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通常不使用`return`关键字。它们通常在初始化新对象后隐式返回，当它们到达函数体的末尾时。在这种情况下，新对象是构造函数调用表达式的值。然而，如果构造函数显式使用`return`语句返回一个对象，则该对象成为调用表达式的值。如果构造函数使用没有值的`return`，或者返回一个原始值，那么返回值将被忽略，新对象将作为调用的值。
- en: 8.2.4 Indirect Invocation
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.4 间接调用
- en: JavaScript functions are objects, and like all JavaScript objects, they have
    methods. Two of these methods, `call()` and `apply()`, invoke the function indirectly.
    Both methods allow you to explicitly specify the `this` value for the invocation,
    which means you can invoke any function as a method of any object, even if it
    is not actually a method of that object. Both methods also allow you to specify
    the arguments for the invocation. The `call()` method uses its own argument list
    as arguments to the function, and the `apply()` method expects an array of values
    to be used as arguments. The `call()` and `apply()` methods are described in detail
    in [§8.7.4](#applyandcall).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript函数是对象，和所有JavaScript对象一样，它们有方法。其中两个方法，`call()`和`apply()`，间接调用函数。这两种方法允许您明确指定调用的`this`值，这意味着您可以将任何函数作为任何对象的方法调用，即使它实际上不是该对象的方法。这两种方法还允许您指定调用的参数。`call()`方法使用其自己的参数列表作为函数的参数，而`apply()`方法期望使用作为参数的值数组。`call()`和`apply()`方法在[§8.7.4](#applyandcall)中有详细描述。
- en: 8.2.5 Implicit Function Invocation
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.5 隐式函数调用
- en: There are various JavaScript language features that do not look like function
    invocations but that cause functions to be invoked. Be extra careful when writing
    functions that may be implicitly invoked, because bugs, side effects, and performance
    issues in these functions are harder to diagnose and fix than in regular functions
    for the simple reason that it may not be obvious from a simple inspection of your
    code when they are being called.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种JavaScript语言特性看起来不像函数调用，但会导致函数被调用。在编写可能被隐式调用的函数时要特别小心，因为这些函数中的错误、副作用和性能问题比普通函数更难诊断和修复，因为从简单检查代码时可能不明显它们何时被调用。
- en: 'The language features that can cause implicit function invocation include:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可能导致隐式函数调用的语言特性包括：
- en: If an object has getters or setters defined, then querying or setting the value
    of its properties may invoke those methods. See [§6.10.6](ch06.xhtml#gettersandsetters)
    for more information.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果对象定义了getter或setter，则查询或设置其属性的值可能会调用这些方法。更多信息请参见[§6.10.6](ch06.xhtml#gettersandsetters)。
- en: When an object is used in a string context (such as when it is concatenated
    with a string), its `toString()` method is called. Similarly, when an object is
    used in a numeric context, its `valueOf()` method is invoked. See [§3.9.3](ch03.xhtml#objtoprim)
    for details.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象在字符串上下文中使用（例如与字符串连接时），会调用其`toString()`方法。类似地，当对象在数值上下文中使用时，会调用其`valueOf()`方法。详细信息请参见[§3.9.3](ch03.xhtml#objtoprim)。
- en: When you loop over the elements of an iterable object, there are a number of
    method calls that occur. [Chapter 12](ch12.xhtml#itergene) explains how iterators
    work at the function call level and demonstrates how to write these methods so
    that you can define your own iterable types.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您遍历可迭代对象的元素时，会发生许多方法调用。[第12章](ch12.xhtml#itergene)解释了迭代器在函数调用级别上的工作原理，并演示了如何编写这些方法，以便您可以定义自己的可迭代类型。
- en: A tagged template literal is a function invocation in disguise. [§14.5](ch14.xhtml#templatetags)
    demonstrates how to write functions that can be used in conjunction with template
    literal strings.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记模板字面量是一个伪装成函数调用的函数。[§14.5](ch14.xhtml#templatetags)演示了如何编写可与模板字面量字符串一起使用的函数。
- en: Proxy objects (described in [§14.7](ch14.xhtml#proxy)) have their behavior completely
    controlled by functions. Just about any operation on one of these objects will
    cause a function to be invoked.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理对象（在[§14.7](ch14.xhtml#proxy)中描述）的行为完全由函数控制。对这些对象的几乎任何操作都��导致函数被调用。
- en: 8.3 Function Arguments and Parameters
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 函数参数和参数
- en: JavaScript function definitions do not specify an expected type for the function
    parameters, and function invocations do not do any type checking on the argument
    values you pass. In fact, JavaScript function invocations do not even check the
    number of arguments being passed. The subsections that follow describe what happens
    when a function is invoked with fewer arguments than declared parameters or with
    more arguments than declared parameters. They also demonstrate how you can explicitly
    test the type of function arguments if you need to ensure that a function is not
    invoked with inappropriate arguments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 函数定义不指定函数参数的预期类型，函数调用也不对传递的参数值进行任何类型检查。事实上，JavaScript 函数调用甚至不检查传递的参数数量。接下来的小节描述了当函数被调用时传入的参数少于声明的参数数量或多于声明的参数数量时会发生什么。它们还演示了如何显式测试函数参数的类型，如果需要确保函数不会被不适当的参数调用。
- en: 8.3.1 Optional Parameters and Defaults
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.1 可选参数和默认值
- en: 'When a function is invoked with fewer arguments than declared parameters, the
    additional parameters are set to their default value, which is normally `undefined`.
    It is often useful to write functions so that some arguments are optional. Following
    is an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时传入的参数少于声明的参数数量时，额外的参数将被设置为它们的默认值，通常是`undefined`。编写一些参数是可选的函数通常很有用。以下是一个例子：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead of using an `if` statement in the first line of this function, you
    can use the `||` operator in this idiomatic way:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数的第一行使用`if`语句的地方，你可以以这种成语化的方式使用`||`运算符：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Recall from [§4.10.2](ch04.xhtml#logicalor) that the `||` operator returns its
    first argument if that argument is truthy and otherwise returns its second argument.
    In this case, if any object is passed as the second argument, the function will
    use that object. But if the second argument is omitted (or `null` or another falsy
    value is passed), a newly created empty array will be used instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[§4.10.2](ch04.xhtml#logicalor)中提到的`||`运算符，如果第一个参数为真，则返回第一个参数，否则返回第二个参数。在这种情况下，如果将任何对象作为第二个参数传递，函数将使用该对象。但如果省略第二个参数（或传递`null`或另一个假值），则将使用一个新创建的空数组。
- en: 'Note that when designing functions with optional arguments, you should be sure
    to put the optional ones at the end of the argument list so that they can be omitted.
    The programmer who calls your function cannot omit the first argument and pass
    the second: they would have to explicitly pass `undefined` as the first argument.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在设计具有可选参数的函数时，应确保将可选参数放在参数列表的末尾，以便可以省略它们。调用函数的程序员不能省略第一个参数并传递第二个参数：他们必须明确地将`undefined`作为第一个参数传递。
- en: 'In ES6 and later, you can define a default value for each of your function
    parameters directly in the parameter list of your function. Simply follow the
    parameter name with an equals sign and the default value to use when no argument
    is supplied for that parameter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 及更高版本中，你可以直接在函数参数列表中为每个参数定义默认值。只需在参数名称后面加上等号和默认值，当没有为该参数提供参数时将使用默认值：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Parameter default expressions are evaluated when your function is called, not
    when it is defined, so each time this `getPropertyNames()` function is invoked
    with one argument, a new empty array is created and passed.^([2](ch08.xhtml#idm46198541553560))
    It is probably easiest to reason about functions if the parameter defaults are
    constants (or literal expressions like `[]` and `{}`). But this is not required:
    you can use variables, or function invocations, for example, to compute the default
    value of a parameter. One interesting case is that, for functions with multiple
    parameters, you can use the value of a previous parameter to define the default
    value of the parameters that follow it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 参数默认表达式在调用函数时进行求值，而不是在定义函数时进行求值，因此每次调用`getPropertyNames()`函数时，都会创建一个新的空数组并传递。^([2](ch08.xhtml#idm46198541553560))
    如果参数默认值是常量（或类似`[]`和`{}`的文字表达式），那么函数的推理可能是最简单的。但这不是必需的：你可以使用变量或函数调用来计算参数的默认值。一个有趣的情况是，对于具有多个参数的函数，可以使用前一个参数的值来定义其后参数的默认值：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code demonstrates that parameter defaults work with arrow functions. The
    same is true for method shorthand functions and all other forms of function definitions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了参数默认值如何与箭头函数一起使用。对于方法简写函数和所有其他形式的函数定义也是如此。
- en: 8.3.2 Rest Parameters and Variable-Length Argument Lists
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.2 Rest 参数和可变长度参数列表
- en: 'Parameter defaults enable us to write functions that can be invoked with fewer
    arguments than parameters. *Rest parameters* enable the opposite case: they allow
    us to write functions that can be invoked with arbitrarily more arguments than
    parameters. Here is an example function that expects one or more numeric arguments
    and returns the largest one:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 参数默认值使我们能够编写可以用比参数更少的参数调用的函数。*Rest 参数*使相反的情况成为可能：它们允许我们编写可以用任意多个参数调用的函数。以下是一个期望一个或多个数字参数并返回最大值的示例函数：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A rest parameter is preceded by three periods, and it must be the last parameter
    in a function declaration. When you invoke a function with a rest parameter, the
    arguments you pass are first assigned to the non-rest parameters, and then any
    remaining arguments (i.e., the “rest” of the arguments) are stored in an array
    that becomes the value of the rest parameter. This last point is important: within
    the body of a function, the value of a rest parameter will always be an array.
    The array may be empty, but a rest parameter will never be `undefined`. (It follows
    from this that it is never useful—and not legal—to define a parameter default
    for a rest parameter.)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: rest 参数由三个点前置，并且必须是函数声明中的最后一个参数。当你使用 rest 参数调用函数时，你传递的参数首先被分配给非 rest 参数，然后任何剩余的参数（即“剩余”的参数）都存储在一个数组中，该数组成为
    rest 参数的值。这一点很重要：在函数体内，rest 参数的值始终是一个数组。数组可能为空，但 rest 参数永远不会是`undefined`。（由此可知，为
    rest 参数定义参数默认值从未有用过，也不合法。）
- en: Functions like the previous example that can accept any number of arguments
    are called *variadic functions*, *variable arity functions*, or *vararg functions*.
    This book uses the most colloquial term, *varargs*, which dates to the early days
    of the C programming language.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像前面的例子那样可以接受任意数量参数的函数称为*可变参数函数*、*可变参数函数*或*vararg函数*。本书使用最口语化的术语*varargs*，这个术语可以追溯到
    C 编程语言的早期。
- en: Don’t confuse the `...` that defines a rest parameter in a function definition
    with the `...` spread operator, described in [§8.3.4](#spread-operator-for-functions),
    which can be used in function invocations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆函数定义中定义 rest 参数的 `...` 与 [§8.3.4](#spread-operator-for-functions) 中描述的展开运算符的
    `...`，后者可用于函数调用中。
- en: 8.3.3 The Arguments Object
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.3 Arguments 对象
- en: 'Rest parameters were introduced into JavaScript in ES6\. Before that version
    of the language, varargs functions were written using the Arguments object: within
    the body of any function, the identifier `arguments` refers to the Arguments object
    for that invocation. The Arguments object is an array-like object (see [§7.9](ch07.xhtml#arraylike))
    that allows the argument values passed to the function to be retrieved by number,
    rather than by name. Here is the `max()` function from earlier, rewritten to use
    the Arguments object instead of a rest parameter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Rest 参数是在 ES6 中引入 JavaScript 的。在该语言版本之前，可变参数函数是使用 Arguments 对象编写的：在任何函数体内，标识符
    `arguments` 指的是该调用的 Arguments 对象。Arguments 对象是一个类似数组的对象（参见 [§7.9](ch07.xhtml#arraylike)），允许按数字而不是名称检索传递给函数的参数值。以下是之前的
    `max()` 函数，重写以使用 Arguments 对象而不是 rest 参数：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Arguments object dates back to the earliest days of JavaScript and carries
    with it some strange historical baggage that makes it inefficient and hard to
    optimize, especially outside of strict mode. You may still encounter code that
    uses the Arguments object, but you should avoid using it in any new code you write.
    When refactoring old code, if you encounter a function that uses `arguments`,
    you can often replace it with a `...args` rest parameter. Part of the unfortunate
    legacy of the Arguments object is that, in strict mode, `arguments` is treated
    as a reserved word, and you cannot declare a function parameter or a local variable
    with that name.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Arguments 对象可以追溯到 JavaScript 最早的日子，并且携带一些奇怪的历史包袱，使其在严格模式之外尤其难以优化和难以使用。你可能仍然会遇到使用
    Arguments 对象的代码，但是在编写任何新代码时应避免使用它。在重构旧代码时，如果遇到使用 `arguments` 的函数，通常可以用 `...args`
    rest 参数来替换它。Arguments 对象的不幸遗产之一是，在严格模式下，`arguments` 被视为保留字，你不能使用该名称声明函数参数或局部变量。
- en: 8.3.4 The Spread Operator for Function Calls
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.4 函数调用的展开运算符
- en: 'The spread operator `...` is used to unpack, or “spread out,” the elements
    of an array (or any other iterable object, such as strings) in a context where
    individual values are expected. We’ve seen the spread operator used with array
    literals in [§7.1.2](ch07.xhtml#spread-operator-in-array-literals). The operator
    can be used, in the same way, in function invocations:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符 `...` 用于在期望单个值的上下文中解包或“展开”数组（或任何其他可迭代对象，如字符串）的元素。我们在 [§7.1.2](ch07.xhtml#spread-operator-in-array-literals)
    中看到展开运算符与数组文字一起使用。该运算符可以以相同的方式在函数调用中使用：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that `...` is not a true operator in the sense that it cannot be evaluated
    to produce a value. Instead, it is a special JavaScript syntax that can be used
    in array literals and function invocations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`...` 不是真正的运算符，因为它不能被评估为产生一个值。相反，它是一种特殊的 JavaScript 语法，可用于数组文字和函数调用中。
- en: 'When we use the same `...` syntax in a function definition rather than a function
    invocation, it has the opposite effect to the spread operator. As we saw in [§8.3.2](#restparameters),
    using `...` in a function definition gathers multiple function arguments into
    an array. Rest parameters and the spread operator are often useful together, as
    in the following function, which takes a function argument and returns an instrumented
    version of the function for testing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在函数定义中而不是函数调用中使用相同的 `...` 语法时，它的效果与展开运算符相反。正如我们在 [§8.3.2](#restparameters)
    中看到的，使用 `...` 在函数定义中将多个函数参数收集到一个数组中。Rest 参数和展开运算符通常一起使用，如下面的函数，该函数接受一个函数参数，并返回一个用于测试的函数的版本：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 8.3.5 Destructuring Function Arguments into Parameters
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.5 将函数参数解构为参数
- en: When you invoke a function with a list of argument values, those values end
    up being assigned to the parameters declared in the function definition. This
    initial phase of function invocation is a lot like variable assignment. So it
    should not be surprising that we can use the techniques of destructuring assignment
    (see [§3.10.3](ch03.xhtml#destructuring-assignment)) with functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用一系列参数值调用函数时，这些值最终被分配给函数定义中声明的参数。函数调用的初始阶段很像变量赋值。因此，我们可以使用解构赋值技术（参见 [§3.10.3](ch03.xhtml#destructuring-assignment)）与函数一起使用，这并不奇怪。
- en: 'If you define a function that has parameter names within square brackets, you
    are telling the function to expect an array value to be passed for each pair of
    square brackets. As part of the invocation process, the array arguments will be
    unpacked into the individually named parameters. As an example, suppose we are
    representing 2D vectors as arrays of two numbers, where the first element is the
    X coordinate and the second element is the Y coordinate. With this simple data
    structure, we could write the following function to add two vectors:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义一个带有方括号内参数名称的函数，那么你告诉函数期望传递一个��组值以用于每对方括号。在调用过程中，数组参数将被解包到各个命名参数中。举个例子，假设我们将
    2D 向量表示为包含两个数字的数组，其中第一个元素是 X 坐标，第二个元素是 Y 坐标。使用这种简单的数据结构，我们可以编写以下函数来添加两个向量：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code would be easier to understand if we destructured the two vector arguments
    into more clearly named parameters:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将两个向量参数解构为更清晰命名的参数，代码将更容易理解：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, if you are defining a function that expects an object argument,
    you can destructure parameters of that object. Let’s use a vector example again,
    except this time, let’s suppose that we represent vectors as objects with `x`
    and `y` parameters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你正在定义一个期望对象参数的函数，你可以解构该对象的参数。再次使用矢量示例，假设我们将矢量表示为具有`x`和`y`参数的对象：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This example of destructuring a single object argument into two parameters
    is a fairly clear one because the parameter names we use match the property names
    of the incoming object. The syntax is more verbose and more confusing when you
    need to destructure properties with one name into parameters with different names.
    Here’s the vector addition example, implemented for object-based vectors:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将单个对象参数解构为两个参数的示例相当清晰，因为我们使用的参数名称与传入对象的属性名称匹配。当你需要将具有一个名称的属性解构为具有不同名称的参数时，语法会更冗长且更令人困惑。这里是基于对象的矢量的矢量加法示例的实现：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The tricky thing about destructuring syntax like `{x:x1, y:y1}` is remembering
    which are the property names and which are the parameter names. The rule to keep
    in mind for destructuring assignment and destructuring function calls is that
    the variables or parameters being declared go in the spots where you’d expect
    values to go in an object literal. So property names are always on the lefthand
    side of the colon, and the parameter (or variable) names are on the right.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于解构语法如`{x:x1, y:y1}`，让人难以记住哪些是属性名称，哪些是参数名称。要记住解构赋值和解构函数调用的规则是，被声明的变量或参数放在你期望值在对象字面量中的位置。因此，属性名称始终在冒号的左侧，参数（或变量）���称在右侧。
- en: 'You can define parameter defaults with destructured parameters. Here’s vector
    multiplication that works with 2D or 3D vectors:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用解构参数定义参数默认值。这里是适用于2D或3D矢量的矢量乘法：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Some languages (like Python) allow the caller of a function to invoke a function
    with arguments specified in `name=value` form, which is convenient when there
    are many optional arguments or when the parameter list is long enough that it
    is hard to remember the correct order. JavaScript does not allow this directly,
    but you can approximate it by destructuring an object argument into your function
    parameters. Consider a function that copies a specified number of elements from
    one array into another array with optionally specified starting offsets for each
    array. Since there are five possible parameters, some of which have defaults,
    and it would be hard for a caller to remember which order to pass the arguments
    in, we can define and invoke the `arraycopy()` function like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言（如Python）允许函数的调用者以`name=value`形式指定参数调用函数，当存在许多可选参数或参数列表足够长以至于难以记住正确顺序时，这是很方便的。JavaScript
    不直接允许这样做，但你可以通过将对象参数解构为函数参数来近似实现。考虑一个函数，它从一个数组中复制指定数量的元素到另一个数组中，并为每个数组指定可选的起始偏移量。由于有五个可能的参数，其中一些具有默认值，并且调用者很难记住传递参数的顺序，我们可以像这样定义和调用`arraycopy()`函数：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you destructure an array, you can define a rest parameter for extra values
    within the array that is being unpacked. That rest parameter within the square
    brackets is completely different than the true rest parameter for the function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当你解构一个数组时，你可以为被解构的数组中的额外值定义一个剩余参数。方括号内的剩余参数与函数的真正剩余参数完全不同：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In ES2018, you can also use a rest parameter when you destructure an object.
    The value of that rest parameter will be an object that has any properties that
    did not get destructured. Object rest parameters are often useful with the object
    spread operator, which is also a new feature of ES2018:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2018中，当你解构一个对象时，也可以使用剩余参数。该剩余参数的值将是一个对象，其中包含未被解构的任何属性。对象剩余参数通常与对象展开运算符一起使用，这也是ES2018的一个新功能：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, keep in mind that, in addition to destructuring argument objects and
    arrays, you can also destructure arrays of objects, objects that have array properties,
    and objects that have object properties, to essentially any depth. Consider graphics
    code that represents circles as objects with `x`, `y`, `radius`, and `color` properties,
    where the `color` property is an array of red, green, and blue color components.
    You might define a function that expects a single circle object to be passed to
    it but destructures that circle object into six separate parameters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住，除了解构参数对象和数组外，你还可以解构对象数组、具有数组属性的对象以及具有对象属性的对象，实际上可以解构到任何深度。考虑表示圆的图形代码，其中圆被表示为具有`x`、`y`、`半径`和`颜色`属性的对象，其中`颜色`属性是红色、绿色和蓝色颜色分量的数组。你可以定义一个函数，该函数期望传递一个圆对象，但将该圆对象解构为六个单独的参数：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If function argument destructuring is any more complicated than this, I find
    that the code becomes harder to read, rather than simpler. Sometimes, it is clearer
    to be explicit about your object property access and array indexing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数参数解构比这更复杂，我发现代码变得更难阅读，而不是更简单。有时，明确地访问对象属性和数组索引会更清晰。
- en: 8.3.6 Argument Types
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.6 参数类型
- en: JavaScript method parameters have no declared types, and no type checking is
    performed on the values you pass to a function. You can help make your code self-documenting
    by choosing descriptive names for function arguments and by documenting them carefully
    in the comments for each function. (Alternatively, see [§17.8](ch17.xhtml#flow)
    for a language extension that allows you to layer type checking on top of regular
    JavaScript.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 方法参数没有声明类型，并且不对传递给函数的值执行类型检查。通过为函数参数选择描述性名称并在每个函数的注释中仔细记录它们，可以帮助使代码自我描述。（或者，参见[§17.8](ch17.xhtml#flow)中允许你在常规JavaScript之上添加类型检查的语言扩展。）
- en: As described in [§3.9](ch03.xhtml#conversions), JavaScript performs liberal
    type conversion as needed. So if you write a function that expects a string argument
    and then call that function with a value of some other type, the value you passed
    will simply be converted to a string when the function tries to use it as a string.
    All primitive types can be converted to strings, and all objects have `toString()`
    methods (if not necessarily useful ones), so an error never occurs in this case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [§3.9](ch03.xhtml#conversions) 中所述，JavaScript 根据需要执行自由的类型转换。因此，如果您编写一个期望字符串参数的函数，然后使用其他类型的值调用该函数，那么当函数尝试将其用作字符串时，您传递的值将被简单地转换为字符串。所有原始类型都可以转换为字符串，所有对象都有
    `toString()` 方法（不一定是有用的），因此在这种情况下不会发生错误。
- en: 'This is not always true, however. Consider again the `arraycopy()` method shown
    earlier. It expects one or two array arguments and will fail if these arguments
    are of the wrong type. Unless you are writing a private function that will only
    be called from nearby parts of your code, it may be worth adding code to check
    the types of arguments like this. It is better for a function to fail immediately
    and predictably when passed bad values than to begin executing and fail later
    with an error message that is likely to be unclear. Here is an example function
    that performs type-checking:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不总是正确的。再次考虑之前显示的 `arraycopy()` 方法。它期望一个或两个数组参数，并且如果这些参数的类型错误，则会失败。除非您正在编写一个只会从代码附近的部分调用的私有函数，否则值得添加代码来检查参数的类型。当传递错误的值时，最好让函数立即和可预测地失败，而不是开始执行然后在稍后失败并显示可能不清晰的错误消息。这里有一个执行类型检查的示例函数：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 8.4 Functions as Values
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 函数作为值
- en: The most important features of functions are that they can be defined and invoked.
    Function definition and invocation are syntactic features of JavaScript and of
    most other programming languages. In JavaScript, however, functions are not only
    syntax but also values, which means they can be assigned to variables, stored
    in the properties of objects or the elements of arrays, passed as arguments to
    functions, and so on.^([3](ch08.xhtml#idm46198540105128))
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 函数最重要的特点是它们可以被定义和调用。函数的定义和调用是 JavaScript 和大多数其他编程语言的语法特性。然而，在 JavaScript 中，函数不仅仅是语法，还是值，这意味着它们可以被分配给变量，存储在对象的属性或数组的元素中，作为函数的参数传递等。^([3](ch08.xhtml#idm46198540105128))
- en: 'To understand how functions can be JavaScript data as well as JavaScript syntax,
    consider this function definition:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解函数如何既可以是 JavaScript 数据又可以是 JavaScript 语法，请考虑这个函数定义：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This definition creates a new function object and assigns it to the variable
    `square`. The name of a function is really immaterial; it is simply the name of
    a variable that refers to the function object. The function can be assigned to
    another variable and still work the same way:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义创建了一个新的函数对象并将其分配给变量 `square`。函数的名称实际上并不重要；它只是一个指向函数对象的变量的名称。该函数可以分配给另一个变量，仍然可以正常工作：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Functions can also be assigned to object properties rather than variables.
    As we’ve already discussed, we call the functions “methods” when we do this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以被分配给对象属性而不是变量。正如我们之前讨论过的，当我们这样做时，我们将这些函数称为“方法”：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Functions don’t even require names at all, as when they’re assigned to array
    elements:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 函数甚至不需要名称，比如当它们被分配给数组元素时：
- en: '[PRE43]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The syntax of this last example looks strange, but it is still a legal function
    invocation expression!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例的语法看起来很奇怪，但仍然是一个合法的函数调用表达式！
- en: 'As an example of how useful it is to treat functions as values, consider the
    `Array.sort()` method. This method sorts the elements of an array. Because there
    are many possible orders to sort by (numerical order, alphabetical order, date
    order, ascending, descending, and so on), the `sort()` method optionally takes
    a function as an argument to tell it how to perform the sort. This function has
    a simple job: for any two values it is passed, it returns a value that specifies
    which element would come first in a sorted array. This function argument makes
    `Array.sort()` perfectly general and infinitely flexible; it can sort any type
    of data into any conceivable order. Examples are shown in [§7.8.6](ch07.xhtml#arraysearchandsort).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为将函数视为值的有用性的一个例子，考虑 `Array.sort()` 方法。该方法对数组的元素进行排序。由于有许多可能的排序顺序（数字顺序、字母顺序、日期顺序、升序、降序等），`sort()`
    方法可以选择接受一个函数作为参数，告诉它如何执行排序。这个函数的工���很简单：对于传递给它的任何两个值，它返回一个指定哪个元素在排序后的数组中首先出现的值。这个函数参数使
    `Array.sort()` 变得非常通用和无限灵活；它可以将任何类型的数据按照任何可想象的顺序进行排序。示例在 [§7.8.6](ch07.xhtml#arraysearchandsort)
    中展示。
- en: '[Example 8-1](#functions-EX-2) demonstrates the kinds of things that can be
    done when functions are used as values. This example may be a little tricky, but
    the comments explain what is going on.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-1](#functions-EX-2) 展示了当函数被用作值时可以做的事情。这个例子可能有点棘手，但注释解释了发生了什么。'
- en: Example 8-1\. Using functions as data
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1。将函数用作数据
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 8.4.1 Defining Your Own Function Properties
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.1 定义自己的函数属性
- en: 'Functions are not primitive values in JavaScript, but a specialized kind of
    object, which means that functions can have properties. When a function needs
    a “static” variable whose value persists across invocations, it is often convenient
    to use a property of the function itself. For example, suppose you want to write
    a function that returns a unique integer whenever it is invoked. The function
    must never return the same value twice. In order to manage this, the function
    needs to keep track of the values it has already returned, and this information
    must persist across function invocations. You could store this information in
    a global variable, but that is unnecessary, because the information is used only
    by the function itself. It is better to store the information in a property of
    the Function object. Here is an example that returns a unique integer whenever
    it is called:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '在JavaScript中，函数不是原始值，而是一种特殊的对象，这意味着函数可以有属性。当一个函数需要一个“静态”变量，其值在调用之间保持不变时，通常方便使用函数本身的属性。例如，假设你想编写一个函数，每次调用时都返回一个唯一的整数。该函数���能两次返回相同的值。为了管理这个问题，函数需要跟踪它已经返回的值，并且这个信息必须在函数调用之间保持不变。你可以将这个信息存储在一个全局变量中，但这是不必要的，因为这个信息只被函数本身使用。最好将信息存储在Function对象的属性中。下面是一个示例，每次调用时都返回一个唯一的整数： '
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As another example, consider the following `factorial()` function that uses
    properties of itself (treating itself as an array) to cache previously computed
    results:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑下面的`factorial()`函数，它利用自身的属性（将自身视为数组）来缓存先前计算的结果：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 8.5 Functions as Namespaces
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.5 函数作为命名空间
- en: Variables declared within a function are not visible outside of the function.
    For this reason, it is sometimes useful to define a function simply to act as
    a temporary namespace in which you can define variables without cluttering the
    global namespace.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内声明的变量在函数外部是不可见的。因此，有时候定义一个函数仅仅作为一个临时的命名空间是很有用的，你可以在其中定义变量而不会使全局命名空间混乱。
- en: 'Suppose, for example, you have a chunk of JavaScript code that you want to
    use in a number of different JavaScript programs (or, for client-side JavaScript,
    on a number of different web pages). Assume that this code, like most code, defines
    variables to store the intermediate results of its computation. The problem is
    that since this chunk of code will be used in many different programs, you don’t
    know whether the variables it creates will conflict with variables created by
    the programs that use it. The solution is to put the chunk of code into a function
    and then invoke the function. This way, variables that would have been global
    become local to the function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一段JavaScript代码块，你想在许多不同的JavaScript程序中使用（或者对于客户端JavaScript，在许多不同的网页上使用）。假设这段代码，像大多数代码一样，定义变量来存储计算的中间结果。问题在于，由于这段代码将在许多不同的程序中使用，你不知道它创建的变量是否会与使用它的程序创建的变量发生冲突。解决方案是将代码块放入一个函数中，然后调用该函数。这样，原本将是全局的变量变为函数的局部变量：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This code defines only a single global variable: the function name `chunkNamespace`.
    If defining even a single property is too much, you can define and invoke an anonymous
    function in a single expression:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只定义了一个全局变量：函数名`chunkNamespace`。如果即使定义一个属性也太多了，你可以在单个表达式中定义并调用一个匿名函数：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This technique of defining and invoking a function in a single expression is
    used frequently enough that it has become idiomatic and has been given the name
    “immediately invoked function expression.” Note the use of parentheses in the
    previous code example. The open parenthesis before `function` is required because
    without it, the JavaScript interpreter tries to parse the `function` keyword as
    a function declaration statement. With the parenthesis, the interpreter correctly
    recognizes this as a function definition expression. The leading parenthesis also
    helps human readers recognize when a function is being defined to be immediately
    invoked instead of defined for later use.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 定义和调用一个函数的单个表达式的技术经常被使用，已经成为惯用语，并被称为“立即调用函数表达式”。请注意前面代码示例中括号的使用。在`function`之前的开括号是必需的，因为没有它，JavaScript解释器会尝试将`function`关键字解析为函数声明语句。有了括号，解释器正确地将其识别为函数定义表达式。前导括号还有助于人类读者识别何时定义一个函数以立即调用，而不是为以后使用而定义。
- en: This use of functions as namespaces becomes really useful when we define one
    or more functions inside the namespace function using variables within that namesapce,
    but then pass them back out as the return value of the namespace function. Functions
    like this are known as *closures*, and they’re the topic of the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在命名空间函数内部定义一个或多个函数，并使用该命名空间内的变量，然后将它们作为命名空间函数的返回值传递出去时，函数作为命名空间的用法变得非常有用。这样的函数被称为*闭包*，它们是下一节的主题。
- en: 8.6 Closures
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.6 闭包
- en: Like most modern programming languages, JavaScript uses *lexical scoping*. This
    means that functions are executed using the variable scope that was in effect
    when they were defined, not the variable scope that is in effect when they are
    invoked. In order to implement lexical scoping, the internal state of a JavaScript
    function object must include not only the code of the function but also a reference
    to the scope in which the function definition appears. This combination of a function
    object and a scope (a set of variable bindings) in which the function’s variables
    are resolved is called a *closure* in the computer science literature.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数现代编程语言一样，JavaScript使用*词法作用域*。这意味着函数在定义时使用的变量作用域，而不是在调用时使用的变量作用域。为了实现词法作用域，JavaScript函数对象的内部状态必须包括函数的代码以及函数定义所在的作用域的引用。在计算机科学文献中，函数对象和作用域（一组变量绑定）的组合，用于解析函数变量的作用域，被称为*闭包*。
- en: Technically, all JavaScript functions are closures, but because most functions
    are invoked from the same scope that they were defined in, it normally doesn’t
    really matter that there is a closure involved. Closures become interesting when
    they are invoked from a different scope than the one they were defined in. This
    happens most commonly when a nested function object is returned from the function
    within which it was defined. There are a number of powerful programming techniques
    that involve this kind of nested function closures, and their use has become relatively
    common in JavaScript programming. Closures may seem confusing when you first encounter
    them, but it is important that you understand them well enough to use them comfortably.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，所有的 JavaScript 函数都是闭包，但由于大多数函数是从定义它们的同一作用域中调用的，通常并不重要闭包是否涉及其中。当闭包从与其定义所在不同的作用域中调用时，闭包就变得有趣起来。这种情况最常见于从定义它的函数中返回嵌套函数对象时。有许多强大的编程技术涉及到这种嵌套函数闭包，它们在
    JavaScript 编程中的使用变得相对常见。当你第一次遇到闭包时，它们可能看起来令人困惑，但重要的是你要足够了解它们以便舒适地使用它们。
- en: 'The first step to understanding closures is to review the lexical scoping rules
    for nested functions. Consider the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 理解闭包的第一步是复习嵌套函数的词法作用域规则。考虑以下代码：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `checkscope()` function declares a local variable and then defines and invokes
    a function that returns the value of that variable. It should be clear to you
    why the call to `checkscope()` returns “local scope”. Now, let’s change the code
    just slightly. Can you tell what this code will return?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkscope()`函数声明了一个局部变量，然后定义并调用一个返回该变量值的函数。你应该清楚为什么调用`checkscope()`会返回“local
    scope”。现在，让我们稍微改变一下代码。你能告诉这段代码会返回什么吗？'
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this code, a pair of parentheses has moved from inside `checkscope()` to
    outside of it. Instead of invoking the nested function and returning its result,
    `checkscope()` now just returns the nested function object itself. What happens
    when we invoke that nested function (with the second pair of parentheses in the
    last line of code) outside of the function in which it was defined?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，一对括号已经从`checkscope()`内部移到了外部。现在，`checkscope()`不再调用嵌套函数并返回其结果，而是直接返回嵌套函数对象本身。当我们在定义它的函数之外调用该嵌套函数（在代码的最后一行中的第二对括号中）时会发生什么？
- en: 'Remember the fundamental rule of lexical scoping: JavaScript functions are
    executed using the scope they were defined in. The nested function `f()` was defined
    in a scope where the variable `scope` was bound to the value “local scope”. That
    binding is still in effect when `f` is executed, no matter where it is executed
    from. So the last line of the preceding code example returns “local scope”, not
    “global scope”. This, in a nutshell, is the surprising and powerful nature of
    closures: they capture the local variable (and parameter) bindings of the outer
    function within which they are defined.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 记住词法作用域的基本规则：JavaScript 函数是在定义它们的作用域中执行的。嵌套函数`f()`是在一个作用域中定义的，该作用域中变量`scope`绑定到值“local
    scope”。当执行`f`时，这个绑定仍然有效，无论从哪里执行。因此，前面代码示例的最后一行返回“local scope”，而不是“global scope”。这就是闭包的令人惊讶和强大的本质：它们捕获了它们所定义的外部函数的局部变量（和参数）绑定。
- en: 'In [§8.4.1](#yourownfunctionprops), we defined a `uniqueInteger()` function
    that used a property of the function itself to keep track of the next value to
    be returned. A shortcoming of that approach is that buggy or malicious code could
    reset the counter or set it to a noninteger, causing the `uniqueInteger()` function
    to violate the “unique” or the “integer” part of its contract. Closures capture
    the local variables of a single function invocation and can use those variables
    as private state. Here is how we could rewrite the `uniqueInteger()` using an
    immediately invoked function expression to define a namespace and a closure that
    uses that namespace to keep its state private:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在[§8.4.1](#yourownfunctionprops)中，我们定义了一个`uniqueInteger()`函数，该函数使用函数本身的属性来跟踪下一个要返回的值。这种方法的一个缺点是，有错误或恶意代码可能会重置计数器或将其设置为非整数，导致`uniqueInteger()`函数违反其“unique”或“integer”部分的约定。闭包捕获了单个函数调用的局部变量，并可以将这些变量用作私有状态。下面是我们如何使用立即调用函数表达式来重新编写`uniqueInteger()`，以定义一个命名空间和使用该命名空间来保持其状态私有的闭包：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In order to understand this code, you have to read it carefully. At first glance,
    the first line of code looks like it is assigning a function to the variable `uniqueInteger`.
    In fact, the code is defining and invoking (as hinted by the open parenthesis
    on the first line) a function, so it is the return value of the function that
    is being assigned to `uniqueInteger`. Now, if we study the body of the function,
    we see that its return value is another function. It is this nested function object
    that gets assigned to `uniqueInteger`. The nested function has access to the variables
    in its scope and can use the `counter` variable defined in the outer function.
    Once that outer function returns, no other code can see the `counter` variable:
    the inner function has exclusive access to it.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这段代码，你必须仔细阅读它。乍一看，代码的第一行看起来像是将一个函数赋给变量`uniqueInteger`。实际上，代码正在定义并调用一个函数（第一行的开括号提示了这一点），因此将函数的返回值赋给了`uniqueInteger`。现在，如果我们研究函数体，我们会发现它的返回值是另一个函数。正是这个嵌套函数对象被赋给了`uniqueInteger`。嵌套函数可以访问其作用域中的变量，并且可以使用外部函数中定义的`counter`变量。一旦外部函数返回，其他代码就无法看到`counter`变量：内部函数对其具有独占访问权限。
- en: 'Private variables like `counter` need not be exclusive to a single closure:
    it is perfectly possible for two or more nested functions to be defined within
    the same outer function and share the same scope. Consider the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 像`counter`这样的私有变量不一定是单个闭包的专有：完全可以在同一个外部函数中定义两个或更多个嵌套函数并共享相同的作用域。考虑以下代码：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `counter()` function returns a “counter” object. This object has two methods:
    `count()` returns the next integer, and `reset()` resets the internal state. The
    first thing to understand is that the two methods share access to the private
    variable `n`. The second thing to understand is that each invocation of `counter()`
    creates a new scope—independent of the scopes used by previous invocations—and
    a new private variable within that scope. So if you call `counter()` twice, you
    get two counter objects with different private variables. Calling `count()` or
    `reset()` on one counter object has no effect on the other.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter()`函数返回一个“计数器”对象。这个对象有两个方法：`count()`返回下一个整数，`reset()`重置内部状态。首先要理解的是，这两个方法共享对私有变量`n`的访问。其次要理解的是，每次调用`counter()`都会创建一个新的作用域——独立于先前调用使用的作用域，并在该作用域内创建一个新的私有变量。因此，如果您两次调用`counter()`，您将得到两个具有不同私有变量的计数器对象。在一个计数器对象上调用`count()`或`reset()`对另一个没有影响。'
- en: 'It is worth noting here that you can combine this closure technique with property
    getters and setters. The following version of the `counter()` function is a variation
    on code that appeared in [§6.10.6](ch06.xhtml#gettersandsetters), but it uses
    closures for private state rather than relying on a regular object property:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您可以将闭包技术与属性的getter和setter结合使用。下面这个`counter()`函数的版本是[§6.10.6](ch06.xhtml#gettersandsetters)中出现的代码的变体，但它使用闭包来实现私有状态，而不是依赖于常规对象属性：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that this version of the `counter()` function does not declare a local
    variable but just uses its parameter `n` to hold the private state shared by the
    property accessor methods. This allows the caller of `counter()` to specify the
    initial value of the private variable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`counter()`函数的版本并没有声明一个局部变量，而是只是使用其参数`n`来保存属性访问方法共享的私有状态。这允许`counter()`的调用者指定私有变量的初始值。
- en: '[Example 8-2](#addPrivateProperty.js) is a generalization of the shared private
    state through the closures technique we’ve been demonstrating here. This example
    defines an `addPrivateProperty()` function that defines a private variable and
    two nested functions to get and set the value of that variable. It adds these
    nested functions as methods of the object you specify.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-2](#addPrivateProperty.js)是通过我们一直在演示的闭包技术对共享私有状态进行泛化的一个例子。这个示例定义了一个`addPrivateProperty()`函数，该函数定义了一个私有变量和两个嵌套函数来获取和设置该变量的值。它将这些嵌套函数作为您指定对象的方法添加。'
- en: Example 8-2\. Private property accessor methods using closures
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 使用闭包的私有属性访问方法
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We’ve now seen a number of examples in which two closures are defined in the
    same scope and share access to the same private variable or variables. This is
    an important technique, but it is just as important to recognize when closures
    inadvertently share access to a variable that they should not share. Consider
    the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了许多例子，其中两个闭包在同一个作用域中定义并共享对相同私有变量或变量的访问。这是一个重要的技术，但同样重要的是要认识到闭包无意中共享对不应共享的变量的访问。考虑以下代码：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When working with code like this that creates multiple closures using a loop,
    it is a common error to try to move the loop within the function that defines
    the closures. Think about the following code, for example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理像这样使用循环创建多个闭包的代码时，一个常见的错误是尝试将循环移到定义闭包的函数内部��例如，考虑以下代码：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This code creates 10 closures and stores them in an array. The closures are
    all defined within the same invocation of the function, so they share access to
    the variable `i`. When `constfuncs()` returns, the value of the variable `i` is
    10, and all 10 closures share this value. Therefore, all the functions in the
    returned array of functions return the same value, which is not what we wanted
    at all. It is important to remember that the scope associated with a closure is
    “live.” Nested functions do not make private copies of the scope or make static
    snapshots of the variable bindings. Fundamentally, the problem here is that variables
    declared with `var` are defined throughout the function. Our `for` loop declares
    the loop variable with `var i`, so the variable `i` is defined throughout the
    function rather than being more narrowly scoped to the body of the loop. The code
    demonstrates a common category of bugs in ES5 and before, but the introduction
    of block-scoped variables in ES6 addresses the issue. If we just replace the `var`
    with a `let` or a `const`, then the problem goes away. Because `let` and `const`
    are block scoped, each iteration of the loop defines a scope that is independent
    of the scopes for all other iterations, and each of these scopes has its own independent
    binding of `i`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了10个闭包并将它们存储在一个数组中。这些闭包都在同一个函数调用中定义，因此它们共享对变量`i`的访问。当`constfuncs()`返回时，变量`i`的值为10，所有10个闭包都共享这个值。因此，返回的函数数组中的所有函数都返回相同的值，这并不是我们想要的。重要的是要记住，与闭包相关联的作用域是“活动的”。嵌套函数不会创建作用域的私有副本，也不会对变量绑定进行静态快照。从根本上说，这里的问题是使用`var`声明的变量在整个函数中都被定义。我们的`for`循环使用`var
    i`声明循环变量，因此变量`i`在整个函数中被定义，而不是更窄地限制在循环体内。这段代码展示了ES5及之前版本中常见的一类错误，但ES6引入的块作用域变量解决了这个问题。如果我们只是用`let`或`const`替换`var`，问题就消失了。因为`let`和`const`是块作用域的，循环的每次迭代都定义了一个独立于所有其他迭代的作用域，并且每个作用域都有自己独立的`i`绑定。
- en: 'Another thing to remember when writing closures is that `this` is a JavaScript
    keyword, not a variable. As discussed earlier, arrow functions inherit the `this`
    value of the function that contains them, but functions defined with the `function`
    keyword do not. So if you’re writing a closure that needs to use the `this` value
    of its containing function, you should use an arrow function, or call `bind()`,
    on the closure before returning it, or assign the outer `this` value to a variable
    that your closure will inherit:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 写闭包时要记住的另一��事是，`this`是JavaScript关键字，而不是变量。正如前面讨论的，箭头函数继承了包含它们的函数的`this`值，但使用`function`关键字定义的函数不会。因此，如果您编写一个需要使用其包含函数的`this`值的闭包，您应该在返回之前使用箭头函数或调用`bind()`，或将外部`this`值分配给闭包将继承的变量：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 8.7 Function Properties, Methods, and Constructor
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.7 函数属性、方法和构造函数
- en: We’ve seen that functions are values in JavaScript programs. The `typeof` operator
    returns the string “function” when applied to a function, but functions are really
    a specialized kind of JavaScript object. Since functions are objects, they can
    have properties and methods, just like any other object. There is even a `Function()`
    constructor to create new function objects. The subsections that follow document
    the `length`, `name`, and `prototype` properties; the `call()`, `apply()`, `bind()`,
    and `toString()` methods; and the `Function()` constructor.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到函数在JavaScript程序中是值。当应用于函数时，`typeof`运算符返回字符串“function”，但函数实际上是JavaScript对象的一种特殊类型。由于函数是对象，它们可以像任何其他对象一样具有属性和方法。甚至有一个`Function()`构造函数来创建新的函数对象。接下来的小节记录了`length`、`name`和`prototype`属性；`call()`、`apply()`、`bind()`和`toString()`方法；以及`Function()`构造函数。
- en: 8.7.1 The length Property
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.1 length属性
- en: The read-only `length` property of a function specifies the *arity* of the function—the
    number of parameters it declares in its parameter list, which is usually the number
    of arguments that the function expects. If a function has a rest parameter, that
    parameter is not counted for the purposes of this `length` property.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的只读`length`属性指定函数的*arity*——它在参数列表中声明的参数数量，通常是函数期望的参数数量。如果函数有一个剩余参数，那么这个参数不会计入`length`属性的目的。
- en: 8.7.2 The name Property
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.2 名称属性
- en: The read-only `name` property of a function specifies the name that was used
    when the function was defined, if it was defined with a name, or the name of the
    variable or property that an unnamed function expression was assigned to when
    it was first created. This property is primarily useful when writing debugging
    or error messages.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的只读`name`属性指定函数在定义时使用的名称，如果它是用名称定义的，或者在创建时未命名的函数表达式被分配给的变量或属性的名称。当编写调试或错误消息时，此属性非常有用。
- en: 8.7.3 The prototype Property
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.3 prototype属性
- en: All functions, except arrow functions, have a `prototype` property that refers
    to an object known as the *prototype object*. Every function has a different prototype
    object. When a function is used as a constructor, the newly created object inherits
    properties from the prototype object. Prototypes and the `prototype` property
    were discussed in [§6.2.3](ch06.xhtml#prototypes) and will be covered again in
    [Chapter 9](ch09.xhtml#classes).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数，除了箭头函数，都有一个`prototype`属性，指向一个称为*原型对象*的对象。每个函数都有一个不同的原型对象。当一个函数被用作构造函数时，新创建的对象会从原型对象继承属性。原型和`prototype`属性在[§6.2.3](ch06.xhtml#prototypes)中讨论过，并将在[第9章](ch09.xhtml#classes)中再次涉及。
- en: 8.7.4 The call() and apply() Methods
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.4 call()和apply()方法
- en: '`call()` and `apply()` allow you to indirectly invoke ([§8.2.4](#indirectinvocation))
    a function as if it were a method of some other object. The first argument to
    both `call()` and `apply()` is the object on which the function is to be invoked;
    this argument is the invocation context and becomes the value of the `this` keyword
    within the body of the function. To invoke the function `f()` as a method of the
    object `o` (passing no arguments), you could use either `call()` or `apply()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`call()`和`apply()`允许您间接调用（[§8.2.4](#indirectinvocation)）一个函数，就好像它是另一个对象的方法一样。`call()`和`apply()`的第一个参数是要调用函数的对象；这个参数是调用上下文，并在函数体内成为`this`关键字的值。要将函数`f()`作为对象`o`的方法调用（不传递参数），可以使用`call()`或`apply()`：'
- en: '[PRE58]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Either of these lines of code are similar to the following (which assume that
    `o` does not already have a property named `m`):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码中的任何一行与以下代码类似（假设`o`尚未具有名为`m`的属性）：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Remember that arrow functions inherit the `this` value of the context where
    they are defined. This cannot be overridden with the `call()` and `apply()` methods.
    If you call either of those methods on an arrow function, the first argument is
    effectively ignored.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，箭头函数继承了定义它们的上下文的`this`值。这不能通过`call()`和`apply()`方法覆盖。如果在箭头函数上调用这些方法之一，第一个参数实际上会被忽略。
- en: 'Any arguments to `call()` after the first invocation context argument are the
    values that are passed to the function that is invoked (and these arguments are
    not ignored for arrow functions). For example, to pass two numbers to the function
    `f()` and invoke it as if it were a method of the object `o`, you could use code
    like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个调用上下文参数之后的任何`call()`参数都是传递给被调用函数的值（对于箭头函数，这些参数不会被忽略）。例如，要向函数`f()`传递两个数字，并将其作为对象`o`的方法调用，可以使用以下代码：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `apply()` method is like the `call()` method, except that the arguments
    to be passed to the function are specified as an array:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`方法类似于`call()`方法，只是要传递给函数的参数被指定为一个数组：'
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If a function is defined to accept an arbitrary number of arguments, the `apply()`
    method allows you to invoke that function on the contents of an array of arbitrary
    length. In ES6 and later, we can just use the spread operator, but you may see
    ES5 code that uses `apply()` instead. For example, to find the largest number
    in an array of numbers without using the spread operator, you could use the `apply()`
    method to pass the elements of the array to the `Math.max()` function:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数被定义为接受任意数量的参数，`apply()` 方法允许你在任意长度的数组内容上调用该函数。在 ES6 及更高版本中，我们可以直接使用扩展运算符，但你可能会看到使用
    `apply()` 而不是扩展运算符的 ES5 ���码。例如，要在不使用扩展运算符的情况下找到数组中的最大数，你可以使用 `apply()` 方法将数组的元素传递给
    `Math.max()` 函数：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `trace()` function defined in the following is similar to the `timed()`
    function defined in [§8.3.4](#spread-operator-for-functions), but it works for
    methods instead of functions. It uses the `apply()` method instead of a spread
    operator, and by doing that, it is able to invoke the wrapped method with the
    same arguments and the same `this` value as the wrapper method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面定义的 `trace()` 函数类似于 [§8.3.4](#spread-operator-for-functions) 中定义的 `timed()`
    函数，但它适用于方法而不是函数。它使用 `apply()` 方法而不是扩展运算符，通过这样做，它能够以与包装方法相同的参数和 `this` 值调用被包装的方法：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 8.7.5 The bind() Method
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.5 `bind()` 方法
- en: 'The primary purpose of `bind()` is to *bind* a function to an object. When
    you invoke the `bind()` method on a function `f` and pass an object `o`, the method
    returns a new function. Invoking the new function (as a function) invokes the
    original function `f` as a method of `o`. Any arguments you pass to the new function
    are passed to the original function. For example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` 的主要目的是将函数*绑定*到对象。当你在函数 `f` 上调用 `bind()` 方法并传递一个对象 `o` 时，该方法会返回一个新函数。调用新函数（作为函数）会将原始函数
    `f` 作为 `o` 的方法调用。传递给新函数的任何参数都会传递给原始函数。例如：'
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Arrow functions inherit their `this` value from the environment in which they
    are defined, and that value cannot be overridden with `bind()`, so if the function
    `f()` in the preceding code was defined as an arrow function, the binding would
    not work. The most common use case for calling `bind()` is to make non-arrow functions
    behave like arrow functions, however, so this limitation on binding arrow functions
    is not a problem in practice.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数从定义它们的环境继承它们的 `this` 值，并且该值不能被 `bind()` 覆盖，因此如果前面代码中的函数 `f()` 被定义为箭头函数，绑定将不起作用。然而，调用
    `bind()` 最常见的用例是使非箭头函数的行为类似箭头函数，因此在实践中，对绑定箭头函数的限制并不是问题。
- en: 'The `bind()` method does more than just bind a function to an object, however.
    It can also perform partial application: any arguments you pass to `bind()` after
    the first are bound along with the `this` value. This partial application feature
    of `bind()` does work with arrow functions. Partial application is a common technique
    in functional programming and is sometimes called *currying*. Here are some examples
    of the `bind()` method used for partial application:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()` 方法不仅仅是将函数绑定到对象，它还可以执行部分应用：在第一个参数之后传递给 `bind()` 的任何参数都与 `this` 值一起绑定。`bind()`
    的这种部分应用特性适用于箭头函数。部分应用是函数式编程中的常见技术，有时被称为*柯里化*。以下是 `bind()` 方法用于部分应用的一些示例：'
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `name` property of the function returned by `bind()` is the name property
    of the function that `bind()` was called on, prefixed with the word “bound”.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `bind()` 返回的函数的 `name` 属性是调用 `bind()` 的函数的名称属性，前缀为“bound”。
- en: 8.7.6 The toString() Method
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.6 `toString()` 方法
- en: Like all JavaScript objects, functions have a `toString()` method. The ECMAScript
    spec requires this method to return a string that follows the syntax of the function
    declaration statement. In practice, most (but not all) implementations of this
    `toString()` method return the complete source code for the function. Built-in
    functions typically return a string that includes something like “[native code]”
    as the function body.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有 JavaScript 对象一样，函数有一个 `toString()` 方法。ECMAScript 规范要求该方法返回一个遵循函数声明语法的字符串。实际上，大多数（但不是所有）实现这个
    `toString()` 方法的实现会返回函数的完整源代码。内置函数通常返回一个包含类似“[native code]”的字符串作为函数体的字符串。
- en: 8.7.7 The Function() Constructor
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.7 `Function()` 构造函数
- en: 'Because functions are objects, there is a `Function()` constructor that can
    be used to create new functions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是对象，所以有一个 `Function()` 构造函数可用于创建新函数：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This line of code creates a new function that is more or less equivalent to
    a function defined with the familiar syntax:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码创建了一个新函数，它与使用熟悉语法定义的函数更或多少等效：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `Function()` constructor expects any number of string arguments. The last
    argument is the text of the function body; it can contain arbitrary JavaScript
    statements, separated from each other by semicolons. All other arguments to the
    constructor are strings that specify the parameter names for the function. If
    you are defining a function that takes no arguments, you would simply pass a single
    string—the function body—to the constructor.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function()` 构造函数期望任意数量的字符串参数。最后一个参数是函数体的文本；它可以包含任意 JavaScript 语句，用分号分隔。构造函数的所有其他参数都是指定函数参数名称的字符串。如果你定义一个不带参数的函数，你只需将一个字符串（函数体）传递给构造函数。'
- en: Notice that the `Function()` constructor is not passed any argument that specifies
    a name for the function it creates. Like function literals, the `Function()` constructor
    creates anonymous functions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Function()` 构造函数没有传递任何指定创建的函数名称的参数。与函数字面量一样，`Function()` 构造函数创建匿名函数。
- en: 'There are a few points that are important to understand about the `Function()`
    constructor:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点很重要需要了解关于 `Function()` 构造函数：
- en: The `Function()` constructor allows JavaScript functions to be dynamically created
    and compiled at runtime.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function()` 构造函数允许在运行时动态创建和编译 JavaScript 函数。'
- en: The `Function()` constructor parses the function body and creates a new function
    object each time it is called. If the call to the constructor appears within a
    loop or within a frequently called function, this process can be inefficient.
    By contrast, nested functions and function expressions that appear within loops
    are not recompiled each time they are encountered.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function()`构造函数解析函数体并在每次调用时创建一个新的函数对象。如果构造函数的调用出现在循环中或在频繁调用的函数内部，这个过程可能效率低下。相比之下，在循环中出现的嵌套函数和函数表达式在遇到时不会重新编译。'
- en: 'A last, very important point about the `Function()` constructor is that the
    functions it creates do not use lexical scoping; instead, they are always compiled
    as if they were top-level functions, as the following code demonstrates:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`Function()`构造函数的最后一个非常重要的观点是，它创建的函数不使用词法作用域；相反，它们总是被编译为顶级函数，如下面的代码所示：
- en: '[PRE68]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `Function()` constructor is best thought of as a globally scoped version
    of `eval()` (see [§4.12.2](ch04.xhtml#globaleval)) that defines new variables
    and functions in its own private scope. You will probably never need to use this
    constructor in your code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function()`构造函数最好被视为`eval()`的全局作用域版本（参见[§4.12.2](ch04.xhtml#globaleval)），它在自己的私有作用域中定义新的变量和函数。你可能永远不需要在你的代码中使用这个构造函数。'
- en: 8.8 Functional Programming
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.8 函数式编程
- en: JavaScript is not a functional programming language like Lisp or Haskell, but
    the fact that JavaScript can manipulate functions as objects means that we can
    use functional programming techniques in JavaScript. Array methods such as `map()`
    and `reduce()` lend themselves particularly well to a functional programming style.
    The sections that follow demonstrate techniques for functional programming in
    JavaScript. They are intended as a mind-expanding exploration of the power of
    JavaScript’s functions, not as a prescription for good programming style.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不像Lisp或Haskell那样是一种函数式编程语言，但JavaScript可以将函数作为对象进行操作的事实意味着我们可以在JavaScript中使用函数式编程技术。数组方法如`map()`和`reduce()`特别适合函数式编程风格。接下来的部分演示了JavaScript中函数式编程的技术。它们旨在探索JavaScript函数的强大功能，而不是规范良好的编程风格。
- en: 8.8.1 Processing Arrays with Functions
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8.1 使用函数处理数组
- en: 'Suppose we have an array of numbers and we want to compute the mean and standard
    deviation of those values. We might do that in nonfunctional style like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个数字数组，我们想要计算这些值的均值和标准差。我们可以像这样以非函数式的方式进��：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can perform these same computations in concise functional style using the
    array methods `map()` and `reduce()` like this (see [§7.8.1](ch07.xhtml#arrayiteratormethods)
    to review these methods):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组方法`map()`和`reduce()`以简洁的函数式风格执行相同的计算，如下所示（参见[§7.8.1](ch07.xhtml#arrayiteratormethods)回顾这些方法）：
- en: '[PRE70]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This new version of the code looks quite different than the first one, but
    it is still invoking methods on objects, so it has some object-oriented conventions
    remaining. Let’s write functional versions of the `map()` and `reduce()` methods:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本的代码看起来与第一个版本非常不同，但仍然在对象上调用方法，因此仍然保留了一些面向对象的约定。让我们编写`map()`和`reduce()`方法的函数式版本：
- en: '[PRE71]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With these `map()` and `reduce()` functions defined, our code to compute the
    mean and standard deviation now looks like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义的`map()`和`reduce()`函数，我们现在计算均值和标准差的代码如下：
- en: '[PRE72]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 8.8.2 Higher-Order Functions
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8.2 高阶函数
- en: 'A *higher-order function* is a function that operates on functions, taking
    one or more functions as arguments and returning a new function. Here is an example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*高阶函数*是一个操作函数的函数，它接受一个或多个函数作为参数并返回一个新函数。这里有一个例子：'
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This `not()` function is a higher-order function because it takes a function
    argument and returns a new function. As another example, consider the `mapper()`
    function that follows. It takes a function argument and returns a new function
    that maps one array to another using that function. This function uses the `map()`
    function defined earlier, and it is important that you understand how the two
    functions are different:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`not()`函数是一个高阶函数，因为它接受一个函数参数并返回一个新函数。再举一个例子，考虑接下来的`mapper()`函数。它接受一个函数参数并返回一个使用该函数将一个数组映射到另一个数组的新函数。这个函数使用了之前定义的`map()`函数，你需要理解这两个函数的不同之处很重要：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here is another, more general, example that takes two functions, `f` and `g`,
    and returns a new function that computes `f(g())`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个更一般的例子，它接受两个函数`f`和`g`，并返回一个计算`f(g())`的新函数：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `partial()` and `memoize()` functions defined in the sections that follow
    are two more important higher-order functions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中定义的`partial()`和`memoize()`函数是另外两个重要的高阶函数。
- en: 8.8.3 Partial Application of Functions
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8.3 函数的部分应用
- en: 'The `bind()` method of a function `f` (see [§8.7.5](#bind)) returns a new function
    that invokes `f` in a specified context and with a specified set of arguments.
    We say that it binds the function to an object and partially applies the arguments.
    The `bind()` method partially applies arguments on the left—that is, the arguments
    you pass to `bind()` are placed at the start of the argument list that is passed
    to the original function. But it is also possible to partially apply arguments
    on the right:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`f`的`bind()`方法（参见[§8.7.5](#bind)）返回一个在指定上下文中调用`f`并带有指定参数集的新函数。我们说它将函数绑定到一个对象并部分应用参数。`bind()`方法在左侧部分应用参数，也就是说，你传递给`bind()`的参数被放在传递给原始函数的参数列表的开头。但也可以在右侧部分应用参数：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'These partial application functions allow us to easily define interesting functions
    out of functions we already have defined. Here are some examples:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分应用函数使我们能够轻松地从已定义的函数中定义有趣的函数。以下是一些示例：
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Partial application becomes even more interesting when we combine it with other
    higher-order functions. Here, for example, is a way to define the preceding `not()`
    function just shown using composition and partial application:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将部分应用与其他高阶函数结合时，部分应用变得更加有趣。例如，以下是使用组合和部分应用定义前面刚刚展示的`not()`函数的一种方法：
- en: '[PRE78]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can also use composition and partial application to redo our mean and standard
    deviation calculations in extreme functional style:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用组合和部分应用来以极端函数式风格重新执行我们的均值和标准差计算：
- en: '[PRE79]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice that this code to compute mean and standard deviation is entirely function
    invocations; there are no operators involved, and the number of parentheses has
    grown so large that this JavaScript is beginning to look like Lisp code. Again,
    this is not a style that I advocate for JavaScript programming, but it is an interesting
    exercise to see how deeply functional JavaScript code can be.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段用于计算均值和标准差的代码完全是函数调用；没有涉及运算符，并且括号的数量已经变得如此之多，以至于这段JavaScript代码开始看起来像Lisp代码。再次强调，这不是我推崇的JavaScript编程风格，但看到JavaScript代码可以有多函数式是一个有趣的练习。
- en: 8.8.4 Memoization
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8.4 Memoization
- en: 'In [§8.4.1](#yourownfunctionprops), we defined a factorial function that cached
    its previously computed results. In functional programming, this kind of caching
    is called *memoization*. The code that follows shows a higher-order function,
    `memoize()`, that accepts a function as its argument and returns a memoized version
    of the function:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在[§8.4.1](#yourownfunctionprops)中，我们定义了一个阶乘函数，它缓存了先前计算的结果。在函数式编程中，这种缓存称为*memoization*。接下来的代码展示了一个高阶函数，`memoize()`，它接受一个函数作为参数，并返回该函数的一个记忆化版本：
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `memoize()` function creates a new object to use as the cache and assigns
    this object to a local variable so that it is private to (in the closure of) the
    returned function. The returned function converts its arguments array to a string
    and uses that string as a property name for the cache object. If a value exists
    in the cache, it returns it directly. Otherwise, it calls the specified function
    to compute the value for these arguments, caches that value, and returns it. Here
    is how we might use `memoize()`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoize()`函数创建一个新对象用作缓存，并将此对象分配给一个局部变量，以便它对（在返回的函数的闭包中）是私有的。返回的函数将其参数数组转换为字符串，并将该字符串用作缓存对象的属性名。如果缓存中存在值，则直接返回它。否则，调用指定的函数来计算这些参数的值，缓存该值，并返回它。以下是我们如何使用`memoize()`：'
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 8.9 Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.9 总结
- en: 'Some key points to remember about this chapter are as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章的一些关键要点如下：
- en: You can define functions with the `function` keyword and with the ES6 `=>` arrow
    syntax.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`function`关键字和ES6的`=>`箭头语法定义函数。
- en: You can invoke functions, which can be used as methods and constructors.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以调用函数，这些函数可以用作方法和构造函数。
- en: Some ES6 features allow you to define default values for optional function parameters,
    to gather multiple arguments into an array using a rest parameter, and to destructure
    object and array arguments into function parameters.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些ES6功能允许您为可选函数参数定义默认值，使用rest参数将多个参数收集到一个数组中，并将对象和数组参数解构为函数参数。
- en: You can use the `...` spread operator to pass the elements of an array or other
    iterable object as arguments in a function invocation.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`...`扩展运算符将数组或其他可迭代对象的元素作为参数传递给函数调用。
- en: A function defined inside of and returned by an enclosing function retains access
    to its lexical scope and can therefore read and write the variables defined inside
    the outer function. Functions used in this way are called *closures*, and this
    is a technique that is worth understanding.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在封闭函数内部定义并返回的函数保留对其词法作用域的访问权限，因此可以读取和写入外部函数中定义的变量。以这种方式使用的函数称为*closures*，这是一种值得理解的技术。
- en: Functions are objects that can be manipulated by JavaScript, and this enables
    a functional style of programming.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数是JavaScript可以操作的对象，这使得函数式编程成为可能。
- en: ^([1](ch08.xhtml#idm46198542019096-marker)) The term was coined by Martin Fowler.
    See [*http://martinfowler.com/dslCatalog/methodChaining.html*](http://martinfowler.com/dslCatalog/methodChaining.html).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#idm46198542019096-marker)) 这个术语是由Martin Fowler创造的。参见[*http://martinfowler.com/dslCatalog/methodChaining.html*](http://martinfowler.com/dslCatalog/methodChaining.html)。
- en: ^([2](ch08.xhtml#idm46198541553560-marker)) If you are familiar with Python,
    note that this is different than Python, in which every invocation shares the
    same default value.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.xhtml#idm46198541553560-marker)) 如果你熟悉Python，注意这与Python不同，其中每次调用都共享相同的默认值。
- en: ^([3](ch08.xhtml#idm46198540105128-marker)) This may not seem like a particularly
    interesting point unless you are familiar with more static languages, in which
    functions are part of a program but cannot be manipulated by the program.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.xhtml#idm46198540105128-marker)) 这可能看起来不是特别有趣，除非您熟悉更静态的语言，在这些语言中，函数是程序的一部分，但不能被程序操纵。
