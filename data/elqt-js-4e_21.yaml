- en: '19'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '19'
- en: 'PROJECT: A PIXEL ART EDITOR'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目：一个像素艺术编辑器
- en: The material from the previous chapters gives you all the elements you need
    to build a basic web application. In this chapter, we will do just that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 之前章节的材料为你构建一个基本的web应用程序提供了所有必要的元素。在这一章，我们将正是这样做。
- en: 'Our application will be a pixel-drawing program that allows you to modify a
    picture pixel by pixel by manipulating a zoomed-in view of it, shown as a grid
    of colored squares. You can use the program to open image files, scribble on them
    with your mouse or other pointer device, and save them. This is what it will look
    like:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将是一个像素绘制程序，允许你通过操控放大的图像视图逐个像素地修改图像，图像视图显示为一个有色方块的网格。你可以使用该程序打开图像文件，用鼠标或其他指针设备在其上涂鸦，并保存它们。这就是它的外观：
- en: '![Image](../images/f0319-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0319-01.jpg)'
- en: Painting on a computer is great. You don’t need to worry about materials, skill,
    or talent. You just start smearing and see where you end up.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上绘画是很棒的。你不需要担心材料、技巧或天赋。你只需开始涂抹，看看最终会得到什么。
- en: Components
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件
- en: The interface for the application shows a big <canvas> element on top, with
    a number of form fields below it. The user draws on the picture by selecting a
    tool from a <select> field and then clicking, touching, or dragging across the
    canvas. There are tools for drawing single pixels or rectangles, for filling an
    area, and for picking a color from the picture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的界面上方显示一个大的 `<canvas>` 元素，下面有多个表单字段。用户通过从 `<select>` 字段中选择一个工具，然后在画布上点击、触摸或拖动来绘制图像。有用于绘制单个像素或矩形的工具、填充区域的工具以及从图像中选取颜色的工具。
- en: We will structure the editor interface as a number of *components*, objects
    that are responsible for a piece of the DOM and that may contain other components
    inside them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把编辑器界面结构化为多个 *组件*，这些对象负责DOM的一部分，并且可以包含其他组件。
- en: The state of the application consists of the current picture, the selected tool,
    and the selected color. We’ll set things up so that the state lives in a single
    value and the interface components always base the way they look on the current
    state.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的状态由当前图像、选定工具和选定颜色组成。我们将设置这样一个环境，使得状态存在于一个单一的值中，而界面组件始终根据当前状态来决定它们的外观。
- en: To see why this is important, let’s consider the alternative—distributing pieces
    of state throughout the interface. Up to a certain point, this is easier to program.
    We can just put in a color field and read its value when we need to know the current
    color.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这点的重要性，让我们考虑另一种选择——在整个界面中分散状态的片段。在某种程度上，这更容易编程。我们可以直接放入一个颜色字段，并在需要知道当前颜色时读取其值。
- en: But then we add the color picker—a tool that lets you click the picture to select
    the color of a given pixel. To keep the color field showing the correct color,
    that tool would have to know that the color field exists and update it whenever
    it picks a new color. If you ever add another place that makes the color visible
    (maybe the mouse cursor could show it), you have to update your color-changing
    code to keep that synchronized as well.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但随后我们添加了颜色选择器——一个工具，允许你点击图像以选择给定像素的颜色。为了保持颜色字段显示正确的颜色，该工具必须知道颜色字段的存在，并在每次选择新颜色时更新它。如果你再添加另一个地方使颜色可见（也许鼠标光标可以显示它），你也必须更新你的颜色更改代码，以保持同步。
- en: In effect, this creates a problem where each part of the interface needs to
    know about all other parts, which is not very modular. For small applications
    like the one in this chapter, that may not be a problem. For bigger projects,
    it can turn into a real nightmare.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这会造成一个问题，即界面中的每个部分都需要了解所有其他部分，这并不是很模块化。对于像本章中的小型应用程序，这可能不是问题。对于更大的项目，这可能会变成一个真正的噩梦。
- en: To avoid this nightmare on principle, we’re going to be strict about *data flow*.
    There is a state, and the interface is drawn based on that state. An interface
    component may respond to user actions by updating the state, at which point the
    components get a chance to synchronize themselves with this new state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了原则上避免这个噩梦，我们将严格遵循 *数据流*。有一个状态，界面是基于该状态绘制的。界面组件可以通过更新状态来响应用户的操作，此时这些组件有机会与这个新状态同步。
- en: In practice, each component is set up so that when it is given a new state,
    it also notifies its child components, insofar as those need to be updated. Setting
    this up is a bit of a hassle. Making this more convenient is the main selling
    point of many browser programming libraries. But for a small application like
    this, we can do it without such infrastructure.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，每个组件被设置为在接收到新状态时，也会通知其子组件，前提是那些需要被更新。设置这个有点麻烦。使其更方便是许多浏览器编程库的主要卖点。但对于像这样的一个小应用，我们可以在没有这种基础设施的情况下完成。
- en: Updates to the state are represented as objects, which we’ll call *actions*.
    Components may create such actions and *dispatch* them—give them to a central
    state management function. That function computes the next state, after which
    the interface components update themselves to this new state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对状态的更新以对象形式表示，我们称之为*动作*。组件可以创建这样的动作并*分发*它们——将其交给中心状态管理函数。该函数计算下一个状态，然后界面组件更新为这个新状态。
- en: 'We’re taking the messy task of running a user interface and applying structure
    to it. Though the DOM-related pieces are still full of side effects, they are
    held up by a conceptually simple backbone: the state update cycle. The state determines
    what the DOM looks like, and the only way DOM events can change the state is by
    dispatching actions to the state.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将运行用户界面的杂乱任务进行结构化。尽管与DOM相关的部分仍然充满了副作用，但它们由一个概念上简单的主干支撑：状态更新周期。状态决定了DOM的外观，DOM事件改变状态的唯一方式是通过向状态分发动作。
- en: 'There are *many* variants of this approach, each with its own benefits and
    problems, but their central idea is the same: state changes should go through
    a single well-defined channel, not happen all over the place.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有*许多*变体，每种都有其自身的优点和问题，但它们的核心思想是相同的：状态变化应通过单一的、明确的通道进行，而不是随处发生。
- en: Our components will be classes conforming to an interface. Their constructor
    is given a state—which may be the whole application state or some smaller value
    if it doesn’t need access to everything—and uses that to build up a dom property.
    This is the DOM element that represents the component. Most constructors will
    also take some other values that won’t change over time, such as the function
    they can use to dispatch an action.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件将是符合接口的类。它们的构造函数接受一个状态——这可能是整个应用状态或较小的值（如果不需要访问所有内容）——并利用它构建一个dom属性。这是表示组件的DOM元素。大多数构造函数还将接受一些不会随时间变化的其他值，例如它们可以用于分发动作的函数。
- en: Each component has a syncState method that is used to synchronize it to a new
    state value. The method takes one argument, the state, which is of the same type
    as the first argument to its constructor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都有一个syncState方法，用于将其同步到新的状态值。该方法接受一个参数，即状态，其类型与构造函数的第一个参数相同。
- en: The State
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: The application state will be an object with picture, tool, and color properties.
    The picture is itself an object that stores the width, height, and pixel content
    of the picture. The pixels are stored in a single array, row by row, from top
    to bottom.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 应用状态将是一个具有picture、tool和color属性的对象。picture本身是一个对象，存储图片的宽度、高度和像素内容。像素按行存储在一个单一数组中，从上到下。
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We want to be able to treat a picture as an immutable value, for reasons we’ll
    get back to later in the chapter. But we also sometimes need to update a whole
    bunch of pixels at a time. To be able to do that, the class has a draw method
    that expects an array of updated pixels—objects with x, y, and color properties—and
    creates a new picture with those pixels overwritten. This method uses slice without
    arguments to copy the entire pixel array—the start of the slice defaults to 0,
    and the end defaults to the array’s length.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够将图片视为一个不可变的值，原因将在本章后面再提到。但我们有时也需要一次更新一大堆像素。为此，该类具有一个draw方法，期望接收一个更新的像素数组——包含x、y和颜色属性的对象——并使用这些像素覆盖创建一张新图片。此方法使用没有参数的slice来复制整个像素数组——切片的开始默认为0，结束默认为数组的长度。
- en: The empty method uses two pieces of array functionality that we haven’t seen
    before. The Array constructor can be called with a number to create an empty array
    of the given length. The fill method can then be used to fill this array with
    a given value. These are used to create an array in which all pixels have the
    same color.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 空方法使用了我们之前未见过的两种数组功能。数组构造函数可以用一个数字调用，以创建一个给定长度的空数组。然后可以使用填充方法将该数组填充为给定的值。这些用于创建一个所有像素都具有相同颜色的数组。
- en: Colors are stored as strings containing traditional CSS color codes made up
    of a hash sign (#) followed by six hexadecimal (base-16) digits—two for the red
    component, two for the green component, and two for the blue component. This is
    a somewhat cryptic and inconvenient way to write colors, but it is the format
    the HTML color input field uses, and it can be used in the fillStyle property
    of a canvas drawing context, so for the ways we’ll use colors in this program,
    it is practical enough.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色以字符串形式存储，包含传统的 CSS 颜色代码，由井号 (#) 后跟六个十六进制（基数 16）数字组成——两个用于红色成分，两个用于绿色成分，两个用于蓝色成分。这是一种相对隐晦且不方便的书写颜色方式，但这是
    HTML 颜色输入字段使用的格式，并且可以在画布绘制上下文的 fillStyle 属性中使用，因此在我们将在此程序中使用颜色的方式上，这足够实用。
- en: Black, where all components are zero, is written “#000000”, and bright pink
    looks like “#ff00ff”, where the red and blue components have the maximum value
    of 255, written ff in hexadecimal digits (which use *a* to *f* to represent digits
    10 to 15).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色，所有组件均为零，写作“#000000”，而亮粉色看起来像“#ff00ff”，其中红色和蓝色成分的最大值为 255，以十六进制数字（使用 *a* 到
    *f* 表示数字 10 到 15）表示为 ff。
- en: 'We’ll allow the interface to dispatch actions as objects whose properties overwrite
    the properties of the previous state. The color field, when the user changes it,
    could dispatch an object like {color: *field*.*value*}, from which this update
    function can compute a new state.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将允许接口以对象的形式分发动作，这些对象的属性会覆盖之前状态的属性。当用户更改颜色字段时，可以分发一个对象，如 {color: *field*.*value*}，从中这个更新函数可以计算出一个新的状态。'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This pattern, in which object spread is used to first add the properties an
    existing object and then override some of those, is common in JavaScript code
    that uses immutable objects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式中，使用对象扩展先添加现有对象的属性，然后覆盖其中一些属性，在使用不可变对象的 JavaScript 代码中很常见。
- en: DOM Building
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM 构建
- en: 'One of the main things that interface components do is create DOM structure.
    We again don’t want to directly use the verbose DOM methods for that, so here’s
    a slightly expanded version of the elt function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 界面组件的主要功能之一是创建 DOM 结构。我们同样不想直接使用冗长的 DOM 方法，因此这里是稍微扩展版的 elt 函数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The main difference between this version and the one we used in [Chapter 16](ch16.xhtml#ch16)
    is that it assigns *properties* to DOM nodes, not *attributes*. This means we
    can’t use it to set arbitrary attributes, but we *can* use it to set properties
    whose value isn’t a string, such as onclick, which can be set to a function to
    register a click event handler.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本与我们在[第 16 章](ch16.xhtml#ch16)中使用的版本之间的主要区别在于，它将 *属性* 分配给 DOM 节点，而不是 *属性值*。这意味着我们不能用它来设置任意属性，但我们
    *可以* 用它来设置值不是字符串的属性，例如 onclick，可以设置为一个函数以注册点击事件处理程序。
- en: 'This allows this convenient style for registering event handlers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们以这种方便的方式注册事件处理程序：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Canvas
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布
- en: 'The first component we’ll define is the part of the interface that displays
    the picture as a grid of colored boxes. This component is responsible for two
    things: showing a picture and communicating pointer events on that picture to
    the rest of the application.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义的第一个组件是界面的一部分，它将图片显示为一个彩色方块的网格。这个组件负责两件事：显示一张图片并将该图片上的指针事件传递给应用程序的其余部分。
- en: Therefore, we can define it as a component that only knows about the current
    picture, not the whole application state. Because it doesn’t know how the application
    as a whole works, it cannot directly dispatch actions. Rather, when responding
    to pointer events, it calls a callback function provided by the code that created
    it, which will handle the application-specific parts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将其定义为一个只知道当前图片的组件，而不是整个应用程序状态。因为它不知道整个应用程序的工作方式，所以不能直接分发动作。相反，在响应指针事件时，它调用由创建它的代码提供的回调函数，该函数将处理特定于应用程序的部分。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We draw each pixel as a 10-by-10 square, as determined by the scale constant.
    To avoid unnecessary work, the component keeps track of its current picture and
    does a redraw only when syncState is given a new picture.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个像素绘制为 10x10 的方块，具体由比例常量决定。为了避免不必要的工作，组件跟踪其当前图片，仅在 syncState 获得新图片时进行重绘。
- en: The actual drawing function sets the size of the canvas based on the scale and
    picture size and fills it with a series of squares, one for each pixel.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的绘制函数根据比例和图片大小设置画布的大小，并用一系列方块填充，每个方块对应一个像素。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the left mouse button is pressed while the mouse is over the picture canvas,
    the component calls the pointerDown callback, giving it the position of the pixel
    that was clicked—in picture coordinates. This will be used to implement mouse
    interaction with the picture. The callback may return another callback function
    to be notified when the pointer is moved to a different pixel while the button
    is held down.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标左键在图片画布上被按下时，组件调用pointerDown回调，传递被点击的像素位置——以图片坐标表示。这将用于实现鼠标与图片的交互。回调可以返回另一个回调函数，以在按钮按下时，指针移动到不同的像素时收到通知。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since we know the size of the pixels and we can use getBoundingClientRect to
    find the position of the canvas on the screen, it is possible to go from mouse
    event coordinates (clientX and clientY) to picture coordinates. These are always
    rounded down so that they refer to a specific pixel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道像素的大小，并且可以使用getBoundingClientRect找到画布在屏幕上的位置，因此可以将鼠标事件坐标（clientX和clientY）转换为图片坐标。这些坐标总是向下取整，以便指向特定的像素。
- en: With touch events, we have to do something similar, but using different events
    and making sure we call preventDefault on the “touchstart” event to prevent panning.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于触摸事件，我们需要做类似的事情，但使用不同的事件，并确保在“touchstart”事件上调用preventDefault以防止平移。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For touch events, clientX and clientY aren’t available directly on the event
    object, but we can use the coordinates of the first touch object in the touches
    property.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于触摸事件，clientX和clientY在事件对象上并不可用，但我们可以使用touches属性中第一个触摸对象的坐标。
- en: The Application
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序
- en: To make it possible to build the application piece by piece, we’ll implement
    the main component as a shell around a picture canvas and a dynamic set of tools
    and controls that we pass to its constructor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够逐步构建应用程序，我们将主组件实现为围绕图片画布和动态工具与控件集合的外壳，并将其传递给构造函数。
- en: The *controls* are the interface elements that appear below the picture. They’ll
    be provided as an array of component constructors.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*控件*是出现在图片下方的界面元素。它们将作为组件构造函数的数组提供。'
- en: The *tools* do things like drawing pixels or filling in an area. The application
    shows the set of available tools as a <select> field. The currently selected tool
    determines what happens when the user interacts with the picture with a pointer
    device. The set of available tools is provided as an object that maps the names
    that appear in the drop-down field to functions that implement the tools. Such
    functions get a picture position, a current application state, and a dispatch
    function as arguments. They may return a move handler function that gets called
    with a new position and a current state when the pointer moves to a different
    pixel.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*工具*用于绘制像素或填充区域。应用程序将可用工具的集合显示为一个<select>字段。当前选择的工具决定用户使用指针设备与图片互动时会发生什么。可用工具的集合作为一个对象提供，该对象将下拉字段中显示的名称映射到实现这些工具的函数。这些函数接收图片位置、当前应用程序状态和分发函数作为参数。它们可能返回一个移动处理函数，当指针移动到不同的像素时，以新的位置和当前状态作为参数被调用。'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pointer handler given to PictureCanvas calls the currently selected tool
    with the appropriate arguments and, if that returns a move handler, adapts it
    to also receive the state.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给PictureCanvas的指针处理程序使用适当的参数调用当前选定的工具，并且如果返回一个移动处理程序，则还会调整它以接收状态。
- en: All controls are constructed and stored in this.controls so that they can be
    updated when the application state changes. The call to reduce introduces spaces
    between the controls’ DOM elements. That way, they don’t look so pressed together.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控件都在this.controls中构建并存储，以便在应用程序状态变化时进行更新。对reduce的调用在控件的DOM元素之间引入空格。这样，它们看起来不会那么紧凑。
- en: The first control is the tool selection menu. It creates a <select> element
    with an option for each tool and sets up a “change” event handler that updates
    the application state when the user selects a different tool.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个控件是工具选择菜单。它创建一个<select>元素，为每个工具设置一个选项，并设置一个“change”事件处理程序，当用户选择不同工具时更新应用程序状态。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By wrapping the label text and the field in a <label> element, we tell the browser
    that the label belongs to that field so that you can, for example, click the label
    to focus the field.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将标签文本和字段包装在<label>元素中，我们告诉浏览器该标签属于该字段，这样你可以点击标签来聚焦该字段。
- en: We also need to be able to change the color, so let’s add a control for that.
    An HTML <input> element with a type attribute of color gives us a form field that
    is specialized for selecting colors. Such a field’s value is always a CSS color
    code in “#*RRGGBB*” format (red, green, and blue components, two digits per color).
    The browser will show a color picker interface when the user interacts with it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够更改颜色，因此让我们添加一个控制项。具有颜色类型属性的HTML <input> 元素为我们提供了一个专门用于选择颜色的表单字段。这样的字段值始终是“#*RRGGBB*”格式的CSS颜色代码（红、绿和蓝组件，每种颜色两个数字）。当用户与之互动时，浏览器将显示颜色选择器界面。
- en: 'Depending on the browser, the color picker might look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据浏览器的不同，颜色选择器可能看起来像这样：
- en: '![Image](../images/f0327-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0327-01.jpg)'
- en: This control creates such a field and wires it up to stay synchronized with
    the application state’s color property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此控件创建一个这样的区域，并将其与应用程序状态的颜色属性保持同步。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Drawing Tools
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘图工具
- en: Before we can draw anything, we need to implement the tools that will control
    the functionality of mouse or touch events on the canvas.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够绘制任何内容之前，我们需要实现控制画布上鼠标或触摸事件功能的工具。
- en: The most basic tool is the draw tool, which changes any pixel you click or tap
    to the currently selected color. It dispatches an action that updates the picture
    to a version in which the pointed-at pixel is given the currently selected color.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的工具是绘图工具，它将你点击或轻触的任何像素更改为当前选定的颜色。它派发一个操作，将图片更新为一个版本，其中所指向的像素被赋予当前选定的颜色。
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function immediately calls the drawPixel function but then also returns
    it so that it’s called again for newly touched pixels when the user drags or swipes
    over the picture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 函数立即调用drawPixel函数，但也返回它，以便在用户拖动或滑动图片时，对新触摸的像素再次调用。
- en: To draw larger shapes, it can be useful to quickly create rectangles. The rectangle
    tool draws a rectangle between the point where you start dragging and the point
    that you drag to.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绘制更大的形状，快速创建矩形是很有用的。矩形工具在你开始拖动的点和你拖动到的点之间绘制一个矩形。
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: An important detail in this implementation is that when dragging, the rectangle
    is redrawn on the picture from the *original* state. That way, you can make the
    rectangle larger and smaller again while creating it, without the intermediate
    rectangles sticking around in the final picture. This is one of the reasons why
    immutable picture objects are useful—we’ll see another reason later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现中的一个重要细节是，在拖动时，矩形是在*原始*状态下在图片上重新绘制的。这样，你可以在创建矩形时将其变大或变小，而不会在最终图片中留下中间的矩形。这是不可变图片对象有用的原因之一——稍后我们将看到另一个原因。
- en: 'Implementing flood fill is somewhat more involved. This is a tool that fills
    the pixel under the pointer and all adjacent pixels that have the same color.
    “Adjacent” means directly horizontally or vertically adjacent, not diagonally.
    This picture illustrates the set of pixels colored when the flood fill tool is
    used at the marked pixel:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实现填充功能稍微复杂一些。这是一个工具，可以填充指针下的像素以及所有具有相同颜色的相邻像素。“相邻”意味着直接水平或垂直相邻，而不是对角线相邻。这张图片展示了在标记像素处使用填充工具时上色的像素集合：
- en: '![Image](../images/f0329-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0329-01.jpg)'
- en: Interestingly, the way we’ll do this looks a bit like the pathfinding code from
    [Chapter 7](ch07.xhtml#ch07). Whereas that code searched through a graph to find
    a route, this code searches through a grid to find all “connected” pixels. The
    problem of keeping track of a branching set of possible routes is similar.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们将要做的方式有点像[第七章](ch07.xhtml#ch07)中的路径查找代码。尽管那段代码在图形中搜索以找到路线，这段代码则在网格中搜索以找到所有“连接”的像素。跟踪一组分支可能路线的问题是类似的。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The array of drawn pixels doubles as the function’s work list. For each pixel
    reached, we have to see whether any adjacent pixels have the same color and haven’t
    already been painted over. The loop counter lags behind the length of the drawn
    array as new pixels are added. Any pixels ahead of it still need to be explored.
    When it catches up with the length, no unexplored pixels remain, and the function
    is done.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制的像素数组同时充当函数的工作列表。对于每个到达的像素，我们必须查看是否有任何相邻像素具有相同的颜色并且尚未被覆盖。随着新像素的添加，循环计数器落后于绘制数组的长度。它前面的任何像素仍需要被探索。当它追上长度时，就没有未探索的像素了，函数也就完成了。
- en: The final tool is a color picker, which allows you to point at a color in the
    picture to use it as the current drawing color.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的工具是一个颜色选择器，它允许你在图片上指向一个颜色，以将其用作当前绘图颜色。
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Saving and Loading
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存与加载
- en: 'When we’ve drawn our masterpiece, we’ll want to save it for later. We should
    add a button for downloading the current picture as an image file. This control
    provides that button:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成了我们的杰作时，我们会想把它保存下来。我们应该添加一个按钮，用于将当前图片作为图像文件下载。这个控件提供了这个按钮：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The component keeps track of the current picture so that it can access it when
    saving. To create the image file, it uses a <canvas> element on which it draws
    the picture (at a scale of one pixel per pixel).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件跟踪当前图片，以便在保存时可以访问它。为了创建图像文件，它使用一个<canvas>元素，在其上绘制图片（每个像素按一比一的比例）。
- en: 'The toDataURL method on a canvas element creates a URL that uses the data:
    schema. Unlike http: and https: URLs, data URLs contain the whole resource in
    the URL. They are usually very long, but they allow us to create working links
    to arbitrary pictures, right here in the browser.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'canvas元素上的toDataURL方法创建一个使用data:方案的URL。与http:和https: URL不同，数据URL在URL中包含整个资源。它们通常非常长，但它们允许我们在浏览器中创建指向任意图片的有效链接。'
- en: To actually get the browser to download the picture, we then create a link element
    that points at this URL and has a download attribute. Such links, when clicked,
    make the browser show a file save dialog. We add that link to the document, simulate
    a click on it, and remove it again. You can do a lot with browser technology,
    but sometimes the way to do it is rather odd.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让浏览器实际下载图片，我们接着创建一个链接元素，指向这个URL，并带有download属性。这样的链接在被点击时，会使浏览器显示文件保存对话框。我们将该链接添加到文档中，模拟一次点击，然后再将其移除。你可以用浏览器技术做很多事情，但有时候实现方式相当奇怪。
- en: And it gets worse. We’ll also want to be able to load existing image files into
    our application. To do that, we again define a button component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而且情况还会更糟。我们还希望能够将现有的图像文件加载到我们的应用程序中。为此，我们再次定义一个按钮组件。
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To get access to a file on the user’s computer, we need the user to select the
    file through a file input field. But we don’t want the load button to look like
    a file input field, so we create the file input when the button is clicked and
    then pretend that this file input itself was clicked.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问用户计算机上的文件，我们需要用户通过文件输入字段选择文件。但我们不希望加载按钮看起来像文件输入字段，因此我们在按钮点击时创建文件输入，然后假装这个文件输入被点击了。
- en: When the user has selected a file, we can use FileReader to get access to its
    contents, again as a data URL. That URL can be used to create an <img> element,
    but because we can’t get direct access to the pixels in such an image, we can’t
    create a Picture object from that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择一个文件时，我们可以使用FileReader来访问其内容，再次以数据URL的形式。该URL可以用来创建一个<img>元素，但由于我们无法直接访问该图像中的像素，因此无法从中创建Picture对象。
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To get access to the pixels, we must first draw the picture to a <canvas> element.
    The canvas context has a getImageData method that allows a script to read its
    pixels. So once the picture is on the canvas, we can access it and construct a
    Picture object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问像素，我们必须首先将图片绘制到<canvas>元素上。canvas上下文具有getImageData方法，允许脚本读取其像素。因此，一旦图片在canvas上，我们就可以访问它并构建一个Picture对象。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ll limit the size of images to 100*×*100 pixels, since anything bigger will
    look *huge* on our display and might slow down the interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把图像的大小限制在100*×*100像素，因为任何更大的图片在我们的显示器上看起来都会显得*巨大*，并可能会减慢界面速度。
- en: The data property of the object returned by getImageData is an array of color
    components. For each pixel in the rectangle specified by the arguments, it contains
    four values that represent the red, green, blue, and *alpha* components of the
    pixel’s color, as numbers between 0 and 255\. The alpha part represents opacity—when
    it is 0, the pixel is fully transparent, and when it is 255, it is fully opaque.
    For our purpose, we can ignore it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: getImageData返回的对象的数据属性是一个颜色分量数组。对于由参数指定的矩形中的每个像素，它包含四个值，代表像素颜色的红、绿、蓝和*alpha*分量，数值范围在0到255之间。alpha部分表示不透明度——当它为0时，像素完全透明，而当它为255时，像素完全不透明。对于我们的目的，我们可以忽略它。
- en: The two hexadecimal digits per component, as used in our color notation, correspond
    precisely to the 0 to 255 range—two base-16 digits can express 16² = 256 different
    numbers. The toString method of numbers can be given a base as an argument, so
    n.toString(16) will produce a string representation in base 16\. We have to make
    sure that each number takes up two digits, so the hex helper function calls padStart
    to add a leading 0 when necessary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件的两个十六进制数字，如我们在颜色标记法中使用的，正好对应于0到255的范围——两个基数为16的数字可以表示16² = 256个不同的数字。数字的toString方法可以接受一个基数作为参数，因此n.toString(16)会生成一个基数为16的字符串表示。我们必须确保每个数字占用两个数字，因此十六进制辅助函数调用padStart在必要时添加前导0。
- en: We can load and save now! That leaves just one more feature before we’re done.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以加载和保存了！这只剩下一个功能，我们就完成了。
- en: Undo History
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 撤销历史
- en: Because half the process of editing is making little mistakes and correcting
    them, an important feature in a drawing program is an undo history.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为编辑过程的一半是犯小错误并纠正它们，绘图程序中的一个重要功能是撤销历史。
- en: To be able to undo changes, we need to store previous versions of the picture.
    Since pictures are immutable values, that’s easy. But it does require an additional
    field in the application state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够撤销更改，我们需要存储图像的先前版本。由于图像是不可变值，这很简单。但这确实需要在应用程序状态中添加一个额外的字段。
- en: We’ll add a done array to keep previous versions of the picture. Maintaining
    this property requires a more complicated state update function that adds pictures
    to the array.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个done数组来保留图像的先前版本。维护这个属性需要一个更复杂的状态更新函数，以将图像添加到数组中。
- en: We don’t want to store *every* change, though—just changes that are a certain
    amount of time apart. To be able to do that, we’ll need a second property, doneAt,
    to track the time at which we last stored a picture in the history.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们并不想存储*每个*更改——只存储时间间隔一定的更改。为了做到这一点，我们需要一个第二个属性doneAt，用来跟踪我们上次在历史中存储图像的时间。
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the action is an undo action, the function takes the most recent picture
    from the history and makes that the current picture. It sets doneAt to zero so
    that the next change is guaranteed to store the picture back in the history, allowing
    you to revert to it another time if you want.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作是撤销操作时，函数从历史记录中获取最近的图像，并将其设为当前图像。它将doneAt设置为零，以确保下一个更改将图像存回历史中，让你在需要时可以恢复到这个图像。
- en: Otherwise, if the action contains a new picture and the last time we stored
    something is more than a second (1,000 milliseconds) ago, the done and doneAt
    properties are updated to store the previous picture.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果操作包含新图像，而我们上次存储的时间超过了一秒（1,000毫秒），则done和doneAt属性会更新以存储之前的图像。
- en: The undo button component doesn’t do much. It dispatches undo actions when clicked
    and disables itself when there is nothing to undo.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销按钮组件并没有太多功能。它在被点击时分发撤销操作，当没有可以撤销的内容时则禁用自身。
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s Draw
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让我们绘图
- en: To set up the application, we need to create a state, a set of tools, a set
    of controls, and a dispatch function. We can pass them to the PixelEditor constructor
    to create the main component. Since we’ll need to create several editors in the
    exercises, we first define some bindings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置应用程序，我们需要创建一个状态、一组工具、一组控件和一个调度函数。我们可以将它们传递给PixelEditor构造函数来创建主要组件。由于我们在练习中需要创建多个编辑器，我们首先定义一些绑定。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When destructuring an object or array, you can use = after a binding name to
    give the binding a default value, which is used when the property is missing or
    holds undefined. The startPixelEditor function makes use of this to accept an
    object with a number of optional properties as an argument. If you don’t provide
    a tools property, for example, tools will be bound to baseTools.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在解构对象或数组时，可以在绑定名称后使用=来为绑定提供默认值，当属性缺失或为undefined时使用。startPixelEditor函数利用这一点接受一个具有多个可选属性的对象作为参数。例如，如果你不提供tools属性，tools将绑定到baseTools。
- en: 'This is how we get an actual editor on the screen:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何在屏幕上获得实际编辑器的方式：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why Is This So Hard?
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么这会如此困难？
- en: Browser technology is amazing. It provides a powerful set of interface building
    blocks, ways to style and manipulate them, and tools to inspect and debug your
    applications. The software you write for the browser can be run on almost every
    computer and phone on the planet.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器技术真是令人惊叹。它提供了一套强大的接口构建块、样式和操作它们的方法，以及检查和调试应用程序的工具。你为浏览器编写的软件可以在地球上几乎每台计算机和手机上运行。
- en: At the same time, browser technology is ridiculous. You have to learn a large
    number of silly tricks and obscure facts to master it, and the default programming
    model it provides is so problematic that most programmers prefer to cover it in
    several layers of abstraction rather than deal with it directly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，浏览器技术非常荒谬。你必须学习大量愚蠢的技巧和晦涩的事实才能掌握它，而它提供的默认编程模型问题重重，以至于大多数程序员宁愿用几层抽象来掩盖它，而不是直接处理它。
- en: While the situation is definitely improving, it mostly does so in the form of
    more elements being added to address shortcomings—creating even more complexity.
    A feature used by a million websites can’t really be replaced. Even if it could,
    it would be hard to decide what it should be replaced with.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管情况确实在改善，但主要以添加更多元素来解决不足的形式进行——这创造了更多的复杂性。被一百万个网站使用的功能是无法真正替代的。即使可以替代，也很难决定用什么来替代。
- en: Technology never exists in a vacuum—we’re constrained by our tools and the social,
    economic, and historical factors that produced them. This can be annoying, but
    it is generally more productive to try to build a good understanding of how the
    *existing* technical reality works—and why it is the way it is—than to rage against
    it or hold out for another reality.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 技术从来不会在真空中存在——我们受限于我们的工具以及产生这些工具的社会、经济和历史因素。这可能让人感到恼火，但一般来说，努力建立对*现有*技术现实如何运作及其原因的良好理解，比愤怒抗争或期待另一种现实要更具生产力。
- en: New abstractions *can* be helpful. The component model and data flow convention
    I used in this chapter is a crude form of that. As mentioned, there are libraries
    that try to make user interface programming more pleasant. At the time of writing,
    React and Svelte are popular choices, but there’s a whole cottage industry of
    such frameworks. If you’re interested in programming web applications, I recommend
    investigating a few of them to understand how they work and what benefits they
    provide.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 新的抽象*可以*是有帮助的。我在本章中使用的组件模型和数据流约定是一种粗略的形式。如前所述，有一些库试图使用户界面编程变得更愉快。在写作时，React
    和 Svelte 是流行的选择，但还有一整套这样的框架。如果你对编写网页应用感兴趣，我建议你调查一下其中的一些，以了解它们是如何运作的，以及它们提供了什么好处。
- en: Exercises
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: There is still room for improvement in our program. Let’s add a few more features
    as exercises.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序仍然有改进的空间。让我们增加一些功能作为练习。
- en: '*Keyboard Bindings*'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*键盘绑定*'
- en: Add keyboard shortcuts to the application. The first letter of a tool’s name
    selects the tool, and CTRL-Z or COMMAND-Z activates undo.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为应用程序添加键盘快捷键。工具名称的首字母选择该工具，而 CTRL-Z 或 COMMAND-Z 则激活撤销。
- en: Do this by modifying the PixelEditor component. Add a tabIndex property of 0
    to the wrapping <div> element so that it can receive keyboard focus. Note that
    the *property* corresponding to the tabindex *attribute* is called tabIndex, with
    a capital I, and our elt function expects property names. Register the key event
    handlers directly on that element. This means you have to click, touch, or tab
    to the application before you can interact with it with the keyboard.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改 PixelEditor 组件来做到这一点。在包裹的 <div> 元素中添加一个 tabIndex 属性值为 0，以便它可以接收键盘焦点。注意，*属性*对应于
    tabindex *属性* 被称为 tabIndex，I 大写，而我们的 elt 函数期望属性名称。直接在该元素上注册键盘事件处理程序。这意味着你必须点击、触摸或通过标签切换到应用程序，然后才能用键盘与之交互。
- en: Remember that keyboard events have ctrlKey and metaKey (for COMMAND on Mac)
    properties that you can use to see whether those keys are held down.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，键盘事件有 ctrlKey 和 metaKey（在 Mac 上为 COMMAND）属性，你可以使用它们来查看这些键是否被按下。
- en: '*Efficient Drawing*'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*高效绘图*'
- en: During drawing, the majority of work that our application does happens in drawPicture.
    Creating a new state and updating the rest of the DOM isn’t very expensive, but
    repainting all the pixels on the canvas is quite a bit of work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘图过程中，我们的应用程序大部分工作都发生在 drawPicture 中。创建一个新状态并更新其余的 DOM 并不太昂贵，但重绘画布上的所有像素则需要相当多的工作。
- en: Find a way to make the syncState method of PictureCanvas faster by redrawing
    only the pixels that actually changed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一种方法，通过仅重绘实际改变的像素来加速 PictureCanvas 的 syncState 方法。
- en: Remember that drawPicture is also used by the save button, so if you change
    it, either make sure the changes don’t break the old use or create a new version
    with a different name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，drawPicture 也被保存按钮使用，因此如果你更改它，请确保更改不会破坏旧的使用方式，或者创建一个不同名称的新版本。
- en: Also note that changing the size of a <canvas> element, by setting its width
    or height properties, clears it, making it entirely transparent again.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，通过设置 <canvas> 元素的宽度或高度属性来更改其大小，会清除它，使其再次完全透明。
- en: '*Circles*'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*圆形*'
- en: Define a tool called circle that draws a filled circle when you drag. The center
    of the circle lies at the point where the drag or touch gesture starts, and its
    radius is determined by the distance dragged.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为圆形的工具，当你拖动时绘制一个填充的圆。圆心位于拖动或触摸手势开始的点，其半径由拖动的距离决定。
- en: '*Proper Lines*'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*适当的线条*'
- en: This is a more advanced exercise than the preceding three, and it will require
    you to design a solution to a nontrivial problem. Make sure you have plenty of
    time and patience before starting to work on this exercise, and don’t get discouraged
    by initial failures.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这比前面的三个练习要复杂，需要你设计一个解决非平凡问题的方案。在开始这个练习之前，确保你有足够的时间和耐心，并且不要因为最初的失败而气馁。
- en: On most browsers, when you select the draw tool and quickly drag across the
    picture, you don’t get a closed line. Rather, you get dots with gaps between them
    because the “mousemove” or “touchmove” events did not fire quickly enough to hit
    every pixel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数浏览器中，当你选择绘图工具并快速拖动图像时，你不会得到一条闭合的线条。而是会得到带有间隙的点，因为“mousemove”或“touchmove”事件没有足够快地触发以击中每个像素。
- en: Improve the draw tool to make it draw a full line. This means you have to make
    the motion handler function remember the previous position and connect that to
    the current one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 改进绘图工具，使其绘制完整的线条。这意味着你需要让动作处理函数记住上一个位置，并将其与当前的位置连接起来。
- en: To do this, since the pixels can be an arbitrary distance apart, you’ll have
    to write a general line drawing function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，由于像素之间的距离可以是任意的，你需要编写一个通用的绘线函数。
- en: A line between two pixels is a connected chain of pixels, as straight as possible,
    going from the start to the end. Diagonally adjacent pixels count as connected.
    A slanted line should look like the picture on the left, not the picture on the
    right.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两个像素之间的线条是一个连接的像素链，尽可能地直，从起点到终点。对角相邻的像素算作连接。倾斜的线条应该像左侧的图片，而不是右侧的图片。
- en: '![Image](../images/f0336-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0336-01.jpg)'
- en: Finally, if we have code that draws a line between two arbitrary points, we
    might as well use it to also define a line tool, which draws a straight line between
    the start and end of a drag.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们有一段代码可以在两个任意点之间绘制一条线，我们也可以用它来定义一个线条工具，该工具在拖动的起点和终点之间绘制一条直线。
