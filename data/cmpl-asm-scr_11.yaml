- en: Chapter 9 Introduction to Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章 第二部分简介
- en: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2](https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2](https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2)
- en: '[Compiling to Assembly from Scratch](./#table-of-contents)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[从头开始编译汇编](./#table-of-contents)'
- en: by [Vladimir Keleshev](/)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: by [弗拉基米尔·凯列舍夫](/)
- en: Before extending the compiler, let’s discuss the language we have implemented
    so far.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展编译器之前，让我们讨论一下我们迄今为止实现的语言。
- en: Is our language memory-safe? What is memory safety, anyway? Simply speaking,
    a language is memory-safe if it does not allow you to write a program that causes
    a segmentation fault. The baseline language is memory-safe if we limit ourselves
    to calling functions that we have defined ourselves. However, our calling convention
    allows us to call arbitrary `libc` functions. You can find creative ways to call
    these functions that will lead to a segmentation fault (try `free(42)`). So, unless
    we do something about that, the baseline language is not memory-safe.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编程语言是内存安全的吗？内存安全究竟是什么意思？简单来说，如果一种语言不允许你编写导致段错误的程序，那么这种语言就是内存安全的。如果我们只调用我们自己定义的函数，那么基本语言就是内存安全的。然而，我们的调用约定允许我们调用任意的`libc`函数。你可以找到一些创造性的方法来调用这些函数，这会导致段错误（尝试`free(42)`）。所以，除非我们对此采取措施，否则基本语言不是内存安全的。
- en: A way to fix that is to introduce a prefix for function labels. For example,
    a function `factorial` can be compiled with a label `ts$factorial:`, and a call
    to `factorial` can be compiled to a jump to `ts$factorial`. This way, you can
    only call functions that are defined in the source language, or that had explicit
    wrappers written in assembly. These wrappers can be auto-generated by the compiler
    and also handle type conversion, if necessary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是为函数标签引入一个前缀。例如，一个名为`factorial`的函数可以被编译为标签`ts$factorial:`，对`factorial`的调用可以被编译为跳转到`ts$factorial`。这样，你只能调用在源语言中定义的函数，或者那些在汇编中明确编写的包装器。这些包装器可以由编译器自动生成，并在必要时处理类型转换。
- en: Is our language dynamically-typed? Or is it statically-typed? Both and neither!
    The baseline language supports only integer numbers. So, it could be thought of
    as a dynamically-typed language with only one data type, or as a statically-typed
    language with one static type. But we are soon to change this.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的编程语言是动态类型还是静态类型？既是又是都不是！基本语言只支持整数类型。所以，它可以被认为是一种只有一种数据类型的动态类型语言，或者是一种只有一种静态类型的静态类型语言。但我们很快就要改变这一点。
- en: However, before we explore static and dynamic typing, we need to have more than
    one data type in our language. We will start by introducing booleans, undefined,
    and then arrays. First, we will introduce them in an unsafe/untyped manner, and
    then we will apply static/dynamic treatment to them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们探索静态和动态类型之前，我们的语言需要支持多种数据类型。我们将从介绍布尔值、未定义和数组开始。首先，我们将以不安全/无类型的方式介绍它们，然后我们将对它们应用静态/动态处理。
- en: '[Next: Chapter 10\. Primitive Scalar Data Types](./10-primitive-scalar-data-types)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[下一章：第10章 基本标量数据类型](./10-primitive-scalar-data-types)'
- en: '* * *'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
