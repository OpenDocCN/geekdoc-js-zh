- en: Chapter 17\. JavaScript Tools and Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章 JavaScript工具和扩展
- en: 'Congratulations on reaching the final chapter of this book. If you have read
    everything that comes before, you now have a detailed understanding of the JavaScript
    language and know how to use it in Node and in web browsers. This chapter is a
    kind of graduation present: it introduces a handful of important programming tools
    that many JavaScript programmers find useful, and also describes two widely used
    extensions to the core JavaScript language. Whether or not you choose to use these
    tools and extensions for your own projects, you are almost certain to see them
    used in other projects, so it is important to at least know what they are.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您达到本书的最后一章。如果您已经阅读了前面的所有内容，现在您对JavaScript语言有了详细的了解，并知道如何在Node和Web浏览器中使用它。本章是一种毕业礼物：它介绍了许多JavaScript程序员发现有用的重要编程工具，并描述了核心JavaScript语言的两个广泛使用的扩展。无论您是否选择为自己的项目使用这些工具和扩展，您几乎肯定会在其他项目中看到它们的使用，因此至少了解它们是很重要的。
- en: 'The tools and language extensions covered in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的工具和语言扩展包括：
- en: ESLint for finding potential bugs and style problems in your code.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ESLint用于在代码中查找潜在的错误和样式问题。
- en: Prettier for formatting your JavaScript code in a standardized way.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prettier以标准化方式格式化您的JavaScript代码。
- en: Jest as an all-in-one solution for writing JavaScript unit tests.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest作为编写JavaScript单元测试的一体化解决方案。
- en: npm for managing and installing the software libraries that your program depends
    on.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm用于管理和安装程序依赖的软件库。
- en: Code-bundling tools—like webpack, Rollup, and Parcel—that convert your modules
    of JavaScript code into a single bundle for use on the web.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码捆绑工具——如webpack、Rollup和Parcel——将您的JavaScript代码模块转换为用于Web的单个捆绑包。
- en: Babel for translating JavaScript code that uses brand-new language features
    (or that uses language extensions) into JavaScript code that can run in current
    web browsers.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel用于将使用全新语言特性（或语言扩展）的JavaScript代码转换为可以在当前Web浏览器中运行的JavaScript代码。
- en: The JSX language extension (used by the React framework) that allows you to
    describe user interfaces using JavaScript expressions that look like HTML markup.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSX语言扩展（由React框架使用）允许您使用类似HTML标记的JavaScript表达式描述用户界面。
- en: The Flow language extension (or the similar TypeScript extension) that allows
    you to annotate your JavaScript code with types and check your code for type safety.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flow语言扩展（或类似的TypeScript扩展）允许您使用类型注释注释您的JavaScript代码，并检查代码是否具有类型安全性。
- en: This chapter does not document these tools and extensions in any comprehensive
    way. The goal is simply to explain them in enough depth that you can understand
    why they are useful and when you might want to use them. Everything covered in
    this chapter is widely used in the JavaScript programming world, and if you do
    decide to adopt a tool or extension, you’ll find lots of documentation and tutorials
    online.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会以任何全面的方式记录这些工具和扩展。目标只是以足够深度解释它们，以便您了解它们为何有用以及何时可能需要使用它们。本章涵盖的所有内容在JavaScript编程世界中被广泛使用，如果您决定采用工具或扩展，您会在网上找到大量文档和教程。
- en: 17.1 Linting with ESLint
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.1 使用ESLint进行Linting
- en: In programming, the term *lint* refers to code that, while technically correct,
    is unsightly, or a possible bug, or suboptimal in some way. A *linter* is a tool
    for detecting lint in your code, and *linting* is the process of running a linter
    on your code (and then fixing your code to remove the lint so that the linter
    no longer complains).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，术语*lint*指的是在技术上正确但不雅观、可能存在错误或以某种方式不够优化的代码。*linter*是一种用于检测代码中lint的工具，*linting*是在代码上运行linter的过程（然后修复代码以消除lint，使linter不再抱怨）。
- en: 'The most commonly used linter for JavaScript today is [ESLint](https://eslint.org).
    If you run it and then take the time to actually fix the issues it points out,
    it will make your code cleaner and less likely to have bugs. Consider the following
    code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天JavaScript最常用的linter是[ESLint](https://eslint.org)。如果您运行它，然后花时间实际修复它指出的问题，它将使您的代码更清洁，更不容易出现错误。考虑以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you run ESLint on this code, you might get output like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此代码上运行ESLint，可能会得到如下输出：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Linters can seem nitpicky sometimes. Does it really matter whether we used double
    quotes or single quotes for our strings? On the other hand, getting indentation
    right is important for readability, and using `===` and `let` instead of `==`
    and `var` protects you from subtle bugs. And unused variables are dead weight
    in your code—there is no reason to keep those around.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时linter可能看起来很挑剔。我们是使用双引号还是单引号真的很重要吗？另一方面，正确的缩进对于可读性很重要，使用`===`和`let`而不是`==`和`var`可以保护您免受微妙错误的影响。未使用的变量是代码中的累赘——没有理由保留它们。
- en: ESLint defines many linting rules and has an ecosystem of plug-ins that add
    many more. But ESLint is fully configurable, and you can define a configuration
    file that tunes ESLint to enforce exactly the rules you want and only those rules.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ESLint定义了许多linting规则，并具有添加许多其他规则的插件生态系统。但ESLint是完全可配置的，您可以定义一个配置文��来调整ESLint以强制执行您想要的规则，仅限于这些规则。
- en: 17.2 JavaScript Formatting with Prettier
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.2 使用Prettier进行JavaScript格式化
- en: One of the reasons that some projects use linters is to enforce a consistent
    coding style so that when a team of programmers is working on a shared codebase,
    they use compatible code conventions. This includes code indentation rules, but
    can also include things like what kind of quotation marks are preferred and whether
    there should be a space between the `for` keyword and the open parenthesis that
    follows it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目使用linter的原因之一是强制执行一致的编码风格，以便当程序员团队共同工作在共享的代码库上时，他们使用兼容的代码约定。这包括代码缩进规则，但也可以包括诸如首选引号类型以及`for`关键字和其后的开括号之间是否应该有空格等内容。
- en: A modern alternative to enforcing code formatting rules via a linter is to adopt
    a tool like [Prettier](https://prettier.io) to automatically parse and reformat
    all of your code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 强制代码格式规则的现代替代方法是采用类似 [Prettier](https://prettier.io) 的工具，自动解析和重新格式化所有代码。
- en: 'Suppose you have written the following function, which works, but is formatted
    unconventionally:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了以下函数，它可以工作，但格式不太规范：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running Prettier on this code fixes the indentation, adds missing semicolons,
    adds spaces around binary operators and inserts line breaks after `{` and before
    `}`, resulting in much more conventional-looking code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Prettier 对这段代码进行了缩进修复，添加了缺失的分号，围绕二进制运算符添加了空格，并在 `{` 之后和 `}` 之前插入了换行符，使代码看起来更加传统：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you invoke Prettier with the `--write` option, it will simply reformat the
    specified file in place rather than printing a reformatted version. If you use
    `git` to manage your source code, you can invoke Prettier with the `--write` option
    in a commit hook so that code is automatically formatted before being checked
    in.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `--write` 选项调用 Prettier，它将简单地在原地重新格式化指定的文件，而不是打印重新格式化的版本。如果你使用 `git` 管理你的源代码，你可以在提交钩子中使用
    `--write` 选项调用 Prettier，这样代码就会在检入之前自动格式化。
- en: Prettier is particularly powerful if you configure your code editor to run it
    automatically every time you save a file. I find it liberating to write sloppy
    code and see it fixed automatically for me.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你配置你的代码编辑器在每次保存文件时自动运行 Prettier，Prettier 就会变得非常强大。我觉得写松散的代码然后看到它被自动修复很解放。
- en: Prettier is configurable, but it only has a few options. You can select the
    maximum line length, the indentation amount, whether semicolons should be used,
    whether strings should be single- or double-quoted, and a few other things. In
    general, Prettier’s default options are quite reasonable. The idea is that you
    just adopt Prettier for your project and then never have to think about code formatting
    again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Prettier 是可配置的，但只有少数选项。你可以选择最大行长度、缩进量、是否应该使用分号、字符串是单引号还是双引号，以及其他一些内容。一般来说，Prettier
    的默认选项是相当合理的。其思想是你只需为你的项目采用 Prettier，然后就再也不用考虑代码格式了。
- en: Personally, I really like using Prettier on JavaScript projects. I have not
    used it for the code in this book, however, because in much of my code I rely
    on careful hand formatting to align my comments vertically, and Prettier messes
    them up.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我非常喜欢在 JavaScript 项目中使用 Prettier。然而，在这本书中的代码中我没有使用它，因为在我的许多代码中，我依赖仔细的手动格式化来垂直对齐我的注释，而
    Prettier 会搞乱它们。
- en: 17.3 Unit Testing with Jest
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.3 使用 Jest 进行单元测试
- en: Writing tests is an important part of any nontrivial programming project. Dynamic
    languages like JavaScript support testing frameworks that dramatically reduce
    the effort required to write tests, and almost make test writing fun! There are
    a lot of test tools and libraries for JavaScript, and many are written in a modular
    way so that it is possible to pick one library as your test runner, another library
    for assertions, and a third for mocking. In this section, however, we’ll describe
    [Jest](https://jestjs.io), which is a popular framework that includes everything
    you need in a single package.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 写测试是任何非平凡编程项目的重要部分。像JavaScript这样的动态语言支持测试框架，大大减少了编写测试所需的工作量，几乎让测试编写变得有趣！JavaScript有很多测试工具和库，许多都是以模块化的方式编写的，因此可以选择一个库作为测试运行器，另一个库用于断言，第三个库用于模拟。然而，在本节中，我们将描述[
    Jest ](https://jestjs.io)，这是一个流行的框架，包含了你在一个单一包中所需的一切。
- en: 'Suppose you’ve written the following function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了以下函数：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A good set of tests for this function might verify that `getTemperature()`
    is fetching the right URL, and that it is converting temperature scales correctly.
    We can do this with a Jest-based test like the following. This code defines a
    mock implementation of `getJSON()` so that the test does not actually make a network
    request. And because `getTemperature()` is an async function, the tests are async
    as well—it can be tricky to test asynchronous functions, but Jest makes it relatively
    easy:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数的一个很好的测试集可能会验证 `getTemperature()` 是否获取了正确的 URL，并且是否正确地转换了温度标度。我们可以使用类似下面的基于
    Jest 的测试来做到这一点。这段代码定义了 `getJSON()` 的模拟实现，以便测试实际上不会发出网络请求。由于 `getTemperature()`
    是一个异步函数，所以测试也是异步的——测试异步函数可能有些棘手，但 Jest 让它相对容易：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the test written, we can use the `jest` command to run it, and we discover
    that one of our tests fails:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 写好测试后，我们可以使用 `jest` 命令来运行它，然后我们发现我们的一个测试失败了：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our `getTemperature()` implementation is using the wrong formula for converting
    C to F. It multiplies by 5 and divides by 9 rather than multiplying by 9 and dividing
    by 5\. If we fix the code and run Jest again, we can see the tests pass. And,
    as a bonus, if we add the `--coverage` argument when we invoke `jest`, it will
    compute and display the code coverage for our tests:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `getTemperature()` 实现使用了错误的公式将摄氏度转换为华氏度。它将乘以5再除以9，而不是乘以9再除以5。如果我们修复代码并再次运行
    Jest，我们可以看到测试通过。而且，作为一个奖励，如果我们在调用 `jest` 时添加 `--coverage` 参数，它将计算并显示我们测试的代码覆盖率：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Running our test gave us 100% code coverage for the module we were testing,
    which is exactly what we wanted. It only gave us partial coverage of `getJSON()`,
    but we mocked that module and were not trying to test it, so that is expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的测试为我们正在测试的模块提供了 100% 的代码覆盖率，这正是我们想要的。它只为 `getJSON()` 提供了部分覆盖，但我们对该模块进行了模拟，并且并不打算测试它，所以这是预期的。
- en: 17.4 Package Management with npm
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.4 使用 npm 进行包管理
- en: In modern software development, it is common for any nontrivial program that
    you write to depend on third-party software libraries. If you’re writing a web
    server in Node, for example, you might be using the Express framework. And if
    you’re creating a user interface to be displayed in a web browser, you might use
    a frontend framework like React or LitElement or Angular. A package manager makes
    it easy to find and install third-party packages like these. Just as importantly,
    a package manager keeps track of what packages your code depends on and saves
    this information into a file so that when someone else wants to try your program,
    they can download your code and your list of dependencies, then use their own
    package manager to install all the third-party packages that your code needs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，编写的任何非平凡程序都可能依赖于第三方软件库。例如，如果您在Node中编写Web服务器，可能会使用Express框架。如果您正在创建要在Web浏览器中显示的用户界面，则可能会使用像React、LitElement或Angular这样的前端框架。包管理器使查找和安装这些第三方包变得容易。同样重要的是，包管理器会跟踪代码所依赖的包，并将此信息保存到文件中，以便其他人想要尝试您的程序时，他们可以下载您的代码和依赖项列表，然后使用自己的包管理器安装代码所需的所有第三方包。
- en: npm is the package manager that is bundled with Node, and was introduced in
    [§16.1.5](ch16.xhtml#npm). It is just as useful for client-side JavaScript programming
    as it is for server-side programming with Node, however.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: npm是随Node捆绑的包管理器，并在[§16.1.5](ch16.xhtml#npm)中介绍。它对于客户端JavaScript编程和Node服务器端编程同样有用。
- en: If you are trying out someone else’s JavaScript project, then one of the first
    things you will often do after downloading their code is to type `npm install`.
    This reads the dependencies listed in the *package.json* file and downloads the
    third-party packages that the project needs and saves them in a *node_modules/*
    directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试其他人的JavaScript项目，那么在下载他们的代码后，您通常会首先执行`npm install`。这会读取*package.json*文件中列出的依赖项，并下载项目需要的第三方包并将其保存在*node_modules/*目录中。
- en: 'You can also type `npm install <package-name>` to install a particular package
    to your project’s *node_modules/* directory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以输入`npm install <package-name>`来将特定包安装到项目的*node_modules/*目录中：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In addition to installing the named package, npm also makes a record of the
    dependency in the *package.json* file for the project. Recording dependencies
    in this way is what allows others to install those dependencies simply by typing
    `npm install`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装命名的包外，npm还会在项目的*package.json*文件中记录依赖关系。以这种方式记录依赖关系是让其他人通过输入`npm install`来安装这些依赖关系的原因。
- en: 'The other kind of dependency is on developer tools that are needed by developers
    who want to work on your project, but aren’t actually needed to run the code.
    If a project uses Prettier, for example, to ensure that all of its code is consistently
    formatted, then Prettier is a “dev dependency,” and you can install and record
    one of these with `--save-dev`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种依赖关系是开发人员工具的依赖，这些工具是开发人员想要在项目上工作时需要的，但实际上不需要运行代码。例如，如果项目使用Prettier来确保所有代码格式一致，那么Prettier就是一个“dev
    dependency”，您可以使用`--save-dev`来安装和记录其中之一：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sometimes you might want to install developer tools globally so that they are
    accessible anywhere even for code that is not part of a formal project with a
    *package.json* file and a *node_modules/* directory. For that you can use the
    `-g` (for global) option:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望全局安装开发工具，以便它们可以在任何地方访问，即使不是正式项目的代码也可以使用*package.json*文件和*node_modules/*目录。为此，您可以使用`-g`（全局）选项：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In addition to the “install” command, npm supports “uninstall” and “update”
    commands, which do what their names say. npm also has an interesting “audit” command
    that you can use to find and fix security vulnerabilities in your dependencies:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“install”命令，npm还支持“uninstall”和“update”命令，其功能如其名称所示。npm还有一个有趣的“audit”命令，您可以使用它来查找并修复依赖项中的安全漏洞：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When you install a tool like ESLint locally for a project, the eslint script
    winds up in *./node_modules/.bin/eslint*, which makes the command awkward to run.
    Fortunately, npm is bundled with a command known as “npx,” which you can use to
    run locally installed tools with commands like `npx eslint` or `npx jest`. (And
    if you use npx to invoke a tool that has not been installed yet, it will install
    it for you.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为项目本地安装类似ESLint这样的工具时，eslint脚本会出现在*./node_modules/.bin/eslint*中，这使得运行命令变得笨拙。幸运的是，npm捆绑了一个��为“npx”的命令，您可以使用它来运行本地安装的工具，如`npx
    eslint`或`npx jest`。（如果您使用npx调用尚未安装的工具，它将为您安装它。）
- en: The company behind npm also maintains the [*https://npmjs.com*](https://npmjs.com)
    package repository, which holds hundreds of thousands of open source packages.
    But you don’t have to use the npm package manager to access this repository of
    packages. Alternatives include [yarn](https://yarnpkg.com) and [pnpm](https://pnpm.js.org).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: npm背后的公司还维护着[*https://npmjs.com*](https://npmjs.com)包仓库，其中包含数十万个开源包。但您不必使用npm包管理器来访问这个包仓库。替代方案包括[yarn](https://yarnpkg.com)和[pnpm](https://pnpm.js.org)。
- en: 17.5 Code Bundling
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.5 代码捆绑
- en: If you are writing a large JavaScript program to run in web browsers, you will
    probably want to use a code-bundling tool, especially if you use external libraries
    that are delivered as modules. Web developers have been using ES6 modules ([§10.3](ch10.xhtml#es6modules))
    for years, since well before the `import` and `export` keywords were supported
    on the web. In order to do this, programmers use a code-bundler tool that starts
    at the main entry point (or entry points) of the program and follows the tree
    of `import` directives to find all modules that the program depends on. It then
    combines all of those individual module files into a single bundle of JavaScript
    code and rewrites the `import` and `export` directives to make the code work in
    this new form. The result is a single file of code that can be loaded into a web
    browser that does not support modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个大型的JavaScript程序以在网络浏览器中运行，那么您可能需要使用一个代码捆绑工具，特别是如果您使用作为模块交付的外部库。多年来，网络开发人员一直在使用ES6模块([§10.3](ch10.xhtml#es6modules))，早在网络上支持`import`和`export`关键字之前。为了做到这一点，程序员使用一个代码捆绑工具，从程序的主入口点（或入口点）开始，并遵循`import`指令的树，以找到程序所依赖的所有模块。然后，它将所有这些单独的模块文件组合成一个JavaScript代码的单个捆绑包，并重写`import`和`export`指令，使代码在这种新形式下工作。结果是一个单个的代码文件，可以加载到不支持模块的网络浏览器中。
- en: ES6 modules are nearly universally supported by web browsers today, but web
    developers still tend to use code bundlers, at least when releasing production
    code. Developers find that user experience is best when a single medium-sized
    bundle of code is loaded when a user first visits a website than when many small
    modules are loaded.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ES6模块现在几乎被所有的网络浏览器支持，但网络开发人员在发布生产代码时仍倾向于使用代码捆绑工具。开发人员发现，当用户首次访问网站时，加载一个中等大小的代码捆绑包比加载许多小模块时用户体验更好。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Web performance is a notoriously tricky topic and there are lots of variables
    to consider, including ongoing improvements by browser vendors, so the only way
    to be sure of the fastest way to load your code is by testing thoroughly and measuring
    carefully. Keep in mind that there is one variable that is completely under your
    control: code size. Less JavaScript code will always load and run faster than
    more JavaScript code!'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网络性能是一个众所周知的棘手话题，有很多要考虑的变量，包括浏览器供应商的持续改进，因此确保加载代码的最快方式的唯一方法是进行彻底的测试和仔细的测量。请记住，有一个完全在您控制之下的变量：代码大小。较少的JavaScript代码总是比较多的JavaScript代码加载和运行更快！
- en: There are a number of good JavaScript bundler tools available. Commonly used
    bundlers include [webpack](https://webpack.js.org), [Rollup](https://rollupjs.org/guide/en)
    and [Parcel](https://parceljs.org). The basic features of bundlers are more or
    less the same, and they are differentiated based on how configurable they are
    or how easy they are to use. Webpack has been around for a long time, has a large
    ecosystem of plug-ins, is highly configurable, and can support older nonmodule
    libraries. But it can also be complex and hard to configure. At the other end
    of the spectrum is Parcel which is intended as a zero-configuration alternative
    that simply does the right thing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多优秀的JavaScript捆绑工具可供选择。常用的捆绑工具包括[webpack](https://webpack.js.org)、[Rollup](https://rollupjs.org/guide/en)和[Parcel](https://parceljs.org)。捆绑工具的基本功能大致相同，它们的区别在于可配置性或易用性。Webpack已经存在很长时间，拥有庞大的插件生态系统，可高度配置，并且可以支持旧的非模块化库。但它也可能复杂且难以配置。另一端是Parcel，它被设计为一个零配置的替代方案，只需简单地做正确的事情。
- en: 'In addition to performing basic bundling, bundler tools can also provide some
    additional features:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行基本的捆绑外，捆绑工具还可以提供一些附加功能：
- en: Some programs have more than one entry point. A web application with multiple
    pages, for example, could be written with a different entry point for each page.
    Bundlers generally allow you to create one bundle per entry point or to create
    a single bundle that supports multiple entry points.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些程序可能有多个入口点。例如，一个具有多个页面的网络应用程序可以为每个页面编写不同的入口点。打包工具通常允许您为每个入口点创建一个捆绑包，或者创建一个支持多个入口点的单个捆绑包。
- en: 'Programs can use `import()` in its functional form ([§10.3.6](ch10.xhtml#dynamicimports))
    instead of its static form to dynamically load modules when they are actually
    needed rather than statically loading them at program startup time. Doing this
    is often a good way to improve the startup time for your program. Bundler tools
    that support `import()` may be able to produce multiple output bundles: one to
    load at startup time, and one or more that are loaded dynamically when needed.
    This can work well if there are only a few calls to `import()` in your program
    and they load modules with relatively disjoint sets of dependencies. If the dynamically
    loaded modules share dependencies then it becomes tricky to figure out how many
    bundles to produce, and you are likely to have to manually configure your bundler
    to sort this out.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序可以使用`import()`的功能形式([§10.3.6](ch10.xhtml#dynamicimports))，而不是静态形式，在实际需要时动态加载模块，而不是在程序启动时静态加载它们。这通常是改善程序启动时间的好方法。支持`import()`的捆绑工具可能能够生成多个输出捆绑包：一个在启动时加载，一个或多个在需要时动态加载。如果动态加载的模块共享依赖关系，那么确定要生成多少个捆绑包就变得棘手了，您可能需要手动配置捆绑工具来解决这个问题。
- en: Bundlers can generally output a *source map* file that defines a mapping between
    the lines of code in the bundle and the corresponding lines in the original source
    files. This allows browser developer tools to automatically display JavaScript
    errors at their original unbundled locations.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捆绑工具通常可以输出一个*源映射*文件，定义了捆绑包中代码行与原始���文件中对应行之间的映射关系。这使得浏览器开发工具可以自动显示JavaScript错误的原始未捆绑位置。
- en: Sometimes when you import a module into your program, you only use a few of
    its features. A good bundler tool can analyze the code to determine which parts
    are unused and can be omitted from the bundles. This feature goes by the whimsical
    name of “tree-shaking.”
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时当你将一个模块导入到你的程序中时，你可能只使用其中的一部分功能。一个好的打包工具可以分析代码以确定哪些部分是未使用的，可以从捆绑包中省略。这个功能被戏称为“tree-shaking”。
- en: Bundlers typically have a plug-in–based architecture and support plug-ins that
    allow importing and bundling “modules” that are not actually files of JavaScript
    code. Suppose that your program includes a large JSON-compatible data structure.
    Code bundlers can be configured to allow you to move that data structure into
    a separate JSON file and then import it into your program with a declaration like
    `import widgets from "./big-widget-list.json"`. Similarly, web developers who
    embed CSS into their JavaScript programs can use bundler plug-ins that allow them
    to import CSS files with an `import` directive. Note, however, that if you import
    anything other than a JavaScript file, you are using a nonstandard JavaScript
    extension and making your code dependent on the bundler tool.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包工具通常具有基于插件的架构，并支持插件，允许导入和捆绑实际上不是 JavaScript 代码文件的“模块”。假设你的程序包含一个大型的 JSON 兼容数据结构。代码打包工具可以配置允许你将该数据结构移动到一个单独的
    JSON 文件中，然后通过类似`import widgets from "./big-widget-list.json"`的声明将其导入到你的程序中。同样，将
    CSS 嵌入到 JavaScript 程序中的 web 开发人员可以使用打包工具插件，允许他们使用`import`指令导入 CSS 文件。但是请注意，如果导入的不是
    JavaScript 文件，你正在使用一个非标准的 JavaScript 扩展，并使你的代码依赖于打包工具。
- en: In a language like JavaScript that does not require compilation, running a bundler
    tool feels like a compilation step, and it is frustrating to have to run a bundler
    after every code edit before you can run the code in your browser. Bundlers typically
    support filesystem watchers that detect edits to any files in a project directory
    and automatically regenerate the necessary bundles. With this feature in place
    you can typically save your code and then immediately reload your web browser
    window to try it out.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在像 JavaScript 这样不需要编译的语言中，运行一个打包工具感觉像是一个编译步骤，每次在运行代码之前都必须运行一个打包工具，这让人感到沮丧。打包工具通常支持文件系统监视器，检测项目目录中任何文件的编辑，并自动重新生成必要的捆绑包。有了这个功能，你通常可以保存你的代码，然后立即重新加载你的
    web 浏览器窗口以尝试它。
- en: Some bundlers also support a “hot module replacement” mode for developers where
    each time a bundle is regenerated, it is automatically loaded into the browser.
    When this works, it is a magical experience for developers, but there are some
    tricks going on under the hood to make it work, and it is not suitable for all
    projects.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些打包工具还支持开发人员的“热模块替换”模式，每次重新生成捆绑包时，它会自动加载到浏览器中。当这个功能起作用时，对开发人员来说是一种神奇的体验，但在幕后进行了一些技巧使其工作，它并不适用于所有项目。
- en: 17.6 Transpilation with Babel
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.6 使用 Babel 进行转译
- en: '[Babel](https://babeljs.io) is a tool that compiles JavaScript written using
    modern language features into JavaScript that does not use those modern language
    features. Because it compiles JavaScript to JavaScript, Babel is sometimes called
    a “transpiler.” Babel was created so that web developers could use the new language
    features of ES6 and later while still targeting web browsers that only supported
    ES5.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[Babel](https://babeljs.io) 是一个工具，将使用现代语言特性编写的 JavaScript 编译成不使用这些现代语言特性的 JavaScript。由于它将
    JavaScript 编译成 JavaScript，因此有时称为“转译器”。Babel 的创建是为了让 web 开发人员能够使用 ES6 及更高版本的新语言特性，同时仍针对只支持
    ES5 的 web 浏览器。'
- en: Language features such as the `**` exponentiation operator and arrow functions
    can be transformed relatively easily into `Math.pow()` and `function` expressions.
    Other language features, such as the `class` keyword, require much more complex
    transformations, and, in general, the code output by Babel is not meant to be
    human readable. Like bundler tools, however, Babel can produce source maps that
    map transformed code locations back to their original source locations, and this
    helps dramatically when working with transformed code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`**`指数运算符和箭头函数之类的语言特性可以相对容易地转换为`Math.pow()`和`function`表达式。其他语言特性，如`class`关键字，需要进行更复杂的转换，而且一般来说，Babel
    输出的代码并不是为了人类可读性。然而，像打包工具一样，Babel 可以生成源映射，将转换后的代码位置映射回原始源位置，这在处理转换后的代码时非常有帮助。
- en: Browser vendors are doing a better job of keeping up with the evolution of the
    JavaScript language, and there is much less need today to compile away arrow functions
    and class declarations. Babel can still help when you want to use the very latest
    features like underscore separators in numeric literals.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器供应商正在更好地跟上 JavaScript 语言的演变，今天几乎不需要编译掉箭头函数和类声明。当你想要使用最新功能，如数字文字中的下划线分隔符时，Babel
    仍然可以帮助。
- en: Like most of the other tools described in this chapter, you can install Babel
    with npm and run it with npx. Babel reads a *.babelrc* configuration file that
    tells it how you would like your JavaScript code transformed. Babel defines “presets”
    that you can choose from depending on which language extensions you want to use
    and how aggressively you want to transform standard language features. One of
    Babel’s interesting presets is for code compression by minification (stripping
    comments and whitespace, renaming variables, and so on).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 像本章描述的大多数其他工具一样，你可以使用 npm 安装 Babel，并使用 npx 运行它。Babel 读取一个 *.babelrc* 配置文件，告诉它如何转换你的
    JavaScript 代码。Babel 定义了“预设”，你可以根据想要使用的语言扩展和你想要多么积极地转换标准语言特性来选择。Babel 的一个有趣的预设是用于通过缩小来进行代码压缩（去除注释和空格，重命名变量等）。
- en: If you use Babel and a code-bundling tool, you may be able to set up the code
    bundler to automatically run Babel on your JavaScript files as it builds the bundle
    for you. If so, this can be a convenient option because it simplifies the process
    of producing runnable code. Webpack, for example, supports a “babel-loader” module
    that you can install and configure to run Babel on each JavaScript module as it
    is bundled up.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Babel和一个代码捆绑工具，你可以设置代码捆绑器在构建捆绑包时自动运行Babel来处理你的JavaScript文件。如果是这样，这可能是一个方便的选项，因为它简化了生成可运行代码的过程。例如，Webpack支持一个“babel-loader”模块，你可以安装并配置它在捆绑时运行Babel来处理每个JavaScript模块。
- en: Even though there is less need to transform the core JavaScript language today,
    Babel is still commonly used to support nonstandard extensions to the language,
    and we’ll describe two of these language extensions in the sections that follow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 即使今天对核心JavaScript语言的转换需求较少，Babel仍然常用于支持语言的非标准扩展，我们将在接下来的章节中描述其中的两个语言扩展。
- en: '17.7 JSX: Markup Expressions in JavaScript'
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.7 JSX：JavaScript中的标记表达式
- en: JSX is an extension to core JavaScript that uses HTML-style syntax to define
    a tree of elements. JSX is most closely associated with the React framework for
    user interfaces on the web. In React, the trees of elements defined with JSX are
    ultimately rendered into a web browser as HTML. Even if you have no plans to use
    React yourself, its popularity means that you are likely to see code that uses
    JSX. This section explains what you need to know to make sense of of it. (This
    section is about the JSX language extension, not about React, and it explains
    only enough of React to provide context for the JSX syntax.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JSX是核心JavaScript的扩展，使用类似HTML的语法来定义元素树。JSX与React框架最为密切相关，用于Web上的用户界面。在React中，使用JSX定义的元素树最终会被渲染成HTML在Web浏览器中。即使你没有计划自己使用React，但由于其流行，你可能会看到使用JSX的代码。本节将解释你需要了解的内容以理解它。（本节关于JSX语言扩展，不是关于React，仅解释React的部分内容以提供JSX语法的上下文。）
- en: 'You can think of a JSX element as a new type of JavaScript expression syntax.
    JavaScript string literals are delimited with quotation marks, and regular expression
    literals are delimited with slashes. In the same way, JSX expression literals
    are delimited with angle brackets. Here is a very simple one:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将JSX元素视为一种新类型的JavaScript表达式语法。JavaScript字符串字面量用引号界定，正则表达式字面量用斜杠界定。同样，JSX表达式字面量用尖括号界定。这是一个非常简单的例子：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you use JSX, you will need to use Babel (or a similar tool) to compile JSX
    expressions into regular JavaScript. The transformation is simple enough that
    some developers choose to use React without using JSX. Babel transforms the JSX
    expression in this assignment statement into a simple function call:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用JSX，你将需要使用Babel（或类似工具）将JSX表达式编译成常规JavaScript。转换足够简单，以至于一些开发人员选择在不使用JSX的情况下使用React。Babel将此赋值语句中的JSX表达式转换为简单的函数调用：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'JSX syntax is HTML-like, and like HTML elements, React elements can have attributes
    like these:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: JSX语法类似HTML，并且像HTML元素一样，React元素可以具有以下属性：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When an element has one or more attributes, they become properties of an object
    passed as the second argument to `createElement()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素有一个或多个属性时，它们成为传递给`createElement()`的第二个参数的对象的属性：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Like HTML elements, JSX elements can have strings and other elements as children.
    Just as JavaScript’s arithmetic operators can be used to write arithmetic expressions
    of arbitrary complexity, JSX elements can also be nested arbitrarily deeply to
    create trees of elements:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 像HTML元素一样，JSX元素可以具有字符串和其他元素作为子元素。就像JavaScript的算术运算符可以用于编写任意复杂度的算术表达式一样，JSX元素也可以任意深度地嵌套以创建元素树：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Regular JavaScript function call expressions can also be nested arbitrarily
    deeply, and these nested JSX expressions translate into a set of nested `createElement()`
    calls. When an JSX element has children, those children (which are typically strings
    and other JSX elements) are passed as the third and subsequent arguments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 常规JavaScript函数调用表达式也可以任意深度地嵌套，这些嵌套的JSX表达式转换为一组嵌套的`createElement()`调用。当一个JSX元素有子元素时，这些子元素（通常是字符串和其他JSX元素）作为第三个及后续参数传递：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The value returned by `React.createElement()` is an ordinary JavaScript object
    that is used by React to render output in a browser window. Since this section
    is about the JSX syntax and not about React, we’re not going to go into any detail
    about the returned Element objects or the rendering process. It is worth noting
    that you can configure Babel to compile JSX elements to invocations of a different
    function, so if you think that JSX syntax would be a useful way to express other
    kinds of nested data structures, you can adopt it for your own non-React uses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`React.createElement()`返回的值是React用于在浏览器窗口中呈现输出的普通JavaScript对象。由于本节是关于JSX语法而不是关于React，我们不会详细介绍返回的元素对象或呈现过程。值得注意的是，你可以配置Babel将JSX元素编译为调用不同函数的调用，因此如果你认为JSX语法是表达其他类型嵌套数据结构的有用方式，你可以将其用于自己的非React用途。'
- en: 'An important feature of JSX syntax is that you can embed regular JavaScript
    expressions within JSX expressions. Within a JSX expression, text within curly
    braces is interpreted as plain JavaScript. These nested expressions are allowed
    as attribute values and as child elements. For example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JSX语法的一个重要特点是你可以在JSX表达式中嵌入常规JavaScript表达式。在JSX表达式中，花括号内的文本被解释为普通JavaScript。这些嵌套表达式允许作为属性值和子元素。例如：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `sidebar()` function returns a JSX element. It takes four arguments that
    it uses within the JSX element. The curly brace syntax may remind you of template
    literals that use `${}` to include JavaScript expressions within strings. Since
    we know that JSX expressions compile into function invocations, it should not
    be surprising that arbitrary JavaScript expressions can be included because function
    invocations can be written with arbitrary expressions as well. This example code
    is translated by Babel into the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`sidebar()`函数返回一个JSX元素。它接受四个参数，这些参数在JSX元素中使用。花括号语法可能会让你想起使用`${}`在字符串中包含JavaScript表达式的模板字面量。由于我们知道JSX表达式编译为函数调用，因此包含任意JavaScript表达式并不奇怪，因为函数调用也可以用任意表达式编写。Babel将此示例代码转换为以下内容：'
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code is easy to read and understand: the curly braces are gone and the
    resulting code passes the incoming function parameters to `React.createElement()`
    in a natural way. Note the neat trick that we’ve done here with the `drawLine`
    parameter and the short-circuiting `&&` operator. If you call `sidebar()` with
    only three arguments, then `drawLine` defaults to `true`, and the fourth argument
    to the outer `createElement()` call is the `<hr/>` element. But if you pass `false`
    as the fourth argument to `sidebar()`, then the fourth argument to the outer `createElement()`
    call evaluates to `false`, and no `<hr/>` element is ever created. This use of
    the `&&` operator is a common idiom in JSX to conditionally include or exclude
    a child element depending on the value of some other expression. (This idiom works
    with React because React simply ignores children that are `false` or `null` and
    does not produce any output for them.)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码易于阅读和理解：花括号消失了，生成的代码以自然的方式将传入的函数参数传递给`React.createElement()`。请注意我们在这里使用`drawLine`参数和短路`&&`运算符的巧妙技巧。如果你只用三个参数调用`sidebar()`，那么`drawLine`默认为`true`，并且外部`createElement()`调用的第四个参数是`<hr/>`元素。但如果将`false`作为第四个参数传递给`sidebar()`，那么外部`createElement()`调用的第四个参数将计算为`false`，并且永远不会创建`<hr/>`元素。这种使用`&&`运算符的习惯用法在JSX中是一种常见的习语，根据某些其他表达式的值有条件地包含或排除子元素。（这种习惯用法在React中有效，因为React简单地忽略`false`或`null`的子元素，并且不为它们生成任何输出。）
- en: 'When you use JavaScript expressions within JSX expressions, you are not limited
    to simple values like the string and boolean values in the preceding example.
    Any JavaScript value is allowed. In fact, it is quite common in React programming
    to use objects, arrays, and functions. Consider the following function, for example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在JSX表达式中使用JavaScript表达式时，你不仅限于前面示例中的字符串和布尔值等简单值。任何JavaScript值都是允许的。事实上，在React编程中使用对象、数组和函数是非常常见的。例如，考虑以下函数：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function uses an object literal as the value of the `style` attribute
    on the `<ul>` element. (Note that double curly braces are required here.) The
    `<ul>` element has a single child, but the value of that child is an array. The
    child array is the array created by using the `map()` function on the input array
    to create an array of `<li>` elements. (This works with React because the React
    library flattens the children of an element when it renders them. An element with
    one array child is the same as that element with each of those array elements
    as children.) Finally, note that each of the nested `<li>` elements has an `onClick`
    event handler attribute whose value is an arrow function. The JSX code compiles
    to the following pure JavaScript code (which I have formatted with Prettier):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将对象字面量用作`<ul>`元素上`style`属性的值。（请注意，这里需要双大括号。）`<ul>`元素只有一个子元素，但该子元素的值是一个数组。子数组是通过在输入数组上使用`map()`函数创建`<li>`元素数组而创建的数组。（这在React中有效，因为React库在渲染时会展平元素的子元素。具有一个数组子元素的元素与该元素的每个数组元素作为子元素相同。）最后，请注意每个嵌套的`<li>`元素都有一个`onClick`事件处理程序属性，其值是一个箭头函数。JSX代码编译为以下纯JavaScript代码（我已使用Prettier格式化）：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'One other use of object expressions in JSX is with the object spread operator
    ([§6.10.4](ch06.xhtml#object-spread-operator)) to specify multiple attributes
    at once. Suppose that you find yourself writing a lot of JSX expressions that
    repeat a common set of attributes. You can simplify your expressions by defining
    the attributes as properties of an object and “spreading them into” your JSX elements:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: JSX中对象表达式的另一个用途是使用对象扩展运算符（[§6.10.4](ch06.xhtml#object-spread-operator)）一次指定多个属性。假设你发现自己编写了许多重复一组常见属性的JSX表达式。你可以通过将属性定义为对象的属性并将它们“扩展到”你的JSX元素中来简化表达式：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Babel compiles this to use an `_extends()` function (omitted here) that combines
    that `className` attribute with the attributes contained in the `hebrew` object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Babel将其编译为使用`_extends()`函数（此处省略）将`className`属性与`hebrew`对象中包含的属性组合在一起：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, there is one more important feature of JSX that we have not covered
    yet. As you’ve seen, all JSX elements begin with an identifier immediately after
    the opening angle bracket. If the first letter of this identifier is lowercase
    (as it has been in all of the examples here), then the identifier is passed to
    `createElement()` as a string. But if the first letter of the identifier is uppercase,
    then it is treated as an actual identifer, and it is the JavaScript value of that
    identifier that is passed as the first argument to `createElement()`. This means
    that the JSX expression `<Math/>` compiles to JavaScript code that passes the
    global Math object to `React.createElement()`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个JSX的重要特性我们还没有涉及。正如你所见，所有JSX元素在开角括号后立即以标识符开头。如果此标识符的第一个字母是小写（就像在这里的所有示例中一样），那么该标识符将作为字符串传递给`createElement()`。但如果标识符的第一个字母是大写，则将其视为实际标识符，并将该标识符的JavaScript值作为`createElement()`的第一个参数传递。这意味着JSX表达式`<Math/>`编译为将全局Math对象传递给`React.createElement()`的JavaScript代码。
- en: For React, this ability to pass non-string values as the first argument to `createElement()`
    enables the creation of *components*. A component is a way of writing a simple
    JSX expression (with an uppercase component name) that represents a more complex
    expression (using lowercase HTML tag names).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于React来说，将非字符串值作为`createElement()`的第一个参数传递的能力使得创建*组件*成为可能。组件是一种编写简单JSX表达式（使用大写组件名称）来表示更复杂表达式（使用小写HTML标签名称）的方式。
- en: 'The simplest way to define a new component in React is to write a function
    that takes a “props object” as its argument and returns a JSX expression. A *props
    object* is simply a JavaScript object that represents attribute values, like the
    objects that are passed as the second argument to `createElement()`. Here, for
    example, is another take on our `sidebar()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中定义一个新组件的最简单方法是编写一个以“props对象”作为参数的函数，并返回一个JSX表达式。*props对象*只是一个表示属性值的JavaScript对象，就像作为`createElement()`的第二个参数传递的对象一样。例如，这里是我们`sidebar()`函数的另一种写法：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This new `Sidebar()` function is a lot like the earlier `sidebar()` function.
    But this one has a name that begins with a capital letter and takes a single object
    argument instead of separate arguments. This makes it a React component and means
    that it can be used in place of an HTML tag name in JSX expressions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`Sidebar()`函数与之前的`sidebar()`函数非常相似。但这个函数以大写字母开头的名称，并接受一个对象参数而不是单独的参数。这使它成为一个React组件，并意味着它可以在JSX表达式中替代HTML标签名称使用：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This `<Sidebar/>` element compiles like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`<Sidebar/>`元素编译如下：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is a simple JSX expression, but when React renders it, it will pass the second
    argument (the Props object) to the first argument (the `Sidebar()` function) and
    will use the JSX expression returned by that function in place of the `<Sidebar>`
    expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的JSX表达式，但当React渲染它时，它会将第二个参数（Props对象）传递给第一个参数（`Sidebar()`函数），并将该函数返回的JSX表达式替换为`<Sidebar>`表达式的位置。
- en: 17.8 Type Checking with Flow
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.8 使用Flow进行类型检查
- en: '[Flow](https://flow.org) is a language extension that allows you to annotate
    your JavaScript code with type information, and a tool for checking your JavaScript
    code (both annotated and unannotated) for type errors. To use Flow, you start
    writing code using the Flow language extension to add type annotations. Then you
    run the Flow tool to analyze your code and report type errors. Once you have fixed
    the errors and are ready to run the code, you use Babel (perhaps automatically
    as part of the code-bundling process) to strip the Flow type annotations out of
    your code. (One of the nice things about the Flow language extension is that there
    isn’t any new syntax that Flow has to compile or transform. You use the Flow language
    extension to add annotations to the code, and all Babel has to do is to strip
    those annotations out to return your code to standard JavaScript.)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[Flow](https://flow.org)是一种语言扩展，允许您在JavaScript代码中添加类型信息，并用于检查您的JavaScript代码（包括带注释和不带注释的代码）中的类型��误。要使用Flow，您开始使用Flow语言扩展编写代码以添加类型注解。然后运行Flow工具分析您的代码并报告类型错误。一旦您修复了错误并准备运行代码，您可以使用Babel（可能作为代码捆绑过程的一部分自动执行）来剥离代码中的Flow类型注解。（Flow语言扩展的一个好处是，Flow没有必须编译或转换的新语法。您使用Flow语言扩展向代码添加注解，而Babel只需剥离这些注解以将您的代码返回到标准JavaScript。）'
- en: Using Flow requires commitment, but I have found that for medium and large projects,
    the extra effort is worth it. It takes extra time to add type annotations to your
    code, to run Flow every time you edit the code, and to fix the type errors it
    reports. But in return Flow will enforce good coding discipline and will not allow
    you to cut corners that can lead to bugs. When I have worked on projects that
    use Flow, I have been impressed by the number of errors it found in my own code.
    Being able to fix those issues before they became bugs is a great feeling and
    gives me extra confidence that my code is correct.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flow需要承诺，但我发现对于中大型项目来说，额外的努力是值得的。为代码添加类型注解，每次编辑代码时运行Flow，以及修复它报告的类型错误都需要额外的时间。但作为回报，Flow将强制执行良好的编码纪律，并不允许你采取可能导致错误的捷径。当我在使用Flow的项目上工作时，我对它在我的代码中发现的错误数量感到印象深刻。在这些问题变成错误之前修复这些问题是一种很棒的感觉，并让我对我的代码正确性更有信心。
- en: 'When I first started using Flow, I found that it was sometimes difficult to
    understand why it was complaining about my code. With some practice, though, I
    came to understand its error messages and found that it was usually easy to make
    minor changes to my code to make it safer and to satisfy Flow.^([1](ch17.xhtml#idm46198481315640))
    I do not recommend using Flow if you still feel like you are learning JavaScript
    itself. But once you are confident with the language, adding Flow to your JavaScript
    projects will push you to take your programming skills to the next level. And
    this, really, is why I’m dedicating the last section of this book to a Flow tutorial:
    because learning about JavaScript type systems offers a glimpse of another level,
    or another style, of programming.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次开始使用Flow时，我发现有时很难理解它为什么会抱怨我的代码。然而，通过一些实践，我开始理解它的错误消息，并发现通常很容易对我的代码进行微小更改，使其更安全并满足Flow的要求。^([1](ch17.xhtml#idm46198481315640))
    如果你仍然觉得自己在学习JavaScript本身，我不建议使用Flow。但一旦你对这门语言有信心，将Flow添加到你的JavaScript项目中将推动你将编程技能提升到下一个水平。这也是为什么我将这本书的最后一节专门用于Flow教程的原因：因为了解JavaScript类型系统提供了另一种编程水平或风格的一瞥。
- en: 'This section is a tutorial, and it does not attempt to cover Flow comprehensively.
    If you decide to try Flow, you will almost certainly end up spending time reading
    the documentation at [*https://flow.org*](https://flow.org). On the other hand,
    you do not need to master the Flow type system before you can start making practical
    use of it in your projects: the simple uses of Flow described here will take you
    a long way.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是一个教程，不打算全面涵盖Flow。如果您决定尝试Flow，几乎肯定会花时间阅读[*https://flow.org*](https://flow.org)上的文档。另一方面，您不需要在掌握Flow类型系统之前就能开始在项目中实际使用它：这里描述的Flow的简单用法将带您走很远。
- en: 17.8.1 Installing and Running Flow
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.1 安装和运行Flow
- en: Like the other tools described in this chapter, you can install the Flow type-checking
    tool using a package manager, with a command like `npm install -g flow-bin` or
    `npm install --save-dev flow-bin`. If you install the tool globally with `-g`,
    then you can run it with `flow`. And if you install it locally in your project
    with `--save-dev`, then you can run it with `npx flow`. Before using Flow to do
    type checking, the first time run it as `flow --init` in the root directory of
    your project to create a `.flowconfig` configuration file. You may never need
    to add anything to this file, but Flow needs it to know where your project root
    is.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 像本章中描述的其他工具一样，您可以使用包管理器安装Flow类型检查工具，使用类似`npm install -g flow-bin`或`npm install
    --save-dev flow-bin`的命令。如果使用`-g`全局安装工具，那么可以使用`flow`运行它。如果在项目中使用`--save-dev`本地安装它，那么可以使用`npx
    flow`运行它。在使用Flow进行类型检查之前，首次在项目的根目录中运行`flow --init`以创建`.flowconfig`配置文件。您可能永远不需要向此文件添加任何内容，但Flow需要知道您的项目根目录在哪里。
- en: When you run Flow, it will find all the JavaScript source code in your project,
    but it will only report type errors for the files that have “opted in” to type
    checking by adding a `// @flow` comment at the top of the file. This opt-in behavior
    is important because it means that you can adopt Flow for existing projects and
    then begin to convert your code one file at a time, without being bothered by
    errors and warnings on files that have not yet been converted.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Flow时，它会找到项目中的所有JavaScript源代码，但只会为已通过在文件顶部添加`// @flow`注释而“选择加入”类型检查的文件报告类型错误。这种选择加入的行为很重要，因为这意味着您可以为现有项目采用Flow，然后逐个文件地开始转换代码，而不会受到尚未转换的文件上的错误和警告的困扰。
- en: Flow may be able to find errors in your code even if all you do is opt in with
    a `// @flow` comment. Even if you do not use the Flow language extension and add
    no type annotations to your code, the Flow type checker tool can still make inferences
    about the values in your program and alert you when you use them inconsistently.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您只是通过`// @flow`注释选择加入，Flow也可能能够找到代码中的错误。即使您不使用Flow语言扩展并且不向代码添加任何类型注释，Flow类型检查工具仍然可以推断程序中的值，并在您不一致地使用它们时提醒您。
- en: 'Consider the following Flow error message:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Flow错误消息：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, we declare the variable `i` and assign an object to it. Then we
    use `i` again as a loop variable, overwriting the object. Flow notices this and
    flags an error when we try to use `i` as if it still held an object. (A simple
    fix would be to write `for(let i = 0;` making the loop variable local to the loop.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们声明变量`i`并将一个对象赋给它。然后我们再次使用`i`作为循环变量，覆盖了对象。Flow注意到这一点，并在我们尝试像仍然保存对象一样使用`i`时标记错误。（一个简单的修复方法是写`for(let
    i = 0;`使循环变量局部于循环。）
- en: 'Here is another error that Flow detects even without type annotations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Flow即使没有类型注释也能检测到的另一个错误：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Flow sees that the `size()` function takes a single argument. It doesn’t know
    the type of that argument, but it can see that the argument is expected to have
    a `length` property. When it sees this `size()` function being called with a numeric
    argument, it correctly flags this as an error because numbers do not have `length`
    properties.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Flow看到`size()`函数接受一个参数。它不知道该参数的类型，但可以看到该参数应具有`length`属性。当看到使用数字参数调用此`size()`函数时，它会正确地标记此为错误，因为数字没有`length`属性。
- en: 17.8.2 Using Type Annotations
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.2 使用类型注释
- en: 'When you declare a JavaScript variable, you can add a Flow type annotation
    to it by following the variable name with a colon and the type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明JavaScript变量时，可以在变量名称后面加上冒号和类型来添加Flow类型注释：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Flow would know the types of these variables even if you did not annotate them:
    it can see what values you assign to each variable, and it keeps track of that.
    If you add type annotations, however, Flow knows both the type of the variable
    and that you have expressed the intent that the variable should always be of that
    type. So if you use the type annotation, Flow will flag an error if you ever assign
    a value of a different type to that variable. Type annotations for variables are
    also particularly useful if you tend to declare all your variables up at the top
    of a function before they are used.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您没有为这些变量添加注释，Flow也会知道这些变量的类型：它可以看到您为每个变量分配的值，并跟踪它们。但是，如果添加了类型注释，Flow既知道变量的类型，又知道您已表达了该变量应始终为该类型的意图。因此，如果使用类型注释，如果将不同类型的值分配给该变量，Flow将标记错误。对于变量，类型注释也特别有用，如果您倾向于在函数使用之前在函数顶部声明所有变量。
- en: 'Type annotations for function arguments are like annotations for variables:
    follow the name of the function argument with a colon and the type name. When
    annotating a function, you typically also add an annotation for the return type
    of the function. This goes between the close parenthesis and the open curly brace
    of the function body. Functions that return nothing use the Flow type `void`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数的类型注释与变量的注释类似：在函数参数名称后面跟着冒号和类型名称。在注释函数时，通常还会为函数的返回类型添加注释。这在函数体的右括号和左花括号之间。返回空值的函数使用Flow类型`void`。
- en: 'In the preceding example we defined a `size()` function that expected an argument
    with a `length` property. Here’s how we could change that function to explicitly
    specify that it expects a string argument and returns a number. Note, Flow now
    flags an error if we pass an array to the function, even though the function would
    work in that case:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个期望具有`length`属性的参数的`size()`函数。下面是如何将该函数更改为明确指定它期望一个字符串参数并返回一个数字。请注意，即使在这种情况下函数可以正常工作，Flow现在也会标记错误，如果我们将数组传递给函数：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using type annotations with arrow functions is also possible, though it can
    turn this normally succinct syntax into something more verbose:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头函数的类型注解也是可能的，尽管这可能会将这个通常简洁的语法变得更冗长：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An important thing to understand about Flow is that the JavaScript value `null`
    has the Flow type `null` and the JavaScript value `undefined` has the Flow type
    `void`. But neither of these values is a member of any other type (unless you
    explicitly add it). If you declare a function parameter to be a string, then it
    must be a string, and it is an error to pass `null` or to pass `undefined` or
    to omit the argument (which is basically the same thing as passing `undefined`):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Flow的一个重要事项是，JavaScript值`null`具有Flow类型`null`，JavaScript值`undefined`具有Flow类型`void`。但这两个值都不是任何其他类型的成员（除非你明确添加它）。如果你声明一个函数参数为字符串，那么它必须是一个字符串，传递`null`、传递`undefined`或省略参数（基本上与传递`undefined`相同）都是错误的：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you want to allow `null` and `undefined` as legal values for a variable
    or function argument, simply prefix the type with a question mark. For example,
    use `?string` or `?number` instead of `string` or `number`. If we change our `size()`
    function to expect an argument of type `?string`, then Flow doesn’t complain when
    we pass `null` to the function. But it now has something else to complain about:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想允许`null`和`undefined`作为变量或函数参数的合法值，只需在类型前加上问号。例如，使用`?string`或`?number`代替`string`或`number`。如果我们将`size()`函数更改为期望类型为`?string`的参数，那么当我们将`null`传递给函数时，Flow不会抱怨。但现在它有其他事情要抱怨：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What Flow is telling us here is that it is not safe to write `s.length` because,
    at this place in our code, `s` might be `null` or `undefined`, and those values
    do not have `length` properties. This is where Flow makes sure we do not cut any
    corners. If a value might be `null`, Flow will insist that we check for that case
    before we do anything that depends on the value not being `null`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Flow在这里告诉我们的是，在我们的代码中，写`s.length`是不安全的，因为此处的`s`可能是`null`或`undefined`，而这些值没有`length`属性。这就是Flow确保我们不会偷懒的地方。如果一个值可能是`null`，Flow会坚持要求我们在执行任何依赖于该值不是`null`的操作之前检查该情况。
- en: 'In this case, we can fix the issue by changing the body of the function as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以通过更改函数主体来解决问题如下：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When the function is first called, the parameter can have more than one type.
    But by adding type-checking code, we create a block within the code where Flow
    knows for sure that the parameter is a string. When we use `s.length` within that
    block, Flow does not complain. Note that Flow does not require you to write verbose
    code like this. Flow would also be satisfied if we just replaced the body of the
    `size()` function with `return s ? s.length : -1;`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '当函数首次调用时，参数可以有多种类型。但通过添加类型检查代码，我们在代码中创建了一个块，Flow可以确定参数是一个字符串。当我们在该块内使用`s.length`时，Flow不会抱怨。请注意，Flow不要求你编写冗长的代码。如果我们只是用`return
    s ? s.length : -1;`替换`size()`函数的主体，Flow也会满意。'
- en: 'Flow syntax allows a question mark before any type specification to indicate
    that, in addition to the specified type, `null` and `undefined` are allowed as
    well. Question marks can also appear after a parameter name to indicate that the
    parameter itself is optional. So if we changed the declaration of the parameter
    `s` from `s: ?string` to `s? : string`, that would mean it is OK to call `size()`
    with no arguments (or with the value `undefined`, which is the same as omitting
    it), but that if we do call it with a parameter other than `undefined`, then that
    parameter must be a string. In this case, `null` is not a legal value.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 'Flow语法允许在任何类型规范之前加上问号，以指示除了指定的类型外，`null`和`undefined`也���允许的。问号也可以出现在参数名后，以指示参数本身是可选的。因此，如果我们将参数`s`的声明从`s:
    ?string`更改为`s? : string`，那意味着可以用没有参数调用`size()`（或值为`undefined`，这与省略它相同），但如果我们用除`undefined`之外的参数调用它，那么该参数必须是一个字符串。在这种情况下，`null`不是合法值。'
- en: So far, we’ve discussed primitive types `string`, `number`, `boolean`, `null`,
    and `void` and have demonstrated how you can use use them with variable declarations,
    function parameters, and function return values. The subsections that follow describe
    some more complex types supported by Flow.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了原始类型`string`、`number`、`boolean`、`null`和`void`，并演示了如何在变量声明、函数参数和函数返回值中使用它们。接下来的小节描述了Flow支持的一些更复杂的类型。
- en: 17.8.3 Class Types
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.3 类型类
- en: 'In addition to the primitive types that Flow knows about, it also knows about
    all of JavaScript’s built-in classes and allows you to use class name as types.
    The following function, for example, uses type annotations to indicate that it
    should be invoked with one Date object and one RegExp object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Flow了解的原始类型外，它还了解所有JavaScript的内置类，并允许你使用类名作为类型。例如，以下函数使用类型注解指示应使用一个Date对象和一个RegExp对象调用它：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you define your own classes with the `class` keyword, those classes automatically
    become valid Flow types. In order to make this work, however, Flow does require
    you to use type annotations in the class. In particular, each property of the
    class must have its type declared. Here is a simple complex number class that
    demonstrates this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`class`关键字定义自己的类，那些类会自动成为有效的Flow类型。然而，为了使其工作，Flow确实要求你在类中使用类型注解。特别是，类的每个属性必须声明其类型。这里是一个简单的复数类示例，演示了这一点：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 17.8.4 Object Types
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.4 对象类型
- en: 'The Flow type to describe an object looks a lot like an object literal, except
    that property values are replaced by property types. Here, for example, is a function
    that expects an object with numeric `x` and `y` properties:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 描述对象的 Flow 类型看起来很像对象字面量，只是属性值被属性类型替换。例如，这里是一个期望具有数字 `x` 和 `y` 属性的对象的函数：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this code, the text `{x:number, y:number}` is a Flow type, just like `string`
    or `Date` is. As with any type, you can add a question mark at the front to indicate
    that `null` and `undefined` should also be allowed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，文本 `{x:number, y:number}` 是一个 Flow 类型，就像 `string` 或 `Date` 一样。与任何类型一样，你可以在前面加上问号来表示
    `null` 和 `undefined` 也应该被允许。
- en: 'Within an object type, you can follow any of the property names with a question
    mark to indicate that that property is optional and may be omitted. For example,
    you might write the type for an object that represents a 2D or 3D point like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象类型中，你可以在任何属性名称后面加上问号，表示该属性是可选的，可以省略。例如，你可以这样写一个表示 2D 或 3D 点的对象类型：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If a property is not marked as optional in an object type, then it is required,
    and Flow will report an error if an appropriate property is not present in the
    actual value. Normally, however, Flow tolerates extra properties. If you were
    to pass an object that had a `w` property to the `distance()` function above,
    Flow would not complain.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对象类型中未标记属性为可选，则该属性是必需的，如果实际值中缺少适当的属性，Flow 将报告错误。然而，通常情况下，Flow 容忍额外的属性。如果你向上面的
    `distance()` 函数传递一个具有 `w` 属性的对象，Flow 不会抱怨。
- en: 'If you want Flow to strictly enforce that an object does not have properties
    other than those explicitly declared in its type, you can declare an *exact object
    type* by adding vertical bars to the curly braces:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 Flow 严格执行对象除了在其类型中明确声明的属性之外没有其他属性，你可以通过在花括号中添加竖线来声明*精确对象类型*：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'JavaScript’s objects are sometimes used as dictionaries or string-to-value
    maps. When used like this, the property names are not known in advance and cannot
    be declared in a Flow type. If you use objects this way, you can still use Flow
    to describe the data structure. Suppose that you have an object where the properties
    are the names of the world’s major cities and the values of those properties are
    objects that specify the geographical location of those cities. You might declare
    this data structure like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的对象有时被用作字典或字符串值映射。当以这种方式使用对象时，属性名称事先不知道，也不能在 Flow 类型中声明。如果���以这种方式使用对象，你仍然可以使用
    Flow 来描述数据结构。假设你有一个对象，其中属性是世界主要城市的名称，这些属性的值是指定这些城市地理位置的对象。你可以这样声明这个数据结构：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 17.8.5 Type Aliases
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.5 类型别名
- en: 'Objects can have many properties, and the Flow type that describes such an
    object will be long and difficult to type. And even relatively short object types
    can be confusing because they look so much like object literals. Once we get beyond
    simple types like `number` and `?string`, it is often useful to be able to define
    names for our Flow types. And in fact, Flow uses the `type` keyword to do exactly
    that. Follow the `type` keyword with an identifier, an equals sign, and a Flow
    type. Once you’ve done that, the identifier will be an alias for the type. Here,
    for example, is how we could rewrite the `distance()` function from the previous
    section with an explicitly defined `Point` type:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以有许多属性，描述这样一个对象的 Flow 类型将会很长且难以输入。即使相对较短的对象类型也可能令人困惑，因为它们看起来非常像对象字面量。一旦我们超越了像
    `number` 和 `?string` 这样的简单类型，为我们的 Flow 类型定义名称通常是有用的。事实上，Flow 使用 `type` 关键字来做到这一点。在
    `type` 关键字后面跟上标识符、等号和 Flow 类型。一旦你这样做了，该标识符将成为该类型的别名。例如，这里是我们如何使用显式定义的 `Point`
    类型重写上一节中的 `distance()` 函数：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that this code exports the `distance()` function and also exports the `Point`
    type. Other modules can use `import type Point from './distance.js'` if they want
    to use that type definition. Keep in mind, though, that `import type` is a Flow
    language extension and not a real JavaScript import directive. Type imports and
    exports are used by the Flow type checker, but like all other Flow language extensions,
    they are stripped out of the code before it ever runs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码导出了 `distance()` 函数，并且还导出了 `Point` 类型。其他模块可以使用 `import type Point from
    './distance.js'` 如果他们想使用该类型定义。但请记住，`import type` 是一个 Flow 语言扩展，而不是真正的 JavaScript
    导入指令。类型导入和导出被 Flow 类型检查器使用，但像所有其他 Flow 语言扩展一样，在代码运行之前它们都会被剥离。
- en: Finally, it is worth noting that instead of defining a name for a Flow object
    type that represents a point, it would probably be simpler and cleaner to just
    define a Point class and use that class as the type.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，与其定义一个代表点的 Flow 对象类型的名称，可能更简单和更清晰的是只定义一个 Point 类并将该类用作类型。
- en: 17.8.6 Array Types
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.6 数组类型
- en: 'The Flow type to describe an array is a compound type that also includes the
    type of the array elements. Here, for example, is a function that expects an array
    of numbers, and the error that Flow reports if you try to call the function with
    an array that has non-numeric elements:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 描述数组的 Flow 类型是一个复合类型，还包括数组元素的类型。例如，这里是一个期望数字数组的函数，以及如果尝试使用具有非数字元素的数组调用该函数时 Flow
    报告的错误：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The Flow type for an array is `Array` followed by the element type in angle
    brackets. You can also express an array type by following the element type with
    open and close square brackets. So in this example we could have written `number[]`
    instead of `Array<number>`. I prefer the angle bracket notation because, as we’ll
    see, there are other Flow types that use this angle-bracket syntax.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数组的 Flow 类型是 `Array`，后面跟着尖括号中的元素类型。你也可以通过在元素类型后面加上开放和关闭方括号来表示数组类型。因此，在这个例子中，我们可以写成
    `number[]` 而不是 `Array<number>`。我更喜欢尖括号表示法，因为，正如我们将看到的，还有其他使用这种尖括号语法的 Flow 类型。
- en: 'The Array type syntax shown works for arrays with an arbitrary number of elements,
    all of which have the same type. Flow has a different syntax for describing the
    type of a *tuple*: an array with a fixed number of elements, each of which may
    have a different type. To express the type of a tuple, simply write the type of
    each of its elements, separate them with commas, and enclose them all in square
    brackets.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的Array类型语法适用于具有任意数量元素的数组，所有元素都具有相同的类型。Flow有一种不同的语法来描述*元组*的类型：一个具有固定数量元素的数组，每个元素可能具有不同的类型。要表示元组的类型，只需写出每个元素的类型，用逗号分隔，然后将它们都括在方括号中。
- en: 'A function that returns an HTTP status code and message might look like this,
    for example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个返回HTTP状态码和消息的函数可能如下所示：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Functions that return tuples are awkward to work with unless you use destructuring
    assignment:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组的函数在不使用解构赋值的情况下很难处理：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Destructuring assignment, plus Flow’s type-aliasing capabilities, make tuples
    easy enough to work with that you might consider them as an alternative to classes
    for simple datatypes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值，再加上Flow的类型别名功能，使得元组易于处理，以至于你可能会考虑它们作为简单数据类型的替代方案：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have a way to express the type of an array, let’s return to the
    `size()` function from earlier and modify it to expect an array argument instead
    of a string argument. We want the function to be able to accept an array of any
    length, so a tuple type is not appropriate. But we don’t want to restrict our
    function to working only for arrays where all the elements have the same type.
    The solution is the type `Array<mixed>`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种表达数组类型的方法，让我们回到之前的`size()`��数，并修改它以接受一个数组参数而不是一个字符串参数。我们希望函数能够接受任意长度的数组，因此元组类型不合适。但我们也不希望将函数限制为仅适用于所有元素类型相同的数组。解决方案是类型`Array<mixed>`：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The element type `mixed` indicates that the elements of the array can be of
    any type. If our function actually indexed the array and attempted to use any
    of those elements, Flow would insist that we use `typeof` checks or other tests
    to determine the type of the element before performing any unsafe operation on
    it. (If you are willing to give up on type checking, you can also use `any` instead
    of `mixed`: it allows you to do whatever you want with the values of the array
    without ensuring that the values are of the type you expect.)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 元素类型`mixed`表示数组的元素可以是任何类型。如果我们的函数实际上对数组进行索引并尝试使用其中的任何元素，Flow将坚持要求我们使用`typeof`检查或其他测试来确定元素的类型，然后再执行任何不安全的操作。（如果你愿意放弃类型检查，也可以使用`any`代替`mixed`：它允许你对数组的值做任何想做的事情，而不必确保这些值是你期望的类型。）
- en: 17.8.7 Other Parameterized Types
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.7 其他参数化类型
- en: We’ve seen that when you annotate a value as an `Array`, Flow requires you to
    also specify the type of the array elements inside angle brackets. This additional
    type is known as a *type parameter*, and Array is not the only JavaScript class
    that is parameterized.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当您将一个值注释为`Array`时，Flow要求您还必须在尖括号内指定数组元素的类型。这个额外的类型被称为*类型参数*，而Array并不是唯一一个被参数化的JavaScript类。
- en: 'JavaScript’s Set class is a collection of elements, like an array is, and you
    can’t use `Set` as a type by itself, but you have to include a type parameter
    within angle brackets to specify the type of the values contained in the set.
    (Though you can use `mixed` or `any` if the set may contain values of multiple
    types.) Here’s an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的Set类是一个元素集合，就像数组一样，你不能单独使用`Set`作为一种类型，而是必须在尖括号内包含一个类型参数来指定集合中包含的值的类型。（尽管如果集合可能包含多种类型的值，你可以使用`mixed`或`any`。）以下是一个示例：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Map is another parameterized type. In this case, there are two type parameters
    that must be specified; the type of the keys and the types of the values:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Map是另一种参数化类型。在这种情况下，必须指定两个类型参数；键的类型和值的类型：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Flow lets you define type parameters for your own classes as well. The following
    code defines a Result class but parameterizes that class with an Error type and
    a Value type. We use placeholders `E` and `V` in the code to represent these type
    parameters. When the user of this class declares a variable of type Result, they
    will specify the actual types to substitute for `E` and `V`. The variable declaration
    might look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Flow还允许您为自己的类定义类型参数。以下代码定义了一个Result类，但使用一个Error类型和一个Value类型对该类进行参数化。我们在代码中使用占位符`E`和`V`来表示这些类型参数。当这个类的用户声明一个Result类型的变量时，他们将指定实际类型来替换`E`和`V`。变量声明可能如下所示：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And here is how the parameterized class is defined:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是参数化类的定义方式：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And you can even define type parameters for functions:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以为函数定义类型参数：
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 17.8.8 Read-Only Types
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.8 只读类型
- en: Flow defines some special parameterized “utility types” that have names beginning
    with `$`. Most of these types have advanced use cases that we are not going to
    cover here. But two of them are quite useful in practice. If you have an object
    type T and want to make a read-only version of that type, just write `$ReadOnly<T>`.
    Similarly, you can write `$ReadOnlyArray<T>` to describe a read-only array with
    elements of type T.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Flow定义了一些特殊的参数化“实用类型”，其名称以`$`开头。这些类型中的大多数都有我们这里不打算涵盖的高级用例。但其中两个在实践中非常有用。如果你有一个对象类型T，并想要创建该类型的只读版本，只需编写`$ReadOnly<T>`。类似地，您可以编写`$ReadOnlyArray<T>`来描述一个具有类型T的只读数组。
- en: 'The reason to use these types is not because they can offer any guarantee that
    an object or array can’t be modified (see `Object.freeze()` in [§14.2](ch14.xhtml#extensibleattr)
    if you want true read-only objects) but because it allows you to catch bugs caused
    by unintentional modifications. If you write a function that takes an object or
    array argument and does not change any of the object’s properties or the array’s
    elements, then you can annotate the function parameter with one of Flow’s read-only
    types. If you do this, then Flow will report an error if you forget and accidentally
    modify the input value. Here are two examples:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类型的原因不是因为它们可以提供任何对象或数组不能被修改的保证（如果你想要真正的只读对象，请参见 [§14.2](ch14.xhtml#extensibleattr)
    中的 `Object.freeze()`），而是因为它可以帮助你捕捉由无意修改引起的错误。如果你编写一个接受对象或数组参数并且不改变对象的任何属性或数组的元素的函数，那么你可以用
    Flow 的只读类型注释函数参数。如果你这样做，那么如果你忘记并意外修改输入值，Flow 将报告错误。以下是两个示例：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 17.8.9 Function Types
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.9 函数类型
- en: We have seen how to add type annotations to specify the types of a function’s
    parameters and its return type. But when one of the parameters of a function is
    itself a function, we need to be able to specify the type of that function parameter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何添加类型注释来指定函数参数和返回类型的类型。但是当函数的一个参数本身是一个函数时，我们需要能够指定该函数参数的类型。
- en: To express the type of a function with Flow, write the types of each parameter,
    separate them with commas, enclose them in parentheses, and then follow that with
    an arrow and type return type of the function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Flow 表达函数的类型，需要写出每个参数的类型，用逗号分隔，将它们括在括号中，然后跟上一个箭头和函数的返回类型。
- en: 'Here is an example function that expects to be passed a callback function.
    Notice how we defined a type alias for the type of the callback function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个期望传递回调函数的示例函数。请注意我们为回调函数的类型定义了一个类型别名：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 17.8.10 Union Types
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.10 Union 类型
- en: Let’s return one more time to the `size()` function. It doesn’t really make
    sense to have a function that does nothing other than return the length of an
    array. Arrays have a perfectly good `length` property for that. But `size()` might
    be useful if it could take any kind of collection object (an array or a Set or
    a Map) and return the number of elements in the collection. In regular untyped
    JavaScript it would be easy to write a `size()` function like that. With Flow,
    we need a way to express a type that allows arrays, Sets, and Maps, but doesn’t
    allow values of any other type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回到 `size()` 函数。创建一个什么都不做，只返回数组长度的函数并没有太多意义。数组有一个完全好用的 `length` 属性。但如果 `size()`
    能够接受任何类型的集合对象（数组或 Set 或 Map）并返回集合中元素的数量，那么它可能会有用。在常规的未类型化 JavaScript 中，编写一个这样的
    `size()` 函数很容易。但是在 Flow 中，我们需要一种方式来表达一个允许数组、Set 和 Map 的类型，但不允许任何其他类型值。
- en: 'Flow calls types like this *Union types* and allows you to express them by
    simply listing the desired types and separating them with vertical bar characters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 将这种类型称为 *Union 类型*，并允许你通过简单列出所需类型并用竖线字符分隔它们来表达它们：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Union types can be read using the word “or”—“an array or a Set or a Map”—so
    the fact that this Flow syntax uses the same vertical bar character as JavaScript’s
    OR operators is intentional.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Union 类型可以用“或”这个词来阅读——“一个数组或一个 Set 或一个 Map”——因此，这种 Flow 语法使用与 JavaScript 的 OR
    运算符相同的竖线字符是有意的。
- en: We saw earlier that putting a question mark before a type allows `null` and
    `undefined` values. And now you can see that a `?` prefix is simply a shortcut
    for adding a `|null|void` suffix to a type.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到在类型前面加一个问号允许 `null` 和 `undefined` 值。现在你可以��到，`?` 前缀只是一个为类型添加 `|null|void`
    后缀的快捷方式。
- en: 'In general, when you annotate a value with a Union type, Flow will not allow
    you to use that value until you’ve done enough tests to figure out what the type
    of the actual value is. In the `size()` example we just looked at, we need to
    explicitly check whether the argument is an array before we try to access the
    `length` property of the argument. Note that we do not have to distinguish a Set
    argument from a Map argument, however: both of those classes define a `size` property,
    so the code in the `else` clause is safe as long as the argument is not an array.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你用 Union 类型注释一个值时，Flow 不会允许你使用该值，直到你进行足够的测试以确定实际值的类型。在我们刚刚看过的 `size()`
    示例中，我们需要明确检查参数是否为数组，然后再尝试访问参数的 `length` 属性。请注意，我们不必区分 Set 参数和 Map 参数，然而：这两个类都定义了
    `size` 属性，因此只要参数不是数组，`else` 子句中的代码就是安全的。
- en: 17.8.11 Enumerated Types and Discriminated Unions
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8.11 枚举类型和辨别联合
- en: 'Flow allows you to use primitive literals as types that consist of that one
    single value. If you write `let x:3;`, then Flow will not allow you to assign
    any value to that variable other than 3\. It is not often useful to define types
    that have only a single member, but a union of literal types can be useful. You
    can probably imagine a use for types like these, for example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Flow 允许你使用原始字面量作为只包含一个单一值的类型。如果你写 `let x:3;`，那么 Flow 将不允许你给该变量赋值除了 3 之外的任何值。定义只有一个成员的类型通常不太有用，但字面量类型的联合可能会有用。你可能可以想象出这些类型的用途，例如：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you use types made up of literals, you need to understand that only literal
    values are allowed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用由字面量组成的类型，你需要理解只有字面值是允许的：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When Flow checks your types, it does not actually do the calculations: it just
    checks the types of the calculations. Flow knows that `toLowerCase()` returns
    a string and that the `+` operator on numbers returns a number. Even though we
    know that both of these calculations return values that are within the type, Flow
    cannot know that and flags errors on both of these lines.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Flow 检查你的类型时，它实际上并不执行计算：它只检查计算的类型。Flow 知道 `toLowerCase()` 返回一个字符串，`+` 运算符在数字上返回一个数字。尽管我们知道这两个计算返回的值都在类型内，但
    Flow 无法知道这一点，并在这两行上标记错误。
- en: 'A union type of literal types like `Answer` and `Digit` is an example of an
    *enumerated type*, or *enum*. A canonical use case for enum types is to represent
    the suits of playing cards:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 像`Answer`和`Digit`这样的字面类型的联合类型是*枚举类型*的一个例子。枚举类型的一个典型用例是表示扑克牌的花色：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A more relevant example might be HTTP status codes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 更相关的例子可能是HTTP状态码：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'One of the pieces of advice that new programmers often hear is to avoid using
    literals in their code and to instead define symbolic constants to represent those
    values. One practical reason for this is to avoid the problem of typos: if you
    misspell a string literal like “Diamonds” JavaScript may never complain but your
    code may not work right. If you mistype an identifier, on the other hand, JavaScript
    is likely to throw an error that you’ll notice. With Flow, this advice does not
    always apply. If you annotate a variable with the type Suit, and then try to assign
    a misspelled suit to it, Flow will alert you to the error.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 新手程序员经常听到的建议之一是避免在代码中使用字面量，而是定义符号常量来代表这些值。这样做的一个实际原因是避免拼写错误的问题：如果你拼错了一个字符串字面量，比如“Diamonds”，JavaScript可能不会抱怨，但你的代码可能无法正常工作。另一方面，如果你拼错了一个标识符，JavaScript很可能会抛出一个你会注意到的错误。然而，在使用Flow时，这个建议并不总是适用。如果你用类型Suit注释一个变量，然后尝试将一个拼写错误的suit赋给它，Flow会提醒你错误。
- en: Another important use for literal types is the creation of *discriminated unions*.
    When you work with union types (made up of actually different types, not of literals),
    you typically have to write code to discriminate among the possible types. In
    the previous section, we wrote a function that could take an array or a Set or
    a Map as its argument and had to write code to discriminate array input from Set
    or Map input. If you want to create a union of Object types, you can make these
    types easy to discriminate by using a literal type within each of the individual
    Object types.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 字面类型的另一个重要用途是创建*辨别联合体*。当你使用联合类型（由实际不同类型组成，而不是字面量）时，通常需要编写代码来区分可能的类型。在前一节中，我们编写了一个函数，它可以接受一个数组、一个Set或一个Map作为其参数，并且必须编写代码来区分数组输入和Set或Map输入。如果你想创建一个对象类型的联合体，可以通过在每个单独的对象类型中使用字面类型来使这些类型易于区分。
- en: 'An example will make this clear. Suppose you’re using a worker thread in Node
    ([§16.11](ch16.xhtml#node-worker-threads)) and are using `postMessage()` and “message”
    events for sending object-based messages between the main thread and the worker
    thread. There are multiple types of messages that the worker might want to send
    to the main thread, but we’d like to write a Flow Union type that describes all
    possible messages. Consider this code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子来说明。假设你正在Node中使用工作线程（[§16.11](ch16.xhtml#node-worker-threads)），并且正在使用`postMessage()`和“message”事件在主线程和工作线程之间发送基于对象的消息。工作线程可能想要向主线程发送多种类型的消息，但我们希望编写一个描述所有可能消息的Flow联合类型。考虑以下代码：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 17.9 Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.9 总结
- en: JavaScript is the most-used programming language in the world today. It is a
    living language—one that continues to evolve and improve—surrounded by a flourishing
    ecosystem of libraries, tools, and extensions. This chapter introduced some of
    those tools and extensions, but there are many more to learn about. The JavaScript
    ecosystem flourishes because the JavaScript developer community is active and
    vibrant, full of peers who share their knowledge through blog posts, videos, and
    conference presentations. As you close this book and go forth to join this community,
    you will find no shortage of information sources to keep you engaged with and
    learning about JavaScript.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是当今世界上使用最广泛的编程语言。它是一种活跃的语言，不断发展和改进，周围有着繁荣的库、工具和扩展生态系统。本章介绍了其中一些工具和扩展，但还有许多其他内容需要了解。JavaScript生态系统蓬勃发展，因为JavaScript开发者社区活跃而充满活力，同行们通过博客文章、视频和会议演讲分享他们的知识。当你结束阅读这本书，加入这个社区时，你会发现有很多信息源可以让你与JavaScript保持联系并继续学习。
- en: Best wishes, David Flanagan, March 2020
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 祝一切顺利，David Flanagan，2020年3月
- en: ^([1](ch17.xhtml#idm46198481315640-marker)) If you have programmed with Java,
    you may have experienced something like this the first time you wrote a generic
    API that used a type parameter. I found the learning process for Flow to be remarkably
    similar to what I went through in 2004 when generics were added to Java.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch17.xhtml#idm46198481315640-marker)) 如果你有Java编程经验，可能在第一次编写使用类型参数的通用API时会遇到类似的情况。我发现学习Flow的过程与2004年Java添加泛型时经历的过程非常相似。
