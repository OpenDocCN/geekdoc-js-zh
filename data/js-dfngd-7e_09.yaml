- en: Chapter 9\. Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 类
- en: JavaScript objects were covered in [Chapter 6](ch06.xhtml#objects). That chapter
    treated each object as a unique set of properties, different from every other
    object. It is often useful, however, to define a *class* of objects that share
    certain properties. Members, or *instances*, of the class have their own properties
    to hold or define their state, but they also have methods that define their behavior.
    These methods are defined by the class and shared by all instances. Imagine a
    class named Complex that represents and performs arithmetic on complex numbers,
    for example. A Complex instance would have properties to hold the real and imaginary
    parts (the state) of the complex number. And the Complex class would define methods
    to perform addition and multiplication (the behavior) of those numbers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象在[第6章](ch06.xhtml#objects)中有所涉及。该章将每个对象视为一组独特的属性，与其他对象不同。然而，通常有必要定义一种共享某些属性的对象*类*。类的成员或*实例*具有自己的属性来保存或定义它们的状态，但它们还具有定义其行为的方法。这些方法由类定义，并由所有实例共享。例如，想象一个名为Complex的类，表示并对复数执行算术运算。Complex实例将具有保存复数的实部和虚部（状态）的属性。Complex类将定义执行这些数字的加法和乘法（行为）的方法。
- en: 'In JavaScript, classes use prototype-based inheritance: if two objects inherit
    properties (generally function-valued properties, or methods) from the same prototype,
    then we say that those objects are instances of the same class. That, in a nutshell,
    is how JavaScript classes work. JavaScript prototypes and inheritance were covered
    in [§6.2.3](ch06.xhtml#prototypes) and [§6.3.2](ch06.xhtml#inheritance), and you
    will need to be familiar with the material in those sections to understand this
    chapter. This chapter covers prototypes in [§9.1](#classesandprototypes).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，类使用基于原型的继承：如果两个对象从同一原型继承属性（通常是函数值属性或方法），那么我们说这些对象是同一类的实例。简而言之，这就是JavaScript类的工作原理。JavaScript原型和继承在[§6.2.3](ch06.xhtml#prototypes)和[§6.3.2](ch06.xhtml#inheritance)中有所涉及，您需要熟悉这些部分的内容才能理解本章。本章在[§9.1](#classesandprototypes)中涵盖了原型。
- en: If two objects inherit from the same prototype, this typically (but not necessarily)
    means that they were created and initialized by the same constructor function
    or factory function. Constructors have been covered in [§4.6](ch04.xhtml#newexprs),
    [§6.2.2](ch06.xhtml#creatingobjectswithnew), and [§8.2.3](ch08.xhtml#constructorinvocation),
    and this chapter has more in [§9.2](#classesandconstructors).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个对象从同一原型继承，这通常（但不一定）意味着它们是由同一构造函数或工厂函数创建和初始化的。构造函数在[§4.6](ch04.xhtml#newexprs)、[§6.2.2](ch06.xhtml#creatingobjectswithnew)和[§8.2.3](ch08.xhtml#constructorinvocation)中有所涉及，本章在[§9.2](#classesandconstructors)中有更多内容。
- en: JavaScript has always allowed the definition of classes. ES6 introduced a brand-new
    syntax (including a `class` keyword) that makes it even easier to create classes.
    These new JavaScript classes work in the same way that old-style classes do, and
    this chapter starts by explaining the old way of creating classes because that
    demonstrates more clearly what is going on behind the scenes to make classes work.
    Once we’ve explained those fundamentals, we’ll shift and start using the new,
    simplified class definition syntax.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript一直允许定义类。ES6引入了全新的语法（包括`class`关键字），使得创建类变得更加容易。这些新的JavaScript类与旧式类的工作方式相同，本章首先解释了创建类的旧方法，因为这更清楚地展示了在幕后使类起作用的原理。一旦我们解释了这些基础知识，我们将转而开始使用新的简化类定义语法。
- en: If you’re familiar with strongly typed object-oriented programming languages
    like Java or C++, you’ll notice that JavaScript classes are quite different from
    classes in those languages. There are some syntactic similarities, and you can
    emulate many features of “classical” classes in JavaScript, but it is best to
    understand up front that JavaScript’s classes and prototype-based inheritance
    mechanism are substantially different from the classes and class-based inheritance
    mechanism of Java and similar languages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉像Java或C++这样的强类型面向对象编程语言，您会注意到JavaScript类与这些语言中的类有很大不同。虽然有一些语法上的相似之处，并且您可以在JavaScript中模拟许多“经典”类的特性，但最好事先了解JavaScript的类和基于原型的继承机制与Java和类似语言的类和基于类的继承机制有很大不同。
- en: 9.1 Classes and Prototypes
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 类和原型
- en: 'In JavaScript, a class is a set of objects that inherit properties from the
    same prototype object. The prototype object, therefore, is the central feature
    of a class. [Chapter 6](ch06.xhtml#objects) covered the `Object.create()` function
    that returns a newly created object that inherits from a specified prototype object.
    If we define a prototype object and then use `Object.create()` to create objects
    that inherit from it, we have defined a JavaScript class. Usually, the instances
    of a class require further initialization, and it is common to define a function
    that creates and initializes the new object. [Example 9-1](#range1.js) demonstrates
    this: it defines a prototype object for a class that represents a range of values
    and also defines a *factory function* that creates and initializes a new instance
    of the class.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，类是一组从同一原型对象继承属性的对象。因此，原型对象是类的核心特征。[第6章](ch06.xhtml#objects)介绍了`Object.create()`函数，该函数返回一个从指定���型对象继承的新创建对象。如果我们定义一个原型对象，然后使用`Object.create()`创建从中继承的对象，我们就定义了一个JavaScript类。通常，类的实例需要进一步初始化，通常定义一个函数来创建和初始化新对象。[示例9-1](#range1.js)演示了这一点：它定义了一个代表值范围的类的原型对象，并定义了一个*工厂函数*，用于创建和初始化类的新实例。
- en: Example 9-1\. A simple JavaScript class
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-1 一个简单的JavaScript类
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a few things worth noting in the code of [Example 9-1](#range1.js):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例9-1](#range1.js)的代码中有一些值得注意的事项：
- en: This code defines a factory function `range()` for creating new Range objects.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码定义了一个用于创建新Range对象的工厂函数`range()`。
- en: It uses the `methods` property of this `range()` function as a convenient place
    to store the prototype object that defines the class. There is nothing special
    or idiomatic about putting the prototype object here.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用了`range()`函数的`methods`属性作为一个方便的存储原型对象的地方，该原型对象定义了类。将原型对象放在这里并没有什么特殊或成语化的地方。
- en: The `range()` function defines `from` and `to` properties on each Range object.
    These are the unshared, noninherited properties that define the unique state of
    each individual Range object.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range()`函数在每个Range对象上定义了`from`和`to`属性。这些是定义每个独立Range对象的唯一状态的非共享、非继承属性。'
- en: The `range.methods` object uses the ES6 shorthand syntax for defining methods,
    which is why you don’t see the `function` keyword anywhere. (See [§6.10.5](ch06.xhtml#object-literal-shorthand-methods)
    to review object literal shorthand method syntax.)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range.methods`对象使用了ES6的简写语法来定义方法，这就是为什么你在任何地方都看不到`function`关键字的原因。（查看[§6.10.5](ch06.xhtml#object-literal-shorthand-methods)来回顾对象字面量简写方法语法。）'
- en: One of the methods in the prototype has the computed name ([§6.10.2](ch06.xhtml#computed-property-names))
    `Symbol.iterator`, which means that it is defining an iterator for Range objects.
    The name of this method is prefixed with `*`, which indicates that it is a generator
    function instead of a regular function. Iterators and generators are covered in
    detail in [Chapter 12](ch12.xhtml#itergene). For now, the upshot is that instances
    of this Range class can be used with the `for/of` loop and with the `...` spread
    operator.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型中的一个方法具有计算名称（[§6.10.2](ch06.xhtml#computed-property-names)），即`Symbol.iterator`，这意味着它正在为Range对象定义一个迭代器。这个方法的名称前缀为`*`，表示它是一个生成器函数而不是常规函数。迭代器和生成器在[第12章](ch12.xhtml#itergene)中有详细介绍。目前，要点是这个Range类的实例可以与`for/of`循环和`...`扩展运算符一起使用。
- en: The shared, inherited methods defined in `range.methods` all use the `from`
    and `to` properties that were initialized in the `range()` factory function. In
    order to refer to them, they use the `this` keyword to refer to the object through
    which they were invoked. This use of `this` is a fundamental characteristic of
    the methods of any class.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`range.methods`中定义的共享的继承方法都使用了在`range()`工厂函数中初始化的`from`和`to`属性。为了引用它们，它们使用`this`关键字来引用通过其调用的对象。这种对`this`的使用是任何类的方法的基本特征。
- en: 9.2 Classes and Constructors
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 类和构造函数
- en: '[Example 9-1](#range1.js) demonstrates a simple way to define a JavaScript
    class. It is not the idiomatic way to do so, however, because it did not define
    a *constructor*. A constructor is a function designed for the initialization of
    newly created objects. Constructors are invoked using the `new` keyword as described
    in [§8.2.3](ch08.xhtml#constructorinvocation). Constructor invocations using `new`
    automatically create the new object, so the constructor itself only needs to initialize
    the state of that new object. The critical feature of constructor invocations
    is that the `prototype` property of the constructor is used as the prototype of
    the new object. [§6.2.3](ch06.xhtml#prototypes) introduced prototypes and emphasized
    that while almost all objects have a prototype, only a few objects have a `prototype`
    property. Finally, we can clarify this: it is function objects that have a `prototype`
    property. This means that all objects created with the same constructor function
    inherit from the same object and are therefore members of the same class. [Example 9-2](#range2.js)
    shows how we could alter the Range class of [Example 9-1](#range1.js) to use a
    constructor function instead of a factory function. [Example 9-2](#range2.js)
    demonstrates the idiomatic way to create a class in versions of JavaScript that
    do not support the ES6 `class` keyword. Even though `class` is well supported
    now, there is still lots of older JavaScript code around that defines classes
    like this, and you should be familiar with the idiom so that you can read old
    code and so that you understand what is going on “under the hood” when you use
    the `class` keyword.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例9-1](#range1.js)演示了定义JavaScript类的一种简单方法。然而，这并不是惯用的做法，因为它没有定义*构造函数*。构造函数是为新创建的对象初始化而设计的函数。构造函数使用`new`关键字调用，如[§8.2.3](ch08.xhtml#constructorinvocation)所述。使用`new`调用构造函数会自动创建新对象，因此构造函数本身只需要初始化该新对象的状态。构造函数调用的关键特征是构造函数的`prototype`属性被用作新对象的原型。[§6.2.3](ch06.xhtml#prototypes)介绍了原型并强调，几乎所有对象都有一个原型，但只有少数对象有一个`prototype`属性。最后，我们可以澄清这一点：函数对象具有`prototype`属性。这意味着使用相同构造函数创建的所有对象都继承自同一个对象，因此它们是同一类的成员。[示例9-2](#range2.js)展示了如何修改[示��9-1](#range1.js)的Range类以使用构造函数而不是工厂函数。[示例9-2](#range2.js)展示了在不支持ES6
    `class`关键字的JavaScript版本中创建类的惯用方法。即使现在`class`得到了很好的支持，仍然有很多旧的JavaScript代码定义类的方式就像这样，你应该熟悉这种习惯用法，这样你就可以阅读旧代码，并且当你使用`class`关键字时，你能理解发生了什么“底层”操作。'
- en: Example 9-2\. A Range class using a constructor
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-2。使用构造函数的Range类
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is worth comparing Examples [9-1](#range1.js) and [9-2](#range2.js) fairly
    carefully and noting the differences between these two techniques for defining
    classes. First, notice that we renamed the `range()` factory function to `Range()`
    when we converted it to a constructor. This is a very common coding convention:
    constructor functions define, in a sense, classes, and classes have names that
    (by convention) begin with capital letters. Regular functions and methods have
    names that begin with lowercase letters.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 值得仔细比较示例[9-1](#range1.js)和[9-2](#range2.js)，并注意这两种定义类的技术之间的区别。首先，注意到我们将`range()`工厂函数重命名为`Range()`当我们将其转换为构造函数时。这是一个非常常见的编码约定：构造函数在某种意义上定义了类，而类的名称（按照约定）以大写字母开头。常规函数和方法的名称以小写字母开头。
- en: Next, notice that the `Range()` constructor is invoked (at the end of the example)
    with the `new` keyword while the `range()` factory function was invoked without
    it. [Example 9-1](#range1.js) uses regular function invocation ([§8.2.1](ch08.xhtml#functioninvocation))
    to create the new object, and [Example 9-2](#range2.js) uses constructor invocation
    ([§8.2.3](ch08.xhtml#constructorinvocation)). Because the `Range()` constructor
    is invoked with `new`, it does not have to call `Object.create()` or take any
    action to create a new object. The new object is automatically created before
    the constructor is called, and it is accessible as the `this` value. The `Range()`
    constructor merely has to initialize `this`. Constructors do not even have to
    return the newly created object. Constructor invocation automatically creates
    a new object, invokes the constructor as a method of that object, and returns
    the new object. The fact that constructor invocation is so different from regular
    function invocation is another reason that we give constructors names that start
    with capital letters. Constructors are written to be invoked as constructors,
    with the `new` keyword, and they usually won’t work properly if they are invoked
    as regular functions. A naming convention that keeps constructor functions distinct
    from regular functions helps programmers know when to use `new`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，请注意在示例末尾使用`new`关键字调用`Range()`构造函数，而`range()`工厂函数在没有使用`new`的情况下调用。[示例9-1](#range1.js)使用常规函数调用([§8.2.1](ch08.xhtml#functioninvocation))创建新对象，而[示例9-2](#range2.js)使用构造函数调用([§8.2.3](ch08.xhtml#constructorinvocation))。因为使用`new`调用`Range()`构造函数，所以不需要调用`Object.create()`或采取任何操作来创建新对象。新对象在构造函数调用之前自动创建，并且可以作为`this`值访问。`Range()`构造函数只需初始化`this`。构造函数甚至不必返回新创建的对象。构造函数调用会自动创建一个新对象，将构造函数作为该对象的方法调用，并返回新对象。构造函数调用与常规函数调用如此不同的事实是我们给构造函数名称以大写字母开头的另一个原因。构造函数被编写为以构造函数方式调用，并且如果以常规函数方式调用，它们通常不会正常工作。将构造函数函数与常规函数区分开的命名约定有助于程序员知道何时使用`new`。
- en: Another critical difference between Examples [9-1](#range1.js) and [9-2](#range2.js)
    is the way the prototype object is named. In the first example, the prototype
    was `range.methods`. This was a convenient and descriptive name, but arbitrary.
    In the second example, the prototype is `Range.prototype`, and this name is mandatory.
    An invocation of the `Range()` constructor automatically uses `Range.prototype`
    as the prototype of the new Range object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 示例[9-1](#range1.js)和[9-2](#range2.js)之间的另一个关键区别是原型对象的命名方式。在第一个示例中，原型是`range.methods`。这是一个方便且描述性强的名称，但是任意的。在第二个示例中，原型是`Range.prototype`，这个名称是强制的。对`Range()`构造函数的调用会自动使用`Range.prototype`作为新Range对象的原型。
- en: 'Finally, also note the things that do not change between Examples [9-1](#range1.js)
    and [9-2](#range2.js) : the range methods are defined and invoked in the same
    way for both classes. Because [Example 9-2](#range2.js) demonstrates the idiomatic
    way to create classes in versions of JavaScript before ES6, it does not use the
    ES6 shorthand method syntax in the prototype object and explicitly spells out
    the methods with the `function` keyword. But you can see that the implementation
    of the methods is the same in both examples.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还要注意示例[9-1](#range1.js)和[9-2](#range2.js)之间没有变化的地方：两个类的范围方法的定义和调用方式是相同的。因为[示例9-2](#range2.js)演示了在ES6之前JavaScript版本中创建类的惯用方式，它没有在原型对象中使用ES6的简写方法语法，并且明确用`function`关键字拼写出方法。但你可以看到两个示例中方法的实现是相同的。
- en: Importantly, note that neither of the two range examples uses arrow functions
    when defining constructors or methods. Recall from [§8.1.3](ch08.xhtml#arrowfunctions)
    that functions defined in this way do not have a `prototype` property and so cannot
    be used as constructors. Also, arrow functions inherit the `this` keyword from
    the context in which they are defined rather than setting it based on the object
    through which they are invoked, and this makes them useless for methods because
    the defining characteristic of methods is that they use `this` to refer to the
    instance on which they were invoked.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，要注意两个范围示例在定义构造函数或方法时都没有使用箭头函数。回想一下[§8.1.3](ch08.xhtml#arrowfunctions)中提到的，以这种方式定义的函数没有`prototype`属性，因此不能用作构造函数。此外，箭头函数从定义它们的上下文中继承`this`关键字，而不是根据调用它们的对象设置它，这使它们对于方法是无用的，因为方法的定义特征是它们使用`this`来引用被调用的实例。
- en: Fortunately, the new ES6 class syntax doesn’t allow the option of defining methods
    with arrow functions, so this is not a mistake that you can accidentally make
    when using that syntax. We will cover the ES6 `class` keyword soon, but first,
    there are more details to cover about constructors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，新的ES6类语法不允许使用箭头函数定义方法，因此在使用该语法时不会出现这种错误。我们很快将介绍ES6的`class`关键字，但首先，还有更多关于构造函数的细节需要讨论。
- en: 9.2.1 Constructors, Class Identity, and instanceof
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.1 构造函数、类标识和instanceof
- en: 'As we’ve seen, the prototype object is fundamental to the identity of a class:
    two objects are instances of the same class if and only if they inherit from the
    same prototype object. The constructor function that initializes the state of
    a new object is not fundamental: two constructor functions may have `prototype`
    properties that point to the same prototype object. Then, both constructors can
    be used to create instances of the same class.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，原型对象对于类的标识是至关重要的：两个对象只有在它们继承自相同的原型对象时才是同一类的实例。初始化新对象状态的构造函数并不是基本的：两个构造函数可能具有指向相同原型对象的`prototype`属性。然后，这两个构造函数都可以用于创建同一类的实例。
- en: 'Even though constructors are not as fundamental as prototypes, the constructor
    serves as the public face of a class. Most obviously, the name of the constructor
    function is usually adopted as the name of the class. We say, for example, that
    the `Range()` constructor creates Range objects. More fundamentally, however,
    constructors are used as the righthand operand of the `instanceof` operator when
    testing objects for membership in a class. If we have an object `r` and want to
    know if it is a Range object, we can write:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管构造函数不像原型那样基础，但构造函数作为类的公共面孔。最明显的是，构造函数的名称通常被采用为类的名称。例如，我们说 `Range()` 构造函数创建
    Range 对象。然而，更根本的是，构造函数在测试对象是否属于类时作为 `instanceof` 运算符的右操作数。如果我们有一个对象 `r` 并想知道它是否是
    Range 对象，我们可以写：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `instanceof` operator was described in [§4.9.4](ch04.xhtml#instanceof).
    The lefthand operand should be the object that is being tested, and the righthand
    operand should be a constructor function that names a class. The expression `o
    instanceof C` evaluates to `true` if `o` inherits from `C.prototype`. The inheritance
    need not be direct: if `o` inherits from an object that inherits from an object
    that inherits from `C.prototype`, the expression will still evaluate to `true`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 运算符在 [§4.9.4](ch04.xhtml#instanceof) 中有描述。左操作数应该是正在测试的对象，右操作数应该是命名类的构造函数。表达式
    `o instanceof C` 在 `o` 继承自 `C.prototype` 时求值为 `true`。继承不必是直接的：如果 `o` 继承自继承自继承自
    `C.prototype` 的对象，表达式仍将求值为 `true`。'
- en: 'Technically speaking, in the previous code example, the `instanceof` operator
    is not checking whether `r` was actually initialized by the `Range` constructor.
    Instead, it is checking whether `r` inherits from `Range.prototype`. If we define
    a function `Strange()` and set its prototype to be the same as `Range.prototype`,
    then objects created with `new Strange()` will count as Range objects as far as
    `instanceof` is concerned (they won’t actually work as Range objects, however,
    because their `from` and `to` properties have not been initialized):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在前面的代码示例中，`instanceof` 运算符并不是在检查 `r` 是否实际由 `Range` 构造函数初始化。相反，它是在检查 `r`
    是否继承自 `Range.prototype`。如果我们定义一个函数 `Strange()` 并将其原型设置为与 `Range.prototype` 相同，那么使用
    `new Strange()` 创建的对象在 `instanceof` 方面将被视为 Range 对象（但实际上它们不会像 Range 对象一样工作，因为它们的
    `from` 和 `to` 属性尚未初始化）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even though `instanceof` cannot actually verify the use of a constructor, it
    still uses a constructor function as its righthand side because constructors are
    the public identity of a class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `instanceof` 无法实际验证构造函数的使用，但它仍将构造函数作为其右操作数，因为构造函数是类的公共标识。
- en: 'If you want to test the prototype chain of an object for a specific prototype
    and do not want to use the constructor function as an intermediary, you can use
    the `isPrototypeOf()` method. In [Example 9-1](#range1.js), for example, we defined
    a class without a constructor function, so there is no way to use `instanceof`
    with that class. Instead, however, we could test whether an object `r` was a member
    of that constructor-less class with this code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要测试对象的原型链以查找特定原型而不想使用构造函数作为中介，可以使用 `isPrototypeOf()` 方法。例如，在 [示例 9-1](#range1.js)
    中，我们定义了一个没有构造函数的类，因此无法使用该类的 `instanceof`。然而，我们可以使用以下代码测试对象 `r` 是否是该无构造函数类的成员：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 9.2.2 The constructor Property
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2.2 构造函数属性
- en: 'In [Example 9-2](#range2.js), we set `Range.prototype` to a new object that
    contained the methods for our class. Although it was convenient to express those
    methods as properties of a single object literal, it was not actually necessary
    to create a new object. Any regular JavaScript function (excluding arrow functions,
    generator functions, and async functions) can be used as a constructor, and constructor
    invocations need a `prototype` property. Therefore, every regular JavaScript function^([1](ch09.xhtml#idm46198535317032))
    automatically has a `prototype` property. The value of this property is an object
    that has a single, non-enumerable `constructor` property. The value of the `constructor`
    property is the function object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 9-2](#range2.js) 中，我们将 `Range.prototype` 设置为一个包含我们类方法的新对象。虽然将这些方法表达为单个对象字面量的属性很方便，但实际上并不需要创建一个新对象。任何常规的
    JavaScript 函数（不包括箭头函数、生成器函数和异步函数）都可以用作构造函数，并且构造函数调用需要一个 `prototype` 属性。因此，每个常规的
    JavaScript 函数^([1](ch09.xhtml#idm46198535317032)) 自动具有一个 `prototype` 属性。该属性的值是一个具有单个、不可枚举的
    `constructor` 属性的对象。`constructor` 属性的值是函数对象：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The existence of this predefined prototype object with its `constructor` property
    means that objects typically inherit a `constructor` property that refers to their
    constructor. Since constructors serve as the public identity of a class, this
    constructor property gives the class of an object:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 具有预定义原型对象及其 `constructor` 属性的存在意味着对象通常继承一个指向其构造函数的 `constructor` 属性。由于构造函数作为类的公共标识，这个构造函数属性给出了对象的类：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 9-1](#prototypefig) illustrates this relationship between the constructor
    function, its prototype object, the back reference from the prototype to the constructor,
    and the instances created with the constructor.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#prototypefig)展示了构造函数、其原型对象、原型指向构造函数的反向引用以及使用构造函数创建的实例之间的关系。'
- en: '![js7e 0901](Images/js7e_0901.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 0901](Images/js7e_0901.png)'
- en: Figure 9-1\. A constructor function, its prototype, and instances
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. 一个构造函数、其原型和实例
- en: 'Notice that [Figure 9-1](#prototypefig) uses our `Range()` constructor as an
    example. In fact, however, the Range class defined in [Example 9-2](#range2.js)
    overwrites the predefined `Range.prototype` object with an object of its own.
    And the new prototype object it defines does not have a `constructor` property.
    So instances of the Range class, as defined, do not have a `constructor` property.
    We can remedy this problem by explicitly adding a constructor to the prototype:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[图9-1](#prototypefig)使用我们的`Range()`构造函数作为示例。实际上，然而，在[示例9-2](#range2.js)中定义的Range类覆盖了预定义的`Range.prototype`对象为自己的对象。并且它定义的新原型对象没有`constructor`属性。因此，如定义的Range类的实例没有`constructor`属性。我们可以通过显式向原型添加构造函数来���决这个问题：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another common technique that you are likely to see in older JavaScript code
    is to use the predefined prototype object with its `constructor` property and
    add methods to it one at a time with code like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在旧版JavaScript代码中常见的技术是使用预定义的原型对象及其具有`constructor`属性，并使用以下代码逐个添加方法：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 9.3 Classes with the class Keyword
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 使用`class`关键字的类
- en: Classes have been part of JavaScript since the very first version of the language,
    but in ES6, they finally got their own syntax with the introduction of the `class`
    keyword. [Example 9-3](#range3.js) shows what our Range class looks like when
    written with this new syntax.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 类自从语言的第一个版本以来就一直是JavaScript的一部分，但在ES6中，它们终于得到了自己的语法，引入了`class`关键字。[示例9-3](#range3.js)展示了使用这种新语法编写的Range类的样子。
- en: Example 9-3\. The Range class rewritten using *class*
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3. 使用*class*重写的Range类
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is important to understand that the classes defined in Examples [9-2](#range2.js)
    and [9-3](#range3.js) work in exactly the same way. The introduction of the `class`
    keyword to the language does not alter the fundamental nature of JavaScript’s
    prototype-based classes. And although [Example 9-3](#range3.js) uses the `class`
    keyword, the resulting Range object is a constructor function, just like the version
    defined in [Example 9-2](#range2.js). The new `class` syntax is clean and convenient
    but is best thought of as “syntactic sugar” for the more fundamental class definition
    mechanism shown in [Example 9-2](#range2.js).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在示例[9-2](#range2.js)和[9-3](#range3.js)中定义的类的工作方式完全相同。引入`class`关键字到语言中并不改变JavaScript基于原型的类的基本性质。尽管[示例9-3](#range3.js)使用了`class`关键字，但生成的Range对象是一个构造函数，就像在[示例9-2](#range2.js)中定义的版本一样。新的`class`语法干净方便，但最好将其视为对在[示例9-2](#range2.js)中显示的更基本的类定义机制的“语法糖”。
- en: 'Note the following things about the class syntax in [Example 9-3](#range3.js):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[示例9-3](#range3.js)中类语法的以下几点：
- en: The class is declared with the `class` keyword, which is followed by the name
    of class and a class body in curly braces.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`class`关键字声明类，后面跟着类名和用大括号括起来的类体。
- en: The class body includes method definitions that use object literal method shorthand
    (which we also used in [Example 9-1](#range1.js)), where the `function` keyword
    is omitted. Unlike object literals, however, no commas are used to separate the
    methods from each other. (Although class bodies are superficially similar to object
    literals, they are not the same thing. In particular, they do not support the
    definition of properties with name/value pairs.)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类体包括使用对象字面量方法简写的方法定义（我们在[示例9-1](#range1.js)中也使用了），其中省略了`function`关键字。然而，与对象字面量不同，没有逗号用于将方法彼此分隔开。
    （尽管类体在表面上与对象字面量相似，但它们并不是同一回事。特别是，它们不支持使用名称/值对定义属性。）
- en: The keyword `constructor` is used to define the constructor function for the
    class. The function defined is not actually named “constructor”, however. The
    `class` declaration statement defines a new variable `Range` and assigns the value
    of this special `constructor` function to that variable.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`constructor`用于为类定义构造函数。但实际上定义的函数并不真正命名为“constructor”。`class`声明语句定义了一个新变量`Range`，并将这个特殊的`constructor`函数的值赋给该变量。
- en: If your class does not need to do any initialization, you can omit the `constructor`
    keyword and its body, and an empty constructor function will be implicitly created
    for you.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的类不需要进行任何初始化，你可以省略`constructor`关键字及其主体，将为你隐式创建一个空的构造函数。
- en: 'If you want to define a class that subclasses—or *inherits from*—another class,
    you can use the `extends` keyword with the `class` keyword:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想定义一个继承自另一个类的类，你可以使用`extends`关键字和`class`关键字：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating subclasses is a whole topic of its own. We’ll return to it, and explain
    the `extends` and `super` keywords shown here, in [§9.5](#subclasses).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子类是一个独立的主题。我们将在[§9.5](#subclasses)中返回并解释这里显示的`extends`和`super`关键字。
- en: 'Like function declarations, class declarations have both statement and expression
    forms. Just as we can write:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明与函数声明一样，既有语句形式又有表达式形式。就像我们可以写：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'we can also write:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以写：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As with function definition expressions, class definition expressions can include
    an optional class name. If you provide such a name, that name is only defined
    within the class body itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数定义表达式一样，类定义表达式可以包括一个可选的类名。如果提供了这样的名称，那个名称仅在类体内部定义。
- en: Although function expressions are quite common (particularly with the arrow
    function shorthand), in JavaScript programming, class definition expressions are
    not something that you are likely to use much unless you find yourself writing
    a function that takes a class as its argument and returns a subclass.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数表达式非常常见（特别是使用箭头函数简写），在JavaScript编程中，类定义表达式不是你经常使用的东西，除非你发现自己正在编写一个以类作为参数并返回子类的函数。
- en: 'We’ll conclude this introduction to the `class` keyword by mentioning a couple
    of important things you should know that are not apparent from `class` syntax:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过提及一些重要的事项来结束对`class`关键字的介绍，这些事项从`class`语法中并不明显：
- en: All code within the body of a `class` declaration is implicitly in strict mode
    ([§5.6.3](ch05.xhtml#strictmode)), even if no `"use strict"` directive appears.
    This means, for example, that you can’t use octal integer literals or the `with`
    statement within class bodies and that you are more likely to get syntax errors
    if you forget to declare a variable before using it.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`声明体内的所有代码都隐式地处于严格模式中（[§5.6.3](ch05.xhtml#strictmode)），即使没有出现`"use strict"`指令。这意味着，例如，你不能在类体内使用八进制整数字面量或`with`语句，并且如果你忘记在使用之前声明一个变量，你更有可能得到语法错误。'
- en: 'Unlike function declarations, class declarations are not “hoisted.” Recall
    from [§8.1.1](ch08.xhtml#functiondeclarations) that function definitions behave
    as if they had been moved to the top of the enclosing file or enclosing function,
    meaning that you can invoke a function in code that comes before the actual definition
    of the function. Although class declarations are like function declarations in
    some ways, they do not share this hoisting behavior: you *cannot* instantiate
    a class before you declare it.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与函数声明不同，类声明不会“被提升”。回想一下[§8.1.1](ch08.xhtml#functiondeclarations)中提到的函数定义行为，就好像它们已经被移动到了包含文件或包含函数的顶部，这意味着你可以在实际函数定义之前的代码中调用函数。尽管类声明在某些方面类似于函数声明，但它们不共享这种提升行为：你*不能*在声明类之前实例化它。
- en: 9.3.1 Static Methods
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.1 静态方法
- en: You can define a static method within a `class` body by prefixing the method
    declaration with the `static` keyword. Static methods are defined as properties
    of the constructor function rather than properties of the prototype object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在`class`体中的方法声明前加上`static`关键字来定义一个静态方法。静态方法被定义为构造函数的属性，而不是原型对象的属性。
- en: 'For example, suppose we added the following code to [Example 9-3](#range3.js):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在[示例 9-3](#range3.js)中添加了以下代码：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The method defined by this code is `Range.parse()`, not `Range.prototype.parse()`,
    and you must invoke it through the constructor, not through an instance:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义的方法是`Range.parse()`，而不是`Range.prototype.parse()`，你必须通过构造函数调用它，而不是通过实例调用：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ll sometimes see static methods called *class methods* because they are
    invoked using the name of the class/constructor. When this term is used, it is
    to contrast class methods with the regular *instance methods* that are invoked
    on instances of the class. Because static methods are invoked on the constructor
    rather than on any particular instance, it almost never makes sense to use the
    `this` keyword in a static method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会看到静态方法被称为*类方法*，因为它们是使用类/构造函数的名称调用的。当使用这个术语时，是为了将类方法与在类的实例上调用的常规*实例方法*进行对比。因为静态方法是在构造函数上调用而不是在任何特定实例上调用，所以在静态方法中几乎不可能使用`this`关键字。
- en: We’ll see examples of static methods in [Example 9-4](#Complex.js).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[示例 9-4](#Complex.js)中看到静态方法的示例。
- en: 9.3.2 Getters, Setters, and other Method Forms
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.2 获取器、设置器和其他方法形式
- en: Within a `class` body, you can define getter and setter methods ([§6.10.6](ch06.xhtml#gettersandsetters))
    just as you can in object literals. The only difference is that in class bodies,
    you don’t put a comma after the getter or setter. [Example 9-4](#Complex.js) includes
    a practical example of a getter method in a class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`class`体内，你可以像在对象字面量中一样定义获取器和设置器方法（[§6.10.6](ch06.xhtml#gettersandsetters)），唯一的区别是在类体中，你不在获取器或设置器后面加逗号。[示例 9-4](#Complex.js)包括了一个类中获取器方法的实际示例。
- en: 'In general, all of the shorthand method definition syntaxes allowed in object
    literals are also allowed in class bodies. This includes generator methods (marked
    with `*`) and methods whose names are the value of an expression in square brackets.
    In fact, you’ve already seen (in [Example 9-3](#range3.js)) a generator method
    with a computed name that makes the Range class iterable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在对象字面量中允许的所有简写方法定义语法在类体中也是允许的。这包括生成器方法（用`*`标记）和方法的名称是方括号中表达式的值的方法。事实上，你已经在[示例 9-3](#range3.js)中看到了一个具有计算名称的生成器方法，使得
    Range 类可迭代：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 9.3.3 Public, Private, and Static Fields
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.3 公共、私有和静态字段
- en: In the discussion here of classes defined with the `class` keyword, we have
    only described the definition of methods within the class body. The ES6 standard
    only allows the creation of methods (including getters, setters, and generators)
    and static methods; it does not include syntax for defining fields. If you want
    to define a field (which is just an object-oriented synonym for “property”) on
    a class instance, you must do that in the constructor function or in one of the
    methods. And if you want to define a static field for a class, you must do that
    outside the class body, after the class has been defined. [Example 9-4](#Complex.js)
    includes examples of both kinds of fields.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里讨论使用`class`关键字定义的类时，我们只描述了类体内的方法定义。ES6标准只允许创建方法（包括获取器、设置器和生成器）和静态方法；它不包括定义字段的语法。如果你想在类实例上定义一个字段（这只是面向对象的“属性”同义词），你必须在构造函数中或在其中一个方法中进行定义。如果你想为一个类定义一个静态字段，你必须在类体之外，在类定义之后进行定义。[示例 9-4](#Complex.js)包括了这两种字段的示例。
- en: Standardization is underway, however, for extended class syntax that allows
    the definition of instance and static fields, in both public and private forms.
    The code shown in the rest of this section is not yet standard JavaScript as of
    early 2020 but is already supported in Chrome and partially supported (public
    instance fields only) in Firefox. The syntax for public instance fields is in
    common use by JavaScript programmers using the React framework and the Babel transpiler.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，标准化正在进行中，允许扩展类语法来定义实例和静态字段，包括公共和私有形式。截至2020年初，本节其余部分展示的代码尚不是标准JavaScript，但已经在Chrome中得到支持，并在Firefox中部分支持（仅支持公共实例字段）。公共实例字段的语法已经被使用React框架和Babel转译器的JavaScript程序员广泛使用。
- en: 'Suppose you’re writing a class like this one, with a constructor that initializes
    three fields:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个像这样的类，其中包含一个初始化三个字段的构造函数：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the new instance field syntax that is likely to be standardized, you could
    instead write:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可能会被标准化的新实例字段语法，你可以这样写：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The field initialization code has moved out of the constructor and now appears
    directly in the class body. (That code is still run as part of the constructor,
    of course. If you do not define a constructor, the fields are initialized as part
    of the implicitly created constructor.) The `this.` prefixes that appeared on
    the lefthand side of the assignments are gone, but note that you still must use
    `this.` to refer to these fields, even on the righthand side of the initializer
    assignments. The advantage of initializing your instance fields in this way is
    that this syntax allows (but does not require) you to put the initializers up
    at the top of the class definition, making it clear to readers exactly what fields
    will hold the state of each instance. You can declare fields without an initializer
    by just writing the name of the field followed by a semicolon. If you do that,
    the initial value of the field will be `undefined`. It is better style to always
    make the initial value explicit for all of your class fields.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 字段初始化代码已经从构造函数中移出，现在直接出现在类体中。（当然，该代码仍然作为构造函数的一部分运行。如果你没有定义构造函数，那么字段将作为隐式创建的构造函数的一部分进行初始化。）出现在赋值左侧的`this.`前缀已经消失，但请注意，即使在初始化赋值的右侧，你仍然必须使用`this.`来引用这些字段。以这种方式初始化实例字段的优势在于，这种语法允许（但不要求）你将初始化器放在类定义的顶部，清楚地告诉读者每个实例的状态将由哪些字段保存。你可以通过只写字段名称后跟一个分号来声明没有初始化器的字段。如果这样做，字段的初始值将为`undefined`。对于所有类字段，始终明确指定初始值是更好的风格。
- en: Before the addition of this field syntax, class bodies looked a lot like object
    literals using shortcut method syntax, except that the commas had been removed.
    This field syntax—with equals signs and semicolons instead of colons and commas—makes
    it clear that class bodies are not at all the same as object literals.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此字段语法之前，类体看起来很像使用快捷方法语法的对象文字，只是逗号已被移除。这种带有等号和分号而不是冒号和逗号的字段语法清楚地表明类体与对象文字完全不同。
- en: 'The same proposal that seeks to standardize these instance fields also defines
    private instance fields. If you use the instance field initialization syntax shown
    in the previous example to define a field whose name begins with `#` (which is
    not normally a legal character in JavaScript identifiers), that field will be
    usable (with the `#` prefix) within the class body but will be invisible and inaccessible
    (and therefore immutable) to any code outside of the class body. If, for the preceding
    hypothetical Buffer class, you wanted to ensure that users of the class could
    not inadvertently modify the `size` field of an instance, you could use a private
    `#size` field instead, then define a getter function to provide read-only access
    to the value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与寻求标准化这些实例字段的提案相同，还定义了私有实例字段。如果你使用前面示例中显示的实例字段初始化语法来定义一个以`#`开头的字段（这在 JavaScript
    标识符中通常不是合法字符），那么该字段将可以在类体内（带有`#`前缀）使用，但对于类体外的任何代码来说是不可见和不可访问的（因此是不可变的）。如果对于前面的假设的
    Buffer 类，你希望确保类的用户不能无意中修改实例的`size`字段，那么你可以使用一个私有的`#size`字段，然后定义一个获取器函数来提供只读访问权限：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that private fields must be declared using this new field syntax before
    they can be used. You can’t just write `this.#size = 0;` in the constructor of
    a class unless you include a “declaration” of the field directly in the class
    body.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，私有字段必须在使用之前使用这种新字段语法进行声明。除非在类体中直接包含字段的“声明”，否则不能在类的构造函数中只写`this.#size = 0;`。
- en: 'Finally, a related proposal seeks to standardize the use of the `static` keyword
    for fields. If you add `static` before a public or private field declaration,
    those fields will be created as properties of the constructor function instead
    of properties of instances. Consider the static `Range.parse()` method we’ve defined.
    It included a fairly complex regular expression that might be good to factor out
    into its own static field. With the proposed new static field syntax, we could
    do that like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个相关的提案旨在标准化`static`关键字用于字段。如果在公共或私有字段声明之前添加`static`，那么这些字段将作为构造函数的属性而不是实例的属性创���。考虑我们定义的静态`Range.parse()`方法。它包含一个可能很好地分解为自己的静态字段的相当复杂的正则表达式。使用提议的新静态字段语法，我们可以这样做：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we wanted this static field to be accessible only within the class, we could
    make it private using a name like `#pattern`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望这个静态字段只能在类内部访问，我们可以使用类似`#pattern`的私有名称。
- en: '9.3.4 Example: A Complex Number Class'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3.4 示例：复数类
- en: '[Example 9-4](#Complex.js) defines a class to represent complex numbers. The
    class is a relatively simple one, but it includes instance methods (including
    getters), static methods, instance fields, and static fields. It includes some
    commented-out code demonstrating how we might use the not-yet-standard syntax
    for defining instance fields and static fields within the class body.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-4](#Complex.js) 定义了一个表示复数的类。这个类相对简单，但包括实例方法（包括获取器）、静态方法、实例字段和静态字段。它包含了一些被注释掉的代码，演示了我们如何使用尚未标准化的语法来在类体内定义实例字段和静态字段。'
- en: 'Example 9-4\. Complex.js: a complex number class'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. Complex.js：一个复数类
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the Complex class of [Example 9-4](#Complex.js) defined, we can use the
    constructor, instance fields, instance methods, class fields, and class methods
    with code like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例 9-4](#Complex.js) 中定义的 Complex 类，我们可以使用构造函数、实例字段、实例方法、类字段和类方法的代码如下：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 9.4 Adding Methods to Existing Classes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 为现有类添加方法
- en: 'JavaScript’s prototype-based inheritance mechanism is dynamic: an object inherits
    properties from its prototype, even if the properties of the prototype change
    after the object is created. This means that we can augment JavaScript classes
    simply by adding new methods to their prototype objects.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的基于原型的继承机制是动态的：一个对象从其原型继承属性，即使原型的属性在对象创建后发生变化。这意味着我们可以通过简单地向其原型对象添加新方法来增强JavaScript类。
- en: 'Here, for example, is code that adds a method for computing the complex conjugate
    to the Complex class of [Example 9-4](#Complex.js):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是为计算复共轭添加一个方法到[示例 9-4](#Complex.js)的Complex类的代码：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The prototype object of built-in JavaScript classes is also open like this,
    which means that we can add methods to numbers, strings, arrays, functions, and
    so on. This is useful for implementing new language features in older versions
    of the language:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内置类的原型对象也是开放的，这意味着我们可以向数字、字符串、数组、函数等添加方法。这对于在语言的旧版本中实现新的语言特性很有用：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is another example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding methods to the prototypes of built-in types like this is generally considered
    to be a bad idea because it will cause confusion and compatibility problems in
    the future if a new version of JavaScript defines a method with the same name.
    It is even possible to add methods to `Object.prototype`, making them available
    for all objects. But this is never a good thing to do because properties added
    to `Object.prototype` are visible to `for/in` loops (though you can avoid this
    by using `Object.defineProperty()` [[§14.1](ch14.xhtml#propertydescriptors)] to
    make the new property non-enumerable).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样向内置类型的原型添加方法通常被认为是一个坏主意，因为如果JavaScript的新版本定义了同名方法，将会导致混乱和兼容性问题。甚���可以向`Object.prototype`添加方法，使其对所有对象可用。但这绝不是一个好主意，因为添加到`Object.prototype`的属性对`for/in`循环可见（尽管您可以通过使用`Object.defineProperty()`[[§14.1](ch14.xhtml#propertydescriptors)]使新属性不可枚举来避免这种情况）。
- en: 9.5 Subclasses
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 子类
- en: In object-oriented programming, a class B can *extend* or *subclass* another
    class A. We say that A is the *superclass* and B is the *subclass*. Instances
    of B inherit the methods of A. The class B can define its own methods, some of
    which may *override* methods of the same name defined by class A. If a method
    of B overrides a method of A, the overriding method in B often needs to invoke
    the overridden method in A. Similarly, the subclass constructor `B()` must typically
    invoke the superclass constructor `A()` in order to ensure that instances are
    completely initialized.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，一个类B可以*扩展*或*子类化*另一个类A。我们说A是*超类*，B是*子类*。B的实例继承A的方法。类B可以定义自己的方法，其中一些可能会*覆盖*类A定义的同名方法。如果B的方法覆盖了A的方法，那么B中的覆盖方法通常需要调用A中被覆盖的方法。同样，子类构造函数`B()`通常必须调用超类构造函数`A()`，以确保实例完全初始化。
- en: This section starts by showing how to define subclasses the old, pre-ES6 way,
    and then quickly moves on to demonstrate subclassing using the `class` and `extends`
    keywords and superclass constructor method invocation with the `super` keyword.
    Next is a subsection about avoiding subclasses and relying on object composition
    instead of inheritance. The section ends with an extended example that defines
    a hierarchy of Set classes and demonstrates how abstract classes can be used to
    separate interface from implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节首先展示了如何以旧的、ES6之前的方式定义子类，然后迅速转向演示使用`class`和`extends`关键字以及使用`super`关键字调用超类构造方法的子类化。接下来是一个关于避免子类化，依靠对象组合而不是继承的子节。本节以一个定义了一系列Set类的扩展示例结束，并演示了如何使用抽象类来将接口与实现分离。
- en: 9.5.1 Subclasses and Prototypes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.1 子类和原型
- en: Suppose we wanted to define a Span subclass of the Range class from [Example 9-2](#range2.js).
    This subclass will work just like a Range, but instead of initializing it with
    a start and an end, we’ll instead specify a start and a distance, or span. An
    instance of this Span class is also an instance of the Range superclass. A span
    instance inherits a customized `toString()` method from `Span.prototype`, but
    in order to be a subclass of Range, it must also inherit methods (such as `includes()`)
    from `Range.prototype`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要定义一个Span子类，继承自[示例 9-2](#range2.js)的Range类。这个子类将像Range一样工作，但不是用起始和结束来初始化，而是指定一个起始和一个距离，或者跨度。Span类的一个实例也是Range超类的一个实例。跨度实例从`Span.prototype`继承了一个定制的`toString()`方法，但为了成为Range的子类，它还必须从`Range.prototype`继承方法（如`includes()`）。
- en: 'Example 9-5\. Span.js: a simple subclass of Range'
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. Span.js：Range的一个简单子类
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In order to make Span a subclass of Range, we need to arrange for `Span.prototype`
    to inherit from `Range.prototype`. The key line of code in the preceding example
    is this one, and if it makes sense to you, you understand how subclasses work
    in JavaScript:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Span成为Range的一个子类，我们需要让`Span.prototype`从`Range.prototype`继承。在前面示例中的关键代码行是这一行，如果这对你有意义，你就理解了JavaScript中子类是如何工作的：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Objects created with the `Span()` constructor will inherit from the `Span.prototype`
    object. But we created that object to inherit from `Range.prototype`, so Span
    objects will inherit from both `Span.prototype` and `Range.prototype`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Span()`构造函数创建的对象将从`Span.prototype`对象继承。但我们创建该对象是为了从`Range.prototype`继承，因此Span对象将同时从`Span.prototype`和`Range.prototype`继承。
- en: You may notice that our `Span()` constructor sets the same `from` and `to` properties
    that the `Range()` constructor does and so does not need to invoke the `Range()`
    constructor to initialize the new object. Similarly, Span’s `toString()` method
    completely re-implements the string conversion without needing to call Range’s
    version of `toString()`. This makes Span a special case, and we can only really
    get away with this kind of subclassing because we know the implementation details
    of the superclass. A robust subclassing mechanism needs to allow classes to invoke
    the methods and constructor of their superclass, but prior to ES6, JavaScript
    did not have a simple way to do these things.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到我们的`Span()`构造函数设置了与`Range()`构造函数相同的`from`和`to`属性，因此不需要调用`Range()`构造函数来初始化新对象。类似地，Span的`toString()`方法完全重新实现了字符串转换，而不需要调用Range的`toString()`版本。这使Span成为一个特殊情况，我们只能在了解超类的实现细节时才能这样做。一个健壮的子类化机制需要允许类调用其超类的方法和构造函数，但在ES6之前，JavaScript没��简单的方法来做这些事情。
- en: Fortunately, ES6 solves these problems with the `super` keyword as part of the
    `class` syntax. The next section demonstrates how it works.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ES6通过`super`关键字作为`class`语法的一部分解决了这些问题。下一节将演示它是如何工作的。
- en: 9.5.2 Subclasses with extends and super
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.2 使用extends和super创建子类
- en: 'In ES6 and later, you can create a superclass simply by adding an `extends`
    clause to a class declaration, and you can do this even for built-in classes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6及更高版本中，你可以通过在类声明中添加`extends`子句来简单地创建一个超类，甚至可以对内置类这样做：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This EZArray subclass defines two simple getter methods. Instances of EZArray
    behave like ordinary arrays, and we can use inherited methods and properties like
    `push()`, `pop()`, and `length`. But we can also use the `first` and `last` getters
    defined in the subclass. Not only are instance methods like `pop()` inherited,
    but static methods like `Array.isArray` are also inherited. This is a new feature
    enabled by ES6 class syntax: `EZArray()` is a function, but it inherits from `Array()`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个EZArray子类定义了两个简单的getter方法。EZArray的实例表现得像普通数组，我们可以使用继承的方法和属性，比如`push()`、`pop()`和`length`。但我们也可以使用子类中定义的`first`和`last`
    getter。不仅实例方法像`pop()`被继承了，静态方法像`Array.isArray`也被继承了。这是ES6类语法启用的一个新特性：`EZArray()`是一个函数，但它继承自`Array()`：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our EZArray subclass is too simple to be very instructive. [Example 9-6](#TypedMap.js)
    is a more fully fleshed-out example. It defines a TypedMap subclass of the built-in
    Map class that adds type checking to ensure that the keys and values of the map
    are of the specified types (according to `typeof`). Importantly, this example
    demonstrates the use of the `super` keyword to invoke the constructor and methods
    of the superclass.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的EZArray子类过于简单，无法提供很多指导性。[示例 9-6](#TypedMap.js) 是一个更加完整的示例。它定义了一个TypedMap的子类，继承自内置的Map类，并添加了类型检查以确保地图的键和值是指定类型（根据`typeof`）。重要的是，这个示例演示了使用`super`关键字来调用超类的构造函数和方法。
- en: 'Example 9-6\. TypedMap.js: a subclass of Map that checks key and value types'
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. TypedMap.js：检查键和值类型的Map子类
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The first two arguments to the `TypedMap()` constructor are the desired key
    and value types. These should be strings, such as “number” and “boolean”, that
    the `typeof` operator returns. You can also specify a third argument: an array
    (or any iterable object) of `[key,value]` arrays that specify the initial entries
    in the map. If you specify any initial entries, then the first thing the constructor
    does is verify that their types are correct. Next, the constructor invokes the
    superclass constructor, using the `super` keyword as if it was a function name.
    The `Map()` constructor takes one optional argument: an iterable object of `[key,value]`
    arrays. So the optional third argument of the `TypedMap()` constructor is the
    optional first argument to the `Map()` constructor, and we pass it to that superclass
    constructor with `super(entries)`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedMap()`构造函数的前两个参数是期望的键和值类型。这些应该是字符串，比如“number”和“boolean”，这是`typeof`运算符返回的。你还可以指定第三个参数：一个包含`[key,value]`数组的数组（或任何可迭代对象），指定地图中的初始条目。如果指定了任何初始条目，构造函数首先验证它们的类型是否正确。接下来，构造函数使用`super`关键字调用超类构造函数，就像它是一个函数名一样。`Map()`构造函数接受一个可选参数：一个包含`[key,value]`数组的可迭代对象。因此，`TypedMap()`构造函数的可选第三个参数是`Map()`构造函数的可选第一个参数，我们使用`super(entries)`将其传递给超类构造函数。'
- en: After invoking the superclass constructor to initialize superclass state, the
    `TypedMap()` constructor next initializes its own subclass state by setting `this.keyType`
    and `this.valueType` to the specified types. It needs to set these properties
    so that it can use them again in the `set()` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用超类构造函数初始化超类状态后，`TypedMap()`构造函数接下来通过设置`this.keyType`和`this.valueType`来初始化自己的子类状态。它需要设置这些属性以便在`set()`方法中再次使用它们。
- en: 'There are a few important rules that you will need to know about using `super()`
    in constructors:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中使用`super()`时，有一些重要的规则你需要知道：
- en: If you define a class with the `extends` keyword, then the constructor for your
    class must use `super()` to invoke the superclass constructor.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你用`extends`关键字定义一个类，那么你的类的构造函数必须使用`super()`来调用超类构造函数。
- en: If you don’t define a constructor in your subclass, one will be defined automatically
    for you. This implicitly defined constructor simply takes whatever values are
    passed to it and passes those values to `super()`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在子类中没有定义构造函数，系统会自动为你定义一个。这个隐式定义的构造函数简单地接受传递给它的任何值，并将这些值传递给`super()`。
- en: You may not use the `this` keyword in your constructor until after you have
    invoked the superclass constructor with `super()`. This enforces a rule that superclasses
    get to initialize themselves before subclasses do.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`super()`之前，你不能在构造函数中使用`this`关键字。这强制了一个规则，即超类在子类之前初始化。
- en: The special expression `new.target` is undefined in functions that are invoked
    without the `new` keyword. In constructor functions, however, `new.target` is
    a reference to the constructor that was invoked. When a subclass constructor is
    invoked and uses `super()` to invoke the superclass constructor, that superclass
    constructor will see the subclass constructor as the value of `new.target`. A
    well-designed superclass should not need to know whether it has been subclassed,
    but it might be useful to be able to use `new.target.name` in logging messages,
    for example.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊表达式`new.target`在没有使用`new`关键字调用的函数中是未定义的。然而，在构造函数中，`new.target`是对被调用的构造函数的引用。当子类构造函数被调用并使用`super()`来调用超类构造函数时，那个超类构造函数将会把子类构造函数视为`new.target`的值。一个设计良好的超类不应该知道自己是否被子类化，但在日志消息中使用`new.target.name`可能会很有用。
- en: 'After the constructor, the next part of [Example 9-6](#TypedMap.js) is a method
    named `set()`. The Map superclass defines a method named `set()` to add a new
    entry to the map. We say that this `set()` method in TypedMap *overrides* the
    `set()` method of its superclass. This simple TypedMap subclass doesn’t know anything
    about adding new entries to map, but it does know how to check types, so that
    is what it does first, verifying that the key and value to be added to the map
    have the correct types and throwing an error if they do not. This `set()` method
    doesn’t have any way to add the key and value to the map itself, but that is what
    the superclass `set()` method is for. So we use the `super` keyword again to invoke
    the superclass’s version of the method. In this context, `super` works much like
    the `this` keyword does: it refers to the current object but allows access to
    overridden methods defined in the superclass.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数之后，[示例 9-6](#TypedMap.js)的下一部分是一个名为`set()`的方法。Map超类定义了一个名为`set()`的方法来向地图添加新条目。我们说这个TypedMap中的`set()`方法*覆盖*了其超类的`set()`方法。这个简单的TypedMap子类对于向地图添加新条目一无所知，但它知道如何检查类型，所以首先进行类型检查，验证要添加到地图中的键和值是否具有正确的类型，如果不是则抛出错误。这个`set()`方法没有任何方法将键和值添加到地图本身，但这就是超类`set()`方法的作用。因此，我们再次使用`super`关键字来调用超类的方法版本。在这个上下文中，`super`的工作方式很像`this`关键字：它引用当前对象但允许访问在超类中定义的重写方法。
- en: In constructors, you are required to invoke the superclass constructor before
    you can access `this` and initialize the new object yourself. There are no such
    rules when you override a method. A method that overrides a superclass method
    is not required to invoke the superclass method. If it does use `super` to invoke
    the overridden method (or any method) in the superclass, it can do that at the
    beginning or the middle or the end of the overriding method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，你必须在访问`this`并自己初始化新对象之前调用超类构造函数。当你重写一个方法时，没有这样的规则。重写超类方法的方法不需要调用超类方法。如果它确实使用`super`来调用被重写的方法（或超类中的任何方法），它可以在重写方法的开始、中间或结尾进行调用。
- en: Finally, before we leave the TypedMap example behind, it is worth noting that
    this class is an ideal candidate for the use of private fields. As the class is
    written now, a user could change the `keyType` or `valueType` properties to subvert
    the type checking. Once private fields are supported, we could change these properties
    to `#keyType` and `#valueType` so that they could not be altered from the outside.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们离开TypedMap示例之前，值得注意的是，这个类是使用私有字段的理想候选。目前这个类的写法，用户可以更改`keyType`或`valueType`属性以规避类型检查。一旦支持私有字段，我们可以将这些属性更改为`#keyType`和`#valueType`，这样它们就无法从外部更改。
- en: 9.5.3 Delegation Instead of Inheritance
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.3 代理而非继承
- en: The `extends` keyword makes it easy to create subclasses. But that does not
    mean that you *should* create lots of subclasses. If you want to write a class
    that shares the behavior of some other class, you can try to inherit that behavior
    by creating a subclass. But it is often easier and more flexible to get that desired
    behavior into your class by having your class create an instance of the other
    class and simply delegating to that instance as needed. You create a new class
    not by subclassing, but instead by wrapping or “composing” other classes. This
    delegation approach is often called “composition,” and it is an oft-quoted maxim
    of object-oriented programming that one should “favor composition over inheritance.”^([2](ch09.xhtml#idm46198532816792))
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`关键字使创建子类变得容易。但这并不意味着你*应该*创建大量子类。如果你想编写一个共享某个其他类行为的类，你可以尝试通过创建子类来继承该行为。但通常更容易和更灵活的方法是通过让你的类创建另一个类的实例并根据需要简单地委托给该实例来获得所需的行为。你创建一个新类不是通过子类化，而是通过包装或“组合”其他类。这种委托方法通常被称为“组合”，并且面向对象编程的一个经常引用的格言是应该“优先选择组合而非继承”。^([2](ch09.xhtml#idm46198532816792))'
- en: Suppose, for example, we wanted a Histogram class that behaves something like
    JavaScript’s Set class, except that instead of just keeping track of whether a
    value has been added to set or not, it instead maintains a count of the number
    of times the value has been added. Because the API for this Histogram class is
    similar to Set, we might consider subclassing Set and adding a `count()` method.
    On the other hand, once we start thinking about how we might implement this `count()`
    method, we might realize that the Histogram class is more like a Map than a Set
    because it needs to maintain a mapping between values and the number of times
    they have been added. So instead of subclassing Set, we can create a class that
    defines a Set-like API but implements those methods by delegating to an internal
    Map object. [Example 9-7](#Histogram.js) shows how we could do this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要一个直方图类，其行为类似于 JavaScript 的 Set 类，但不仅仅是跟踪值是否已添加到集合中，而是维护值已添加的次数。因为这个直方图类的
    API 类似于 Set，我们可以考虑继承 Set 并添加一个`count()`方法。另一方面，一旦我们开始考虑如何实现这个`count()`方法，我们可能会意识到直方图类更像是一个
    Map 而不是一个 Set，因为它需要维护值和它们被添加的次数之间的映射关系。因此，我们可以创建一个定义了类似 Set API 的类，但通过委托给内部 Map
    对象来实现这些方法。[示例 9-7](#Histogram.js)展示了我们如何做到这一点。
- en: 'Example 9-7\. Histogram.js: a Set-like class implemented with delegation'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7\. Histogram.js：使用委托实现的类似 Set 的类
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'All the `Histogram()` constructor does in [Example 9-7](#Histogram.js) is create
    a Map object. And most of the methods are one-liners that just delegate to a method
    of the map, making the implementation quite simple. Because we used delegation
    rather than inheritance, a Histogram object is not an instance of Set or Map.
    But Histogram implements a number of commonly used Set methods, and in an untyped
    language like JavaScript, that is often good enough: a formal inheritance relationship
    is sometimes nice, but often optional.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-7](#Histogram.js)中的`Histogram()`构造函数只是创建了一个 Map 对象。大多数方法都只是简单地委托给地图的一个方法，使得实现非常简单。因为我们使用了委托而不是继承，一个
    Histogram 对象不是 Set 或 Map 的实例。但 Histogram 实现了许多常用的 Set 方法，在像 JavaScript 这样的无类型语言中，这通常已经足够了：正式的继承关系有时很好，但通常是可选的。'
- en: 9.5.4 Class Hierarchies and Abstract Classes
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5.4 类层次结构和抽象类
- en: '[Example 9-6](#TypedMap.js) demonstrated how we can subclass Map. [Example 9-7](#Histogram.js)
    demonstrated how we can instead delegate to a Map object without actually subclassing
    anything. Using JavaScript classes to encapsulate data and modularize your code
    is often a great technique, and you may find yourself using the `class` keyword
    frequently. But you may find that you prefer composition to inheritance and that
    you rarely need to use `extends` (except when you’re using a library or framework
    that requires you to extend its base classes).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-6](#TypedMap.js)演示了我们如何继承 Map。[示例 9-7](#Histogram.js)演示了我们如何委托给一个 Map
    对象而不实际继承任何东西。使用 JavaScript 类来封装数据和模块化代码通常是一个很好的技术，你可能会经常使用`class`关键字。但你可能会发现你更喜欢组合而不是继承，并且很少需要使用`extends`（除非你使用要求你扩展其基类的库或框架）。'
- en: There are some circumstances when multiple levels of subclassing are appropriate,
    however, and we’ll end this chapter with an extended example that demonstrates
    a hierarchy of classes representing different kinds of sets. (The set classes
    defined in [Example 9-8](#sets.js) are similar to, but not completely compatible
    with, JavaScript’s built-in Set class.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，多级子类化是合适的，我们将以一个扩展示例结束本章，该示例演示了代表不同类型集合的类的层次结构。([示例 9-8](#sets.js)中定义的集合类与
    JavaScript 内置的 Set 类类似，但不完全兼容。)
- en: '[Example 9-8](#sets.js) defines lots of subclasses, but it also demonstrates
    how you can define *abstract classes*—classes that do not include a complete implementation—to
    serve as a common superclass for a group of related subclasses. An abstract superclass
    can define a partial implementation that all subclasses inherit and share. The
    subclasses, then, only need to define their own unique behavior by implementing
    the abstract methods defined—but not implemented—by the superclass. Note that
    JavaScript does not have any formal definition of abstract methods or abstract
    classes; I’m simply using that name here for unimplemented methods and incompletely
    implemented classes.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-8](#sets.js)定义了许多子类，但它还演示了如何定义*抽象类*——不包括完整实现的类——作为一组相关子类的共同超类。抽象超类可以定义所有子类继承和共享的部分实现。然后，子类只需要通过实现超类定义但未实现的抽象方法来定义自己的独特行为。请注意，JavaScript
    没有任何正式定义抽象方法或抽象类的规定；我在这里仅仅是使用这个名称来表示未实现的方法和未完全实现的类。'
- en: '[Example 9-8](#sets.js) is well commented and stands on its own. I encourage
    you to read it as a capstone example for this chapter on classes. The final class
    in [Example 9-8](#sets.js) does a lot of bit manipulation with the `&`, `|`, and
    `~` operators, which you can review in [§4.8.3](ch04.xhtml#bitwiseoperators).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-8](#sets.js)有很好的注释，可以独立运行。我鼓励你将其作为本章关于类的顶尖示例来阅读。在[示例 9-8](#sets.js)中的最终类使用了`&`、`|`和`~`运算符进行大量的位操作，你可以在[§4.8.3](ch04.xhtml#bitwiseoperators)中复习。'
- en: 'Example 9-8\. Sets.js: a hierarchy of abstract and concrete set classes'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8\. Sets.js：抽象和具体集合类的层次结构
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 9.6 Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 总结
- en: 'This chapter has explained the key features of JavaScript classes:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经解释了 JavaScript 类的关键特性：
- en: Objects that are members of the same class inherit properties from the same
    prototype object. The prototype object is the key feature of JavaScript classes,
    and it is possible to define classes with nothing more than the `Object.create()`
    method.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一类的对象从相同的原型对象继承属性。原型对象是 JavaScript 类的关键特性，可以仅使用`Object.create()`方法定义类。
- en: Prior to ES6, classes were more typically defined by first defining a constructor
    function. Functions created with the `function` keyword have a `prototype` property,
    and the value of this property is an object that is used as the prototype of all
    objects created when the function is invoked with `new` as a constructor. By initializing
    this prototype object, you can define the shared methods of your class. Although
    the prototype object is the key feature of the class, the constructor function
    is the public identity of the class.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ES6之前，类通常是通过首先定义构造函数来定义的。使用`function`关键字创建的函数具有一个`prototype`属性，该属性的值是一个对象，当使用`new`作为构造函数调用函数时，该对象被用作所有创建的对象的原型。通过初始化这个原型对象，您可以定义类的共享方法。虽然原型对象是类的关键特征，但构造函数是类的公共标识。
- en: ES6 introduces a `class` keyword that makes it easier to define classes, but
    under the hood, constructor and prototype mechanism remains the same.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6引入了`class`关键字，使得定义类更容易，但在底层，构造函数和原型机制仍然保持不变。
- en: Subclasses are defined using the `extends` keyword in a class declaration.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类是在类声明中使用`extends`关键字定义的。
- en: Subclasses can invoke the constructor of their superclass or overridden methods
    of their superclass with the `super` keyword.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类可以使用`super`关键字调用其父类的构造函数或重写的方法。
- en: ^([1](ch09.xhtml#idm46198535317032-marker)) Except functions returned by the
    ES5 `Function.bind()` method. Bound functions have no prototype property of their
    own, but they use the prototype of the underlying function if they are invoked
    as constructors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.xhtml#idm46198535317032-marker)) 除了ES5的`Function.bind()`方法返回的函数。绑定函数没有自己的原型属性，但如果作为构造函数调用它们，则它们使用基础函数的原型。
- en: ^([2](ch09.xhtml#idm46198532816792-marker)) See *Design Patterns* (Addison-Wesley
    Professional) by Erich Gamma et al. or *Effective Java* (Addison-Wesley Professional)
    by Joshua Bloch, for example.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.xhtml#idm46198532816792-marker)) 例如，参见Erich Gamma等人的*设计模式*（Addison-Wesley
    Professional）或Joshua Bloch的*Effective Java*（Addison-Wesley Professional）。
