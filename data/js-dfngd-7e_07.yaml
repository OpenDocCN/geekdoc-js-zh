- en: Chapter 7\. Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 数组
- en: 'This chapter documents arrays, a fundamental datatype in JavaScript and in
    most other programming languages. An *array* is an ordered collection of values.
    Each value is called an *element*, and each element has a numeric position in
    the array, known as its *index*. JavaScript arrays are *untyped*: an array element
    may be of any type, and different elements of the same array may be of different
    types. Array elements may even be objects or other arrays, which allows you to
    create complex data structures, such as arrays of objects and arrays of arrays.
    JavaScript arrays are *zero-based* and use 32-bit indexes: the index of the first
    element is 0, and the highest possible index is 4294967294 (2^(32)−2), for a maximum
    array size of 4,294,967,295 elements. JavaScript arrays are *dynamic*: they grow
    or shrink as needed, and there is no need to declare a fixed size for the array
    when you create it or to reallocate it when the size changes. JavaScript arrays
    may be *sparse*: the elements need not have contiguous indexes, and there may
    be gaps. Every JavaScript array has a `length` property. For nonsparse arrays,
    this property specifies the number of elements in the array. For sparse arrays,
    `length` is larger than the highest index of any element.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数组，这是JavaScript和大多数其他编程语言中的一种基本数据类型。*数组*是一个有序的值集合。每个值称为一个*元素*，每个元素在数组中有一个数值位置，称为其*索引*。JavaScript数组是*无类型*的：数组元素可以是任何类型，同一数组的不同元素可以是不同类型。数组元素甚至可以是对象或其他数组，这使您可以创建复杂的数据结构，例如对象数组和数组数组。JavaScript数组是*基于零*的，并使用32位索引：第一个元素的索引为0，最大可能的索引为4294967294（2^(32)−2），最大数组大小为4,294,967,295个元素。JavaScript数组是*动态*的：它们根据需要增长或缩小，并且在创建数组时无需声明固定大小，也无需在大小更改时重新分配。JavaScript数组可能是*稀疏*的：元素不必具有连续的索引，可能存在间隙。每个JavaScript数组都有一个`length`属性。对于非稀疏数组，此属性指定数组中的元素数量。对于稀疏数组，`length`大于任何元素的最高索引。
- en: JavaScript arrays are a specialized form of JavaScript object, and array indexes
    are really little more than property names that happen to be integers. We’ll talk
    more about the specializations of arrays elsewhere in this chapter. Implementations
    typically optimize arrays so that access to numerically indexed array elements
    is generally significantly faster than access to regular object properties.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数组是JavaScript对象的一种特殊形式，数组索引实际上只是整数属性名。我们将在本章的其他地方更详细地讨论数组的特殊性。实现通常会优化数组，使得对数值索引的数组元素的访问通常比对常规对象属性的访问要快得多。
- en: Arrays inherit properties from `Array.prototype`, which defines a rich set of
    array manipulation methods, covered in [§7.8](#arraymethods). Most of these methods
    are *generic*, which means that they work correctly not only for true arrays,
    but for any “array-like object.” We’ll discuss array-like objects in [§7.9](#arraylike).
    Finally, JavaScript strings behave like arrays of characters, and we’ll discuss
    this in [§7.10](#stringarrays).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数组从`Array.prototype`继承属性，该属性定义了一组丰富的数组操作方法，涵盖在[§7.8](#arraymethods)中。这些方法大多是*通用*的，这意味着它们不仅适用于真实数组，还适用于任何“类似数组的对象”。我们将在[§7.9](#arraylike)中讨论类似数组的对象。最后，JavaScript字符串的行为类似于字符数组，我们将在[§7.10](#stringarrays)中讨论这一点。
- en: ES6 introduces a set of new array classes known collectively as “typed arrays.”
    Unlike regular JavaScript arrays, typed arrays have a fixed length and a fixed
    numeric element type. They offer high performance and byte-level access to binary
    data and are covered in [§11.2](ch11.xhtml#typedarrays).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ES6引入了一组被统称为“类型化数组”的新数组类。与常规的JavaScript数组不同，类型化数组具有固定的长度和固定的数值元素类型。它们提供高性能和对二进制数据的字节级访问，并在[§11.2](ch11.xhtml#typedarrays)中有所涉及。
- en: 7.1 Creating Arrays
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.1 创建数组
- en: 'There are several ways to create arrays. The subsections that follow explain
    how to create arrays with:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建数组的方法。接下来的小节将解释如何使用以下方式创建数组：
- en: Array literals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组字面量
- en: The `...` spread operator on an iterable object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可迭代对象上的`...`展开运算符
- en: The `Array()` constructor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array()`构造函数'
- en: The `Array.of()` and `Array.from()` factory methods
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array.of()`和`Array.from()`工厂方法'
- en: 7.1.1 Array Literals
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.1 数组字面量
- en: 'By far the simplest way to create an array is with an array literal, which
    is simply a comma-separated list of array elements within square brackets. For
    example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创造数组最简单的方法是使用数组字面量，它只是方括号内以逗号分隔的数组元素列表。例如：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The values in an array literal need not be constants; they may be arbitrary
    expressions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量中的值不必是常量；它们可以是任意表达式：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Array literals can contain object literals or other array literals:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量可以包含对象字面量或其他数组字面量：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If an array literal contains multiple commas in a row, with no value between,
    the array is sparse (see [§7.3](#sparsearrays)). Array elements for which values
    are omitted do not exist but appear to be `undefined` if you query them:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组字面量中包含多个连续的逗号，且之间没有值，那么该数组是稀疏的（参见[§7.3](#sparsearrays)）。省略值的数组元素并不存在，但如果查询它们，则看起来像是`undefined`：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Array literal syntax allows an optional trailing comma, so `[,,]` has a length
    of 2, not 3.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量语法允许有可选的尾随逗号，因此`[,,]`的长度为2，而不是3。
- en: 7.1.2 The Spread Operator
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.2 展开运算符
- en: 'In ES6 and later, you can use the “spread operator,” `...`, to include the
    elements of one array within an array literal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6及更高版本中，您可以使用“展开运算符”`...`将一个数组的元素包含在一个数组字面量中：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The three dots “spread” the array `a` so that its elements become elements within
    the array literal that is being created. It is as if the `...a` was replaced by
    the elements of the array `a`, listed literally as part of the enclosing array
    literal. (Note that, although we call these three dots a spread operator, this
    is not a true operator because it can only be used in array literals and, as we’ll
    see later in the book, function invocations.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个点“展开”数组`a`，使得它的元素成为正在创建的数组字面量中的元素。就好像`...a`被数组`a`的元素替换，字面上列为封闭数组字面量的一部分。
    （请注意，尽管我们称这三个点为展开运算符，但这不是一个真正的运算符，因为它只能在数组字面量中使用，并且正如我们将在本书后面看到的，函数调用。）
- en: 'The spread operator is a convenient way to create a (shallow) copy of an array:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符是创建（浅层）数组副本的便捷方式：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The spread operator works on any iterable object. (*Iterable* objects are what
    the `for/of` loop iterates over; we first saw them in [§5.4.4](ch05.xhtml#forofloop),
    and we’ll see much more about them in [Chapter 12](ch12.xhtml#itergene).) Strings
    are iterable, so you can use a spread operator to turn any string into an array
    of single-character strings:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符适用于任何可迭代对象。(*可迭代*对象是`for/of`循环迭代的对象；我们首次在[§5.4.4](ch05.xhtml#forofloop)中看到它们，并且我们将在[第12章](ch12.xhtml#itergene)中看到更多关于它们的内容。)
    字符串是可迭代的，因此您可以使用展开运算符将任何字符串转换为由单个字符字符串组成的数组：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Set objects ([§11.1.1](ch11.xhtml#setclass)) are iterable, so an easy way to
    remove duplicate elements from an array is to convert the array to a set and then
    immediately convert the set back to an array using the spread operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象（[§11.1.1](ch11.xhtml#setclass)）是可迭代的，因此从数组中删除重复元素的简单方法是将数组转换为集合，然后立即使用展开运算符将集合转换回数组：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 7.1.3 The Array() Constructor
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.3 Array() 构造函数
- en: 'Another way to create an array is with the `Array()` constructor. You can invoke
    this constructor in three distinct ways:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种创建数组的方法是使用`Array()`构造函数。您可以以三种不同的方式调用此构造函数： '
- en: 'Call it with no arguments:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带参数调用它：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method creates an empty array with no elements and is equivalent to the
    array literal `[]`.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法创建一个没有元素的空数组，等同于数组字面量`[]`。
- en: 'Call it with a single numeric argument, which specifies a length:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个数字参数调用它，指定长度：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This technique creates an array with the specified length. This form of the
    `Array()` constructor can be used to preallocate an array when you know in advance
    how many elements will be required. Note that no values are stored in the array,
    and the array index properties “0”, “1”, and so on are not even defined for the
    array.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术创建具有指定长度的数组。当您事先知道将需要多少元素时，可以使用`Array()`构造函数的这种形式来预先分配数组。请注意，数组中不存储任何值，并且数组索引属性“0”、“1”等甚至未为数组定义。
- en: 'Explicitly specify two or more array elements or a single non-numeric element
    for the array:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确指定两个或更多数组元素或单个非数值元素：
- en: '[PRE10]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this form, the constructor arguments become the elements of the new array.
    Using an array literal is almost always simpler than this usage of the `Array()`
    constructor.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种形式中，构造函数参数成为新数组的元素。几乎总是比使用`Array()`构造函数更简单的是使用数组字面量。
- en: 7.1.4 Array.of()
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.4 Array.of()
- en: When the `Array()` constructor function is invoked with one numeric argument,
    it uses that argument as an array length. But when invoked with more than one
    numeric argument, it treats those arguments as elements for the array to be created.
    This means that the `Array()` constructor cannot be used to create an array with
    a single numeric element.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个数值参数调用`Array()`构造函数时，它将该参数用作数组长度。但是，当使用多个数值参数调用时，它将这些参数视为要创建的数组的元素。这意味着`Array()`构造函数不能用于创建具有单个数值元素的数组。
- en: 'In ES6, the `Array.of()` function addresses this problem: it is a factory method
    that creates and returns a new array, using its argument values (regardless of
    how many of them there are) as the array elements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，`Array.of()`函数解决了这个问题：它是一个工厂方法，使用其参数值（无论有多少个）作为数组元素创建并返回一个新数组：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7.1.5 Array.from()
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1.5 Array.from()
- en: '`Array.from` is another array factory method introduced in ES6\. It expects
    an iterable or array-like object as its first argument and returns a new array
    that contains the elements of that object. With an iterable argument, `Array.from(iterable)`
    works like the spread operator `[...iterable]` does. It is also a simple way to
    make a copy of an array:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from`是 ES6 中引入的另一个数组工厂方法。它期望一个可迭代或类似数组的对象作为其第一个参数，并返回一个包含该对象元素的新数组。对于可迭代参数，`Array.from(iterable)`的工作方式类似于展开运算符`[...iterable]`。这也是制作数组副本的简单方法：'
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Array.from()` is also important because it defines a way to make a true-array
    copy of an array-like object. Array-like objects are non-array objects that have
    a numeric length property and have values stored with properties whose names happen
    to be integers. When working with client-side JavaScript, the return values of
    some web browser methods are array-like, and it can be easier to work with them
    if you first convert them to true arrays:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()`也很重要，因为它定义了一种使类似数组对象的真数组副本的方法。类似数组的对象是具有数值长度属性并且具有存储值的属性的非数组对象，这些属性的名称恰好是整数。在使用客户端
    JavaScript 时，某些 Web 浏览器方法的返回值是类似数组的，如果您首先将它们转换为真数组，那么使用它们可能会更容易：'
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`Array.from()` also accepts an optional second argument. If you pass a function
    as the second argument, then as the new array is being built, each element from
    the source object will be passed to the function you specify, and the return value
    of the function will be stored in the array instead of the original value. (This
    is very much like the array `map()` method that will be introduced later in the
    chapter, but it is more efficient to perform the mapping while the array is being
    built than it is to build the array and then map it to another new array.)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()`还接受一个可选的第二个参数。如果将一个函数作为第二个参数传递，那么在构建新数组时，源对象的每个元素都将传递给您指定的函数，并且函数的返回值将存储在数组中，而不是原始值。（这非常类似于稍后将在本章介绍的数组`map()`方法，但在构建数组时执行映射比构建数组然后将其映射到另一个新数组更有效。）'
- en: 7.2 Reading and Writing Array Elements
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.2 读取和写入数组元素
- en: 'You access an element of an array using the `[]` operator. A reference to the
    array should appear to the left of the brackets. An arbitrary expression that
    has a non-negative integer value should be inside the brackets. You can use this
    syntax to both read and write the value of an element of an array. Thus, the following
    are all legal JavaScript statements:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`[]`运算符访问数组元素。方括号左侧应该是数组的引用。方括号内应该是一个非负整数值的任意表达式。你可以使用这种语法来读取和写入数组元素的值。因此，以下都是合法的
    JavaScript 语句：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What is special about arrays is that when you use property names that are non-negative
    integers less than 2^(32)–1, the array automatically maintains the value of the
    `length` property for you. In the preceding, for example, we created an array
    `a` with a single element. We then assigned values at indexes 1, 2, and 3\. The
    `length` property of the array changed as we did, so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的特殊之处在于，当你使用非负整数且小于2^(32)–1的属性名时，数组会自动为你维护`length`属性的值。例如，在前面的例子中，我们创建了一个只有一个元素的数组`a`。然后我们在索引1、2和3处分配了值。随着我们的操作，数组的`length`属性也发生了变化，因此：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remember that arrays are a specialized kind of object. The square brackets
    used to access array elements work just like the square brackets used to access
    object properties. JavaScript converts the numeric array index you specify to
    a string—the index `1` becomes the string `"1"`—then uses that string as a property
    name. There is nothing special about the conversion of the index from a number
    to a string: you can do that with regular objects, too:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，数组是一种特殊类型的对象。用于访问数组元素的方括号与用于访问对象属性的方括号工作方式相同。JavaScript将你指定的数值数组索引转换为字符串——索引`1`变为字符串`"1"`——然后将该字符串用作属性名。将索引从数字转换为字符串没有什么特殊之处：你也可以对常规对象这样做：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is helpful to clearly distinguish an *array index* from an *object property
    name*. All indexes are property names, but only property names that are integers
    between 0 and 2^(32)–2 are indexes. All arrays are objects, and you can create
    properties of any name on them. If you use properties that are array indexes,
    however, arrays have the special behavior of updating their `length` property
    as needed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地区分*数组索引*和*对象属性名*是有帮助的。所有索引都是属性名，但只有介于0和2^(32)–2之间的整数属性名才是索引。所有数组都是对象，你可以在它们上面创建任何名称的属性。然而，如果你使用的是数组索引的属性，数组会根据需要更新它们的`length`属性。
- en: 'Note that you can index an array using numbers that are negative or that are
    not integers. When you do this, the number is converted to a string, and that
    string is used as the property name. Since the name is not a non-negative integer,
    it is treated as a regular object property, not an array index. Also, if you index
    an array with a string that happens to be a non-negative integer, it behaves as
    an array index, not an object property. The same is true if you use a floating-point
    number that is the same as an integer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以使用负数或非整数的数字对数组进行索引。当你这样做时，数字会转换为字符串，并且该字符串将用作属性名。由于名称不是非负整数，因此它被视为常规对象属性，而不是数组索引。此外，如果你使用恰好是非负整数的字符串对数组进行索引，它将表现为数组索引，而不是对象属性。如果你使用与整数相同的浮点数，情况也是如此：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The fact that array indexes are simply a special type of object property name
    means that JavaScript arrays have no notion of an “out of bounds” error. When
    you try to query a nonexistent property of any object, you don’t get an error;
    you simply get `undefined`. This is just as true for arrays as it is for objects:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数组索引只是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有“越界”错误的概念。当你尝试查询任何对象的不存在属性时，你不会收到错误；你只会得到`undefined`。对于数组和对象来说，这一点同样适用：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 7.3 Sparse Arrays
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.3 稀疏数组
- en: A *sparse* array is one in which the elements do not have contiguous indexes
    starting at 0\. Normally, the `length` property of an array specifies the number
    of elements in the array. If the array is sparse, the value of the `length` property
    is greater than the number of elements. Sparse arrays can be created with the
    `Array()` constructor or simply by assigning to an array index larger than the
    current array `length`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*稀疏*数组是指元素的索引不是从0开始的连续索引。通常，数组的`length`属性指定数组中元素的数量。如果数组是稀疏的，`length`属性的值将大于元素的数量。可以使用`Array()`构造函数创建稀疏数组，或者简单地通过分配给大于当前数组`length`的数组索引来创建稀疏数组。'
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ll see later that you can also make an array sparse with the `delete` operator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到，你也可以使用`delete`运算符使数组变得稀疏。
- en: Arrays that are sufficiently sparse are typically implemented in a slower, more
    memory-efficient way than dense arrays are, and looking up elements in such an
    array will take about as much time as regular object property lookup.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具有足够稀疏性的数组通常以比密集数组更慢、更节省内存的方式实现，查找这种数组中的元素将花费与常规对象属性查找相同的时间。
- en: 'Note that when you omit a value in an array literal (using repeated commas
    as in `[1,,3]`), the resulting array is sparse, and the omitted elements simply
    do not exist:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你在数组字面量中省略一个值（使用重复逗号，如`[1,,3]`），结果得到的数组是稀疏的，省略的元素简单地不存在：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Understanding sparse arrays is an important part of understanding the true nature
    of JavaScript arrays. In practice, however, most JavaScript arrays you will work
    with will not be sparse. And, if you do have to work with a sparse array, your
    code will probably treat it just as it would treat a nonsparse array with `undefined`
    elements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 理解稀疏数组是理解 JavaScript 数组真正本质的重要部分。然而，在实践中，你将使用的大多数 JavaScript 数组都不会是稀疏的。而且，如果你确实需要使用稀疏数组，你的代码可能会像对待具有`undefined`元素的非稀疏数组一样对待它。
- en: 7.4 Array Length
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.4 数组长度
- en: 'Every array has a `length` property, and it is this property that makes arrays
    different from regular JavaScript objects. For arrays that are dense (i.e., not
    sparse), the `length` property specifies the number of elements in the array.
    Its value is one more than the highest index in the array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组都有一个`length`属性，正是这个属性使数组与常规 JavaScript 对象不同。对于密集数组（即非稀疏数组），`length`属性指定数组中元素的数量。其值比数组中最高索引多一：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When an array is sparse, the `length` property is greater than the number of
    elements, and all we can say about it is that `length` is guaranteed to be larger
    than the index of every element in the array. Or, put another way, an array (sparse
    or not) will never have an element whose index is greater than or equal to its
    `length`. In order to maintain this invariant, arrays have two special behaviors.
    The first we described above: if you assign a value to an array element whose
    index `i` is greater than or equal to the array’s current `length`, the value
    of the `length` property is set to `i+1`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组是稀疏的时，`length`属性大于元素数量，我们只能说`length`保证大于数组中每个元素的索引。换句话说，数组（稀疏或非稀疏）永远不会有索引大于或等于其`length`的元素。为了保持这个不变量，数组有两个特殊行为。我们上面描述的第一个：如果您为索引`i`大于或等于数组当前`length`的数组元素分配一个值，`length`属性的值将设置为`i+1`。
- en: 'The second special behavior that arrays implement in order to maintain the
    length invariant is that, if you set the `length` property to a non-negative integer
    `n` smaller than its current value, any array elements whose index is greater
    than or equal to `n` are deleted from the array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数组为了保持长度不变的第二个特殊行为是，如果您将`length`属性设置为小于当前值的非负整数`n`，则任何索引大于或等于`n`的数组元素将从数组中删除：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can also set the `length` property of an array to a value larger than its
    current value. Doing this does not actually add any new elements to the array;
    it simply creates a sparse area at the end of the array.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将数组的`length`属性设置为大于当前值的值。这样做实际上并不向数组添加任何新元素；它只是在数组末尾创建了一个稀疏区域。
- en: 7.5 Adding and Deleting Array Elements
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.5 添加和删除数组元素
- en: 'We’ve already seen the simplest way to add elements to an array: just assign
    values to new indexes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到向数组添加元素的最简单方法：只需为新索引分配值：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also use the `push()` method to add one or more values to the end of
    an array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`push()`方法将一个或多个值添加到数组的末尾：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Pushing a value onto an array `a` is the same as assigning the value to `a[a.length]`.
    You can use the `unshift()` method (described in [§7.8](#arraymethods)) to insert
    a value at the beginning of an array, shifting the existing array elements to
    higher indexes. The `pop()` method is the opposite of `push()`: it removes the
    last element of the array and returns it, reducing the length of an array by 1\.
    Similarly, the `shift()` method removes and returns the first element of the array,
    reducing the length by 1 and shifting all elements down to an index one lower
    than their current index. See [§7.8](#arraymethods) for more on these methods.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将值推送到数组`a`上与将值分配给`a[a.length]`相同。您可以使用`unshift()`方法（在[§7.8](#arraymethods)中描述）在数组的开头插入一个值，将现有数组元素移动到更高的索引。`pop()`方法是`push()`的相反操作：它删除数组的最后一个元素并返回它，将数组的长度减少1。类似地，`shift()`方法删除并返回数组的第一个元素，将长度减1并将所有元素向下移动到比当前索引低一个索引。有关这些方法的更多信息，请参阅[§7.8](#arraymethods)。
- en: 'You can delete array elements with the `delete` operator, just as you can delete
    object properties:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`delete`运算符删除数组元素，就像您可以删除对象属性一样：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deleting an array element is similar to (but subtly different than) assigning
    `undefined` to that element. Note that using `delete` on an array element does
    not alter the `length` property and does not shift elements with higher indexes
    down to fill in the gap that is left by the deleted property. If you delete an
    element from an array, the array becomes sparse.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数组元素与将`undefined`分配给该元素类似（但略有不同）。请注意，使用`delete`删除数组元素不会改变`length`属性，并且不会将具有更高索引的元素向下移动以填补被删除属性留下的空白。如果从数组中删除一个元素，数组将变得稀疏。
- en: As we saw above, you can also remove elements from the end of an array simply
    by setting the `length` property to the new desired length.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面看到的，您也可以通过将`length`属性设置为新的所需长度来从数组末尾删除元素。
- en: Finally, `splice()` is the general-purpose method for inserting, deleting, or
    replacing array elements. It alters the `length` property and shifts array elements
    to higher or lower indexes as needed. See [§7.8](#arraymethods) for details.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`splice()`是用于插入、删除或替换数组元素的通用方法。它改变`length`属性并根据需要将数组元素移动到更高或更低的索引。有关详细信息，请参阅[§7.8](#arraymethods)。
- en: 7.6 Iterating Arrays
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.6 遍历数组
- en: 'As of ES6, the easiest way to loop through each of the elements of an array
    (or any iterable object) is with the `for/of` loop, which was covered in detail
    in [§5.4.4](ch05.xhtml#forofloop):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从ES6开始，遍历数组（或任何可迭代对象）的最简单方法是使用`for/of`循环，这在[§5.4.4](ch05.xhtml#forofloop)中有详细介绍：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The built-in array iterator that the `for/of` loop uses returns the elements
    of an array in ascending order. It has no special behavior for sparse arrays and
    simply returns `undefined` for any array elements that do not exist.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/of`循环使用的内置数组迭代器按升序返回数组的元素。对于稀疏数组，它没有特殊行为，只是对于不存在的数组元素返回`undefined`。'
- en: 'If you want to use a `for/of` loop for an array and need to know the index
    of each array element, use the `entries()` method of the array, along with destructuring
    assignment, like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用`for/of`循环遍历数组并需要知道每个数组元素的索引，请使用数组的`entries()`方法，以及解构赋值，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another good way to iterate arrays is with `forEach()`. This is not a new form
    of the `for` loop, but an array method that offers a functional approach to array
    iteration. You pass a function to the `forEach()` method of an array, and `forEach()`
    invokes your function once on each element of the array:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种遍历数组的好方法是使用`forEach()`。这不是`for`循环的新形式，而是一种提供数组迭代功能的数组方法。您将一个函数传递给数组的`forEach()`方法，`forEach()`在数组的每个元素上调用您的函数一次：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you would expect, `forEach()` iterates the array in order, and it actually
    passes the array index to your function as a second argument, which is occasionally
    useful. Unlike the `for/of` loop, the `forEach()` is aware of sparse arrays and
    does not invoke your function for elements that are not there.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，`forEach()`按顺序迭代数组，并将数组索引作为第二个参数传递给你的函数，这有时很有用。与`for/of`循环不同，`forEach()`知道稀疏数组，并且不会为不存在的元素调用你的函数。
- en: '[§7.8.1](#arrayiteratormethods) documents the `forEach()` method in more detail.
    That section also covers related methods such as `map()` and `filter()` that perform
    specialized kinds of array iteration.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[§7.8.1](#arrayiteratormethods)详细介绍了`forEach()`方法。该部分还涵盖了类似`map()`和`filter()`的相关方法，执行特定类型的数组迭代。'
- en: 'You can also loop through the elements of an array with a good old-fashioned
    `for` loop ([§5.4.3](ch05.xhtml#forloop)):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用传统的`for`循环遍历数组的元素（[§5.4.3](ch05.xhtml#forloop)）：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In nested loops, or other contexts where performance is critical, you may sometimes
    see this basic array iteration loop written so that the array length is only looked
    up once rather than on each iteration. Both of the following `for` loop forms
    are idiomatic, though not particularly common, and with modern JavaScript interpreters,
    it is not at all clear that they have any performance impact:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套循环或其他性能关键的情况下，有时会看到基本的数组迭代循环被写成只查找一次数组长度而不是在每次迭代中查找。以下两种`for`循环形式都是惯用的，尽管不是特别常见，并且在现代JavaScript解释器中，它们是否会对性能产生影响并不清楚：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These examples assume that the array is dense and that all elements contain
    valid data. If this is not the case, you should test the array elements before
    using them. If you want to skip undefined and nonexistent elements, you might
    write:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例假设数组是密集的，并且所有元素都包含有效数据。如果不是这种情况，您应该在使用数组元素之前对其进行测试。如果要跳过未定义和不存在的元素，您可以这样写：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 7.7 Multidimensional Arrays
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.7 多维���组
- en: 'JavaScript does not support true multidimensional arrays, but you can approximate
    them with arrays of arrays. To access a value in an array of arrays, simply use
    the `[]` operator twice. For example, suppose the variable `matrix` is an array
    of arrays of numbers. Every element in `matrix[x]` is an array of numbers. To
    access a particular number within this array, you would write `matrix[x][y]`.
    Here is a concrete example that uses a two-dimensional array as a multiplication
    table:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不支持真正的多维数组，但可以用数组的数组来近似实现。要访问数组中的值，只需简单地两次使用`[]`运算符。例如，假设变量`matrix`是一个包含数字数组的数组。`matrix[x]`中的每个元素都是一个数字数组。要访问这个数组中的特定数字，你可以写成`matrix[x][y]`。以下是一个使用二维数组作为乘法表的具体示例：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 7.8 Array Methods
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.8 数组方法
- en: 'The preceding sections have focused on basic JavaScript syntax for working
    with arrays. In general, though, it is the methods defined by the Array class
    that are the most powerful. The next sections document these methods. While reading
    about these methods, keep in mind that some of them modify the array they are
    called on and some of them leave the array unchanged. A number of the methods
    return an array: sometimes, this is a new array, and the original is unchanged.
    Other times, a method will modify the array in place and will also return a reference
    to the modified array.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分重点介绍了处理数组的基本JavaScript语法。然而，一般来说，Array类定义的方法是最强大的。接下来的部分记录了这些方法。在阅读这些方法时，请记住其中一些方法会修改调用它们的数组，而另一些方法则会保持数组不变。其中一些方法会返回一个数组：有时这是一个新数组，原始数组保持不变。其他时候，一个方法会就地修改数组，并同时返回修改后的数组的引用。
- en: 'Each of the subsections that follows covers a group of related array methods:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的各小节涵盖了一组相关的数组方法：
- en: Iterator methods loop over the elements of an array, typically invoking a function
    that you specify on each of those elements.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代方法循环遍历数组的元素，通常在每个元素上调用您指定的函数。
- en: Stack and queue methods add and remove array elements to and from the beginning
    and the end of an array.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列方法向数组的开头和结尾添加和移除数组元素。
- en: Subarray methods are for extracting, deleting, inserting, filling, and copying
    contiguous regions of a larger array.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子数组方法用于提取、删除、插入、填充和复制较大数组的连续区域。
- en: Searching and sorting methods are for locating elements within an array and
    for sorting the elements of an array.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和排序方法用于在数组中定位元素并对数组元素进行排序。
- en: The following subsections also cover the static methods of the Array class and
    a few miscellaneous methods for concatenating arrays and converting arrays to
    strings.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节还涵盖了Array类的静态方法以及一些用于连接数组和将数组转换为字符串的杂项方法。
- en: 7.8.1 Array Iterator Methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.1 数组迭代方法
- en: The methods described in this section iterate over arrays by passing array elements,
    in order, to a function you supply, and they provide convenient ways to iterate,
    map, filter, test, and reduce arrays.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的方法通过将数组元素按顺序传递给您提供的函数来迭代数组，并提供了方便的方法来迭代、映射、过滤、测试和减少数组。
- en: 'Before we explain the methods in detail, however, it is worth making some generalizations
    about them. First, all of these methods accept a function as their first argument
    and invoke that function once for each element (or some elements) of the array.
    If the array is sparse, the function you pass is not invoked for nonexistent elements.
    In most cases, the function you supply is invoked with three arguments: the value
    of the array element, the index of the array element, and the array itself. Often,
    you only need the first of these argument values and can ignore the second and
    third values.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在详细解释这些方法之前，值得对它们做一些概括。首先，所有这些方法都接受一个函数作为它们的第一个参数，并为数组的每个元素（或某些元素）调用该函数。如果数组是稀疏的，您传递的函数不会为不存在的元素调用。在大多数情况下，您提供的函数会被调用三个参数：数组元素的值、数组元素的索引和数组本身。通常，您只需要第一个参数值，可以忽略第二和第三个值。
- en: Most of the iterator methods described in the following subsections accept an
    optional second argument. If specified, the function is invoked as if it is a
    method of this second argument. That is, the second argument you pass becomes
    the value of the `this` keyword inside of the function you pass as the first argument.
    The return value of the function you pass is usually important, but different
    methods handle the return value in different ways. None of the methods described
    here modify the array on which they are invoked (though the function you pass
    can modify the array, of course).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的小节中描述的大多数迭代器方法都接受一个可选的第二个参数。如果指定了，函数将被调用，就好像它是第二个参数的方法一样。也就是说，您传递的第二个参数将成为您作为第一个参数传递的函数内部的
    `this` 关键字的值。您传递的函数的返回值通常很重要，但不同的方法以不同的方式处理返回值。这里描述的方法都不会修改调用它们的数组（尽管您传递的函数可以修改数组，当然）。
- en: Each of these functions is invoked with a function as its first argument, and
    it is very common to define that function inline as part of the method invocation
    expression instead of using an existing function that is defined elsewhere. Arrow
    function syntax (see [§8.1.3](ch08.xhtml#arrowfunctions)) works particularly well
    with these methods, and we will use it in the examples that follow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些函数都是以一个函数作为其第一个参数调用的，很常见的是在方法调用表达式中定义该函数内联，而不是使用在其他地方定义的现有函数。箭头函数语法（参见[§8.1.3](ch08.xhtml#arrowfunctions)）与这些方法特别配合，我们将在接下来的示例中使用它。
- en: forEach()
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forEach()
- en: 'The `forEach()` method iterates through an array, invoking a function you specify
    for each element. As we’ve described, you pass the function as the first argument
    to `forEach()`. `forEach()` then invokes your function with three arguments: the
    value of the array element, the index of the array element, and the array itself.
    If you only care about the value of the array element, you can write a function
    with only one parameter—the additional arguments will be ignored:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`forEach()` 方法遍历数组，为每个元素调用您指定的函数。正如我们所描述的，您将函数作为第一个参数传递给 `forEach()`。然后，`forEach()`
    使用三个参数调用您的函数：数组元素的值，数组元素的索引和数组本身。如果您只关心数组元素的值，您可以编写一个只有一个参数的函数——额外的参数将被忽略：'
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that `forEach()` does not provide a way to terminate iteration before all
    elements have been passed to the function. That is, there is no equivalent of
    the `break` statement you can use with a regular `for` loop.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`forEach()` 不提供在所有元素被传递给函数之前终止迭代的方法。也就是说，您无法像在常规 `for` 循环中使用 `break` 语句那样使用。
- en: map()
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: map()
- en: 'The `map()` method passes each element of the array on which it is invoked
    to the function you specify and returns an array containing the values returned
    by your function. For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 方法将调用它的数组的每个元素传递给您指定的函数，并返回一个包含您函数返回的值的数组。例如：'
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The function you pass to `map()` is invoked in the same way as a function passed
    to `forEach()`. For the `map()` method, however, the function you pass should
    return a value. Note that `map()` returns a new array: it does not modify the
    array it is invoked on. If that array is sparse, your function will not be called
    for the missing elements, but the returned array will be sparse in the same way
    as the original array: it will have the same length and the same missing elements.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `map()` 的函数的调用方式与传递给 `forEach()` 的函数相同。然而，对于 `map()` 方法，您传递的函数应该返回一个值。请注意，`map()`
    返回一个新数组：它不会修改调用它的数组。如果该数组是稀疏的，您的函数将不会为缺失的元素调用，但返回的数组将与原始数组一样稀疏：它将具有相同的长度和相同的缺失元素。
- en: filter()
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: filter()
- en: 'The `filter()` method returns an array containing a subset of the elements
    of the array on which it is invoked. The function you pass to it should be predicate:
    a function that returns `true` or `false`. The predicate is invoked just as for
    `forEach()` and `map()`. If the return value is `true`, or a value that converts
    to `true`, then the element passed to the predicate is a member of the subset
    and is added to the array that will become the return value. Examples:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()` 方法返回一个包含调用它的数组的元素子集的数组。传递给它的函数应该是谓词：一个返回 `true` 或 `false` 的函数。谓词的调用方式与
    `forEach()` 和 `map()` 相同。如果返回值为 `true`，或者可以转换为 `true` 的值，则传递给谓词的元素是子集的成员，并将添加到将成为返回值的数组中。示例：'
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that `filter()` skips missing elements in sparse arrays and that its return
    value is always dense. To close the gaps in a sparse array, you can do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`filter()` 跳过稀疏数组中的缺失元素，并且其返回值始终是密集的。要填补稀疏数组中的空白，您可以这样做：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And to close gaps and remove undefined and null elements, you can use `filter`,
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要填补空白并删除未定义和空元素，您可以使用 `filter`，如下所示：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: find() and findIndex()
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: find() 和 findIndex()
- en: 'The `find()` and `findIndex()` methods are like `filter()` in that they iterate
    through your array looking for elements for which your predicate function returns
    a truthy value. Unlike `filter()`, however, these two methods stop iterating the
    first time the predicate finds an element. When that happens, `find()` returns
    the matching element, and `findIndex()` returns the index of the matching element.
    If no matching element is found, `find()` returns `undefined` and `findIndex()`
    returns `-1`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 和 `findIndex()` 方法类似于 `filter()`，它们遍历数组，寻找使谓词函数返回真值的元素。然而，这两种方法在谓词第一次找到元素时停止遍历。当这种情况发生时，`find()`
    返回匹配的元素，而 `findIndex()` 返回匹配元素的索引。如果找不到匹配的元素，`find()` 返回 `undefined`，而 `findIndex()`
    返回 `-1`：'
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: every() and some()
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: every() 和 some()
- en: 'The `every()` and `some()` methods are array predicates: they apply a predicate
    function you specify to the elements of the array, then return `true` or `false`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`every()` 和 `some()` 方法是数组谓词：它们将您指定的谓词函数应用于数组的元素，然后返回 `true` 或 `false`。'
- en: 'The `every()` method is like the mathematical “for all” quantifier ∀: it returns
    `true` if and only if your predicate function returns `true` for all elements
    in the array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`every()` 方法类似于数学中的“对于所有”量词 ∀：仅当��的谓词函数对数组中的所有元素返回 `true` 时，它才返回 `true`：'
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `some()` method is like the mathematical “there exists” quantifier ∃: it
    returns `true` if there exists at least one element in the array for which the
    predicate returns `true` and returns `false` if and only if the predicate returns
    `false` for all elements of the array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`some()`方法类似于数学中的“存在”量词∃：如果数组中存在至少一个使谓词返回`true`的元素，则返回`true`，如果谓词对数组的所有元素返回`false`，则返回`false`：'
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that both `every()` and `some()` stop iterating array elements as soon
    as they know what value to return. `some()` returns `true` the first time your
    predicate returns <code>true</code> and only iterates through the entire array
    if your predicate always returns `false`. `every()` is the opposite: it returns
    `false` the first time your predicate returns `false` and only iterates all elements
    if your predicate always returns `true`. Note also that, by mathematical convention,
    `every()` returns `true` and `some` returns `false` when invoked on an empty array.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`every()`和`some()`都会在他们知道要返回的值时停止迭代数组元素。`some()`在您的谓词第一次返回`true`时返回`true`，只有在您的谓词始终返回`false`时才���遍历整个数组。`every()`则相反：当您的谓词第一次返回`false`时返回`false`，只有在您的谓词始终返回`true`时才会迭代所有元素。还要注意，按照数学约定，当在空数组上调用`every()`时，`every()`返回`true`，而在空数组上调用`some`时，`some`返回`false`。
- en: reduce() and reduceRight()
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: reduce()和reduceRight()
- en: 'The `reduce()` and `reduceRight()` methods combine the elements of an array,
    using the function you specify, to produce a single value. This is a common operation
    in functional programming and also goes by the names “inject” and “fold.” Examples
    help illustrate how it works:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`和`reduceRight()`方法使用您指定的函数组合数组的元素，以产生单个值。这是函数式编程中的常见操作，也称为“注入”和“折叠”。示例有助于说明它是如何工作的：'
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`reduce()` takes two arguments. The first is the function that performs the
    reduction operation. The task of this reduction function is to somehow combine
    or reduce two values into a single value and to return that reduced value. In
    the examples we’ve shown here, the functions combine two values by adding them,
    multiplying them, and choosing the largest. The second (optional) argument is
    an initial value to pass to the function.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`接受两个参数。第一个是执行减少操作的函数。这个减少函数的任务是以某种方式将两个值组合或减少为单个值，并返回该减少值。在我们这里展示的示例中，这些函数通过相加、相乘和选择最大值来组合两个值。第二个（可选）参数是传递给函数的初始值。'
- en: Functions used with `reduce()` are different than the functions used with `forEach()`
    and `map()`. The familiar value, index, and array values are passed as the second,
    third, and fourth arguments. The first argument is the accumulated result of the
    reduction so far. On the first call to the function, this first argument is the
    initial value you passed as the second argument to `reduce()`. On subsequent calls,
    it is the value returned by the previous invocation of the function. In the first
    example, the reduction function is first called with arguments 0 and 1\. It adds
    these and returns 1\. It is then called again with arguments 1 and 2 and returns
    3\. Next, it computes 3+3=6, then 6+4=10, and finally 10+5=15\. This final value,
    15, becomes the return value of `reduce()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reduce()`的函数与`forEach()`和`map()`中使用的函数不同。熟悉的值、索引和数组值作为第二、第三和第四个参数传递。第一个参数是到目前为止减少的累积结果。在第一次调用函数时，这个第一个参数是您作为`reduce()`的第二个参数传递的初始值。在后续调用中，它是前一个函数调用返回的值。在第一个示例中，减少函数首先使用参数0和1进行调用。它将它们相加并返回1。然后再次使用参数1和2调用它并返回3。接下来，它计算3+3=6，然后6+4=10，最后10+5=15。这个最终值15成为`reduce()`的返回值。
- en: 'You may have noticed that the third call to `reduce()` in this example has
    only a single argument: there is no initial value specified. When you invoke `reduce()`
    like this with no initial value, it uses the first element of the array as the
    initial value. This means that the first call to the reduction function will have
    the first and second array elements as its first and second arguments. In the
    sum and product examples, we could have omitted the initial value argument.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到此示例中对`reduce()`的第三次调用只有一个参数：没有指定初始值。当您像这样调用`reduce()`而没有初始值时，它将使用数组的第一个元素作为初始值。这意味着减少函数的第一次调用将具有数组的第一个和第二个元素作为其第一个和第二个参数。在求和和乘积示例中，我们可以省略初始值参数。
- en: Calling `reduce()` on an empty array with no initial value argument causes a
    TypeError. If you call it with only one value—either an array with one element
    and no initial value or an empty array and an initial value—it simply returns
    that one value without ever calling the reduction function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在空数组上调用`reduce()`且没有初始值参数会导致TypeError。如果您只使用一个值调用它——要么是一个具有一个元素且没有初始值的数组，要么是一个空数组和一个初始值——它将简单地返回那个值，而不会调用减少函数。
- en: '`reduceRight()` works just like `reduce()`, except that it processes the array
    from highest index to lowest (right-to-left), rather than from lowest to highest.
    You might want to do this if the reduction operation has right-to-left associativity,
    for example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduceRight()`的工作方式与`reduce()`完全相同，只是它从最高索引到最低索引（从右到左）处理数组，而不是从最低到最高。如果减少操作具有从右到左的结合性，您可能希望这样做，例如：'
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that neither `reduce()` nor `reduceRight()` accepts an optional argument
    that specifies the `this` value on which the reduction function is to be invoked.
    The optional initial value argument takes its place. See the `Function.bind()`
    method ([§8.7.5](ch08.xhtml#bind)) if you need your reduction function invoked
    as a method of a particular object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`reduce()`和`reduceRight()`都不接受一个可选参数，该参数指定要调用减少函数的`this`值。可选的初始值参数代替了它。如果您需要将您的减少函数作为特定对象的方法调用，请参阅`Function.bind()`方法（[§8.7.5](ch08.xhtml#bind)）。
- en: The examples shown so far have been numeric for simplicity, but `reduce()` and
    `reduceRight()` are not intended solely for mathematical computations. Any function
    that can combine two values (such as two objects) into one value of the same type
    can be used as a reduction function. On the other hand, algorithms expressed using
    array reductions can quickly become complex and hard to understand, and you may
    find that it is easier to read, write, and reason about your code if you use regular
    looping constructs to process your arrays.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所展示的示例都是为了简单起见而是数值的，但`reduce()`和`reduceRight()`并不仅仅用于数学计算。任何能将两个值（如两个对象）合并为相同类型值的函数都可以用作缩减函数。另一方面，使用数组缩减表达的算法可能很快变得复杂且难以理解，你可能会发现，如果使用常规的循环结构来处理数组，那么阅读、编写和推理代码会更容易。
- en: 7.8.2 Flattening arrays with flat() and flatMap()
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.2 使用flat()���flatMap()展平数组
- en: 'In ES2019, the `flat()` method creates and returns a new array that contains
    the same elements as the array it is called on, except that any elements that
    are themselves arrays are “flattened” into the returned array. For example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2019中，`flat()`方法创建并返回一个新数组，其中包含调用它的数组的相同元素，除了那些本身是数组的元素被“展平”到返回的数组中。例如：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When called with no arguments, `flat()` flattens one level of nesting. Elements
    of the original array that are themselves arrays are flattened, but array elements
    of *those* arrays are not flattened. If you want to flatten more levels, pass
    a number to `flat()`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当不带参数调用时，`flat()`会展平一层嵌套。原始数组中本身是数组的元素会被展平，但*那些*数组的元素不会被展平。如果你想展平更多层次，请向`flat()`传递一个数字：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `flatMap()` method works just like the `map()` method (see [“map()”](#arraymap))
    except that the returned array is automatically flattened as if passed to `flat()`.
    That is, calling `a.flatMap(f)` is the same as (but more efficient than) `a.map(f).flat()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap()`方法的工作方式与`map()`方法相同（参见[“map()”](#arraymap)），只是返回的数组会自动展平，就像传递给`flat()`一样。也就是说，调用`a.flatMap(f)`与（但更有效率）`a.map(f).flat()`相同：'
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can think of `flatMap()` as a generalization of `map()` that allows each
    element of the input array to map to any number of elements of the output array.
    In particular, `flatMap()` allows you to map input elements to an empty array,
    which flattens to nothing in the output array:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`flatMap()`视为`map()`的一般化，允许输入数组的每个元素映射到输出数组的任意数量的元素。特别是，`flatMap()`允许你将输入元素映射到一个空数组，这在输出数组中展平为无内容：
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 7.8.3 Adding arrays with concat()
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.3 使用concat()添加数组
- en: 'The `concat()` method creates and returns a new array that contains the elements
    of the original array on which `concat()` was invoked, followed by each of the
    arguments to `concat()`. If any of these arguments is itself an array, then it
    is the array elements that are concatenated, not the array itself. Note, however,
    that `concat()` does not recursively flatten arrays of arrays. `concat()` does
    not modify the array on which it is invoked:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat()`方法创建并返回一个新数组，其中包含调用`concat()`的原始数组的元素，后跟`concat()`的每个参数。如果其中任何参数本身是一个数组，则连接的是数组元素，而不是数组本身。但请注意，`concat()`不会递归展平数组的数组。`concat()`不会修改调用它的数组：'
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that `concat()` makes a new copy of the array it is called on. In many
    cases, this is the right thing to do, but it is an expensive operation. If you
    find yourself writing code like `a = a.concat(x)`, then you should think about
    modifying your array in place with `push()` or `splice()` instead of creating
    a new one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`concat()`会在调用时创建原始数组的新副本。在许多情况下，这是正确的做法，但这是一个昂贵的操作。如果你发现自己写的代码像`a = a.concat(x)`，那么你应该考虑使用`push()`或`splice()`来就地修改数组，而不是创建一个新数组。
- en: 7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift()
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.4 使用push()、pop()、shift()和unshift()实现栈和队列
- en: 'The `push()` and `pop()` methods allow you to work with arrays as if they were
    stacks. The `push()` method appends one or more new elements to the end of an
    array and returns the new length of the array. Unlike `concat()`, `push()` does
    not flatten array arguments. The `pop()` method does the reverse: it deletes the
    last element of an array, decrements the array length, and returns the value that
    it removed. Note that both methods modify the array in place. The combination
    of `push()` and `pop()` allows you to use a JavaScript array to implement a first-in,
    last-out stack. For example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`和`pop()`方法允许你像处理栈一样处理数组。`push()`方法将一个或多个新元素附加到数组的末尾，并返回数组的新长度。与`concat()`不同，`push()`不会展平数组参数。`pop()`方法则相反：它删除数组的最后一个元素，减少数组长度，并返回它删除的值。请注意，这两种方法都会就地修改数组。`push()`和`pop()`的组合允许你使用JavaScript数组来实现先进后出的栈。例如：'
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `push()` method does not flatten an array you pass to it, but if you want
    to push all of the elements from one array onto another array, you can use the
    spread operator ([§8.3.4](ch08.xhtml#spread-operator-for-functions)) to flatten
    it explicitly:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`push()`方法不会展平你传递给它的数组，但如果你想将一个数组的所有元素推到另一个数组中，你可以使用展开运算符（[§8.3.4](ch08.xhtml#spread-operator-for-functions)）来显式展平它：'
- en: '[PRE49]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `unshift()` and `shift()` methods behave much like `push()` and `pop()`,
    except that they insert and remove elements from the beginning of an array rather
    than from the end. `unshift()` adds an element or elements to the beginning of
    the array, shifts the existing array elements up to higher indexes to make room,
    and returns the new length of the array. `shift()` removes and returns the first
    element of the array, shifting all subsequent elements down one place to occupy
    the newly vacant space at the start of the array. You could use `unshift()` and
    `shift()` to implement a stack, but it would be less efficient than using `push()`
    and `pop()` because the array elements need to be shifted up or down every time
    an element is added or removed at the start of the array. Instead, though, you
    can implement a queue data structure by using `push()` to add elements at the
    end of an array and `shift()` to remove them from the start of the array:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshift()`和`shift()`方法的行为与`push()`和`pop()`类似，只是它们是从数组的开头而不是末尾插入和删除元素。`unshift()`在数组开头添加一个或多个元素，将现有数组元素向���高的索引移动以腾出空间，并返回数组的新长度。`shift()`移除并返回数组的第一个元素，将所有后续元素向下移动一个位置以占据数组开头的新空间。您可以使用`unshift()`和`shift()`来实现堆栈，但与使用`push()`和`pop()`相比效率较低，因为每次在数组开头添加或删除元素时都需要将数组元素向上或向下移动。不过，您可以通过使用`push()`在数组末尾添加元素并使用`shift()`从数组开头删除元素来实现队列数据结构：'
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There is one feature of `unshift()` that is worth calling out because you may
    find it surprising. When passing multiple arguments to `unshift()`, they are inserted
    all at once, which means that they end up in the array in a different order than
    they would be if you inserted them one at a time:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshift()`的一个值得注意的特点是，当向`unshift()`传递多个参数时，它们会一次性插入，这意味着它们以与逐个插入时不同的顺序出现在数组中：'
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin()
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.5 使用slice()、splice()、fill()和copyWithin()创建子数组
- en: Arrays define a number of methods that work on contiguous regions, or subarrays
    or “slices” of an array. The following sections describe methods for extracting,
    replacing, filling, and copying slices.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 数组定义了一些在连续区域、子数组或数组的“切片”上工作的方法。以下部分描述了用于提取、替换、填充和复制切片的方法。
- en: slice()
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: slice()
- en: 'The `slice()` method returns a *slice*, or subarray, of the specified array.
    Its two arguments specify the start and end of the slice to be returned. The returned
    array contains the element specified by the first argument and all subsequent
    elements up to, but not including, the element specified by the second argument.
    If only one argument is specified, the returned array contains all elements from
    the start position to the end of the array. If either argument is negative, it
    specifies an array element relative to the length of the array. An argument of
    –1, for example, specifies the last element in the array, and an argument of –2
    specifies the element before that one. Note that `slice()` does not modify the
    array on which it is invoked. Here are some examples:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice()`方法返回指定数组的*切片*或子数组。它的两个参数指定要返回的切片的起始和结束。返回的数组包含由第一个参数指定的元素和直到第二个参数指定的元素之前的所有后续元素（不包括该元素）。如果只指定一个参数，则返回的数组包含从起始位置到数组末尾的所有元素。如果任一参数为负数，则它指定相对于数组长度的数组元素。例如，参数-1指定数组中的最后一个元素，参数-2指定该元素之前的元素。请注意，`slice()`不会修改调用它的数组。以下是一些示例：'
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: splice()
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: splice()
- en: '`splice()` is a general-purpose method for inserting or removing elements from
    an array. Unlike `slice()` and `concat()`, `splice()` modifies the array on which
    it is invoked. Note that `splice()` and `slice()` have very similar names but
    perform substantially different operations.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice()`是一个通用的方法，用于向数组中插入或删除元素。与`slice()`和`concat()`不同，`splice()`会修改调用它的数组。请注意，`splice()`和`slice()`的名称非常相似，但执行的操作有很大不同。'
- en: '`splice()` can delete elements from an array, insert new elements into an array,
    or perform both operations at the same time. Elements of the array that come after
    the insertion or deletion point have their indexes increased or decreased as necessary
    so that they remain contiguous with the rest of the array. The first argument
    to `splice()` specifies the array position at which the insertion and/or deletion
    is to begin. The second argument specifies the number of elements that should
    be deleted from (spliced out of) the array. (Note that this is another difference
    between these two methods. The second argument to `slice()` is an end position.
    The second argument to `splice()` is a length.) If this second argument is omitted,
    all array elements from the start element to the end of the array are removed.
    `splice()` returns an array of the deleted elements, or an empty array if no elements
    were deleted. For example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice()`可以从数组中删除元素、向数组中插入新元素，或同时执行这两个操作。数组中插入或删除点之后的元素的索引会根据需要增加或减少，以使它们与数组的其余部分保持连续。`splice()`的第一个参数指定插入和/或删除开始的数组位置。第二个参数指定应从数组中删除的元素数量。（请注意，这是这两种方法之间的另一个区别。`slice()`的第二个参数是结束位置。`splice()`的第二个参数是长度。）如果省略了第二个参数，则从起始元素到数组末尾的所有数组元素都将被删除。`splice()`返回一个包含已删除元素的数组，如果没有删除元素，则返回一个空数组。例如：'
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The first two arguments to `splice()` specify which array elements are to be
    deleted. These arguments may be followed by any number of additional arguments
    that specify elements to be inserted into the array, starting at the position
    specified by the first argument. For example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`splice()`的前两个参数指定要删除的数组元素。这些参数后面可以跟任意数量的额外参数，这些参数指定要插入到数组中的元素，从第一个参数指定的位置开始。例如：'
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that, unlike `concat()`, `splice()` inserts arrays themselves, not the
    elements of those arrays.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`concat()`不同，`splice()`插入的是数组本身，而不是这些数组的元素。
- en: fill()
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充()
- en: 'The `fill()` method sets the elements of an array, or a slice of an array,
    to a specified value. It mutates the array it is called on, and also returns the
    modified array:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()`方法将数组或数组的一个片段的元素设置为指定的值。它会改变调用它的数组，并返回修改后的数组：'
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first argument to `fill()` is the value to set array elements to. The optional
    second argument specifies the starting index. If omitted, filling starts at index
    0\. The optional third argument specifies the ending index—array elements up to,
    but not including, this index will be filled. If this argument is omitted, then
    the array is filled from the start index to the end. You can specify indexes relative
    to the end of the array by passing negative numbers, just as you can for `slice()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()`的第一个参数是要设置数组元素的值。可选的第二个参数指定开始索引。如果省略，填充将从索引0开始。可选的第三个参数指定结束索引——将填充到该索引之前的数组元素。如果省略此参数，则数组将从开始索引填充到结束。您可以通过传递负数来指定相对于数组末尾的索引，就像对`slice()`一样。'
- en: copyWithin()
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: copyWithin()
- en: '`copyWithin()` copies a slice of an array to a new position within the array.
    It modifies the array in place and returns the modified array, but it will not
    change the length of the array. The first argument specifies the destination index
    to which the first element will be copied. The second argument specifies the index
    of the first element to be copied. If this second argument is omitted, 0 is used.
    The third argument specifies the end of the slice of elements to be copied. If
    omitted, the length of the array is used. Elements from the start index up to,
    but not including, the end index will be copied. You can specify indexes relative
    to the end of the array by passing negative numbers, just as you can for `slice()`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyWithin()`将数组的一个片段复制到数组内的新位置。它会就地修改数组并返回修改后的数组，但不会改变数组的长度。第一个参数指定要复制第一个元素的目标索引。第二个参数指定要复制的第一个元素的索引。如果省略第二个参数，则使用0。第三个参数指定要复制的元素片段的结束。如果省略，将使用数组的长度。从开始索引到结束索引之前的元素将被复制。您可以通过传递负数来指定相对于数组末尾的索引，就像对`slice()`一样：'
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`copyWithin()` is intended as a high-performance method that is particularly
    useful with typed arrays (see [§11.2](ch11.xhtml#typedarrays)). It is modeled
    after the `memmove()` function from the C standard library. Note that the copy
    will work correctly even if there is overlap between the source and destination
    regions.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyWithin()`旨在作为一种高性能方法，特别适用于类型化数组（参见[§11.2](ch11.xhtml#typedarrays)）。它模仿了C标准库中的`memmove()`函数。请注意，即使源区域和目标区域之间存在重叠，复制也会正确工作。'
- en: 7.8.6 Array Searching and Sorting Methods
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.6 数组搜索和排序方法
- en: Arrays implement `indexOf()`, `lastIndexOf()`, and `includes()` methods that
    are similar to the same-named methods of strings. There are also `sort()` and
    `reverse()` methods for reordering the elements of an array. These methods are
    described in the subsections that follow.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 数组实现了`indexOf()`、`lastIndexOf()`和`includes()`方法，这些方法与字符串的同名方法类似。还有`sort()`和`reverse()`方法用于重新排列数组的元素。这些方法将在接下来的小节中描述。
- en: indexOf() and lastIndexOf()
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: indexOf()和lastIndexOf()
- en: '`indexOf()` and `lastIndexOf()` search an array for an element with a specified
    value and return the index of the first such element found, or `-1` if none is
    found. `indexOf()` searches the array from beginning to end, and `lastIndexOf()`
    searches from end to beginning:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()`和`lastIndexOf()`搜索具有指定值的元素的数组，并返回找到的第一个这样的元素的索引，如果找不到则返回`-1`。`indexOf()`从开头到结尾搜索数组，`lastIndexOf()`从结尾到开头搜索：'
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`indexOf()` and `lastIndexOf()` compare their argument to the array elements
    using the equivalent of the `===` operator. If your array contains objects instead
    of primitive values, these methods check to see if two references both refer to
    exactly the same object. If you want to actually look at the content of an object,
    try using the `find()` method with your own custom predicate function instead.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()`和`lastIndexOf()`使用等价于`===`运算符的方式将它们的参数与数组元素进行比较。如果您的数组包含对象而不是原始值，这些方法将检查两个引用是否确实指向完全相同的对象。如果您想要实际查看对象的内容，请尝试使用带有自定义谓词函数的`find()`方法。'
- en: '`indexOf()` and `lastIndexOf()` take an optional second argument that specifies
    the array index at which to begin the search. If this argument is omitted, `indexOf()`
    starts at the beginning and `lastIndexOf()` starts at the end. Negative values
    are allowed for the second argument and are treated as an offset from the end
    of the array, as they are for the `slice()` method: a value of –1, for example,
    specifies the last element of the array.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf()`和`lastIndexOf()`接受一个可选的第二个参数，该参数指定开始搜索的数组索引。如果省略此参数，`indexOf()`从开头开始，`lastIndexOf()`从末尾开始。第二个参数允许使用负值，并被视为从数组末尾的偏移量，就像`slice()`方法一样：例如，-1表示数组的最后一个元素。'
- en: The following function searches an array for a specified value and returns an
    array of *all* matching indexes. This demonstrates how the second argument to
    `indexOf()` can be used to find matches beyond the first.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数搜索数组中指定值的所有匹配索引，并返回一个*所有*匹配索引的数组。这演示了如何使用`indexOf()`的第二个参数来查找第一个之外的匹配项。
- en: '[PRE58]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that strings have `indexOf()` and `lastIndexOf()` methods that work like
    these array methods, except that a negative second argument is treated as zero.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符串具有类似这些数组方法的`indexOf()`和`lastIndexOf()`方法，只是负的第二个参数被视为零。
- en: includes()
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: includes()
- en: The ES2016 `includes()` method takes a single argument and returns `true` if
    the array contains that value or `false` otherwise. It does not tell you the index
    of the value, only whether it exists. The `includes()` method is effectively a
    set membership test for arrays. Note, however, that arrays are not an efficient
    representation for sets, and if you are working with more than a few elements,
    you should use a real Set object ([§11.1.1](ch11.xhtml#setclass)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ES2016的`includes()`方法接受一个参数，如果数组包含该值则返回`true`，否则返回`false`。它不会告诉您该值的索引，只会告诉您它是否存在。`includes()`方法实际上是用于数组的集合成员测试。但是请注意，数组不是集合的有效表示形式，如果您处理的元素超过几个，应该使用真正的Set对象（[§11.1.1](ch11.xhtml#setclass)）。
- en: 'The `includes()` method is slightly different than the `indexOf()` method in
    one important way. `indexOf()` tests equality using the same algorithm that the
    `===` operator does, and that equality algorithm considers the not-a-number value
    to be different from every other value, including itself. `includes()` uses a
    slightly different version of equality that does consider `NaN` to be equal to
    itself. This means that `indexOf()` will not detect the `NaN` value in an array,
    but `includes()` will:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()`方法与`indexOf()`方法在一个重要方面略有不同。`indexOf()`使用与`===`运算符相同的算法进行相等性测试，该相等性算法认为非数字值与包括它本身在内的每个其他值都不同。`includes()`使用略有不同的相等性版本，它确实认为`NaN`等于它本身。这意味着`indexOf()`不会在数组中检测到`NaN`值，但`includes()`会：'
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: sort()
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sort()`'
- en: '`sort()` sorts the elements of an array in place and returns the sorted array.
    When `sort()` is called with no arguments, it sorts the array elements in alphabetical
    order (temporarily converting them to strings to perform the comparison, if necessary):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`对数组的元素进行原地排序并返回排序后的数组。当不带参数调用`sort()`时，它会按字母顺序对数组元素进行排序（如果需要，会临时将它们转换为字符串进行比较）：'
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If an array contains undefined elements, they are sorted to the end of the array.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组包含未定义的元素，则它们将被排序到数组的末尾。
- en: 'To sort an array into some order other than alphabetical, you must pass a comparison
    function as an argument to `sort()`. This function decides which of its two arguments
    should appear first in the sorted array. If the first argument should appear before
    the second, the comparison function should return a number less than zero. If
    the first argument should appear after the second in the sorted array, the function
    should return a number greater than zero. And if the two values are equivalent
    (i.e., if their order is irrelevant), the comparison function should return 0\.
    So, for example, to sort array elements into numerical rather than alphabetical
    order, you might do this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数组按照字母顺序以外的某种顺序排序，您必须将比较函数作为参数传递给`sort()`。此函数决定哪个参数应该首先出现在排序后的数组中。如果第一个参数应该出现在第二个参数之前，则比较函数应返回小于零的数字。如果第一个参数应该在排序后的数组中出现在第二个参数之后，则函数应返回大于零的数字。如果两个值相等（即，如果它们的顺序无关紧要），则比较函数应返回0。因此，例如，要将数组元素按照数字顺序而不是字母顺序排序，您可以这样做：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As another example of sorting array items, you might perform a case-insensitive
    alphabetical sort on an array of strings by passing a comparison function that
    converts both of its arguments to lowercase (with the `toLowerCase()` method)
    before comparing them:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对数组项进行排序的另一个示例，您可以通过传递一个比较函数对字符串数组进行不区分大小写的字母排序，该函数在比较之前将其两个参数都转换为小写（使用`toLowerCase()`方法）：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: reverse()
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`reverse()`'
- en: 'The `reverse()` method reverses the order of the elements of an array and returns
    the reversed array. It does this in place; in other words, it doesn’t create a
    new array with the elements rearranged but instead rearranges them in the already
    existing array:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse()`方法颠倒数组的元素顺序并返回颠倒的数组。它在原地执行此操作；换句话说，它不会创建一个重新排列元素的新数组，而是在已经存在的数组中重新排列它们：'
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 7.8.7 Array to String Conversions
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.7 数组转换为字符串
- en: The Array class defines three methods that can convert arrays to strings, which
    is generally something you might do when creating log and error messages. (If
    you want to save the contents of an array in textual form for later reuse, serialize
    the array with `JSON.stringify()` [[§6.8](ch06.xhtml#serializingobjects)] instead
    of using the methods described here.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Array类定义了三种可以将数组转换为字符串的方法，通常在创建日志和错误消息时可能会使用。 （如果要以文本形式保存数组的内容以供以后重用，请使用`JSON.stringify()`
    [[§6.8](ch06.xhtml#serializingobjects)]来序列化数组，而不是使用这里描述的方法。）
- en: 'The `join()` method converts all the elements of an array to strings and concatenates
    them, returning the resulting string. You can specify an optional string that
    separates the elements in the resulting string. If no separator string is specified,
    a comma is used:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`方法将数组的所有元素转换为字符串并连接它们，返回生成的字符串。您可以指定一个可选的字符串，用于分隔生成的字符串中的元素。如果未指定分隔符字符串，则使用逗号：'
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `join()` method is the inverse of the `String.split()` method, which creates
    an array by breaking a string into pieces.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`方法是`String.split()`方法的反向��作，它通过将字符串分割成片段来创建数组。'
- en: 'Arrays, like all JavaScript objects, have a `toString()` method. For an array,
    this method works just like the `join()` method with no arguments:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 数组，就像所有JavaScript对象一样，都有一个`toString()`方法。对于数组，此方法的工作方式与没有参数的`join()`方法相同：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the output does not include square brackets or any other sort of delimiter
    around the array value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出不包括方括号或任何其他类型的分隔符。
- en: '`toLocaleString()` is the localized version of `toString()`. It converts each
    array element to a string by calling the `toLocaleString()` method of the element,
    and then it concatenates the resulting strings using a locale-specific (and implementation-defined)
    separator string.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLocaleString()`是`toString()`的本地化版本。它通过调用元素的`toLocaleString()`方法将每个数组元素转换为字符串，然后使用特定于区域设置（和实现定义的）分隔符字符串连接生成的字符串。'
- en: 7.8.8 Static Array Functions
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8.8 静态数组函数
- en: In addition to the array methods we’ve already documented, the Array class also
    defines three static functions that you can invoke through the `Array` constructor
    rather than on arrays. `Array.of()` and `Array.from()` are factory methods for
    creating new arrays. They were documented in [§7.1.4](#arrayof) and [§7.1.5](#arrayfrom).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经记录的数组方法之外，Array类还定义了三个静态函数，您可以通过`Array`构造函数而不是在数组上调用这些函数。`Array.of()`和`Array.from()`是用于创建新数组的工厂方法。它们在[§7.1.4](#arrayof)和[§7.1.5](#arrayfrom)中有记录。
- en: 'The one other static array function is `Array.isArray()`, which is useful for
    determining whether an unknown value is an array or not:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个静态数组函数是`Array.isArray()`，用于确定未知值是否为数组：
- en: '[PRE66]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 7.9 Array-Like Objects
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.9 类似数组对象
- en: 'As we’ve seen, JavaScript arrays have some special features that other objects
    do not have:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，JavaScript数组具有其他对象没有的一些特殊功能：
- en: The `length` property is automatically updated as new elements are added to
    the list.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向列表添加新元素时，`length`属性会自动更新。
- en: Setting `length` to a smaller value truncates the array.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`length`设置为较小的值会截断数组。
- en: Arrays inherit useful methods from `Array.prototype`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组从`Array.prototype`继承了有用的方法。
- en: '`Array.isArray()` returns `true` for arrays.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于数组，`Array.isArray()`返回`true`。
- en: These are the features that make JavaScript arrays distinct from regular objects.
    But they are not the essential features that define an array. It is often perfectly
    reasonable to treat any object with a numeric `length` property and corresponding
    non-negative integer properties as a kind of array.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使JavaScript数组与常规对象不同的特点。但它们并不是定义数组的基本特征。将任何具有数值`length`属性和相应非负整数属性的对象视为一种数组通常是完全合理的。
- en: These “array-like” objects actually do occasionally appear in practice, and
    although you cannot directly invoke array methods on them or expect special behavior
    from the `length` property, you can still iterate through them with the same code
    you’d use for a true array. It turns out that many array algorithms work just
    as well with array-like objects as they do with real arrays. This is especially
    true if your algorithms treat the array as read-only or if they at least leave
    the array length unchanged.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些“类似数组”的对象实际上在实践中偶尔会出现，尽管你不能直接在它们上面调用数组方法或期望`length`属性有特殊行为，但你仍然可以使用与真实数组相同的代码迭代它们。事实证明，许多数组算法与类似数组对象一样有效，就像它们与真实数组一样有效一样。特别是如果你的算法将数组视为只读，或者至少保持数组长度不变时，这一点尤为真实。
- en: 'The following code takes a regular object, adds properties to make it an array-like
    object, and then iterates through the “elements” of the resulting pseudo-array:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将常规对象转换为类似数组对象，然后遍历生成的伪数组的“元素���：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In client-side JavaScript, a number of methods for working with HTML documents
    (such as `document.querySelectorAll()`, for example) return array-like objects.
    Here’s a function you might use to test for objects that work like arrays:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端JavaScript中，许多用于处理HTML文档的方法（例如`document.querySelectorAll()`）返回类似数组的对象。以下是您可能用于测试类似数组对象的函数：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We’ll see in a later section that strings behave like arrays. Nevertheless,
    tests like this one for array-like objects typically return `false` for strings—they
    are usually best handled as strings, not as arrays.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的部分看到字符串的行为类似于数组。然而，对于类似数组对象的此类测试通常对字符串返回`false`——最好将其处理为字符串，而不是数组。
- en: 'Most JavaScript array methods are purposely defined to be generic so that they
    work correctly when applied to array-like objects in addition to true arrays.
    Since array-like objects do not inherit from `Array.prototype`, you cannot invoke
    array methods on them directly. You can invoke them indirectly using the `Function.call`
    method, however (see [§8.7.4](ch08.xhtml#applyandcall) for details):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript数组方法都故意定义为通用的，以便在应用于类似数组对象时与真实数组一样正确工作。由于类似数组对象不继承自`Array.prototype`，因此不能直接在它们上调用数组方法。但是，您可以间接使用`Function.call`方法调用它们（有关详细信息，请参见[§8.7.4](ch08.xhtml#applyandcall)）：
- en: '[PRE69]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The second-to-last line of this code invokes the Array `slice()` method on an
    array-like object in order to copy the elements of that object into a true array
    object. This is an idiomatic trick that exists in much legacy code, but is now
    much easier to do with `Array.from()`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码倒数第二行在类似数组对象上调用Array `slice()`方法，以将该对象的元素复制到真实数组对象中。这是一种成语技巧，存在于许多传统代码中，但现在使用`Array.from()`更容易实现。
- en: 7.10 Strings as Arrays
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.10 字符串作为数组
- en: 'JavaScript strings behave like read-only arrays of UTF-16 Unicode characters.
    Instead of accessing individual characters with the `charAt()` method, you can
    use square brackets:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript字符串表现为UTF-16 Unicode字符的只读数组。您可以使用方括号而不是`charAt()`方法访问单个字符：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `typeof` operator still returns “string” for strings, of course, and the
    `Array.isArray()` method returns `false` if you pass it a string.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于字符串，`typeof`运算符仍然返回“string”，如果您将其传递给`Array.isArray()`方法，则返回`false`。
- en: 'The primary benefit of indexable strings is simply that we can replace calls
    to `charAt()` with square brackets, which are more concise and readable, and potentially
    more efficient. The fact that strings behave like arrays also means, however,
    that we can apply generic array methods to them. For example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可索引字符串的主要好处仅仅是我们可以用方括号替换`charAt()`的调用，这样更简洁、可读，并且可能更高效。然而，字符串表现得像数组意味着我们可以将通用数组方法应用于它们。例如：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Keep in mind that strings are immutable values, so when they are treated as
    arrays, they are read-only arrays. Array methods like `push()`, `sort()`, `reverse()`,
    and `splice()` modify an array in place and do not work on strings. Attempting
    to modify a string using an array method does not, however, cause an error: it
    simply fails silently.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字符串是不可变的值，因此当它们被视为数组时，它们是只读数组。像`push()`、`sort()`、`reverse()`和`splice()`这样的数组方法会就地修改数组，不适用于字符串。然而，尝试使用数组方法修改字符串不会导致错误：它只是悄无声息地失败。
- en: 7.11 Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7.11 总结
- en: 'This chapter has covered JavaScript arrays in depth, including esoteric details
    about sparse arrays and array-like objects. The main points to take from this
    chapter are:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入讨论了JavaScript数组，包括稀疏数组和类数组对象的奇特细节。从本章中可以得出的主要观点是：
- en: Array literals are written as comma-separated lists of values within square
    brackets.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组字面量是用方括号括起来的逗号分隔的值列表编写的。
- en: Individual array elements are accessed by specifying the desired array index
    within square brackets.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在方括号内指定所需的数组索引来访问单个数组元素。
- en: The `for/of` loop and `...` spread operator introduced in ES6 are particularly
    useful ways to iterate arrays.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ES6中引入的`for/of`循环和`...`扩展运算符是迭代数组的特别有用的方式。
- en: The Array class defines a rich set of methods for manipulating arrays, and you
    should be sure to familiarize yourself with the Array API.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Array类定义了一组丰富的方法来操作数组，你应该确保熟悉Array API。
