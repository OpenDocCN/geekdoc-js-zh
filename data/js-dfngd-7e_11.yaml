- en: Chapter 11\. The JavaScript Standard Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章 JavaScript 标准库
- en: 'Some datatypes, such as numbers and strings ([Chapter 3](ch03.xhtml#datatypes)),
    objects ([Chapter 6](ch06.xhtml#objects)), and arrays ([Chapter 7](ch07.xhtml#arrays))
    are so fundamental to JavaScript that we can consider them to be part of the language
    itself. This chapter covers other important but less fundamental APIs that can
    be thought of as defining the “standard library” for JavaScript: these are useful
    classes and functions that are built in to JavaScript and available to all JavaScript
    programs in both web browsers and in Node.^([1](ch11.xhtml#idm46198529052360))'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据类型，如数字和字符串（[第三章](ch03.xhtml#datatypes)）、对象（[第六章](ch06.xhtml#objects)）和数组（[第七章](ch07.xhtml#arrays)）对于
    JavaScript 来说是如此基础，以至于我们可以将它们视为语言本身的一部分。本章涵盖了其他重要但不太基础的 API，可以被视为 JavaScript 的“标准库”：这些是内置于
    JavaScript 中的有用类和函数，可供所有 Web 浏览器和 Node 中的 JavaScript 程序使用。^([1](ch11.xhtml#idm46198529052360))
- en: 'The sections of this chapter are independent of one another, and you can read
    them in any order. They cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各节相互独立，您可以按任意顺序阅读它们。它们涵盖了：
- en: The Set and Map classes for representing sets of values and mappings from one
    set of values to another set of values.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Set 和 Map 类，用于表示值的集合和从一个值集合到另一个值集合的映射。
- en: Array-like objects known as TypedArrays that represent arrays of binary data,
    along with a related class for extracting values from non-array binary data.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化数组（TypedArrays）等类似数组的对象，表示二进制数据的数组，以及用于从非数组二进制数据中提取值的相关类。
- en: Regular expressions and the RegExp class, which define textual patterns and
    are useful for text processing. This section also covers regular expression syntax
    in detail.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式和 RegExp 类，定义文本模式，对文本处理很有用。本节还详细介绍了正则表达式语法。
- en: The Date class for representing and manipulating dates and times.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Date 类用于表示和操作日期和时间。
- en: The Error class and its various subclasses, instances of which are thrown when
    errors occur in JavaScript programs.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Error 类及其各种子类的实例，当 JavaScript 程序发生错误时抛出。
- en: The JSON object, whose methods support serialization and deserialization of
    JavaScript data structures composed of objects, arrays, strings, numbers, and
    booleans.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON 对象，其方法支持对由对象、数组、字符串、数字和布尔值组成的 JavaScript 数据结构进行序列化和反序列化。
- en: The Intl object and the classes it defines that can help you localize your JavaScript
    programs.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intl 对象及其定义的类，可帮助您本地化 JavaScript 程序。
- en: The Console object, whose methods output strings in ways that are particularly
    useful for debugging programs and logging the behavior of those programs.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Console 对象，其方法以特别有用的方式输出字符串，用于调试程序和记录程序的行为。
- en: The URL class, which simplifies the task of parsing and manipulating URLs. This
    section also covers global functions for encoding and decoding URLs and their
    component parts.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL 类简化了解析和操作 URL 的任务。本节还涵盖了用于对 URL 及其组件进行编码和解码的全局函数。
- en: '`setTimeout()` and related functions for specifying code to be executed after
    a specified interval of time has elapsed.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTimeout()`及相关函数用于指定在经过指定时间间隔后执行的代码。'
- en: 'Some of the sections in this chapter—notably, the sections on typed arrays
    and regular expressions—are quite long because there is significant background
    information you need to understand before you can use those types effectively.
    Many of the other sections, however, are short: they simply introduce a new API
    and show some examples of its use.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些部分，尤其是关于类型化数组和正则表达式的部分，由于您需要理解的重要背景信息较多，因此相当长。然而，其他许多部分很短：它们只是介绍一个新的 API
    并展示其使用示例。
- en: 11.1 Sets and Maps
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.1 集合和映射
- en: JavaScript’s Object type is a versatile data structure that can be used to map
    strings (the object’s property names) to arbitrary values. And when the value
    being mapped to is something fixed like `true`, then the object is effectively
    a set of strings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的 Object 类型是一种多功能的数据结构，可以用来将字符串（对象的属性名称）映射到任意值。当被映射的值是像`true`这样固定的值时，那么对象实际上就是一组字符串。
- en: Objects are actually used as maps and sets fairly routinely in JavaScript programming,
    but this is limited by the restriction to strings and complicated by the fact
    that objects normally inherit properties with names like “toString”, which are
    not typically intended to be part of the map or set.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 编程中，对象实际上经常被用作映射和集合，但由于限制为字符串并且对象通常继承具有诸如“toString”之类名称的属性，这使得使用起来有些复杂，通常这些属性并不打算成为映射或集合的一部分。
- en: For this reason, ES6 introduces true Set and Map classes, which we’ll cover
    in the sub-sections that follow.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这个原因，ES6 引入了真正的 Set 和 Map 类，我们将在接下来的子章节中介绍。
- en: 11.1.1 The Set Class
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.1 Set 类
- en: 'A set is a collection of values, like an array is. Unlike arrays, however,
    sets are not ordered or indexed, and they do not allow duplicates: a value is
    either a member of a set or it is not a member; it is not possible to ask how
    many times a value appears in a set.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一组值，类似于数组。但与数组不同，集合没有顺序或索引，并且不允许重复：一个值要么是集合的成员，要么不是成员；无法询问一个值在集合中出现多少次。
- en: 'Create a Set object with the `Set()` constructor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Set()`构造函数创建一个 Set 对象：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The argument to the `Set()` constructor need not be an array: any iterable
    object (including other Set objects) is allowed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set()`构造函数的参数不一定是数组：任何可迭代对象（包括其他 Set 对象）都是允许的：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `size` property of a set is like the `length` property of an array: it
    tells you how many values the set contains:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的`size`属性类似于数组的`length`属性：它告诉你集合包含多少个值：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sets don’t need to be initialized when you create them. You can add and remove
    elements at any time with `add()`, `delete()`, and `clear()`. Remember that sets
    cannot contain duplicates, so adding a value to a set when it already contains
    that value has no effect:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合时无需初始化。您可以随时使用`add()`、`delete()`和`clear()`添加和删除元素。请记住，集合不能包含重复项，因此向集合添加已包含的值不会产生任何效果：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few important points to note about this code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码有几个重要的要���需要注意：
- en: The `add()` method takes a single argument; if you pass an array, it adds the
    array itself to the set, not the individual array elements. `add()` always returns
    the set it is invoked on, however, so if you want to add multiple values to a
    set, you can used chained method calls like `s.add('a').add('b').add('c');`.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`方法接受一个参数；如果传递一个数组，它会将数组本身添加到集合中，而不是单独的数组元素。但是，`add()`始终返回调用它的集合，因此如果要向集合添加多个值，可以使用链式方法调用，如`s.add(''a'').add(''b'').add(''c'');`。'
- en: The `delete()` method also only deletes a single set element at a time. Unlike
    `add()`, however, `delete()` returns a boolean value. If the value you specify
    was actually a member of the set, then `delete()` removes it and returns `true`.
    Otherwise, it does nothing and returns `false`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`方法也仅一次删除单个集合元素。但是，与`add()`不同，`delete()`返回一个布尔值。如果您指定的值实际上是集合的成员，则`delete()`会将其删除并返回`true`。否则，它不执行任何操作并返回`false`。'
- en: Finally, it is very important to understand that set membership is based on
    strict equality checks, like the `===` operator performs. A set can contain both
    the number `1` and the string `"1"`, because it considers them to be distinct
    values. When the values are objects (or arrays or functions), they are also compared
    as if with `===`. This is why we were unable to delete the array element from
    the set in this code. We added an array to the set and then tried to remove that
    array by passing a *different* array (albeit with the same elements) to the `delete()`
    method. In order for this to work, we would have had to pass a reference to exactly
    the same array.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，非常重要的是要理解集合成员是基于严格的相等性检查的，就像`===`运算符执行的那样。集合可以包含数字`1`和字符串`"1"`，因为它认为它们是不同的值。当值为对象（或数组或函数）时，它们也被视为使用`===`进行比较。这就是为什么我们无法从此代码中的集合中删除数组元素的原因。我们向集合添加了一个数组，然后尝试通过向`delete()`方法传递一个*不同*的数组（尽管具有相同元素）来删除该数组。为了使其工作，我们必须传递对完全相同的数组的引用。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Python programmers take note: this is a significant difference between JavaScript
    and Python sets. Python sets compare members for equality, not identity, but the
    trade-off is that Python sets only allow immutable members, like tuples, and do
    not allow lists and dicts to be added to sets.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员请注意：这是JavaScript和Python集合之间的一个重要区别。Python集合比较成员的相等性，而不是身份，但这样做的代价是Python集合只允许不可变成员，如元组，并且不允许将列表和字典添加到集合中。
- en: 'In practice, the most important thing we do with sets is not to add and remove
    elements from them, but to check to see whether a specified value is a member
    of the set. We do this with the `has()` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们与集合最重要的事情不是向其中添加和删除元素，而是检查指定的值是否是集合的成员。我们使用`has()`方法来实现这一点：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The most important thing to understand about sets is that they are optimized
    for membership testing, and no matter how many members the set has, the `has()`
    method will be very fast. The `includes()` method of an array also performs membership
    testing, but the time it takes is proportional to the size of the array, and using
    an array as a set can be much, much slower than using a real Set object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于集合最重要的一点是它们被优化用于成员测试，无论集合有多少成员，`has()`方法都会非常快。数组的`includes()`方法也执行成员测试，但所需时间与数组的大小成正比，使用数组作为集合可能比使用真正的Set对象慢得多。
- en: 'The Set class is iterable, which means that you can use a `for/of` loop to
    enumerate all of the elements of a set:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Set类是可迭代的，这意味着您可以使用`for/of`循环枚举集合的所有元素：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because Set objects are iterable, you can convert them to arrays and argument
    lists with the `...` spread operator:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Set对象是可迭代的，您可以使用`...`扩展运算符将它们转换为数组和参数列表：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Sets are often described as “unordered collections.” This isn’t exactly true
    for the JavaScript Set class, however. A JavaScript set is unindexed: you can’t
    ask for the first or third element of a set the way you can with an array. But
    the JavaScript Set class always remembers the order that elements were inserted
    in, and it always uses this order when you iterate a set: the first element inserted
    will be the first one iterated (assuming you haven’t deleted it first), and the
    most recently inserted element will be the last one iterated.^([2](ch11.xhtml#idm46198528676184))'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 集合经常被描述为“无序集合”。然而，对于JavaScript Set类来说，这并不完全正确。JavaScript集合是无索引的：您无法像数组那样请求集合的第一个或第三个元素。但是JavaScript
    Set类始终记住元素插入的顺序，并且在迭代集合时始终使用此顺序：插入的第一个元素将是首个迭代的元素（假设您尚未首先删除它），最近插入的元素将是最后一个迭代的元素。^([2](ch11.xhtml#idm46198528676184))
- en: 'In addition to being iterable, the Set class also implements a `forEach()`
    method that is similar to the array method of the same name:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可迭代外，Set类还实现了类似于数组同名方法的`forEach()`方法：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `forEach()` of an array passes array indexes as the second argument to the
    function you specify. Sets don’t have indexes, so the Set class’s version of this
    method simply passes the element value as both the first and second argument.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`forEach()`将数组索引作为第二个参数传递给您指定的函数。集合没有索引，因此Set类的此方法简单地将元素值作为第一个和第二个参数传递。
- en: 11.1.2 The Map Class
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.2 Map类
- en: 'A Map object represents a set of values known as *keys*, where each key has
    another value associated with (or “mapped to”) it. In a sense, a map is like an
    array, but instead of using a set of sequential integers as the keys, maps allow
    us to use arbitrary values as “indexes.” Like arrays, maps are fast: looking up
    the value associated with a key will be fast (though not as fast as indexing an
    array) no matter how large the map is.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Map对象表示一组称为*键*的值，其中每个键都有另一个与之关联（或“映射到”）的值。在某种意义上，映射类似于数组，但是不同于使用一组顺序整数作为键，映射允许我们使用任意值作为“索引”。与数组一样，映射很快：查找与键关联的值将很快（尽管不像索引数组那样快），无论映射有多大。
- en: 'Create a new map with the `Map()` constructor:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Map()`构造函数创建一个新的映射：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The optional argument to the `Map()` constructor should be an iterable object
    that yields two element `[key, value]` arrays. In practice, this means that if
    you want to initialize a map when you create it, you’ll typically write out the
    desired keys and associated values as an array of arrays. But you can also use
    the `Map()` constructor to copy other maps or to copy the property names and values
    from an existing object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map()` 构造函数的可选参数应该是一个可迭代对象，产生两个元素 `[key, value]` 数组。在实践中，这意味着如果你想在创建 map 时初始化它，你通常会将所需的键和��联值写成数组的数组。但你也可以使用
    `Map()` 构造函数复制其他 map，或从现有对象复制属性名和值：'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once you have created a Map object, you can query the value associated with
    a given key with `get()` and can add a new key/value pair with `set()`. Remember,
    though, that a map is a set of keys, each of which has an associated value. This
    is not quite the same as a set of key/value pairs. If you call `set()` with a
    key that already exists in the map, you will change the value associated with
    that key, not add a new key/value mapping. In addition to `get()` and `set()`,
    the Map class also defines methods that are like Set methods: use `has()` to check
    whether a map includes the specified key; use `delete()` to remove a key (and
    its associated value) from the map; use `clear()` to remove all key/value pairs
    from the map; and use the `size` property to find out how many keys a map contains.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个 Map 对象，你可以使用 `get()` 查询与给定键关联的值，并可以使用 `set()` 添加新的键/值对。但请记住，map 是一组键，每个键都有一个关联的值。这与一组键/值对并不完全相同。如果你使用一个已经存在于
    map 中的键调用 `set()`，你将改变与该键关联的值，而不是添加一个新的键/值映射。除了 `get()` 和 `set()`，Map 类还定义了类似
    Set 方法的方法：使用 `has()` 检查 map 是否包含指定的键；使用 `delete()` 从 map 中删除一个键（及其关联的值）；使用 `clear()`
    从 map 中删除所有键/值对；使用 `size` 属性查找 map 包含多少个键。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Like the `add()` method of Set, the `set()` method of Map can be chained, which
    allows maps to be initialized without using arrays of arrays:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Set 的 `add()` 方法一样，Map 的 `set()` 方法可以链接，这允许初始化 map 而不使用数组的数组：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As with Set, any JavaScript value can be used as a key or a value in a Map.
    This includes `null`, `undefined`, and `NaN`, as well as reference types like
    objects and arrays. And as with the Set class, Map compares keys by identity,
    not by equality, so if you use an object or array as a key, it will be considered
    different from every other object and array, even those with exactly the same
    properties or elements:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Set 一样，任何 JavaScript 值都可以用作 Map 中的键或值。这包括 `null`、`undefined` 和 `NaN`，以及对象和数组等引用类型。与
    Set 类一样，Map 通过标识比较键，而不是通过相等性比较，因此如果你使用对象或数组作为键，它将被认为与每个其他对象和数组都不同，即使它们具有完全相同的属性或元素：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Map objects are iterable, and each iterated value is a two-element array where
    the first element is a key and the second element is the value associated with
    that key. If you use the spread operator with a Map object, you’ll get an array
    of arrays like the ones that we passed to the `Map()` constructor. And when iterating
    a map with a `for/of` loop, it is idiomatic to use destructuring assignment to
    assign the key and value to separate variables:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Map 对象是可迭代的，每个迭代的值都是一个包含两个元素的数组，第一个元素是键，第二个元素是与该键关联的值。如果你使用展开运算符与 Map 对象一起使用，你将得到一个类似于我们传递给
    `Map()` 构造函数的数组的数组。在使用 `for/of` 循环迭代 map 时，惯用的做法是使用解构赋值将键和值分配给单独的变量：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Like the Set class, the Map class iterates in insertion order. The first key/value
    pair iterated will be the one least recently added to the map, and the last pair
    iterated will be the one most recently added.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Set 类一样，Map 类按插入顺序进行迭代。迭代的第一个键/值对将是最近添加到 map 中的键/值对，而迭代的最后一个键/值对将是最近添加的键/值对。
- en: 'If you want to iterate just the keys or just the associated values of a map,
    use the `keys()` and `values()` methods: these return iterable objects that iterate
    keys and values, in insertion order. (The `entries()` method returns an iterable
    object that iterates key/value pairs, but this is exactly the same as iterating
    the map directly.)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想仅迭代 map 的键或仅迭代关联的值，请使用 `keys()` 和 `values()` 方法：这些方法返回可迭代对象，按插入顺序迭代键和值。（`entries()`
    方法返回一个可迭代对象，按键/值对迭代，但这与直接迭代 map 完全相同。）
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Map objects can also be iterated using the `forEach()` method that was first
    implemented by the Array class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Map 对象也可以使用首次由 Array 类实现的 `forEach()` 方法进行迭代。
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It may seem strange that the value parameter comes before the key parameter
    in the code above, since with `for/of` iteration, the key comes first. As noted
    at the start of this section, you can think of a map as a generalized array in
    which integer array indexes are replaced with arbitrary key values. The `forEach()`
    method of arrays passes the array element first and the array index second, so,
    by analogy, the `forEach()` method of a map passes the map value first and the
    map key second.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会觉得上面的代码中值参数在键参数之前有些奇怪，因为在 `for/of` 迭代中，键首先出现。正如本节开头所述，你可以将 map 视为一个广义的数组，其中整数数组索引被任意键值替换。数组的
    `forEach()` 方法首先传递数组元素，然后传递数组索引，因此，类比地，map 的 `forEach()` 方法首先传递 map 值，然后传递 map
    键。
- en: 11.1.3 WeakMap and WeakSet
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.3 WeakMap 和 WeakSet
- en: The WeakMap class is a variant (but not an actual subclass) of the Map class
    that does not prevent its key values from being garbage collected. Garbage collection
    is the process by which the JavaScript interpreter reclaims the memory of objects
    that are no longer “reachable” and cannot be used by the program. A regular map
    holds “strong” references to its key values, and they remain reachable through
    the map, even if all other references to them are gone. The WeakMap, by contrast,
    keeps “weak” references to its key values so that they are not reachable through
    the WeakMap, and their presence in the map does not prevent their memory from
    being reclaimed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap类是Map类的变体（但不是实际的子类），不会阻止其键值被垃圾回收。垃圾回收是JavaScript解释器回收不再“可达”的对象内存的过程，这些对象不能被程序使用。常规映射保持对其键值的“强”引用，它们通过映射保持可达性，即使所有对它们的其他引用都消失了。相比之下，WeakMap对其键值保持“弱”引用，因此它们不可通过WeakMap访问，它们在映射中的存在不会阻止其内存被回收。
- en: 'The `WeakMap()` constructor is just like the `Map()` constructor, but there
    are some significant differences between WeakMap and Map:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap()`构造函数与`Map()`构造函数完全相同，但WeakMap和Map之间存在一些重要的区别：'
- en: WeakMap keys must be objects or arrays; primitive values are not subject to
    garbage collection and cannot be used as keys.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakMap的键必须是对象或数组；原始值不受垃圾回收的影响，不能用作键。
- en: WeakMap implements only the `get()`, `set()`, `has()`, and `delete()` methods.
    In particular, WeakMap is not iterable and does not define `keys()`, `values()`,
    or `forEach()`. If WeakMap was iterable, then its keys would be reachable and
    it wouldn’t be weak.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakMap只实现了`get()`、`set()`、`has()`和`delete()`方法。特别是，WeakMap不可迭代，并且不定义`keys()`、`values()`或`forEach()`。如果WeakMap是可迭代的，那么它的键将是可达的，它就不会是弱引用的。
- en: Similarly, WeakMap does not implement the `size` property because the size of
    a WeakMap could change at any time as objects are garbage collected.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，WeakMap也不实现`size`属性，因为WeakMap的大小随时可能会随着对象被垃圾回收而改变。
- en: The intended use of WeakMap is to allow you to associate values with objects
    without causing memory leaks. Suppose, for example, that you are writing a function
    that takes an object argument and needs to perform some time-consuming computation
    on that object. For efficiency, you’d like to cache the computed value for later
    reuse. If you use a Map object to implement the cache, you will prevent any of
    the objects from ever being reclaimed, but by using a WeakMap, you avoid this
    problem. (You can often achieve a similar result using a private Symbol property
    to cache the computed value directly on the object. See [§6.10.3](ch06.xhtml#symbols-as-property-names).)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: WeakMap的预期用途是允许您将值与对象关联而不会导致内存泄漏。例如，假设您正在编写一个函数，该函数接受一个对象参数并需要对该对象执行一些耗时的计算。为了效率，您希望缓存计算后的值以供以后重用。如果使用Map对象来实现缓存，将阻止任何对象被回收，但使用WeakMap，您可以避免这个问题。（您通常可以使用私有Symbol属性直接在对象上缓存计算后的值来实现类似的结果。参见[§6.10.3](ch06.xhtml#symbols-as-property-names)。）
- en: 'WeakSet implements a set of objects that does not prevent those objects from
    being garbage collected. The `WeakSet()` constructor works like the `Set()` constructor,
    but WeakSet objects differ from Set objects in the same ways that WeakMap objects
    differ from Map objects:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WeakSet实现了一组对象，不会阻止这些对象被垃圾回收。`WeakSet()`构造函数的工作方式类似于`Set()`构造函数，但WeakSet对象与Set对象的区别与WeakMap对象与Map对象的区别相同：
- en: WeakSet does not allow primitive values as members.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakSet不允许原始值作为成员。
- en: WeakSet implements only the `add()`, `has()`, and `delete()` methods and is
    not iterable.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakSet只实现了`add()`、`has()`和`delete()`方法，并且不可迭代。
- en: WeakSet does not have a `size` property.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakSet没有`size`属性。
- en: 'WeakSet is not frequently used: its use cases are like those for WeakMap. If
    you want to mark (or “brand”) an object as having some special property or type,
    for example, you could add it to a WeakSet. Then, elsewhere, when you want to
    check for that property or type, you can test for membership in that WeakSet.
    Doing this with a regular set would prevent all marked objects from being garbage
    collected, but this is not a concern when using WeakSet.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: WeakSet并不经常使用：它的用例类似于WeakMap。如果你想标记（或“品牌化”）一个对象具有某些特殊属性或类型，例如，你可以将其添加到WeakSet中。然后，在其他地方，当你想检查该属性或类型时，可以测试该WeakSet的成员资格。使用常规集合会阻止所有标记对象被垃圾回收，但使用WeakSet时不必担心这个问题。
- en: 11.2 Typed Arrays and Binary Data
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.2 类型化数组和二进制数据
- en: 'Regular JavaScript arrays can have elements of any type and can grow or shrink
    dynamically. JavaScript implementations perform lots of optimizations so that
    typical uses of JavaScript arrays are very fast. Nevertheless, they are still
    quite different from the array types of lower-level languages like C and Java.
    *Typed arrays*, which are new in ES6,^([3](ch11.xhtml#idm46198527893912)) are
    much closer to the low-level arrays of those languages. Typed arrays are not technically
    arrays (`Array.isArray()` returns `false` for them), but they implement all of
    the array methods described in [§7.8](ch07.xhtml#arraymethods) plus a few more
    of their own. They differ from regular arrays in some very important ways, however:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 常规JavaScript数组可以具有任何类型的元素，并且可以动态增长或缩小。JavaScript实现执行许多优化，使得JavaScript数组的典型用法非常快速。然而，它们与低级语言（如C和Java）的数组类型仍然有很大不同。*类型化数组*是ES6中的新功能，^([3](ch11.xhtml#idm46198527893912))它们更接近这些语言的低级数组。类型化数组在技术上不是数组（`Array.isArray()`对它们返回`false`），但它们实现了[§7.8](ch07.xhtml#arraymethods)中描述的所有数组方法以及一些自己的方法。然而，它们与常规数组在一些非常重要的方面有所不同：
- en: The elements of a typed array are all numbers. Unlike regular JavaScript numbers,
    however, typed arrays allow you to specify the type (signed and unsigned integers
    and IEEE-754 floating point) and size (8 bits to 64 bits) of the numbers to be
    stored in the array.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化数组的元素都是数字。然而，与常规JavaScript数字不同，类型化数组允许您指定要存储在数组中的数字的类型（有符号和无符号整数和IEEE-754浮点数）和大小（8位到64位）。
- en: You must specify the length of a typed array when you create it, and that length
    can never change.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类型化数组时必须指定其长度，并且该长度永远不会改变。
- en: The elements of a typed array are always initialized to 0 when the array is
    created.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型化数组的元素在创建数组时始终初始化为 0。
- en: 11.2.1 Typed Array Types
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.1 类型化数组类型
- en: 'JavaScript does not define a TypedArray class. Instead, there are 11 kinds
    of typed arrays, each with a different element type and constructor:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 没有定义 TypedArray 类。相反，有 11 种类型化数组，每种具有不同的元素类型和构造函数：
- en: '| Constructor | Numeric type |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 构造函数 | 数值类型 |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Int8Array()` | signed bytes |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `Int8Array()` | 有符号字节 |'
- en: '| `Uint8Array()` | unsigned bytes |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8Array()` | 无符号字节 |'
- en: '| `Uint8ClampedArray()` | unsigned bytes without rollover |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Uint8ClampedArray()` | 无溢出的无符号字节 |'
- en: '| `Int16Array()` | signed 16-bit short integers |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `Int16Array()` | 有符号 16 位短整数 |'
- en: '| `Uint16Array()` | unsigned 16-bit short integers |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Uint16Array()` | 无符号 16 位短整数 |'
- en: '| `Int32Array()` | signed 32-bit integers |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Int32Array()` | 有符号 32 位整数 |'
- en: '| `Uint32Array()` | unsigned 32-bit integers |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `Uint32Array()` | 无符号 32 位整数 |'
- en: '| `BigInt64Array()` | signed 64-bit BigInt values (ES2020) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `BigInt64Array()` | 有符号 64 位 BigInt 值（ES2020） |'
- en: '| `BigUint64Array()` | unsigned 64-bit BigInt values (ES2020) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `BigUint64Array()` | 无符号 64 位 BigInt 值（ES2020） |'
- en: '| `Float32Array()` | 32-bit floating-point value |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Float32Array()` | 32 位浮点值 |'
- en: '| `Float64Array()` | 64-bit floating-point value: a regular JavaScript number
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Float64Array()` | 64位浮点值：普通的 JavaScript 数字 |'
- en: The types whose names begin with `Int` hold signed integers, of 1, 2, or 4 bytes
    (8, 16, or 32 bits). The types whose names begin with `Uint` hold unsigned integers
    of those same lengths. The “BigInt” and “BigUint” types hold 64-bit integers,
    represented in JavaScript as BigInt values (see [§3.2.5](ch03.xhtml#bigint)).
    The types that begin with `Float` hold floating-point numbers. The elements of
    a `Float64Array` are of the same type as regular JavaScript numbers. The elements
    of a `Float32Array` have lower precision and a smaller range but require only
    half the memory. (This type is called `float` in C and Java.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 名称以 `Int` 开头的类型保存有符号整数，占用 1、2 或 4 字节（8、16 或 32 位）。名称以 `Uint` 开头的类型保存相同长度的无符号整数。名称为
    “BigInt” 和 “BigUint” 的类型保存 64 位整数，以 BigInt 值的形式表示在 JavaScript 中（参见 [§3.2.5](ch03.xhtml#bigint)）。以
    `Float` 开头的类型保存浮点数。`Float64Array` 的元素与普通的 JavaScript 数字相同类型。`Float32Array` 的元素精度较低，范围较小，但只需一半的内存。
    （在 C 和 Java 中，此类型称为 `float`。）
- en: '`Uint8ClampedArray` is a special-case variant on `Uint8Array`. Both of these
    types hold unsigned bytes and can represent numbers between 0 and 255\. With `Uint8Array`,
    if you store a value larger than 255 or less than zero into an array element,
    it “wraps around,” and you get some other value. This is how computer memory works
    at a low level, so this is very fast. `Uint8ClampedArray` does some extra type
    checking so that, if you store a value greater than 255 or less than 0, it “clamps”
    to 255 or 0 and does not wrap around. (This clamping behavior is required by the
    HTML `<canvas>` element’s low-level API for manipulating pixel colors.)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Uint8ClampedArray` 是 `Uint8Array` 的特殊变体。这两种类型都保存无符号字节，可以表示 0 到 255 之间的数字。对于
    `Uint8Array`，如果将大于 255 或小于零的值存储到数组元素中，它会“环绕”，并且会得到其他值。这是计算机内存在低级别上的工作原理，因此速度非常快。`Uint8ClampedArray`
    进行了一些额外的类型检查，以便如果存储大于 255 或小于 0 的值，则会“夹紧”到 255 或 0，而不会环绕。 （这种夹紧行为是 HTML `<canvas>`
    元素的低级 API 用于操作像素颜色所必需的。）'
- en: Each of the typed array constructors has a `BYTES_PER_ELEMENT` property with
    the value 1, 2, 4, or 8, depending on the type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类型化数组构造函数都有一个 `BYTES_PER_ELEMENT` 属性，其值为 1、2、4 或 8，取决于类型。
- en: 11.2.2 Creating Typed Arrays
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.2 创建类型化数组
- en: 'The simplest way to create a typed array is to call the appropriate constructor
    with one numeric argument that specifies the number of elements you want in the
    array:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类型化数组的最简单方法是调用适当的构造函数，并提供一个数字参数，指定数组中要包含的元素数量：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you create typed arrays in this way, the array elements are all guaranteed
    to be initialized to `0`, `0n`, or `0.0`. But if you know the values you want
    in your typed array, you can also specify those values when you create the array.
    Each of the typed array constructors has static `from()` and `of()` factory methods
    that work like `Array.from()` and `Array.of()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式创建类型化数组时，数组元素都保证初始化为 `0`、`0n` 或 `0.0`。但是，如果您知道要在类型化数组中使用的值，也可以在创建数组时指定这些值。每个类型化数组构造函数都有静态的
    `from()` 和 `of()` 工厂方法，类似于 `Array.from()` 和 `Array.of()`：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Recall that the `Array.from()` factory method expects an array-like or iterable
    object as its first argument. The same is true for the typed array variants, except
    that the iterable or array-like object must also have numeric elements. Strings
    are iterable, for example, but it would make no sense to pass them to the `from()`
    factory method of a typed array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`Array.from()` 工厂方法的第一个参数应为类似数组或可迭代对象。对于类型化数组变体也是如此，只是可迭代或类似数组的对象还必须具有数值元素。例如，字符串是可迭代的，但将它们传递给类型化数组的
    `from()` 工厂方法是没有意义的。
- en: 'If you are just using the one-argument version of `from()`, you can drop the
    `.from` and pass your iterable or array-like object directly to the constructor
    function, which behaves exactly the same. Note that both the constructor and the
    `from()` factory method allow you to copy existing typed arrays, while possibly
    changing the type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只使用 `from()` 的单参数版本，可以省略 `.from` 并直接将可迭代或类似数组对象传递给构造函数，其行为完全相同。请注意，构造函数和 `from()`
    工厂方法都允许您复制现有的类型化数组，同时可能更改类型：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you create a new typed array from an existing array, iterable, or array-like
    object, the values may be truncated in order to fit the type constraints of your
    array. There are no warnings or errors when this happens:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当从现有数组、可迭代对象或类似数组对象创建新的类型化数组时，值可能会被截断以符合数组的类型约束。当发生这种情况时，不会有警告或错误：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, there is one more way to create typed arrays that involves the ArrayBuffer
    type. An ArrayBuffer is an opaque reference to a chunk of memory. You can create
    one with the constructor; just pass in the number of bytes of memory you’d like
    to allocate:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一种使用 ArrayBuffer 类型创建 typed arrays 的方法。ArrayBuffer 是一个对一块内存的不透明引用。你可以用构造函数创建一个，只需传入你想要分配的内存字节数：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The ArrayBuffer class does not allow you to read or write any of the bytes
    that you have allocated. But you can create typed arrays that use the buffer’s
    memory and that do allow you to read and write that memory. To do this, call the
    typed array constructor with an ArrayBuffer as the first argument, a byte offset
    within the array buffer as the second argument, and the array length (in elements,
    not in bytes) as the third argument. The second and third arguments are optional.
    If you omit both, then the array will use all of the memory in the array buffer.
    If you omit only the length argument, then your array will use all of the available
    memory between the start position and the end of the array. One more thing to
    bear in mind about this form of the typed array constructor: arrays must be memory
    aligned, so if you specify a byte offset, the value should be a multiple of the
    size of your type. The `Int32Array()` constructor requires a multiple of four,
    for example, and the `Float64Array()` requires a multiple of eight.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayBuffer 类不允许你读取或写入你分配的任何字节。但你可以创建使用 buffer 内存的 typed arrays，并且允许你读取和写入该内存。为此，调用
    typed array 构造函数，第一个参数是一个 ArrayBuffer，第二个参数是数组缓冲区内的字节偏���量，第三个参数是数组长度（以元素而不是字节计算）。第二和第三个参数是可选的。如果两者都省略，则数组将使用数组缓冲区中的所有内存。如果只省略长度参数，则你的数组将使用从起始位置到数组结束的所有可用内存。关于这种形式的
    typed array 构造函数还有一件事要记住：数组必须是内存对齐的，所以如果你指定了一个字节偏移量，该值应该是你的类型大小的倍数。例如，`Int32Array()`
    构造函数需要四的倍数，而 `Float64Array()` 需要八的倍数。
- en: 'Given the ArrayBuffer created earlier, you could create typed arrays like these:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定之前创建的 ArrayBuffer，你可以创建这样的 typed arrays：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These four typed arrays offer four different views into the memory represented
    by the ArrayBuffer. It is important to understand that all typed arrays have an
    underlying ArrayBuffer, even if you do not explicitly specify one. If you call
    a typed array constructor without passing a buffer object, a buffer of the appropriate
    size will be automatically created. As described later, the `buffer` property
    of any typed array refers to its underlying ArrayBuffer object. The reason to
    work directly with ArrayBuffer objects is that sometimes you may want to have
    multiple typed array views of a single buffer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种 typed arrays 提供了对由 ArrayBuffer 表示的内存的四种不同视图。重要的是要理解，所有 typed arrays 都有一个底层的
    ArrayBuffer，即使你没有明确指定一个。如果你调用一个 typed array 构造函数而没有传递一个 buffer 对象，一个适当大小的 buffer
    将会被自动创建。正如后面所描述的，任何 typed array 的 `buffer` 属性都指向它的底层 ArrayBuffer 对象。直接使用 ArrayBuffer
    对象的原因是有时你可能想要有一个单一 buffer 的多个 typed array 视图。
- en: 11.2.3 Using Typed Arrays
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.3 使用 Typed Arrays
- en: 'Once you have created a typed array, you can read and write its elements with
    regular square-bracket notation, just as you would with any other array-like object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个 typed array，你可以用常规的方括号表示法读取和写入它的元素，就像你对待任何其他类似数组的对象一样：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The function here computes the largest prime number smaller than the number
    you specify. The code is exactly the same as it would be with a regular JavaScript
    array, but using `Uint8Array()` instead of `Array()` makes the code run more than
    four times faster and use eight times less memory in my testing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数计算比你指定的数字小的最大质数。代码与使用常规 JavaScript 数组完全相同，但在我的测试中使用 `Uint8Array()` 而不是
    `Array()` 使代码运行速度超过四倍，并且使用的内存少了八倍。
- en: 'Typed arrays are not true arrays, but they re-implement most array methods,
    so you can use them pretty much just like you’d use regular arrays:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Typed arrays 不是真正的数组，但它们重新实现了大多数数组方法，所以你可以几乎像使用常规数组一样使用它们：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember that typed arrays have fixed lengths, so the `length` property is read-only,
    and methods that change the length of the array (such as `push()`, `pop()`, `unshift()`,
    `shift()`, and `splice()`) are not implemented for typed arrays. Methods that
    alter the contents of an array without changing the length (such as `sort()`,
    `reverse()`, and `fill()`) are implemented. Methods like `map()` and `slice()`
    that return new arrays return a typed array of the same type as the one they are
    called on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，typed arrays 有固定的长度，所以 `length` 属性是只读的，而改变数组长度的方法（如 `push()`、`pop()`、`unshift()`、`shift()`
    和 `splice()`）对 typed arrays 没有实现。改变数组内容而不改变长度的方法（如 `sort()`、`reverse()` 和 `fill()`）是实现的。返回新数组的
    `map()` 和 `slice()` 等方法返回与调用它们的 typed array 相同类型的 typed array。
- en: 11.2.4 Typed Array Methods and Properties
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.4 Typed Array 方法和属性
- en: 'In addition to standard array methods, typed arrays also implement a few methods
    of their own. The `set()` method sets multiple elements of a typed array at once
    by copying the elements of a regular or typed array into a typed array:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准数组方法外，typed arrays 也实现了一些自己的方法。`set()` 方法通过将常规或 typed array 的元素复制到 typed
    array 中一次设置多个元素：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `set()` method takes an array or typed array as its first argument and an
    element offset as its optional second argument, which defaults to 0 if left unspecified.
    If you are copying values from one typed array to another, the operation will
    likely be extremely fast.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()` 方法以数组或 typed array 作为第一个参数，以元素偏移量作为可选的第二个参数，如果未指定则默认为 0。如果你从一个 typed
    array 复制值到另一个，这个操作可能会非常快。'
- en: 'Typed arrays also have a `subarray` method that returns a portion of the array
    on which it is called:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Typed arrays 还有一个 `subarray` 方法，返回调用它的数组的一部分：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`subarray()` takes the same arguments as the `slice()` method and seems to
    work the same way. But there is an important difference. `slice()` returns the
    specified elements in a new, independent typed array that does not share memory
    with the original array. `subarray()` does not copy any memory; it just returns
    a new view of the same underlying values:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`subarray()`接受与`slice()`方法相同的参数，并且似乎工作方式相同。但有一个重要的区别。`slice()`返回一个新的、独立的类型化数组，其中包含指定的元素，不与原始数组共享内存。`subarray()`不复制任何内存；它只返回相同底层值的新视图：'
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The fact that the `subarray()` method returns a new view of an existing array
    brings us back to the topic of ArrayBuffers. Every typed array has three properties
    that relate to the underlying buffer:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`subarray()`方法返回现有数组的新视图，这让我们回到了ArrayBuffers的话题。每个类型化数组都有三个与底层缓冲区相关的属性：'
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `buffer` property is the ArrayBuffer of the array. `byteOffset` is the
    starting position of the array’s data within the underlying buffer. And `byteLength`
    is the length of the array’s data in bytes. For any typed array, `a`, this invariant
    should always be true:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer`属性是数组的ArrayBuffer。`byteOffset`是数组数据在底层缓冲区中的起始位置。`byteLength`是数组数据的字节长度。对于任何类型化数组`a`，这个不变式应该始终成立：'
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'ArrayBuffers are just opaque chunks of bytes. You can access those bytes with
    typed arrays, but an ArrayBuffer is not itself a typed array. Be careful, however:
    you can use numeric array indexing with ArrayBuffers just as you can with any
    JavaScript object. Doing so does not give you access to the bytes in the buffer,
    but it can cause confusing bugs:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayBuffer只是不透明的字节块。您可以使用类型化数组访问这些字节，但ArrayBuffer本身不是类型化数组。但要小心：您可以像在任何JavaScript对象上一样使用数字数组索引访问ArrayBuffers。这样做并不会让您访问缓冲区中的字节，但可能会导致混乱的错误：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We saw previously that you can create an ArrayBuffer with the `ArrayBuffer()`
    constructor and then create typed arrays that use that buffer. Another approach
    is to create an initial typed array, then use the buffer of that array to create
    other views:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到，您可以使用`ArrayBuffer()`构造函数创建一个ArrayBuffer，然后创建使用该缓冲区的类型化数组。另一种方法是创建一个初始类型化数组，然后使用该数组的缓冲区创建其他视图：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 11.2.5 DataView and Endianness
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.5 DataView和字节顺序
- en: 'Typed arrays allow you to view the same sequence of bytes in chunks of 8, 16,
    32, or 64 bits. This exposes the “endianness”: the order in which bytes are arranged
    into longer words. For efficiency, typed arrays use the native endianness of the
    underlying hardware. On little-endian systems, the bytes of a number are arranged
    in an ArrayBuffer from least significant to most significant. On big-endian platforms,
    the bytes are arranged from most significant to least significant. You can determine
    the endianness of the underlying platform with code like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组允许您以8、16、32或64位的块查看相同的字节序列。这暴露了“字节序”：字节被排列成更长字的顺序。为了效率，类型化数组使用底层硬件的本机字节顺序。在小端系统上，数字的字节从最不重要到最重要的顺序排列在ArrayBuffer中。在大端平台上，字节从最重要到最不重要的顺序排列。您可以使用以下代码确定底层平台的字节顺序：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Today, the most common CPU architectures are little-endian. Many network protocols,
    and some binary file formats, require big-endian byte ordering, however. If you’re
    using typed arrays with data that came from the network or from a file, you can’t
    just assume that the platform endianness matches the byte order of the data. In
    general, when working with external data, you can use Int8Array and Uint8Array
    to view the data as an array of individual bytes, but you should not use the other
    typed arrays with multibyte word sizes. Instead, you can use the DataView class,
    which defines methods for reading and writing values from an ArrayBuffer with
    explicitly specified byte ordering:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，最常见的CPU架构是小端。然而，许多网络协议和一些二进制文件格式要求大端字节顺序。如果您正在使用来自网络或文件的数据的类型化数组，您不能仅仅假设平台的字节顺序与数据的字节顺序相匹配。一般来说，在处理外部数据时，您可以使用Int8Array和Uint8Array将数据视为单个字节的数组，但不应使用其他具有多字节字长的类型化数组。相反，您可以使用DataView类，该类定义了用于从具有明确定义的字节顺序的ArrayBuffer中读取和写入值的方法：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: DataView defines 10 `get` methods for each of the 10 typed array classes (excluding
    Uint8ClampedArray). They have names like `getInt16()`, `getUint32()`, `getBigInt64()`,
    and `getFloat64()`. The first argument is the byte offset within the ArrayBuffer
    at which the value begins. All of these getter methods, other than `getInt8()`
    and `getUint8()`, accept an optional boolean value as their second argument. If
    the second argument is omitted or is `false`, big-endian byte ordering is used.
    If the second argument is `true`, little-endian ordering is used.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: DataView为每个10个类型化数组类定义了10个`get`方法（不包括Uint8ClampedArray）。它们的名称类似于`getInt16()`、`getUint32()`、`getBigInt64()`和`getFloat64()`。第一个参数是ArrayBuffer中数值开始的字节偏移量。除了`getInt8()`和`getUint8()`之外，所有这些获取方法都接受一个可选的布尔值作为第二个参数。如果省略第二个参数或为`false`，则使用大端字节顺序。如果第二个参数为`true`，则使用小端顺序。
- en: DataView also defines 10 corresponding Set methods that write values into the
    underlying ArrayBuffer. The first argument is the offset at which the value begins.
    The second argument is the value to write. Each of the methods, except `setInt8()`
    and `setUint8()`, accepts an optional third argument. If the argument is omitted
    or is `false`, the value is written in big-endian format with the most significant
    byte first. If the argument is `true`, the value is written in little-endian format
    with the least significant byte first.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: DataView还定义了10个相应的Set方法，用于将值写入底层ArrayBuffer。第一个参数是值开始的偏移量。第二个参数是要写入的值。除了`setInt8()`和`setUint8()`之外，每个方法都接受一个可选的第三个参数。如果省略参数或为`false`，则以大端格式写入值，最重要的字节在前。如果参数为`true`，则以小端格式写入值，最不重要的字节在前。
- en: Typed arrays and the DataView class give you all the tools you need to process
    binary data and enable you to write JavaScript programs that do things like decompressing
    ZIP files or extracting metadata from JPEG files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组和 DataView 类为您提供了处理二进制数据所需的所有工具，并使您能够编写执行诸如解压缩 ZIP 文件或从 JPEG 文件中提取元数据等操作的
    JavaScript 程序。
- en: 11.3 Pattern Matching with Regular Expressions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.3 使用正则��达式进行模式匹配
- en: A *regular expression* is an object that describes a textual pattern. The JavaScript
    RegExp class represents regular expressions, and both String and RegExp define
    methods that use regular expressions to perform powerful pattern-matching and
    search-and-replace functions on text. In order to use the RegExp API effectively,
    however, you must also learn how to describe patterns of text using the regular
    expression grammar, which is essentially a mini programming language of its own.
    Fortunately, the JavaScript regular expression grammar is quite similar to the
    grammar used by many other programming languages, so you may already be familiar
    with it. (And if you are not, the effort you invest in learning JavaScript regular
    expressions will probably be useful to you in other programming contexts as well.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*是描述文本模式的对象。JavaScript RegExp 类表示正则表达式，String 和 RegExp 都定义了使用正则表达式执行强大的模式匹配和搜索替换功能的方法。然而，为了有效地使用
    RegExp API，您还必须学习如何使用正则表达式语法描述文本模式，这本质上是一种自己的迷你编程语言。幸运的是，JavaScript 正则表达式语法与许多其他编程语言使用的语法非常相似，因此您可能已经熟悉它。
    （如果您不熟悉，学习 JavaScript 正则表达式所投入的努力可能也对您在其他编程环境中有所帮助。）'
- en: The subsections that follow describe the regular expression grammar first, and
    then, after explaining how to write regular expressions, they explain how you
    can use them with methods of the String and RegExp classes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节首先描述了正则表达式语法，然后，在解释如何编写正则表达式之后，它们解释了如何使用它们与 String 和 RegExp 类的方法。
- en: 11.3.1 Defining Regular Expressions
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.1 定义正则表达式
- en: 'In JavaScript, regular expressions are represented by RegExp objects. RegExp
    objects may be created with the `RegExp()` constructor, of course, but they are
    more often created using a special literal syntax. Just as string literals are
    specified as characters within quotation marks, regular expression literals are
    specified as characters within a pair of slash (`/`) characters. Thus, your JavaScript
    code may contain lines like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，正则表达式由 RegExp 对象表示。当然，RegExp 对象可以使用`RegExp()`构造函数创建，但更常见的是使用特殊的字面量语法创建。正如字符串字面量是在引号内指定的字符一样，正则表达式字面量是在一对斜杠（`/`）字符内指定的字符。因此，您的
    JavaScript 代码可能包含如下行：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This line creates a new RegExp object and assigns it to the variable `pattern`.
    This particular RegExp object matches any string that ends with the letter “s.”
    This regular expression could have equivalently been defined with the `RegExp()`
    constructor, like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此行创建一个新的 RegExp 对象，并将其赋给变量`pattern`。这个特定的 RegExp 对象匹配任何以字母“s”结尾的字符串。这个正则表达式也可以用`RegExp()`构造函数定义，就像这样：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Regular-expression pattern specifications consist of a series of characters.
    Most characters, including all alphanumeric characters, simply describe characters
    to be matched literally. Thus, the regular expression `/java/` matches any string
    that contains the substring “java”. Other characters in regular expressions are
    not matched literally but have special significance. For example, the regular
    expression `/s$/` contains two characters. The first, “s”, matches itself literally.
    The second, “$”, is a special meta-character that matches the end of a string.
    Thus, this regular expression matches any string that contains the letter “s”
    as its last character.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式规范由一系列字符组成。大多数字符，包括所有字母数字字符，只是描述要匹配的字符。因此，正则表达式`/java/`匹配包含子字符串“java”的任何字符串。正则表达式中的其他字符不是字面匹配的，而是具有特殊意义。例如，正则表达式`/s$/`包含两个字符。第一个“s”是字面匹配的。第二个“$”是一个特殊的元字符，匹配字符串的结尾。因此，这个正则表达式匹配任何以字母“s”作为最后一个字符的字符串。
- en: 'As we’ll see, regular expressions can also have one or more flag characters
    that affect how they work. Flags are specified following the second slash character
    in RegExp literals, or as a second string argument to the `RegExp()` constructor.
    If we wanted to match strings that end with “s” or “S”, for example, we could
    use the `i` flag with our regular expression to indicate that we want case-insensitive
    matching:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，正则表达式也可以有一个或多个标志字符，影响它们的工作方式。标志是在 RegExp 文本的第二个斜杠字符后指定的，或者作为`RegExp()`构造函数的第二个字符串参数。例如，如果我们想匹配以“s”或“S”结尾的字符串，我们可以在正则表达式中使用`i`标志，表示我们要进行不区分大小写的匹配：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The following sections describe the various characters and meta-characters used
    in JavaScript regular expressions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节描述了 JavaScript 正则表达式中使用的各种字符和元字符。
- en: Literal characters
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字面字符
- en: All alphabetic characters and digits match themselves literally in regular expressions.
    JavaScript regular expression syntax also supports certain nonalphabetic characters
    through escape sequences that begin with a backslash (`\`). For example, the sequence
    `\n` matches a literal newline character in a string. [Table 11-1](#regexps-TABLE-1)
    lists these characters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有字母字符和数字在正则表达式中都以字面意义匹配自身。JavaScript 正则表达式语法还支持以反斜杠（`\`）开头的转义序列表示某些非字母字符。例如，序列`\n`在字符串中匹配一个字面换行符。[表 11-1](#regexps-TABLE-1)
    列出了这些字符。
- en: Table 11-1\. Regular-expression literal characters
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1\. 正则表达式字面字符
- en: '| Character | Matches |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 匹配 |'
- en: '| --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alphanumeric character | Itself |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 字母数字字符 | 本身 |'
- en: '| `\0` | The NUL character (`\u0000`) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `\0` | NUL 字符（`\u0000`） |'
- en: '| `\t` | Tab (`\u0009`) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符（`\u0009`） |'
- en: '| `\n` | Newline (`\u000A`) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符（`\u000A`） |'
- en: '| `\v` | Vertical tab (`\u000B`) |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `\v` | 垂直制表符（`\u000B`） |'
- en: '| `\f` | Form feed (`\u000C`) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `\f` | 换页符（`\u000C`） |'
- en: '| `\r` | Carriage return (`\u000D`) |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符（`\u000D`） |'
- en: '| `\x`*nn* | The Latin character specified by the hexadecimal number *nn*;
    for example, `\x0A` is the same as `\n`. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `\x`*nn* | 十六进制数字 *nn* 指定的拉丁字符；例如，`\x0A` 等同于 `\n`。'
- en: '| `\u`*xxxx* | The Unicode character specified by the hexadecimal number *xxxx*;
    for example, `\u0009` is the same as `\t`. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `\u`*xxxx* | 十六进制数字 *xxxx* 指定的 Unicode 字符；例如，`\u0009` 等同于 `\t`。'
- en: '| `\u{`*n*`}` | The Unicode character specified by the codepoint *n*, where
    *n* is one to six hexadecimal digits between 0 and 10FFFF. Note that this syntax
    is only supported in regular expressions that use the `u` flag. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `\u{`*n*`}` | 由代码点 *n* 指定的 Unicode 字符，其中 *n* 是 0 到 10FFFF 之间的一到六个十六进制数字。请注意，此语法仅在使用
    `u` 标志的正则表达式中受支持。'
- en: '| `\c`*X* | The control character `^`*X*; for example, `\cJ` is equivalent
    to the newline character `\n`. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `\c`*X* | 控制字符 `^`*X*；例如，`\cJ` 等同于换行符 `\n`。'
- en: 'A number of punctuation characters have special meanings in regular expressions.
    They are:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标点符号在正则表达式中具有特殊含义。它们是：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The meanings of these characters are discussed in the sections that follow.
    Some of these characters have special meaning only within certain contexts of
    a regular expression and are treated literally in other contexts. As a general
    rule, however, if you want to include any of these punctuation characters literally
    in a regular expression, you must precede them with a `\`. Other punctuation characters,
    such as quotation marks and `@`, do not have special meaning and simply match
    themselves literally in a regular expression.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字符的含义将在接下来的章节中讨论。其中一些字符仅在正则表达式的某些上下文中具有特殊含义，在其他上下文中被视为文字。然而，作为一般规则，如果要在正则表达式中字面包含任何这些标点符号，必须在其前面加上
    `\`。其他标点符号，如引号和 `@`，没有特殊含义，只是在正则表达式中字面匹配自身。
- en: 'If you can’t remember exactly which punctuation characters need to be escaped
    with a backslash, you may safely place a backslash before any punctuation character.
    On the other hand, note that many letters and numbers have special meaning when
    preceded by a backslash, so any letters or numbers that you want to match literally
    should not be escaped with a backslash. To include a backslash character literally
    in a regular expression, you must escape it with a backslash, of course. For example,
    the following regular expression matches any string that includes a backslash:
    `/\\/`. (And if you use the `RegExp()` constructor, keep in mind that any backslashes
    in your regular expression need to be doubled, since strings also use backslashes
    as an escape character.)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不清哪些标点符号需要用反斜杠转义，你可以安全地在任何标点符号前面放置一个反斜杠。另一方面，请注意，许多字母和数字在前面加上反斜杠时具有特殊含义，��此任何你想字面匹配的字母或数字不应该用反斜杠转义。要在正则表达式中字面包含反斜杠字符，当然必须用反斜杠转义它。例如，以下正则表达式匹配包含反斜杠的任意字符串：`/\\/`。（如果你使用
    `RegExp()` 构造函数，请记住你的正则表达式中的任何反斜杠都需要加倍，因为字符串也使用反斜杠作为转义字符。）
- en: Character classes
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类
- en: Individual literal characters can be combined into *character classes* by placing
    them within square brackets. A character class matches any one character that
    is contained within it. Thus, the regular expression `/[abc]/` matches any one
    of the letters a, b, or c. Negated character classes can also be defined; these
    match any character except those contained within the brackets. A negated character
    class is specified by placing a caret (`^`) as the first character inside the
    left bracket. The RegExp `/[^abc]/` matches any one character other than a, b,
    or c. Character classes can use a hyphen to indicate a range of characters. To
    match any one lowercase character from the Latin alphabet, use `/[a-z]/`, and
    to match any letter or digit from the Latin alphabet, use `/[a-zA-Z0-9]/`. (And
    if you want to include an actual hyphen in your character class, simply make it
    the last character before the right bracket.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将单个文字字符组合到方括号中，可以形成*字符类*。字符类匹配其中包含的任意一个字符。因此，正则表达式 `/[abc]/` 匹配字母 a、b 或 c
    中的任意一个。也可以定义否定字符类；这些匹配除方括号中包含的字符之外的任意字符。否定字符类通过在左方括号内的第一个字符处放置插入符号（`^`）来指定。正则表达式
    `/[^abc]/` 匹配除 a、b 或 c 之外的任意一个字符。字符类可以使用连字符指示字符范围。要匹配拉丁字母表中的任意一个小写字母，请使用 `/[a-z]/`，要匹配拉丁字母表中的任意字母或数字，请使用
    `/[a-zA-Z0-9]/`。（如果要在字符类中包含实际连字符，只需将其放在右方括号之前。）
- en: Because certain character classes are commonly used, the JavaScript regular-expression
    syntax includes special characters and escape sequences to represent these common
    classes. For example, `\s` matches the space character, the tab character, and
    any other Unicode whitespace character; `\S` matches any character that is *not*
    Unicode whitespace. [Table 11-2](#regexps-TABLE-2) lists these characters and
    summarizes character-class syntax. (Note that several of these character-class
    escape sequences match only ASCII characters and have not been extended to work
    with Unicode characters. You can, however, explicitly define your own Unicode
    character classes; for example, `/[\u0400-\u04FF]/` matches any one Cyrillic character.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些字符类通常被使用，JavaScript 正则表达式语法包括特殊字符和转义序列来表示这些常见类。例如，`\s` 匹配空格字符、制表符和任何其他 Unicode
    空白字符；`\S` 匹配任何*非* Unicode 空白字符。[表 11-2](#regexps-TABLE-2) 列出了这些字符并总结了字符类语法。（请注意，其中几个字符类转义序列仅匹配
    ASCII 字符，并未扩展为适用于 Unicode 字符。但是，你可以显式定义自己的 Unicode 字符类；例如，`/[\u0400-\u04FF]/`
    匹配任意一个西里尔字母字符。）
- en: Table 11-2\. Regular expression character classes
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 11-2\. 正则表达式字符类
- en: '| Character | Matches |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 匹配 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[...]` | Any one character between the brackets. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `[...]` | 方括号内的任意一个字符。 |'
- en: '| `[^...]` | Any one character not between the brackets. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `[^...]` | 方括号内的任意一个字符。'
- en: '| `.` | Any character except newline or another Unicode line terminator. Or,
    if the RegExp uses the `s` flag, then a period matches any character, including
    line terminators. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 除换行符或其他 Unicode 行终止符之外的任何字符。或者，如果 RegExp 使用 `s` 标志，则句点匹配任何字符，包括行终止符。'
- en: '| `\w` | Any ASCII word character. Equivalent to `[a-zA-Z0-9_]`. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 任何 ASCII 单词字符。等同于 `[a-zA-Z0-9_]`。'
- en: '| `\W` | Any character that is not an ASCII word character. Equivalent to `[^a-zA-Z0-9_]`.
    |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 任何不是 ASCII 单词字符的字符。等同于 `[^a-zA-Z0-9_]`。'
- en: '| `\s` | Any Unicode whitespace character. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 任何 Unicode 空白字符。'
- en: '| `\S` | Any character that is not Unicode whitespace. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 任何不是 Unicode 空白字符的字符。'
- en: '| `\d` | Any ASCII digit. Equivalent to `[0-9]`. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 任何 ASCII 数字。等同于 `[0-9]`。'
- en: '| `\D` | Any character other than an ASCII digit. Equivalent to `[^0-9]`. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 任何 ASCII 数字之外的字符。等同于 `[^0-9]`。'
- en: '| `[\b]` | A literal backspace (special case). |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `[\b]` | 一个字面退格（特殊情况）。'
- en: 'Note that the special character-class escapes can be used within square brackets.
    `\s` matches any whitespace character, and `\d` matches any digit, so `/[\s\d]/`
    matches any one whitespace character or digit. Note that there is one special
    case. As you’ll see later, the `\b` escape has a special meaning. When used within
    a character class, however, it represents the backspace character. Thus, to represent
    a backspace character literally in a regular expression, use the character class
    with one element: `/[\b]/`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，特殊字符类转义可以在方括号内使用。`\s` 匹配任何空白字符，`\d` 匹配任何数字，因此 `/[\s\d]/` 匹配任何一个空白字符或数字。请注意有一个特殊情况。正如稍后将看到的，`\b`
    转义具有特殊含义。但是，在字符类中使用时，它表示退格字符。因此，要在正则表达式中字面表示退格字符，请使用具有一个元素的字符类：`/[\b]/`。
- en: Repetition
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复
- en: With the regular expression syntax you’ve learned so far, you can describe a
    two-digit number as `/\d\d/` and a four-digit number as `/\d\d\d\d/`. But you
    don’t have any way to describe, for example, a number that can have any number
    of digits or a string of three letters followed by an optional digit. These more
    complex patterns use regular expression syntax that specifies how many times an
    element of a regular expression may be repeated.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您学到的正则表达式语法可以将两位数描述为 `/\d\d/`，将四位数描述为 `/\d\d\d\d/`。但是，您没有任何方法来描述，例如，可以具有任意数量的数字或三个字母后跟一个可选数字的字符串。这些更复杂的模式使用指定正则表达式元素可以重复多少次的正则表达式语法。
- en: The characters that specify repetition always follow the pattern to which they
    are being applied. Because certain types of repetition are quite commonly used,
    there are special characters to represent these cases. For example, `+` matches
    one or more occurrences of the previous pattern.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 指定重复的字符始终跟随其应用的模式。由于某些类型的重复非常常见，因此有特殊字符来表示这些情况。例如，`+` 匹配前一个模式的一个或多个出现。
- en: '[Table 11-3](#regexps-TABLE-3) summarizes the repetition syntax.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-3](#regexps-TABLE-3) 总结了重复语法。'
- en: Table 11-3\. Regular expression repetition characters
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-3\. 正则表达式重复字符
- en: '| Character | Meaning |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `{`*n*`,`*m*`}` | Match the previous item at least *n* times but no more
    than *m* times. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `{`*n*`,`*m*`}` | 匹配前一个项目至少 *n* 次但不超过 *m* 次。'
- en: '| `{`*n*`,}` | Match the previous item *n* or more times. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `{`*n*`,}` | 匹配前一个项目 *n* 次或更多次。'
- en: '| `{`*n*`}` | Match exactly *n* occurrences of the previous item. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `{`*n*`}` | 匹配前一个项目的 *n* 次出现。'
- en: '| `?` | Match zero or one occurrences of the previous item. That is, the previous
    item is optional. Equivalent to `{0,1}`. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 匹配前一个项目的零次或一次出现。也就是说，前一个项目是可选的。等同于 `{0,1}`。'
- en: '| `+` | Match one or more occurrences of the previous item. Equivalent to `{1,}`.
    |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 匹配前一个项目的一个或多个出现。等同于 `{1,}`。'
- en: '| `*` | Match zero or more occurrences of the previous item. Equivalent to
    `{0,}`. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 匹配前一个项目的零次或多次。等同于 `{0,}`。'
- en: 'The following lines show some examples:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了一些示例：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that in all of these examples, the repetition specifiers apply to the single
    character or character class that precedes them. If you want to match repetitions
    of more complicated expressions, you’ll need to define a group with parentheses,
    which are explained in the following sections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在所有这些示例中，重复说明符应用于它们之前的单个字符或字符类。如果要匹配更复杂表达式的重复，您需要使用��号定义一个组，这将在以下部分中解释。
- en: Be careful when using the `*` and `?` repetition characters. Since these characters
    may match zero instances of whatever precedes them, they are allowed to match
    nothing. For example, the regular expression `/a*/` actually matches the string
    “bbbb” because the string contains zero occurrences of the letter a!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*` 和 `?` 重复字符时要小心。由于这些字符可能匹配前面的内容的零次，它们允许匹配空内容。例如，正则表达式 `/a*/` 实际上匹配字符串“bbbb”，因为该字符串不包含字母
    a 的任何出现！
- en: Non-greedy repetition
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非贪婪重复
- en: 'The repetition characters listed in [Table 11-3](#regexps-TABLE-3) match as
    many times as possible while still allowing any following parts of the regular
    expression to match. We say that this repetition is “greedy.” It is also possible
    to specify that repetition should be done in a non-greedy way. Simply follow the
    repetition character or characters with a question mark: `??`, `+?`, `*?`, or
    even `{1,5}?`. For example, the regular expression `/a+/` matches one or more
    occurrences of the letter a. When applied to the string “aaa”, it matches all
    three letters. But `/a+?/` matches one or more occurrences of the letter a, matching
    as few characters as necessary. When applied to the same string, this pattern
    matches only the first letter a.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-3](#regexps-TABLE-3) 中列出的重复字符尽可能多次匹配，同时仍允许正则表达式的任何后续部分匹配。我们说这种重复是“贪婪的”。还可以指定以非贪婪方式进行重复。只需在重复字符后面跟一个问号：`??`、`+?`、`*?`，甚至
    `{1,5}?`。例如，正则表达式 `/a+/` 匹配一个或多个字母 a 的出现。当应用于字符串“aaa”时，它匹配所有三个字母。但是 `/a+?/` 匹配一个或多个字母
    a 的出现，尽可能少地匹配字符。当应用于相同字符串时，此模式仅匹配第一个字母 a。'
- en: 'Using non-greedy repetition may not always produce the results you expect.
    Consider the pattern `/a+b/`, which matches one or more a’s, followed by the letter
    b. When applied to the string “aaab”, it matches the entire string. Now let’s
    use the non-greedy version: `/a+?b/`. This should match the letter b preceded
    by the fewest number of a’s possible. When applied to the same string “aaab”,
    you might expect it to match only one a and the last letter b. In fact, however,
    this pattern matches the entire string, just like the greedy version of the pattern.
    This is because regular expression pattern matching is done by finding the first
    position in the string at which a match is possible. Since a match is possible
    starting at the first character of the string, shorter matches starting at subsequent
    characters are never even considered.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非贪婪重复可能不总是产生您期望的结果。考虑模式`/a+b/`，它匹配一个或多个a，后跟字母b。当应用于字符串“aaab”时，它匹配整个字符��。现在让我们使用非贪婪版本：`/a+?b/`。这应该匹配由尽可能少的a前导的字母b。当应用于相同字符串“aaab”时，您可能希望它仅匹配一个a和最后一个字母b。但实际上，此模式与贪婪版本的模式一样匹配整个字符串。这是因为正则表达式模式匹配是通过找到字符串中可能发生匹配的第一个位置来完成的。由于从字符串的第一个字符开始就可能发生匹配，因此从后续字符开始的较短匹配甚至不会被考虑。
- en: Alternation, grouping, and references
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备选项、分组和引用
- en: The regular expression grammar includes special characters for specifying alternatives,
    grouping subexpressions, and referring to previous subexpressions. The `|` character
    separates alternatives. For example, `/ab|cd|ef/` matches the string “ab” or the
    string “cd” or the string “ef”. And `/\d{3}|[a-z]{4}/` matches either three digits
    or four lowercase letters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法包括用于指定备选项、分组子表达式和引用先前子表达式的特殊字符。`|`字符分隔备选项。例如，`/ab|cd|ef/`匹配字符串“ab”或字符串“cd”或字符串“ef”。而`/\d{3}|[a-z]{4}/`匹配三个数字或四个小写字母中的任何一个。
- en: Note that alternatives are considered left to right until a match is found.
    If the left alternative matches, the right alternative is ignored, even if it
    would have produced a “better” match. Thus, when the pattern `/a|ab/` is applied
    to the string “ab”, it matches only the first letter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，备选项从左到右考虑，直到找到匹配项。如果左侧备选项匹配，则右侧备选项将被忽略，即使它可能产生“更好”的匹配。因此，当将模式`/a|ab/`应用于字符串“ab”时，它仅匹配第一个字母。
- en: Parentheses have several purposes in regular expressions. One purpose is to
    group separate items into a single subexpression so that the items can be treated
    as a single unit by `|`, `*`, `+`, `?`, and so on. For example, `/java(script)?/`
    matches “java” followed by the optional “script”. And `/(ab|cd)+|ef/` matches
    either the string “ef” or one or more repetitions of either of the strings “ab”
    or “cd”.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 括号在正则表达式中有几个目的。一个目的是将单独的项目分组为单个子表达式，以便可以通过`|`、`*`、`+`、`?`等将项目视为单个单元。例如，`/java(script)?/`匹配“java”后跟可选的“script”。而`/(ab|cd)+|ef/`匹配字符串“ef”或一个或多个重复的字符串“ab”或“cd”中的任何一个。
- en: Another purpose of parentheses in regular expressions is to define subpatterns
    within the complete pattern. When a regular expression is successfully matched
    against a target string, it is possible to extract the portions of the target
    string that matched any particular parenthesized subpattern. (You’ll see how these
    matching substrings are obtained later in this section.) For example, suppose
    you are looking for one or more lowercase letters followed by one or more digits.
    You might use the pattern `/[a-z]+\d+/`. But suppose you only really care about
    the digits at the end of each match. If you put that part of the pattern in parentheses
    `(/[a-z]+(\d+)/)`, you can extract the digits from any matches you find, as explained
    later.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中括号的另一个目的是在完整模式内定义子模式。当正则表达式成功匹配目标字符串时，可以提取匹配任何特定括号子模式的目标字符串部分。（您将在本节后面看到如何获取这些匹配的子字符串。）例如，假设您正在寻找一个或多个小写字母后跟一个或多个数字。您可能会使用模式`/[a-z]+\d+/`。但是假设您只关心每个匹配末尾的数字。如果将模式的这部分放在括号中`(/[a-z]+(\d+)/)`，您可以提取任何找到的匹配中的数字，如后面所述。
- en: 'A related use of parenthesized subexpressions is to allow you to refer back
    to a subexpression later in the same regular expression. This is done by following
    a `\` character by a digit or digits. The digits refer to the position of the
    parenthesized subexpression within the regular expression. For example, `\1` refers
    back to the first subexpression, and `\3` refers to the third. Note that, because
    subexpressions can be nested within others, it is the position of the left parenthesis
    that is counted. In the following regular expression, for example, the nested
    subexpression `([Ss]cript)` is referred to as `\2`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 括号子表达式的一个相关用途是允许您在同一正则表达式中稍后引用子表达式。这是通过在`\`字符后跟一个或多个数字来完成的。这些数字指的是正则表达式中括号子表达式的位置。例如，`\1`引用第一个子表达式，`\3`引用第三个。请注意，由于子表达式可以嵌套在其他子表达式中，因此计算的是左括号的位置。例如，在以下正则表达式中，嵌套的子表达式`([Ss]cript)`被称为`\2`：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A reference to a previous subexpression of a regular expression does *not*
    refer to the pattern for that subexpression but rather to the text that matched
    the pattern. Thus, references can be used to enforce a constraint that separate
    portions of a string contain exactly the same characters. For example, the following
    regular expression matches zero or more characters within single or double quotes.
    However, it does not require the opening and closing quotes to match (i.e., both
    single quotes or both double quotes):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对正则表达式的先前子表达式的引用*不*是指该子表达式的模式，而是指匹配该模式的文本。因此，引用可用于强制要求字符串的不同部分包含完全相同的字符。例如，以下正则表达式匹配单引号或双引号内的零个或多个字符。但是，它不要求开头和结尾引号匹配（即，都是单引号或双引号）：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To require the quotes to match, use a reference:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要求引号匹配，请使用引用：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `\1` matches whatever the first parenthesized subexpression matched. In
    this example, it enforces the constraint that the closing quote match the opening
    quote. This regular expression does not allow single quotes within double-quoted
    strings or vice versa. (It is not legal to use a reference within a character
    class, so you cannot write: `/([''"])[^\1]*\1/`.)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`\1`匹配第一个括号子表达式匹配的内容。在此示例中，它强制约束闭合引号与开放引号匹配。此正则表达式不允许单引号在双引号字符串内部，反之亦然。（在字符类内部使用引用是不合法的，因此不能写成：`/([''"])[^\1]*\1/`。）'
- en: When we cover the RegExp API later, you’ll see that this kind of reference to
    a parenthesized subexpression is a powerful feature of regular-expression search-and-replace
    operations.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后讨论 RegExp API 时，您会看到对括号子表达式的引用是正则表达式搜索和替换操作的一个强大功能。
- en: 'It is also possible to group items in a regular expression without creating
    a numbered reference to those items. Instead of simply grouping the items within
    `(` and `)`, begin the group with `(?:` and end it with `)`. Consider the following
    pattern:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在正则表达式中分组项目而不创建对这些项目的编号引用。不要简单地在`(`和`)`内部分组项目，而是从`(?:`开始组，以`)`结束。考虑以下模式：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, the subexpression `(?:[Ss]cript)` is used simply for grouping,
    so the `?` repetition character can be applied to the group. These modified parentheses
    do not produce a reference, so in this regular expression, `\2` refers to the
    text matched by `(fun\w*)`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，子表达式`(?:[Ss]cript)`仅用于分组，因此`?`重复字符可以应用于该组。这些修改后的括号不生成引用，因此在此正则表达式中，`\2`指的是由`(fun\w*)`匹配的文本。
- en: '[Table 11-4](#regexps-TABLE-4) summarizes the regular expression alternation,
    grouping, and referencing operators.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 11-4](#regexps-TABLE-4) 总结了正则表达式的交替、分组和引用操作符。'
- en: Table 11-4\. Regular expression alternation, grouping, and reference characters
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 11-4\. 正则表达式的交替、分组和引用字符
- en: '| Character | Meaning |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `&#124;` | Alternation: match either the subexpression to the left or the
    subexpression to the right. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 交替：匹配左侧子表达式或右侧子表达式。'
- en: '| `(...)` | Grouping: group items into a single unit that can be used with
    `*`, `+`, `?`, `&#124;`, and so on. Also remember the characters that match this
    group for use with later references. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `(...)` | 分组：将项目分组为一个单元，可以与`*`、`+`、`?`、`&#124;`等一起使用。还要记住匹配此组的字符，以便后续引用。'
- en: '| `(?:...)` | Grouping only: group items into a single unit, but do not remember
    the characters that match this group. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `(?:...)` | 仅分组：将项目分组为一个单元，但不记住匹配此组的字符。'
- en: '| `\`*n* | Match the same characters that were matched when group number *n*
    was first matched. Groups are subexpressions within (possibly nested) parentheses.
    Group numbers are assigned by counting left parentheses from left to right. Groups
    formed with `(?:` are not numbered. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `\`*n* | 匹配在第一次匹配组号 *n* 时匹配的相同字符。组是括号内的子表达式（可能是嵌套的）。组号是通过从左到右计算左括号来分配的。使用`(?:`形成的组不编号。'
- en: Specifying match position
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定匹配位置
- en: As described earlier, many elements of a regular expression match a single character
    in a string. For example, `\s` matches a single character of whitespace. Other
    regular expression elements match the positions between characters instead of
    actual characters. `\b`, for example, matches an ASCII word boundary—the boundary
    between a `\w` (ASCII word character) and a `\W` (nonword character), or the boundary
    between an ASCII word character and the beginning or end of a string.^([4](ch11.xhtml#idm46198526281256))
    Elements such as `\b` do not specify any characters to be used in a matched string;
    what they do specify, however, are legal positions at which a match can occur.
    Sometimes these elements are called *regular expression anchors* because they
    anchor the pattern to a specific position in the search string. The most commonly
    used anchor elements are `^`, which ties the pattern to the beginning of the string,
    and `$`, which anchors the pattern to the end of the string.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，正则表达式的许多元素匹配字符串中的单个字符。例如，`\s`匹配单个空白字符。其他正则表达式元素匹配字符之间的位置而不是实际字符。例如���`\b`匹配
    ASCII 单词边界——`\w`（ASCII 单词字符）和`\W`（非单词字符）之间的边界，或者 ASCII 单词字符和字符串的开头或结尾之间的边界。[^4]
    元素如`\b`不指定要在匹配的字符串中使用的任何字符；但它们指定的是合法的匹配位置。有时这些元素被称为*正则表达式锚点*，因为它们将模式锚定到搜索字符串中的特定位置。最常用的锚定元素是`^`，将模式绑定到字符串的开头，以及`$`，将模式锚定到字符串的结尾。
- en: For example, to match the word “JavaScript” on a line by itself, you can use
    the regular expression `/^JavaScript$/`. If you want to search for “Java” as a
    word by itself (not as a prefix, as it is in “JavaScript”), you can try the pattern
    `/\sJava\s/`, which requires a space before and after the word. But there are
    two problems with this solution. First, it does not match “Java” at the beginning
    or the end of a string, but only if it appears with space on either side. Second,
    when this pattern does find a match, the matched string it returns has leading
    and trailing spaces, which is not quite what’s needed. So instead of matching
    actual space characters with `\s`, match (or anchor to) word boundaries with `\b`.
    The resulting expression is `/\bJava\b/`. The element `\B` anchors the match to
    a location that is not a word boundary. Thus, the pattern `/\B[Ss]cript/` matches
    “JavaScript” and “postscript”, but not “script” or “Scripting”.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要匹配单独一行的单词“JavaScript”，可以使用正则表达式`/^JavaScript$/`。如果要搜索“Java”作为单独的单词（而不是作为“JavaScript”中的前缀），可以尝试模式`/\sJava\s/`，这需要单词前后有空格。但是这种解决方案有两个问题。首先，它不匹配字符串的开头或结尾的“Java”，而只有在两侧有空格时才匹配。其次，当此模式找到匹配时，返回的匹配字符串具有前导和尾随空格，这不是所需的。因此，与其用`\s`匹配实际空格字符，不如用`\b`匹配（或锚定）单词边界。得到的表达式是`/\bJava\b/`。元素`\B`将匹配锚定到不是单词边界的位置。因此，模式`/\B[Ss]cript/`匹配“JavaScript”和“postscript”，但不匹配“script”或“Scripting”。
- en: 'You can also use arbitrary regular expressions as anchor conditions. If you
    include an expression within `(?=` and `)` characters, it is a lookahead assertion,
    and it specifies that the enclosed characters must match, without actually matching
    them. For example, to match the name of a common programming language, but only
    if it is followed by a colon, you could use `/[Jj]ava([Ss]cript)?(?=\:)/`. This
    pattern matches the word “JavaScript” in “JavaScript: The Definitive Guide”, but
    it does not match “Java” in “Java in a Nutshell” because it is not followed by
    a colon.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '您还可以使用任意正则表达式作为锚定条件。如果在`(?=`和`)`字符之间包含一个表达式，那么这是一个前瞻断言，并且它指定封闭字符必须匹配，而不实际匹配它们。例如，要匹配一个常见编程语言的名称，但只有在后面跟着一个冒号时，您可以使用`/[Jj]ava([Ss]cript)?(?=\:)/`。这个模式匹配“JavaScript”中的单词“JavaScript:
    The Definitive Guide”，但不匹配“Java in a Nutshell”中的“Java”，因为它后面没有跟着冒号。'
- en: If you instead introduce an assertion with `(?!`, it is a negative lookahead
    assertion, which specifies that the following characters must not match. For example,
    `/Java(?!Script)([A-Z]\w*)/` matches “Java” followed by a capital letter and any
    number of additional ASCII word characters, as long as “Java” is not followed
    by “Script”. It matches “JavaBeans” but not “Javanese”, and it matches “JavaScrip”
    but not “JavaScript” or “JavaScripter”. [Table 11-5](#regexps-TABLE-5) summarizes
    regular expression anchors.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`(?!`引入断言，那么这是一个负向前瞻断言，指定接下来的字符不得匹配。例如，`/Java(?!Script)([A-Z]\w*)/`匹配“Java”后跟一个大写字母和任意数量的其他ASCII单词字符，只要“Java”后面不跟着“Script”。它匹配“JavaBeans”但不匹配“Javanese”，它匹配“JavaScrip”但不匹配“JavaScript”或“JavaScripter”。[表 11-5](#regexps-TABLE-5)总结了正则表达式锚点。
- en: Table 11-5\. Regular expression anchor characters
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-5\. 正则表达式锚点字符
- en: '| Character | Meaning |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^` | Match the beginning of the string or, with the `m` flag, the beginning
    of a line. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 匹配字符串的开头或者在使用`m`标志时，匹配行的开头。 |'
- en: '| `$` | Match the end of the string and, with the `m` flag, the end of a line.
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 匹配字符串的结尾，并且在使用`m`标志时，匹配行的结尾。 |'
- en: '| `\b` | Match a word boundary. That is, match the position between a `\w`
    character and a `\W` character or between a `\w` character and the beginning or
    end of a string. (Note, however, that `[\b]` matches backspace.) |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 匹配单词边界。也就是说，匹配`\w`字符和`\W`字符之间的位置，或者匹配`\w`字符和字符串的开头或结尾之间的位置。（但请注意，`[\b]`匹配退格键。）
    |'
- en: '| `\B` | Match a position that is not a word boundary. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 匹配不是单词边界的位置。 |'
- en: '| `(?=`*p*`)` | A positive lookahead assertion. Require that the following
    characters match the pattern *p*, but do not include those characters in the match.
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `(?=`*p*`)` | 正向前瞻断言。要求接下来的字符匹配模式*p*，但不包括这些字符在匹配中。 |'
- en: '| `(?!`*p*`)` | A negative lookahead assertion. Require that the following
    characters do not match the pattern *p*. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `(?!`*p*`)` | 负向前瞻断言。要求接下来的字符不匹配模式*p*。 |'
- en: Flags
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标志
- en: 'Every regular expression can have one or more flags associated with it to alter
    its matching behavior. JavaScript defines six possible flags, each of which is
    represented by a single letter. Flags are specified after the second `/` character
    of a regular expression literal or as a string passed as the second argument to
    the `RegExp()` constructor. The supported flags and their meanings are:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个正则表达式都可以有一个或多个与之关联的标志，以改变其匹配行为。JavaScript定义了六个可能的标志，每个标志由一个字母表示。标志在正则表达式字面量的第二个`/`字符之后指定，或者作为传递给`RegExp()`构造函数的第二个参数的字符串。支持的标志及其含义如下：
- en: '`g`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`'
- en: The `g` flag indicates that the regular expression is “global”—that is, that
    we intend to use it to find all matches within a string rather than just finding
    the first match. This flag does not alter the way that pattern matching is done,
    but, as we’ll see later, it does alter the behavior of the String `match()` method
    and the RegExp `exec()` method in important ways.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`标志表示正则表达式是“全局”的，也就是说，我们打算在字符串中找到所有匹配项，而不仅仅是找到第一个匹配项。这个标志不会改变匹配模式的方式，但正如我们稍后将看到的，它确实以重要的方式改变了String
    `match()`方法和RegExp `exec()`方法的行为。'
- en: '`i`'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`'
- en: The `i` flag specifies that pattern matching should be case-insensitive.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`标志指定匹配模式时应该忽略大小写���'
- en: '`m`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`m`'
- en: The `m` flag specifies that matching should be done in “multiline” mode. It
    says that the RegExp will be used with multiline strings and that the `^` and
    `$` anchors should match both the beginning and end of the string and also the
    beginning and end of individual lines within the string.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`m`标志指定匹配应该在“多行”模式下进行。它表示正则表达式将与多行字符串一起使用，并且`^`和`$`锚点应该匹配字符串的开头和结尾，以及字符串中各行的开头和结尾。'
- en: '`s`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`s`'
- en: Like the `m` flag, the `s` flag is also useful when working with text that includes
    newlines. Normally, a “.” in a regular expression matches any character except
    a line terminator. When the `s` flag is used, however, “.” will match any character,
    including line terminators. The `s` flag was added to JavaScript in ES2018 and,
    as of early 2020, is supported in Node, Chrome, Edge, and Safari, but not Firefox.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与`m`标志类似，`s`标志在处理包含换行符的文本时也很有用。通常，正则表达式中的“.”匹配除行终止符之外的任何字符。但是，当使用`s`标志时，“.”将匹配任何字符，包括行终止符。`s`标志在ES2018中添加到JavaScript中，并且截至2020年初，在Node、Chrome、Edge和Safari中支持，但在Firefox中不支持。
- en: '`u`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`u`'
- en: The `u` flag stands for Unicode, and it makes the regular expression match full
    Unicode codepoints rather than matching 16-bit values. This flag was introduced
    in ES6, and you should make a habit of using it on all regular expressions unless
    you have some reason not to. If you do not use this flag, then your RegExps will
    not work well with text that includes emoji and other characters (including many
    Chinese characters) that require more than 16 bits. Without the `u` flag, the
    “.” character matches any 1 UTF-16 16-bit value. With the flag, however, “.” matches
    one Unicode codepoint, including those that have more than 16 bits. Setting the
    `u` flag on a RegExp also allows you to use the new `\u{...}` escape sequence
    for Unicode character and also enables the `\p{...}` notation for Unicode character
    classes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`u`标志代表Unicode，它使正则表达式匹配完整的Unicode代码点，而不是匹配16位值。这个标志是在ES6中引入的，你应该养成在所有正则表达式上使用它的习惯，除非你有某种理由不这样做。如果你不使用这个标志，那么你的正则表达式将无法很好地处理包含表情符号和其他需要超过16位的字符（包括许多中文字符）的文本。没有`u`标志，"."字符匹配任何1个UTF-16
    16位值。然而，有了这个标志，"."匹配一个Unicode代码点，包括那些超过16位的代码点。在正则表达式上设置`u`标志还允许你使用新的`\u{...}`转义序列来表示Unicode字符，并且还启用了`\p{...}`表示Unicode字符类。'
- en: '`y`'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`'
- en: The `y` flag indicates that the regular expression is “sticky” and should match
    at the beginning of a string or at the first character following the previous
    match. When used with a regular expression that is designed to find a single match,
    it effectively treats that regular expression as if it begins with `^` to anchor
    it to the beginning of the string. This flag is more useful with regular expressions
    that are used repeatedly to find all matches within a string. In this case, it
    causes special behavior of the String `match()` method and the RegExp `exec()`
    method to enforce that each subsequent match is anchored to the string position
    at which the last one ended.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`标志表示正则表达式是“粘性”的，应该在字符串的开头或上一个匹配项后的第一个字符处匹配。当与旨在找到单个匹配项的正则表达式一起使用时，它有效地将该正则表达式视为以`^`开头以将其锚定到字符串开头。这个标志在重复使用用于在字符串中找到所有匹配项的正则表达式时更有用。在这种情况下，它导致String
    `match()`方法和RegExp `exec()`方法的特殊行为，以强制每个后续匹配项都锚���到上一个匹配项结束的字符串位置。'
- en: These flags may be specified in any combination and in any order. For example,
    if you want your regular expression to be Unicode-aware to do case-insensitive
    matching and you intend to use it to find multiple matches within a string, you
    would specify the flags `uig`, `gui`, or any other permutation of these three
    letters.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志可以以任何组合和任何顺序指定。例如，如果你希望你的正则表达式能够识别Unicode以进行不区分大小写的匹配，并且打算在字符串中查找多个匹配项，你可以指定标志`uig`，`gui`或这三个字母的任何其他排列。
- en: 11.3.2 String Methods for Pattern Matching
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.2 用于模式匹配的字符串方法
- en: Until now, we have been describing the grammar used to define regular expressions,
    but not explaining how those regular expressions can actually be used in JavaScript
    code. We are now switching to cover the API for using RegExp objects. This section
    begins by explaining the string methods that use regular expressions to perform
    pattern matching and search-and-replace operations. The sections that follow this
    one continue the discussion of pattern matching with JavaScript regular expressions
    by discussing the RegExp object and its methods and properties.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在描述用于定义正则表达式的语法，但没有解释这些正则表达式如何在JavaScript代码中实际使用。我们现在转而介绍使用RegExp对象的API。本节首先解释了使用正则表达式执行模式匹配和搜索替换操作的字符串方法。接下来的部分将继续讨论使用JavaScript正则表达式进行模式匹配，讨论RegExp对象及其方法和属性。
- en: search()
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: search()
- en: 'Strings support four methods that use regular expressions. The simplest is
    `search()`. This method takes a regular expression argument and returns either
    the character position of the start of the first matching substring or −1 if there
    is no match:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串支持四种使用正则表达式的方法。最简单的是`search()`。这个方法接受一个正则表达式参数，并返回第一个匹配子字符串的起始字符位置，如果没有匹配则返回-1：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the argument to `search()` is not a regular expression, it is first converted
    to one by passing it to the `RegExp` constructor. `search()` does not support
    global searches; it ignores the `g` flag of its regular expression argument.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`search()`的参数不是正则表达式，则首先通过将其传递给`RegExp`构造函数将其转换为正则表达式。`search()`不支持全局搜索；它会忽略其正则表达式参数的`g`标志。
- en: replace()
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: replace()
- en: 'The `replace()` method performs a search-and-replace operation. It takes a
    regular expression as its first argument and a replacement string as its second
    argument. It searches the string on which it is called for matches with the specified
    pattern. If the regular expression has the `g` flag set, the `replace()` method
    replaces all matches in the string with the replacement string; otherwise, it
    replaces only the first match it finds. If the first argument to `replace()` is
    a string rather than a regular expression, the method searches for that string
    literally rather than converting it to a regular expression with the `RegExp()`
    constructor, as `search()` does. As an example, you can use `replace()` as follows
    to provide uniform capitalization of the word “JavaScript” throughout a string
    of text:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`方法执行搜索替换操作。它将正则表达式作为第一个参数，替换字符串作为第二个参数。它在调用它的字符串中搜索与指定模式匹配的内容。如果正则表达式设置了`g`标志，`replace()`方法将在字符串中替换所有匹配项为替换字符串；否则，它只会替换找到的第一个匹配项。如果`replace()`的第一个参数是一个字符串而不是正则表达式，该方法会直接搜索该字符串而不是像`search()`那样将其转换为正则表达式。例如，你可以使用`replace()`如下提供文本字符串中“JavaScript”一词的统一大写格式：'
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`replace()` is more powerful than this, however. Recall that parenthesized
    subexpressions of a regular expression are numbered from left to right and that
    the regular expression remembers the text that each subexpression matches. If
    a `$` followed by a digit appears in the replacement string, `replace()` replaces
    those two characters with the text that matches the specified subexpression. This
    is a very useful feature. You can use it, for example, to replace quotation marks
    in a string with other characters:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`replace()`比这更强大。回想一下，正则表达式的括号子表达式从左到右编号，并且正则表达式记住了每个子表达式匹配的文本。如果替换字符串中出现了`$`后跟一个数字，`replace()`将用指定子表达式匹配的文本替换这两个字符。这是一个非常有用的功能。例如，你可以使用��将字符串中的引号替换为其他字符：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If your RegExp uses named capture groups, then you can refer to the matching
    text by name rather than by number:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的正则表达式使用了命名捕获组，那么你可以通过名称而不是数字引用匹配的文本：
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Instead of passing a replacement string as the second argument to `replace()`,
    you can also pass a function that will be invoked to compute the replacement value.
    The replacement function is invoked with a number of arguments. First is the entire
    matched text. Next, if the RegExp has capturing groups, then the substrings that
    were captured by those groups are passed as arguments. The next argument is the
    position within the string at which the match was found. After that, the entire
    string that `replace()` was called on is passed. And finally, if the RegExp contained
    any named capture groups, the last argument to the replacement function is an
    object whose property names match the capture group names and whose values are
    the matching text. As an example, here is code that uses a replacement function
    to convert decimal integers in a string to hexadecimal:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要将替换字符串作为第二个参数传递给`replace()`，你也可以传递一个函数作为替换值的计算方法。替换函数会被调用并传入多个参数。首先是整个匹配的文本。接下来，如果正则表达式有捕获组，那么被这些组捕获的子字符串将作为参数传递。下一个参数是匹配被找到的字符串中的位置。之后，调用`replace()`的整个字符串也会被传递。最后，如果正则表达式包含任何命名捕获组，替换函数的最后一个参数是一个对象，其属性名与捕获组名匹配，值为匹配的文本。例如，这里是使用替换函数将字符串中的十进制整数转换为十六进制的代码：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: match()
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: match()
- en: 'The `match()` method is the most general of the String regular expression methods.
    It takes a regular expression as its only argument (or converts its argument to
    a regular expression by passing it to the `RegExp()` constructor) and returns
    an array that contains the results of the match, or `null` if no match is found.
    If the regular expression has the `g` flag set, the method returns an array of
    all matches that appear in the string. For example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`match()`方法是String正则表达式方法中最通用的。它将正则表达式作为唯一参数（或通过将其传递给`RegExp()`构造函数将其参数转换为正则表达式）并返回一个包含匹配结果的数组，如果没有找到匹配则返回`null`。如果正则表达式设置了`g`标志，该方法将返回出现在字符串中的所有匹配项的数组。例如：'
- en: '[PRE47]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If the regular expression does not have the `g` flag set, `match()` does not
    do a global search; it simply searches for the first match. In this nonglobal
    case, `match()` still returns an array, but the array elements are completely
    different. Without the `g` flag, the first element of the returned array is the
    matching string, and any remaining elements are the substrings matching the parenthesized
    capturing groups of the regular expression. Thus, if `match()` returns an array
    `a`, `a[0]` contains the complete match, `a[1]` contains the substring that matched
    the first parenthesized expression, and so on. To draw a parallel with the `replace()`
    method, `a[1]` is the same string as `$1`, `a[2]` is the same as `$2`, and so
    on.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正则表达式没有设置`g`标志，`match()`不会进行全局搜索；它只是搜索第一个匹配项。在这种非全局情况下，`match()`仍然返回一个数组，但数组元素完全不同。没有`g`标志时，返回数组的第一个元素是匹配的字符串，任何剩余的元素是正则表达式中括号捕获组匹配的子字符串。因此，如果`match()`返回一个数组`a`，`a[0]`包含完整匹配，`a[1]`包含匹配第一个括号表达式的子字符串，依此类推。与`replace()`方法类比，`a[1]`与`$1`相同，`a[2]`与`$2`相同，依此类推。
- en: 'For example, consider parsing a URL^([5](ch11.xhtml#idm46198525964472)) with
    the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑使用以下代码解析URL^([5](ch11.xhtml#idm46198525964472))：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In this non-global case, the array returned by `match()` also has some object
    properties in addition to the numbered array elements. The `input` property refers
    to the string on which `match()` was called. The `index` property is the position
    within that string at which the match starts. And if the regular expression contains
    named capture groups, then the returned array also has a `groups` property whose
    value is an object. The properties of this object match the names of the named
    groups, and the values are the matching text. We could rewrite the previous URL
    parsing example, for example, like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种非全局情况下，`match()`返回的数组除了编号数组元素外还有一些对象属性。`input`属性指的是调用`match()`的字符串。`index`属性是匹配开始的字符串位置。如果正则表达式包含命名捕获组，那么返回的数组还有一个`groups`属性，其值是一个对象。这个对象的属性与命名组的名称匹配，值为匹配的文本。例如，我们可以像这样重新编写之前的URL解析示例：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We’ve seen that `match()` behaves quite differently depending on whether the
    RegExp has the `g` flag set or not. There are also important but less dramatic
    differences in behavior when the `y` flag is set. Recall that the `y` flag makes
    a regular expression “sticky” by constraining where in the string matches can
    begin. If a RegExp has both the `g` and `y` flags set, then `match()` returns
    an array of matched strings, just as it does when `g` is set without `y`. But
    the first match must begin at the start of the string, and each subsequent match
    must begin at the character immediately following the previous match.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，`match()` 的行为在正则表达式是否设置了 `g` 标志时会有很大不同。当设置了 `y` 标志时，行为也会有重要但不那么显著的差异。请记住，`y`
    标志通过限制匹配开始的位置使正则表达式“粘滞”。如果一个正则表达式同时设置了 `g` 和 `y` 标志，那么 `match()` 返回一个匹配字符串的数组，就像在设置了
    `g` 而没有设置 `y` 时一样。但第一个匹配必须从字符串的开头开始，每个后续匹配必须从前一个匹配的字符紧随其后开始。
- en: If the `y` flag is set without `g`, then `match()` tries to find a single match,
    and, by default, this match is constrained to the start of the string. You can
    change this default match start position, however, by setting the `lastIndex`
    property of the RegExp object at the index at which you want to match at. If a
    match is found, then this `lastIndex` will be automatically updated to the first
    character after the match, so if you call `match()` again, in this case, it will
    look for a subsequent match. (`lastIndex` may seem like a strange name for a property
    that specifies the position at which to begin the *next* match. We will see it
    again when we cover the RegExp `exec()` method, and its name may make more sense
    in that context.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `y` 标志但没有设置 `g`，那么 `match()` 会尝试找到单个匹配，并且默认情况下，此匹配受限于字符串的开头。然而，您可以通过设置
    RegExp 对象的 `lastIndex` 属性来更改此默认匹配开始位置，指定要匹配的索引位置。如果找到匹配，那么 `lastIndex` 将自动更新为匹配后的第一个字符，因此如果再次调用
    `match()`，它将寻找下一个匹配。(`lastIndex` 可能看起来是一个奇怪的属性名称，它指定开始 *下一个* 匹配的位置。当我们讨论 RegExp
    `exec()` 方法时，我们将再次看到它，这个名称在那种情况下可能更有意义。)
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It is worth noting that passing a non-global regular expression to the `match()`
    method of a string is the same as passing the string to the `exec()` method of
    the regular expression: the returned array and its properties are the same in
    both cases.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，将非全局正则表达��传递给字符串的 `match()` 方法与将字符串传递给正则表达式的 `exec()` 方法是相同的：返回的数组及其属性在这两种情况下都是相同的。
- en: matchAll()
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: matchAll()
- en: The `matchAll()` method is defined in ES2020, and as of early 2020 is implemented
    by modern web browsers and Node. `matchAll()` expects a RegExp with the `g` flag
    set. Instead of returning an array of matching substrings like `match()` does,
    however, it returns an iterator that yields the kind of match objects that `match()`
    returns when used with a non-global RegExp. This makes `matchAll()` the easiest
    and most general way to loop through all matches within a string.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`matchAll()` 方法在 ES2020 中定义，并且在 2020 年初已被现代 Web 浏览器和 Node 实现。`matchAll()` 期望一个设置了
    `g` 标志的正则表达式。然而，与 `match()` 返回匹配子字符串的数组不同，它返回一个迭代器，该迭代器产生与使用非全局 RegExp 时 `match()`
    返回的匹配对象相同的对象。这使得 `matchAll()` 成为遍历字符串中所有匹配的最简单和最通用的方法。'
- en: 'You might use `matchAll()` to loop through the words in a string of text like
    this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `matchAll()` 遍历文本字符串中的单词，如下所示：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can set the `lastIndex` property of a RegExp object to tell `matchAll()`
    what index in the string to begin matching at. Unlike the other pattern-matching
    methods, however, `matchAll()` never modifies the `lastIndex` property of the
    RegExp you call it on, and this makes it much less likely to cause bugs in your
    code.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置 RegExp 对象的 `lastIndex` 属性，告诉 `matchAll()` 在字符串中的哪个索引开始匹配。然而，与其他模式匹配方法不同，`matchAll()`
    永远不会修改您调用它的 RegExp 的 `lastIndex` 属性，这使得它在您的代码中更不容易出错。
- en: split()
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: split()
- en: 'The last of the regular expression methods of the String object is `split()`.
    This method breaks the string on which it is called into an array of substrings,
    using the argument as a separator. It can be used with a string argument like
    this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: String 对象的正则表达式方法中的最后一个是 `split()`。这个方法将调用它的字符串分割成一个子字符串数组，使用参数作为分隔符。它可以像这样使用一个字符串参数：
- en: '[PRE52]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `split()` method can also take a regular expression as its argument, and
    this allows you to specify more general separators. Here we call it with a separator
    that includes an arbitrary amount of whitespace on either side:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法也可以接受正则表达式作为参数，这样可以指定更通用的分隔符。在这里，我们使用一个包含任意数量空白的分隔符来调用它：'
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Surprisingly, if you call `split()` with a RegExp delimiter and the regular
    expression includes capturing groups, then the text that matches the capturing
    groups will be included in the returned array. For example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，如果你使用包含捕获组的正则表达式分隔符调用 `split()`，那么匹配捕获组的文本将包含在返回的数组中。例如：
- en: '[PRE54]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 11.3.3 The RegExp Class
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.3 RegExp 类
- en: This section documents the `RegExp()` constructor, the properties of RegExp
    instances, and two important pattern-matching methods defined by the RegExp class.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了 `RegExp()` 构造函数、RegExp 实例的属性以及 RegExp 类定义的两个重要模式匹配方法。
- en: The `RegExp()` constructor takes one or two string arguments and creates a new
    RegExp object. The first argument to this constructor is a string that contains
    the body of the regular expression—the text that would appear within slashes in
    a regular-expression literal. Note that both string literals and regular expressions
    use the `\` character for escape sequences, so when you pass a regular expression
    to `RegExp()` as a string literal, you must replace each `\` character with `\\`.
    The second argument to `RegExp()` is optional. If supplied, it indicates the regular
    expression flags. It should be `g`, `i`, `m`, `s`, `u`, `y`, or any combination
    of those letters.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegExp()` 构造函数接受一个或两个字符串参数，并创建一个新的 RegExp 对象。这个构造函数的第一个参数是一个包含正则表达式主体的字符串——在正则表达式字面量中出现在斜杠内的文本���请注意，字符串字面量和正则表达式都使用
    `\` 字符作为转义序列，因此当您将正则表达式作为字符串字面量传递给 `RegExp()` 时，必须将每个 `\` 字符替换为 `\\`。`RegExp()`
    的第二个参数是可选的。如果提供，它表示正则表达式的标志。它应该是 `g`、`i`、`m`、`s`、`u`、`y`，或这些字母的任意组合。'
- en: 'For example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `RegExp()` constructor is useful when a regular expression is being dynamically
    created and thus cannot be represented with the regular expression literal syntax.
    For example, to search for a string entered by the user, a regular expression
    must be created at runtime with `RegExp()`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegExp()` 构造函数在动态创建正则表达式时非常有用，因此无法使用正则表达式字面量语法表示。例如，要搜索用户输入的字符串，必须在运行时使用 `RegExp()`
    创建正则表达式。'
- en: 'Instead of passing a string as the first argument to `RegExp()`, you can also
    pass a RegExp object. This allows you to copy a regular expression and change
    its flags:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将字符串作为 `RegExp()` 的第一个参数传递之外，您还可以传递一个 RegExp 对象。这允许您复制正则表达式并更改其标志：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: RegExp properties
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RegExp 属性
- en: 'RegExp objects have the following properties:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: RegExp 对象具有以下属性：
- en: '`source`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`'
- en: 'This read-only property is the source text of the regular expression: the characters
    that appear between the slashes in a RegExp literal.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正则表达式的源文本的只读属性：在 RegExp 字面量中出现在斜杠之间的字符。
- en: '`flags`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags`'
- en: This read-only property is a string that specifies the set of letters that represent
    the flags for the RegExp.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只读属性，指定表示 RegExp 标志的字母集合的字符串。
- en: '`global`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`'
- en: A read-only boolean property that is true if the `g` flag is set.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的布尔属性，如果设置了 `g` 标志，则为 true。
- en: '`ignoreCase`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignoreCase`'
- en: A read-only boolean property that is true if the `i` flag is set.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的布尔属性，如果设置了 `i` 标志，则为 true。
- en: '`multiline`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiline`'
- en: A read-only boolean property that is true if the `m` flag is set.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的布尔属性，如果设置了 `m` 标志，则为 true。
- en: '`dotAll`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotAll`'
- en: A read-only boolean property that is true if the `s` flag is set.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的布尔属性，如果设置了 `s` 标志，则为 true。
- en: '`unicode`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicode`'
- en: A read-only boolean property that is true if the `u` flag is set.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的布尔属性，如果设置了 `u` 标志，则为 true。
- en: '`sticky`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`sticky`'
- en: A read-only boolean property that is true if the `y` flag is set.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的布尔属性，如果设置了 `y` 标志，则为 true。
- en: '`lastIndex`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastIndex`'
- en: This property is a read/write integer. For patterns with the `g` or `y` flags,
    it specifies the character position at which the next search is to begin. It is
    used by the `exec()` and `test()` methods, described in the next two subsections.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是一个读/写整数。对于具有 `g` 或 `y` 标志的模式，它指定下一次搜索开始的字符位置。它由 `exec()` 和 `test()` 方法使用，这两个方法在下面的两个小节中描述。
- en: test()
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: test()
- en: The `test()` method of the RegExp class is the simplest way to use a regular
    expression. It takes a single string argument and returns `true` if the string
    matches the pattern or `false` if it does not match.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: RegExp 类的 `test()` 方法是使用正则表达式的最简单的方法。它接受一个字符串参数，并在字符串与模式匹配时返回 `true`，否则返回 `false`。
- en: '`test()` works by simply calling the (much more complicated) `exec()` method
    described in the next section and returning `true` if `exec()` returns a non-null
    value. Because of this, if you use `test()` with a RegExp that uses the `g` or
    `y` flags, then its behavior depends on the value of the `lastIndex` property
    of the RegExp object, which can change unexpectedly. See [“The lastIndex Property
    and RegExp Reuse”](#lastIndexprop_andRER) for more details.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`test()` 的工作原理是简单地调用（更复杂的）下一节中描述的 `exec()` 方法，并在 `exec()` 返回非空值时返回 `true`。因此，如果您使用带有
    `g` 或 `y` 标志的 RegExp 来使用 `test()`，那么它的行为取决于 RegExp 对象的 `lastIndex` 属性的值，这个值可能会意外更改。有关更多详细信息，请参阅[“lastIndex
    属性和 RegExp 重用”](#lastIndexprop_andRER)。'
- en: exec()
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: exec()
- en: 'The RegExp `exec()` method is the most general and powerful way to use regular
    expressions. It takes a single string argument and looks for a match in that string.
    If no match is found, it returns `null`. If a match is found, however, it returns
    an array just like the array returned by the `match()` method for non-global searches.
    Element 0 of the array contains the string that matched the regular expression,
    and any subsequent array elements contain the substrings that matched any capturing
    groups. The returned array also has named properties: the `index` property contains
    the character position at which the match occurred, and the `input` property specifies
    the string that was searched, and the `groups` property, if defined, refers to
    an object that holds the substrings matching the any named capturing groups.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: RegExp `exec()` 方法是使用正则表达式的最通用和强大的方式。它接受一个字符串参数，并在该字符串中查找匹配项。如果找不到匹配项，则返回 `null`。但是，如果找到匹配项，则返回一个数组，就像对于非全局搜索的
    `match()` 方法返回的数组一样。数组的第 0 个元素包含与正则表达式匹配的字符串，任何后续的数组元素包含与任何捕获组匹配的子字符串。返回的数组还具有命名属性：`index`
    属性包含匹配发生的字符位置，`input` 属性指定被搜索的字符串，如果定义了 `groups` 属性，则指的是一个保存与任何命名捕获组匹配的子字符串的对象。
- en: 'Unlike the String `match()` method, `exec()` returns the same kind of array
    whether or not the regular expression has the global `g` flag. Recall that `match()`
    returns an array of matches when passed a global regular expression. `exec()`,
    by contrast, always returns a single match and provides complete information about
    that match. When `exec()` is called on a regular expression that has either the
    global `g` flag or the sticky `y` flag set, it consults the `lastIndex` property
    of the RegExp object to determine where to start looking for a match. (And if
    the `y` flag is set, it also constrains the match to begin at that position.)
    For a newly created RegExp object, `lastIndex` is 0, and the search begins at
    the start of the string. But each time `exec()` successfully finds a match, it
    updates the `lastIndex` property to the index of the character immediately after
    the matched text. If `exec()` fails to find a match, it resets `lastIndex` to
    0\. This special behavior allows you to call `exec()` repeatedly in order to loop
    through all the regular expression matches in a string. (Although, as we’ve described,
    in ES2020 and later, the `matchAll()` method of String is an easier way to loop
    through all matches.) For example, the loop in the following code will run twice:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与 String 的 `match()` 方法不同，`exec()` 无论正则表达式是否有全局 `g` 标志，都返回相同类型的数组。回想一下，当传递一个全局正则表达式时，`match()`
    返回一个匹配数组。相比之下，`exec()` 总是返回一个单一匹配，并提供关于该匹配的完整信息。当在具有全局 `g` 标志或粘性 `y` 标志的正则表达式上调用
    `exec()` 时，它会查看 RegExp 对象的 `lastIndex` 属性，以确定从哪里开始查找匹配。如果设置了 `y` 标志，它还会限制匹配从该位置开始。对于新创建的
    RegExp 对象，`lastIndex` 为 0，并且搜索从字符串的开头开始。但每次 `exec()` 成功找到一个匹配时，它会更新 `lastIndex`
    属性为匹配文本后面的字符的索引。如果 `exec()` 未找到匹配，它会将 `lastIndex` 重置为 0。这种特殊行为允许你重复调用 `exec()`
    以循环遍历字符串中的所有正则表达式匹配。例如，以下代码中的循环将运行两次：
- en: '[PRE57]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 11.4 Dates and Times
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.4 日期和时间
- en: 'The Date class is JavaScript’s API for working with dates and times. Create
    a Date object with the `Date()` constructor. With no arguments, it returns a Date
    object that represents the current date and time:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Date 类是 JavaScript 用于处理日期和时间的 API。使用 `Date()` 构造函数创建一个 Date 对象。如果没有参数，它会返回一个代表当前日期和时间的
    Date 对象：
- en: '[PRE58]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you pass one numeric argument, the `Date()` constructor interprets that
    argument as the number of milliseconds since the 1970 epoch:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递一个数字参数，`Date()` 构造函数会将该参数解释为自 1970 年起的毫秒数：
- en: '[PRE59]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you specify two or more integer arguments, they are interpreted as the year,
    month, day-of-month, hour, minute, second, and millisecond in your local time
    zone, as in the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定两个或更多整数参数，它们会被解释为年、月、日、小时、分钟、秒和毫秒，使用你的本地时区，如下所示：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: One quirk of the Date API is that the first month of a year is number 0, but
    the first day of a month is number 1\. If you omit the time fields, the `Date()`
    constructor defaults them all to 0, setting the time to midnight.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Date API 的一个怪癖是，一年中的第一个月是数字 0，但一个月中的第一天是数字 1。如果省略时间字段，`Date()` 构造函数会将它们全部默认为
    0，将时间设置为午夜。
- en: 'Note that when invoked with multiple numbers, the `Date()` constructor interprets
    them using whatever time zone the local computer is set to. If you want to specify
    a date and time in UTC (Universal Coordinated Time, aka GMT), then you can use
    the `Date.UTC()`. This static method takes the same arguments as the `Date()`
    constructor, interprets them in UTC, and returns a millisecond timestamp that
    you can pass to the `Date()` constructor:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当使用多��数字调用 `Date()` 构造函数时，它会使用本地计算机设置的任何时区进行解释。如果你想在 UTC（协调世界时，又称 GMT）中指定日期和时间，那么你可以使用
    `Date.UTC()`。这个静态方法接受与 `Date()` 构造函数相同的参数，在 UTC 中解释它们，并返回一个毫秒时间戳，你可以传递给 `Date()`
    构造函数：
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If you print a date (with `console.log(century)`, for example), it will, by
    default, be printed in your local time zone. If you want to display a date in
    UTC, you should explicitly convert it to a string with `toUTCString()` or `toISOString()`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印一个日期（例如使用 `console.log(century)`），默认情况下会以你的本地时区打印。如果你想在 UTC 中显示一个日期，你应该明确地将其转换为字符串，使用
    `toUTCString()` 或 `toISOString()`。
- en: 'Finally, if you pass a string to the `Date()` constructor, it will attempt
    to parse that string as a date and time specification. The constructor can parse
    dates specified in the formats produced by the `toString()`, `toUTCString()`,
    and `toISOString()` methods:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你将一个字符串传递给 `Date()` 构造函数，它将尝试将该字符串解析为日期和时间规范。构造函数可以解析由 `toString()`、`toUTCString()`
    和 `toISOString()` 方法生成的格式指定的日期：
- en: '[PRE62]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once you have a Date object, various get and set methods allow you to query
    and modify the year, month, day-of-month, hour, minute, second, and millisecond
    fields of the Date. Each of these methods has two forms: one that gets or sets
    using local time and one that gets or sets using UTC time. To get or set the year
    of a Date object, for example, you would use `getFullYear()`, `getUTCFullYear()`,
    `setFullYear()`, or `setUTCFullYear()`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个 Date 对象，各种获取和设置方法允许你查询和修改 Date 的年、月、日、小时、分钟、秒和毫秒字段。每个方法都有两种形式：一种使用本地时间进行获取或设置，另一种使用
    UTC 时间进行获取或设置。例如，要获取或设置 Date 对象的年份，你可以使用 `getFullYear()`、`getUTCFullYear()`、`setFullYear()`
    或 `setUTCFullYear()`：
- en: '[PRE63]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To get or set the other fields of a Date, replace “FullYear” in the method name
    with “Month”, “Date”, “Hours”, “Minutes”, “Seconds”, or “Milliseconds”. Some of
    the date set methods allow you to set more than one field at a time. `setFullYear()`
    and `setUTCFullYear()` also optionally allow you to set the month and day-of-month
    as well. And `setHours()` and `setUTCHours()` allow you to specify the minutes,
    seconds, and milliseconds fields in addition to the hours field.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取或设置 Date 的其他字段，将方法名称中的“FullYear”替换为“Month”、“Date”、“Hours”、“Minutes”、“Seconds”或“Milliseconds”。一些日期设置方法允许你一次设置多个字段。`setFullYear()`
    和 `setUTCFullYear()` 还可选择设置月份和日期。而 `setHours()` 和 `setUTCHours()` 还允许你指定分钟、秒和毫秒字段，除了小时字段。
- en: Note that the methods for querying the day-of-month are `getDate()` and `getUTCDate()`.
    The more natural-sounding functions `getDay()` and `getUTCDay()` return the day-of-week
    (0 for Sunday through 6 for Saturday). The day-of-week is read-only, so there
    is not a corresponding `setDay()` method.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，查询日期的方法是`getDate()`和`getUTCDate()`。更自然的函数`getDay()`和`getUTCDay()`返回星期几（星期日为0，星期六为6）。星期几是只读的，因此没有相应的`setDay()`方法。
- en: 11.4.1 Timestamps
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.1 时间戳
- en: JavaScript represents dates internally as integers that specify the number of
    milliseconds since (or before) midnight on January 1, 1970, UTC time. Integers
    as large as 8,640,000,000,000,000 are supported, so JavaScript won’t be running
    out of milliseconds for more than 270,000 years.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript将日期内部表示为整数，指定自1970年1月1日午夜（或之前）以来的毫秒数。支持的整数最大为8,640,000,000,000,000，因此JavaScript在270,000年后不会用尽毫秒。
- en: 'For any Date object, the `getTime()` method returns this internal value, and
    the `setTime()` method sets it. So you can add 30 seconds to a Date with code
    like this, for example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何日期对象，`getTime()`方法返回内部值，而`setTime()`方法设置它。因此，您可以像这样为日期添加30秒：
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'These millisecond values are sometimes called *timestamps*, and it is sometimes
    useful to work with them directly rather than with Date objects. The static `Date.now()`
    method returns the current time as a timestamp and is helpful when you want to
    measure how long your code takes to run:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这些毫秒值有时被称为*时间戳*，直接使用它们而不是Date对象有时很有用。静态的`Date.now()`方法返回当前时间作为时间戳，当您想要测量代码运行时间时很有帮助：
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 11.4.2 Date Arithmetic
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.2 日期算术
- en: Date objects can be compared with JavaScript’s standard `<`, `<=`, `>`, and
    `>=` comparison operators. And you can subtract one Date object from another to
    determine the number of milliseconds between the two dates. (This works because
    the Date class defines a `valueOf()` method that returns a timestamp.)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用JavaScript的标准`<`、`<=`、`>`和`>=`比较运算符比较日期对象。您可以从一个日期对象中减去另一个日期对象以确定两个日期之间的毫秒数。（这是因为Date类定义了一个返回时间戳的`valueOf()`方法。）
- en: 'If you want to add or subtract a specified number of seconds, minutes, or hours
    from a Date, it is often easiest to simply modify the timestamp as demonstrated
    in the previous example, when we added 30 seconds to a date. This technique becomes
    more cumbersome if you want to add days, and it does not work at all for months
    and years since they have varying numbers of days. To do date arithmetic involving
    days, months, and years, you can use `setDate()`, `setMonth()`, and `setYear()`.
    Here, for example, is code that adds three months and two weeks to the current
    date:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要从日期中添加或减去指定数量的秒、分钟或小时，通常最简单的方法是修改时间戳，就像前面示例中添加30秒到日期一样。如果要添加天数，这种技术变得更加繁琐，对于月份和年份则根本不起作用，因为它们的天数不同。要进行涉及天数、月份和年份的日期算术，可以使用`setDate()`、`setMonth()`和`setYear()`。例如，以下是将三个月和两周添加到当前日期的代码：
- en: '[PRE66]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Date setting methods work correctly even when they overflow. When we add three
    months to the current month, we can end up with a value greater than 11 (which
    represents December). The `setMonth()` handles this by incrementing the year as
    needed. Similarly, when we set the day of the month to a value larger than the
    number of days in the month, the month gets incremented appropriately.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 即使溢出，日期设置方法也能正常工作。当我们向当前月份添加三个月时，可能得到大于11的值（代表12月）。`setMonth()`通过根据需要递增年份来处理这一点。同样，当我们将月份的日期设置为大于该月份天数的值时，月份会适当递增。
- en: 11.4.3 Formatting and Parsing Date Strings
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.3 格式化和解析日期字符串
- en: 'If you are using the Date class to actually keep track of dates and times (as
    opposed to just measuring time intervals), then you are likely to need to display
    dates and times to the users of your code. The Date class defines a number of
    different methods for converting Date objects to strings. Here are some examples:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Date类实际跟踪日期和时间（而不仅仅是测量时间间隔），那么您可能需要向代码的用户显示日期和时间。Date类定义了许多不同的方法来将Date对象转换为字符串。以下是一些示例：
- en: '[PRE67]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is a full list of the string formatting methods of the Date class:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Date类的字符串格式化方法的完整列表：
- en: '`toString()`'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()`'
- en: This method uses the local time zone but does not format the date and time in
    a locale-aware way.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用本地时区，但不以区域感知方式格式化日期和时间。
- en: '`toUTCString()`'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`toUTCString()`'
- en: This method uses the UTC time zone but does not format the date in a locale-aware
    way.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用UTC时区，但不以区域感知方式格式化日期。
- en: '`toISOString()`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`toISOString()`'
- en: This method prints the date and time in the standard year-month-day hours:minutes:seconds.ms
    format of the ISO-8601 standard. The letter “T” separates the date portion of
    the output from the time portion of the output. The time is expressed in UTC,
    and this is indicated with the letter “Z” as the last letter of the output.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法以ISO-8601标准的标准年-月-日小时:分钟:秒.ms格式打印日期和时间。字母“T”将输出的日期部分与时间部分分开。时间以UTC表示，并且最后一个字母“Z”表示这一点。
- en: '`toLocaleString()`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLocaleString()`'
- en: This method uses the local time zone and a format that is appropriate for the
    user’s locale.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用本地时区和适合用户区域的格式。
- en: '`toDateString()`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`toDateString()`'
- en: This method formats only the date portion of the Date and omits the time. It
    uses the local time zone and does not do locale-appropriate formatting.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅格式化日期部分并省略时间。它使用本地时区，不进行区域适当的格式化。
- en: '`toLocaleDateString()`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLocaleDateString()`'
- en: This method formats only the date. It uses the local time zone and a locale-appropriate
    date format.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅格式化日期。它使用本地时区和适合区域的日期格式。
- en: '`toTimeString()`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`toTimeString()`'
- en: This method formats only the time and omits the date. It uses the local time
    zone but does not format the time in a locale-aware way.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法仅格式化时间并省略日期。它使用本地时区，但不以区域感知方式格式化时间。
- en: '`toLocaleTimeString()`'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`toLocaleTimeString()`'
- en: This method formats the time in a locale-aware way and uses the local time zone.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法以区域感知方式格式化时间，并使用本地时区。
- en: None of these date-to-string methods is ideal when formatting dates and times
    to be displayed to end users. See [§11.7.2](#datetimeformat) for a more general-purpose
    and locale-aware date- and time-formatting technique.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当将日期和时间格式化为向最终用户显示时，这些日期转换为字符串的方法都不是理想的。查看 [§11.7.2](#datetimeformat) 以获取更通用且区域感知的日期和时间格式化技术。
- en: Finally, in addition to these methods that convert a Date object to a string,
    there is also a static `Date.parse()` method that takes a string as its argument,
    attempts to parse it as a date and time, and returns a timestamp representing
    that date. `Date.parse()` is able to parse the same strings that the `Date()`
    constructor can and is guaranteed to be able to parse the output of `toISOString()`,
    `toUTCString()`, and `toString()`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，除了这些将 Date 对象转换为字符串的方法之外，还有一个静态的 `Date.parse()` 方法，它以字符串作为参数，尝试将其解析为日期和时间，并返回表示该日期的时间戳。`Date.parse()`
    能够解析 `Date()` 构造函数可以解析的相同字符串，并且保证能够解析 `toISOString()`、`toUTCString()` 和 `toString()`
    的输出。
- en: 11.5 Error Classes
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.5 错误类
- en: The JavaScript `throw` and `catch` statements can throw and catch any JavaScript
    value, including primitive values. There is no exception type that must be used
    to signal errors. JavaScript does define an Error class, however, and it is traditional
    to use instances of Error or a subclass when signaling an error with `throw`.
    One good reason to use an Error object is that, when you create an Error, it captures
    the state of the JavaScript stack, and if the exception is uncaught, the stack
    trace will be displayed with the error message, which will help you debug the
    issue. (Note that the stack trace shows where the Error object was created, not
    where the `throw` statement throws it. If you always create the object right before
    throwing it with `throw new Error()`, this will not cause any confusion.)
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的 `throw` 和 `catch` 语句可以抛出和捕获任何 JavaScript 值，包括原始值。没有必须用于信号错误的异常类型。但是，JavaScript
    确实定义了一个 Error 类，并且在使用 `throw` 信号错误时传统上使用 Error 的实例或子类。使用 Error 对象的一个很好的理由是，当您创建一个
    Error 时，它会捕获 JavaScript 堆栈的状态，如果异常未被捕获，堆栈跟踪将显示在错误消息中，这将帮助您调试问题。（请注意，堆栈跟踪显示 Error
    对象的创建位置，而不是 `throw` 语句抛出它的位置。如果您总是在使用 `throw new Error()` 抛出之前创建对象，这将不会引起任何混淆。）
- en: 'Error objects have two properties: `message` and `name`, and a `toString()`
    method. The value of the `message` property is the value you passed to the `Error()`
    constructor, converted to a string if necessary. For error objects created with
    `Error()`, the `name` property is always “Error”. The `toString()` method simply
    returns the value of the `name` property followed by a colon and space and the
    value of the `message` property.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Error 对象有两个属性：`message` 和 `name`，以及一个 `toString()` 方法。`message` 属性的值是您传递给 `Error()`
    构造函数的值，必要时转��为字符串。对于使用 `Error()` 创建的错误对象，`name` 属性始终为“Error”。`toString()` 方法简单地返回
    `name` 属性的值，后跟一个冒号和空格，以及 `message` 属性的值。
- en: Although it is not part of the ECMAScript standard, Node and all modern browsers
    also define a `stack` property on Error objects. The value of this property is
    a multi-line string that contains a stack trace of the JavaScript call stack at
    the moment that the Error object was created. This can be useful information to
    log when an unexpected error is caught.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它不是 ECMAScript 标准的一部分，但 Node 和所有现代浏览器也在 Error 对象上定义了一个 `stack` 属性。该属性的值是一个多行字符串，其中包含
    JavaScript 调用堆栈在创建 Error 对象时的堆栈跟踪。当捕获到意外错误时，这可能是有用的信息进行记录。
- en: In addition to the Error class, JavaScript defines a number of subclasses that
    it uses to signal particular types of errors defined by ECMAScript. These subclasses
    are EvalError, RangeError, ReferenceError, SyntaxError, TypeError, and URIError.
    You can use these error classes in your own code if they seem appropriate. Like
    the base Error class, each of these subclasses has a constructor that takes a
    single message argument. And instances of each of these subclasses have a `name`
    property whose value is the same as the constructor name.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Error 类之外，JavaScript 还定义了一些子类，用于信号 ECMAScript 定义的特定类型的错误。这些子类包括 EvalError、RangeError、ReferenceError、SyntaxError、TypeError
    和 URIError。如果看起来合适，您可以在自己的代码中使用这些错误类。与基本 Error 类一样，这些子类的每个都有一个接受单个消息参数的构造函数。并且每个这些子类的实例都有一个
    `name` 属性，其值与构造函数名称相同。
- en: You should feel free to define your own Error subclasses that best encapsulate
    the error conditions of your own program. Note that you are not limited to the
    `name` and `message` properties. If you create a subclass, you can define new
    properties to provide error details. If you are writing a parser, for example,
    you might find it useful to define a ParseError class with `line` and `column`
    properties that specify the exact location of the parsing failure. Or if you are
    working with HTTP requests, you might want to define an HTTPError class that has
    a `status` property that holds the HTTP status code (such as 404 or 500) of the
    failed request.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随意定义最能封装您自己程序的错误条件的 Error 子类。请注意，您不仅限于 `name` 和 `message` 属性。如果创建一个子类，您可以定义新属性以提供错误详细信息。例如，如果您正在编写解析器，可能会发现定义一个具有指定解析失败确切位置的
    `line` 和 `column` 属性的 ParseError 类很有用。或者，如果您正在处理 HTTP 请求，可能希望定义一个具有保存失败请求的 HTTP
    状态码（例如 404 或 500）的 `status` 属性的 HTTPError 类。
- en: 'For example:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE68]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 11.6 JSON Serialization and Parsing
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.6 JSON 序列化和解析
- en: When a program needs to save data or needs to transmit data across a network
    connection to another program, it must to convert its in-memory data structures
    into a string of bytes or characters than can be saved or transmitted and then
    later be parsed to restore the original in-memory data structures. This process
    of converting data structures into streams of bytes or characters is known as
    *serialization* (or *marshaling* or even *pickling*).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序需要保存数据或需要将数据通过网络连接传输到另一个程序时，它必须将其内存中的数据结构转换为一串字节或字符，这些字节或字符可以被保存或传输，然后稍后被解析以恢复原始的内存中的数据结构。将数据结构转换为字节流或字符流的过程称为*序列化*（或*编组*甚至*腌制*）。
- en: The easiest way to serialize data in JavaScript uses a serialization format
    known as JSON. This acronym stands for “JavaScript Object Notation” and, as the
    name implies, the format uses JavaScript object and array literal syntax to convert
    data structures consisting of objects and arrays into strings. JSON supports primitive
    numbers and strings and also the values `true`, `false`, and `null`, as well as
    arrays and objects built up from those primitive values. JSON does not support
    other JavaScript types like Map, Set, RegExp, Date, or typed arrays. Nevertheless,
    it has proved to be a remarkably versatile data format and is in common use even
    with non-JavaScript-based programs.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中序列化数据的最简单方法使用了一种称为JSON的序列化格式。这个首字母缩写代表“JavaScript对象表示法”，正如名称所示，该格式使用JavaScript对象和数组文字语法将由对象和数组组成的数据结构转换为字符串。JSON支持原始数字和字符串，以及值`true`、`false`和`null`，以及由这些原始值构建的数组和对象。JSON不支持Map、Set、RegExp、Date或类型化数组等其他JavaScript类型。尽管如此，它已被证明是一种非常多才多艺的数据格式，即使在非基于JavaScript的程序中也被广泛使用。
- en: 'JavaScript supports JSON serialization and deserialization with the two functions
    `JSON.stringify()` and `JSON.parse()`, which were covered briefly in [§6.8](ch06.xhtml#serializingobjects).
    Given an object or array (nested arbitrarily deeply) that does not contain any
    nonserializable values like RegExp objects or typed arrays, you can serialize
    the object simply by passing it to `JSON.stringify()`. As the name implies, the
    return value of this function is a string. And given a string returned by `JSON.stringify()`,
    you can re-create the original data structure by passing the string to `JSON.parse()`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript支持使用两个函数`JSON.stringify()`和`JSON.parse()`进行JSON序列化和反序列化，这两个函数在[§6.8](ch06.xhtml#serializingobjects)中简要介绍过。给定一个不包含任何非可序列化值（如RegExp对象或类型化数组）的对象或数组（任意深度嵌套），您可以通过将其传递给`JSON.stringify()`来简单地序列化对象。正如名称所示，此函数的返回值是一个字符串。并且给定`JSON.stringify()`返回的字符串，您可以通过将字符串传递给`JSON.parse()`来重新创建原始数据结构：
- en: '[PRE69]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we leave out the part where serialized data is saved to a file or sent over
    the network, we can use this pair of functions as a somewhat inefficient way of
    creating a deep copy of an object:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略序列化数据保存到文件或通过网络发送的部分，我们可以将这对函数用作创建对象的深层副本的一种效率较低的方式：
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: JSON Is a Subset of JavaScript
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON是JavaScript的一个子集
- en: When data is serialized to JSON format, the result is valid JavaScript source
    code for an expression that evaluates to a copy of the original data structure.
    If you prefix a JSON string with `var data =` and pass the result to `eval()`,
    you’ll get a copy of the original data structure assigned to the variable `data`.
    You should never do this, however, because it is a huge security hole—if an attacker
    could inject arbitrary JavaScript code into a JSON file, they could make your
    program run their code. It is faster and safer to just use `JSON.parse()` to decode
    JSON-formatted data.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据序列化为JSON格式时，结果是一个有效的JavaScript源代码，用于评估为原始数据结构的副本。如果您在JSON字符串前面加上`var data
    =`并将结果传递给`eval()`，您将获得将原始数据结构的副本分配给变量`data`的结果。但是，您绝对不应该这样做，因为这是一个巨大的安全漏洞——如果攻击者可以将任意JavaScript代码注入JSON文件中，他们可以使您的程序运行他们的代码。只需使用`JSON.parse()`来解码JSON格式化数据，这样更快速和安全。
- en: JSON is sometimes used as a human-readable configuration file format. If you
    find yourself hand-editing a JSON file, note that the JSON format is a very strict
    subset of JavaScript. Comments are not allowed and property names must be enclosed
    in double quotes even when JavaScript would not require this.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: JSON有时被用作人类可读的配置文件格式。如果您发现自己手动编辑JSON文件，请注意JSON格式是JavaScript的一个非常严格的子集。不允许注释，属性名称必须用双引号括起来，即使JavaScript不需要这样做。
- en: Typically, you pass only a single argument to `JSON.stringify()` and `JSON.parse()`.
    Both functions accept an optional second argument that allows us to extend the
    JSON format, and these are described next. `JSON.stringify()` also takes an optional
    third argument that we’ll discuss first. If you would like your JSON-formatted
    string to be human-readable (if it is being used as a configuration file, for
    example), then you should pass `null` as the second argument and pass a number
    or string as the third argument. This third argument tells `JSON.stringify()`
    that it should format the data on multiple indented lines. If the third argument
    is a number, then it will use that number of spaces for each indentation level.
    If the third argument is a string of whitespace (such as `'\t'`), it will use
    that string for each level of indent.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只向`JSON.stringify()`和`JSON.parse()`传递单个参数。这两个函数都接受一个可选的第二个参数，允许我们扩展JSON格式，接下来将对此进行描述。`JSON.stringify()`还接受一个可选的第三个参数，我们将首先讨论这个参数。如果您希望您的JSON格式化字符串可读性强（例如用作配置文件），那么应将`null`作为第二个参数传递，并将数字或字符串作为第三个参数传递。第三个参数告诉`JSON.stringify()`应该将数据格式化为多个缩进行。如果第三个参数是一个数字，则它将使用该数字作为每个缩进级别的空格数。如果第三个参数是一个空格字符串（例如`'\t'`），它将使用该字符串作为每个缩进级别。
- en: '[PRE71]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`JSON.parse()` ignores whitespace, so passing a third argument to `JSON.stringify()`
    has no impact on our ability to convert the string back into a data structure.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.parse()`会忽略空格，因此向`JSON.stringify()`传递第三个参数对我们将字符串转换回数据结构的能力没有影响。'
- en: 11.6.1 JSON Customizations
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6.1 JSON自定义
- en: 'If `JSON.stringify()` is asked to serialize a value that is not natively supported
    by the JSON format, it looks to see if that value has a `toJSON()` method, and
    if so, it calls that method and then stringifies the return value in place of
    the original value. Date objects implement `toJSON()`: it returns the same string
    that `toISOString()` method does. This means that if you serialize an object that
    includes a Date, the date will automatically be converted to a string for you.
    When you parse the serialized string, the re-created data structure will not be
    exactly the same as the one you started with because it will have a string where
    the original object had a Date.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`JSON.stringify()`被要求序列化一个 JSON 格式不支持的值，它会查看该值是否有一个`toJSON()`方法，如果有，它会调用该方法，然后将返回值序列化以替换原始值。Date
    对象实现了`toJSON()`：它返回与`toISOString()`方法相同的字符串。这意味着如果序列化包含 Date 的对象，日期将自动转换为字符串。当您解析序列化的字符串时，重新创建的数据结构将不会与您开始的完全相同，因为它将在原始对象有
    Date 的地方有一个字符串。
- en: If you need to re-create Date objects (or modify the parsed object in any other
    way), you can pass a “reviver” function as the second argument to `JSON.parse()`.
    If specified, this “reviver” function is invoked once for each primitive value
    (but not the objects or arrays that contain those primitive values) parsed from
    the input string. The function is invoked with two arguments. The first is a property
    name—either an object property name or an array index converted to a string. The
    second argument is the primitive value of that object property or array element.
    Furthermore, the function is invoked as a method of the object or array that contains
    the primitive value, so you can refer to that containing object with the `this`
    keyword.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要重新创建 Date 对象（或以任何其他方式修改解析的对象），可以将“恢复器”函数作为第二个参数传递给`JSON.parse()`。如果指定了，这个“恢复器”函数将被用于从输入字符串解析的每个原始值（但不包含这些原始值的对象或数组）。该函数被调用时带有两个参数。第一个是属性名称—一个对象属性名称或转换为字符串的数组索引。第二个参数是该对象属性或数组元素的原始值。此外，该函数作为包含原始值的对象或数组的方法被调用，因此您可以使用`this`关键字引用该包含对象。
- en: The return value of the reviver function becomes the new value of the named
    property. If it returns its second argument, the property will remain unchanged.
    If it returns `undefined`, then the named property will be deleted from the object
    or array before `JSON.parse()` returns to the user.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复函数的返回值将成为命名属性的新值。如果它返回其第二个参数，则属性将保持不变。如果返回`undefined`，则在`JSON.parse()`返回给用户之前，命名属性将从对象或数组中删除。
- en: 'As an example, here is a call to `JSON.parse()` that uses a reviver function
    to filter some properties and to re-create Date objects:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，这里是一个调用`JSON.parse()`的示例，使用恢复器函数来过滤一些属性并重新创建 Date 对象：
- en: '[PRE72]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In addition to its use of `toJSON()` described earlier, `JSON.stringify()` also
    allows its output to be customized by passing an array or a function as the optional
    second argument.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面描述的`toJSON()`的使用，`JSON.stringify()`还允许通过将数组或函数作为可选的第二个参数来自定义其输出。
- en: If an array of strings (or numbers—they are converted to strings) is passed
    instead as the second argument, these are used as the names of object properties
    (or array elements). Any property whose name is not in the array will be omitted
    from stringification. Furthermore, the returned string will include properties
    in the same order that they appear in the array (which can be very useful when
    writing tests).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为第二个参数传递的是字符串数组（或数字—它们会被转换为字符串），那么这些将被用作对象属性（或数组元素）的名称。任何名称不在数组中的属性都将被省略。此外，返回的字符串将按照它们在数组中出现的顺序包括属性（在编写测试时非常有用）。
- en: If you pass a function, it is a replacer function—effectively the inverse of
    the optional reviver function you can pass to `JSON.parse()`. If specified, the
    replacer function is invoked for each value to be stringified. The first argument
    to the replacer function is the object property name or array index of the value
    within that object, and the second argument is the value itself. The replacer
    function is invoked as a method of the object or array that contains the value
    to be stringified. The return value of the replacer function is stringified in
    place of the original value. If the replacer returns `undefined` or returns nothing
    at all, then that value (and its array element or object property) is omitted
    from the stringification.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递一个函数，它是一个替换函数—实际上是您可以传递给`JSON.parse()`的可选恢复函数的反函数。如果指定了替换函数，那么替换函数将被用于要序列化的每个值。替换函数的第一个参数是该对象中值的对象属性名称或数组索引，第二个参数是值本身。替换函数作为包含要序列化值的对象或数组的方法被调用。替换函数的返回值将被序列化以替换原始值。如果替换函数返回`undefined`或根本没有返回任何内容，则该值（及其数组元素或对象属性）将被省略在序列化中。
- en: '[PRE73]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The two `JSON.stringify()` calls here use the second argument in a benign way,
    producing serialized output that can be deserialized without requiring a special
    reviver function. In general, though, if you define a `toJSON()` method for a
    type, or if you use a replacer function that actually replaces nonserializable
    values with serializable ones, then you will typically need to use a custom reviver
    function with `JSON.parse()` to get your original data structure back. If you
    do this, you should understand that you are defining a custom data format and
    sacrificing portability and compatibility with a large ecosystem of JSON-compatible
    tools and languages.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个`JSON.stringify()`调用以一种良性的方式使用第二个参数，产生的序列化输出可以在不需要特殊恢复函数的情况下反序列化。然而，一般来说，如果为类型定义了`toJSON()`方法，或者使用一个实际上用可序列化值替换不可序列化值的替换函数，那么通常需要使用自定义恢复函数与`JSON.parse()`一起来获取原始数据结构。如果这样做，你应该明白你正在定义一种自定义数据格式，并牺牲了与大量
    JSON 兼容工具和语言的可移植性和兼容性。
- en: 11.7 The Internationalization API
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.7 国际化 API
- en: The JavaScript internationalization API consists of the three classes Intl.NumberFormat,
    Intl.DateTimeFormat, and Intl.Collator that allow us to format numbers (including
    monetary amounts and percentages), dates, and times in locale-appropriate ways
    and to compare strings in locale-appropriate ways. These classes are not part
    of the ECMAScript standard but are defined as part of the [ECMA402 standard](https://tc39.es/ecma402/)
    and are well-supported by web browsers. The Intl API is also supported in Node,
    but at the time of this writing, prebuilt Node binaries do not ship with the localization
    data required to make them work with locales other than US English. So in order
    to use these classes with Node, you may need to download a separate data package
    or use a custom build of Node.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript国际化API由三个类Intl.NumberFormat、Intl.DateTimeFormat和Intl.Collator组成，允许我们以区域设置适当的方式格式化数字（包括货币金额和百分比）、日期和时间，并以区域设置适当的方式比较字符串。这些类不是ECMAScript标准的一部分，但作为[ECMA402标准](https://tc39.es/ecma402/)的一部分定义，并得到Web浏览器的良好支持。Intl
    API也受Node支持，但在撰写本文时，预构建的Node二进制文件不包含所需的本地化数据，以使它们能够与除美国英语以外的区域设置一起使用。因此，为了在Node中使用这些类，您可能需要下载一个单独的数据包或使用自定义构建的Node。
- en: One of the most important parts of internationalization is displaying text that
    has been translated into the user’s language. There are various ways to achieve
    this, but none of them are within the scope of the Intl API described here.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化中最重要的部分之一是显示已翻译为用户语言的文本。有各种方法可以实现这一点，但这些方法都不在此处描述的Intl API的范围内。
- en: 11.7.1 Formatting Numbers
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.1 格式化数字
- en: Users around the world expect numbers to be formatted in different ways. Decimal
    points can be periods or commas. Thousands separators can be commas or periods,
    and they aren’t used every three digits in all places. Some currencies are divided
    into hundredths, some into thousandths, and some have no subdivisions. Finally,
    although the so-called “Arabic numerals” 0 through 9 are used in many languages,
    this is not universal, and users in some countries will expect to see numbers
    written using the digits from their own scripts.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 世界各地的用户期望以不同的方式格式化数字。小数点可以是句点或逗号。千位分隔符可以是逗号或句点，并且并非在所有地方每三位数字都使用。一些货币被分成百分之一，一些被分成千分之一，一些没有细分。最后，尽管所谓的“阿拉伯数字”0到9在许多语言中使用，但这并非普遍，一些国家的用户期望看到使用其自己脚本中的数字编写的数字。
- en: The Intl.NumberFormat class defines a `format()` method that takes all of these
    formatting possibilities into account. The constructor takes two arguments. The
    first argument specifies the locale that the number should be formatted for and
    the second is an object that specifies more details about how the number should
    be formatted. If the first argument is omitted or `undefined`, then the system
    locale (which we assume to be the user’s preferred locale) will be used. If the
    first argument is a string, it specifies a desired locale, such as `"en-US"` (English
    as used in the United States), `"fr"` (French), or `"zh-Hans-CN"` (Chinese, using
    the simplified Han writing system, in China). The first argument can also be an
    array of locale strings, and in this case, Intl.NumberFormat will choose the most
    specific one that is well supported.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Intl.NumberFormat类定义了一个`format()`方法，考虑到所有这些格式化可能性。构造函数接受两个参数。第一个参数指定应为其格式化数字的区域设置，第二个是一个对象，指定有关如何格式化数字的更多详细信息。如果省略或`undefined`第一个参数，则将使用系统区域设置（我们假设为用户首选区域设置）。如果第一个参数是字符串，则指定所需的区域设置，例如`"en-US"`（美国使用的英语）、`"fr"`（法语）或`"zh-Hans-CN"`（中国使用简体汉字书写系统）。第一个参数也可以是区域设置字符串数组，在这种情况下，Intl.NumberFormat将选择最具体且受支持的区域设置。
- en: 'The second argument to the `Intl.NumberFormat()` constructor, if specified,
    should be an object that defines one or more of the following properties:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了`Intl.NumberFormat()`构造函数的第二个参数，则应该是一个定义一个或多个以下属性的对象：
- en: '`style`'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`'
- en: Specifies the kind of number formatting that is required. The default is `"decimal"`.
    Specify `"percent"` to format a number as a percentage or specify `"currency"`
    to specify a number as an amount of money.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 指定所需的数字格式化类型。默认值为`"decimal"`。指定`"percent"`将数字格式化为百分比，或指定`"currency"`将数字格式化为货币金额。
- en: '`currency`'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`currency`'
- en: If style is `"currency"`, then this property is required to specify the three-letter
    ISO currency code (such as `"USD"` for US dollars or `"GBP"` for British pounds)
    of the desired currency.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样式为`"currency"`，则需要此属性来指定所需货币的三个字母ISO货币代码（例如`"USD"`表示美元或`"GBP"`表示英镑）。
- en: '`currencyDisplay`'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`currencyDisplay`'
- en: If style is `"currency"`, then this property specifies how the currency is displayed.
    The default value `"symbol"` uses a currency symbol if the currency has one. The
    value `"code"` uses the three-letter ISO code, and the value `"name"` spells out
    the name of the currency in long form.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样式为`"currency"`，则此属性指定货币的显示方式。默认值`"symbol"`使用货币符号（如果货币有符号）。值`"code"`使用三个字母ISO代码，值`"name"`以长形式拼写货币名称。
- en: '`useGrouping`'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`useGrouping`'
- en: Set this property to `false` if you do not want numbers to have thousands separators
    (or their locale-appropriate equivalents).
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性设置为`false`，如果您不希望数字具有千位分隔符（或其相应的区域设置等价物）。
- en: '`minimumIntegerDigits`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`minimumIntegerDigits`'
- en: The minimum number of digits to use to display the integer part of the number.
    If the number has fewer digits than this, it will be padded on the left with zeros.
    The default value is 1, but you can use values as high as 21.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示数字整数部分的最小位数。如果数字的位数少于此值，则将在左侧用零填充。默认值为1，但可以使用高达21的值。
- en: '`minimumFractionDigits`, `maximumFractionDigits`'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`minimumFractionDigits`，`maximumFractionDigits`'
- en: These two properties control the formatting of the fractional part of the number.
    If a number has fewer fractional digits than the minimum, it will be padded with
    zeros on the right. If it has more than the maximum, then the fractional part
    will be rounded. Legal values for both properties are between 0 and 20\. The default
    minimum is 0 and the default maximum is 3, except when formatting monetary amounts,
    when the length of the fractional part varies depending on the specified currency.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性控制数字的小数部分的格式。如果一个数字的小数位数少于最小值，它将在右侧用零填充。如果小数位数超过最大值，那么小数部分将被四舍五入。这两个属性的合法值介于0和20之间。默认最小值为0，最大值为3，除了在格式化货币金额时，小数部分的长度会根据指定的货币而变化。
- en: '`minimumSignificantDigits`, `maximumSignificantDigits`'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`minimumSignificantDigits`，`maximumSignificantDigits`'
- en: These properties control the number of significant digits used when formatting
    a number, making them suitable when formatting scientific data, for example. If
    specified, these properties override the integer and fractional digit properties
    listed previously. Legal values are between 1 and 21.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性控制在格式化数字时使用的有效数字位数，使其适用于格式化科学数据等情况。如果指定了这些属性，它们将覆盖先前列出的整数和小数位数属性。合法值介于1和21之间。
- en: 'Once you have created an Intl.NumberFormat object with the desired locale and
    options, you use it by passing a number to its `format()` method, which returns
    an appropriately formatted string. For example:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用所需的区域设置和选项创建了一个 Intl.NumberFormat 对象，您可以通过将数字传递给其`format()`方法来使用它，该方法将返回一个适当格式化的字符串。例如：
- en: '[PRE74]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A useful feature of `Intl.NumberFormat` (and the other Intl classes as well)
    is that its `format()` method is bound to the NumberFormat object to which it
    belongs. So instead of defining a variable that refers to the formatting object
    and then invoking the `format()` method on that, you can just assign the `format()`
    method to a variable and use it as if it were a standalone function, as in this
    example:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intl.NumberFormat`（以及其他 Intl 类）的一个有用功能是它的`format()`方法绑定到它所属的 NumberFormat
    对象。因此，您可以将`format()`方法分配给一个变量，并像独立函数一样使用它，而不是定义一个引用格式化对象的变量，然后在该变量上调用`format()`方法，就像这个例子中一样：'
- en: '[PRE75]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Some languages, such as Arabic, use their own script for decimal digits:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，比如阿拉伯语，使用自己的脚本来表示十进制数字：
- en: '[PRE76]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Other languages, such as Hindi, use a script that has its own set of digits,
    but tend to use the ASCII digits 0–9 by default. If you want to override the default
    script used for digits, add `-u-nu-` to the locale and follow it with an abbreviated
    script name. You can format numbers with Indian-style grouping and Devanagari
    digits like this, for example:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言，比如印地语，使用自己的数字字符集，但默认情况下倾向于使用 ASCII 数字 0-9。如果要覆盖用于数字的默认字符集，请在区域设置中添加`-u-nu-`，然后跟上简写的字符集名称。例如，您可以这样格式化数字，使用印度风格的分组和天城数字：
- en: '[PRE77]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`-u-` in a locale specifies that what comes next is a Unicode extension. `nu`
    is the extension name for the numbering system, and `deva` is short for Devanagari.
    The Intl API standard defines names for a number of other numbering systems, mostly
    for the Indic languages of South and Southeast Asia.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在区域设置中的`-u-`指定接下来是一个 Unicode 扩展。`nu`是编号系统的扩展名称，`deva`是 Devanagari 的缩写。Intl API
    标准为许多其他编号系统定义了名称，主要用于南亚和东南亚的印度语言。
- en: 11.7.2 Formatting Dates and Times
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.2 格式化日期和时间
- en: 'The Intl.DateTimeFormat class is a lot like the Intl.NumberFormat class. The
    `Intl.DateTimeFormat()` constructor takes the same two arguments that `Intl.NumberFormat()`
    does: a locale or array of locales and an object of formatting options. And the
    way you use an Intl.DateTimeFormat instance is by calling its `format()` method
    to convert a Date object to a string.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: Intl.DateTimeFormat 类与 Intl.NumberFormat 类非常相似。`Intl.DateTimeFormat()`构造函数接受与`Intl.NumberFormat()`相同的两个参数：区域设置或区域设置数组以及格式选项对象。使用
    Intl.DateTimeFormat 实例的方法是调用其`format()`方法，将 Date 对象转换为字符串。
- en: As mentioned in [§11.4](#datesandtimes), the Date class defines simple `toLocaleDateString()`
    and `toLocaleTimeString()` methods that produce locale-appropriate output for
    the user’s locale. But these methods don’t give you any control over what fields
    of the date and time are displayed. Maybe you want to omit the year but add a
    weekday to the date format. Do you want the month to be represented numerically
    or spelled out by name? The Intl.DateTimeFormat class provides fine-grained control
    over what is output based on the properties in the options object that is passed
    as the second argument to the constructor. Note, however, that Intl.DateTimeFormat
    cannot always display exactly what you ask for. If you specify options to format
    hours and seconds but omit minutes, you’ll find that the formatter displays the
    minutes anyway. The idea is that you use the options object to specify what date
    and time fields you’d like to present to the user and how you’d like those formatted
    (by name or by number, for example), then the formatter will look for a locale-appropriate
    format that most closely matches what you have asked for.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如[§11.4](#datesandtimes)中所述，Date 类定义了简单的`toLocaleDateString()`和`toLocaleTimeString()`方法，为用户的区域设置生成适当的输出。但是这些方法不会让您控制显示的日期和时间字段。也许您想省略年份，但在日期格式中添加一个工作日。您希望月份是以数字形式表示还是以名称拼写出来？Intl.DateTimeFormat
    类根据传递给构造函数的第二个参数中的选项对象中的属性提供对输出的细粒度控制。但是，请注意，Intl.DateTimeFormat 不能总是精确显示您要求的内容。如果指���了格式化小时和秒的选项但省略了分钟，您会发现格式化程序仍然会显示分钟。这个想法是您使用选项对象指定要向用户呈现的日期和时间字段以及您希望如何格式化这些字段（例如按名称或按数字），然后格式化程序将查找最接近您要求的内容的适合区域设置的格式。
- en: The available options are the following. Only specify properties for date and
    time fields that you would like to appear in the formatted output.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选项如下。只为您希望出现在格式化输出中的日期和时间字段指定属性。
- en: '`year`'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`年`'
- en: Use `"numeric"` for a full, four-digit year or `"2-digit"` for a two-digit abbreviation.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"numeric"`表示完整的四位数年份，或使用`"2-digit"`表示两位数缩写。
- en: '`month`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`月`'
- en: Use `"numeric"` for a possibly short number like “1”, or `"2-digit"` for a numeric
    representation that always has two digits, like “01”. Use `"long"` for a full
    name like “January”, `"short"` for an abbreviated name like “Jan”, and `"narrow"`
    for a highly abbreviated name like “J” that is not guaranteed to be unique.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"numeric"`表示可能的短数字，如“1”，或`"2-digit"`表示始终有两位数字的数字表示，如“01”。使用`"long"`表示全名，如“January”，`"short"`表示缩写，如“Jan”，`"narrow"`表示高度缩写，如“J”，不保证唯一。
- en: '`day`'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`day`'
- en: Use `"numeric"` for a one- or two-digit number or `"2-digit"` for a two-digit
    number for the day-of-month.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"numeric"`表示一位或两位数字，或`"2-digit"`表示月份的两位数字。
- en: '`weekday`'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`weekday`'
- en: Use `"long"` for a full name like “Monday”, `"short"` for an abbreviated name
    like “Mon”, and `"narrow"` for a highly abbreviated name like “M” that is not
    guaranteed to be unique.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`"long"`表示全名，如“Monday”，`"short"`表示缩写，如“Mon”，`"narrow"`表示高度缩写，如“M”，不保证唯一。
- en: '`era`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`era`'
- en: This property specifies whether a date should be formatted with an era, such
    as CE or BCE. This may be useful if you are formatting dates from very long ago
    or if you are using a Japanese calendar. Legal values are `"long"`, `"short"`,
    and `"narrow"`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定日期是否应以时代（如CE或BCE）格式化。如果您正在格式化很久以前的日期或使用日本日历，则可能��有用。合法值为`"long"`、`"short"`和`"narrow"`。
- en: '`hour`, `minute`, `second`'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`hour`、`minute`、`second`'
- en: These properties specify how you would like time displayed. Use `"numeric"`
    for a one- or two-digit field or `"2-digit"` to force single-digit numbers to
    be padded on the left with a 0.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性指定您希望如何显示时间。使用`"numeric"`表示一位或两位数字字段，或`"2-digit"`强制将单个数字左侧填充为0。
- en: '`timeZone`'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeZone`'
- en: This property specifies the desired time zone for which the date should be formatted.
    If omitted, the local time zone is used. Implementations always recognize “UTC”
    and may also recognize Internet Assigned Numbers Authority (IANA) time zone names,
    such as “America/Los_Angeles”.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定应为其格式化日期的所需时区。如果省略，将使用本地时区。实现始终识别“UTC”，并且还可以识别互联网分配的数字管理局（IANA）时区名称，例如“America/Los_Angeles”。
- en: '`timeZoneName`'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeZoneName`'
- en: This property specifies how the time zone should be displayed in a formatted
    date or time. Use `"long"` for a fully spelled-out time zone name and `"short"`
    for an abbreviated or numeric time zone.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定应如何在格式化的日期或时间中显示时区。使用`"long"`表示完全拼写的时区名称，`"short"`表示缩写或数字时区。
- en: '`hour12`'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`hour12`'
- en: This boolean property specifies whether or not to use 12-hour time. The default
    is locale dependent, but you can override it with this property.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布尔属性指定是否使用12小时制。默认是与地区相关的，但你可以用这个属性来覆盖它。
- en: '`hourCycle`'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`hourCycle`'
- en: This property allows you to specify whether midnight is written as 0 hours,
    12 hours, or 24 hours. The default is locale dependent, but you can override the
    default with this property. Note that `hour12` takes precedence over this property.
    Use the value `"h11"` to specify that midnight is 0 and the hour before midnight
    is 11pm. Use `"h12"` to specify that midnight is 12\. Use `"h23"` to specify that
    midnight is 0 and the hour before midnight is 23. And use `"h24"` to specify that
    midnight is 24.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性允许您指定午夜是写作0小时、12小时还是24小时。默认是与地区相关的，但您可以用此属性覆盖默认值。请注意，`hour12`优先于此属性。使用值`"h11"`指定午夜为0，午夜前一小时为11pm。使用`"h12"`指定午夜为12。使用`"h23"`指定午夜为0，午夜前一小时为23。使用`"h24"`指定午夜为24。
- en: 'Here are some examples:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE78]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Intl.DateTimeFormat can display dates using calendars other than the default
    Julian calendar based on the Christian era. Although some locales may use a non-Christian
    calendar by default, you can always explicitly specify the calendar to use by
    adding `-u-ca-` to the locale and following that with the name of the calendar.
    Possible calendar names include “buddhist”, “chinese”, “coptic”, “ethiopic”, “gregory”,
    “hebrew”, “indian”, “islamic”, “iso8601”, “japanese”, and “persian”. Continuing
    the preceding example, we can determine the year in various non-Christian calendars:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Intl.DateTimeFormat可以使用除基于基督教时代的默认儒略历之外的其他日历显示日期。尽管一些地区可能默认使用非基督教日历，但您始终可以通过在地区后添加`-u-ca-`并在其后跟日历名称来明确指定要使用的日历。可能的日历名称包括“buddhist”、“chinese”、“coptic”、“ethiopic”、“gregory”、“hebrew”、“indian”、“islamic”、“iso8601”、“japanese”和“persian”。继续前面的示例，我们可以确定各种非基督教历法中的年份：
- en: '[PRE79]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 11.7.3 Comparing Strings
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.3 比较字符串
- en: The problem of sorting strings into alphabetical order (or some more general
    “collation order” for nonalphabetical scripts) is more challenging than English
    speakers often realize. English uses a relatively small alphabet with no accented
    letters, and we have the benefit of a character encoding (ASCII, since incorporated
    into Unicode) whose numerical values perfectly match our standard string sort
    order. Things are not so simple in other languages. Spanish, for example treats
    ñ as a distinct letter that comes after n and before o. Lithuanian alphabetizes
    Y before J, and Welsh treats digraphs like CH and DD as single letters with CH
    coming after C and DD sorting after D.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串按字母顺序排序（或对于非字母脚本的更一般“排序顺序”）的问题比英语使用者通常意识到的更具挑战性。英语使用相对较小的字母表，没有重音字母，并且我们有字符编码（ASCII，已合并到Unicode中）的好处，其数值完全匹配我们的标准字符串排序顺序。在其他语言中情况并不那么简单。例如，西班牙语将ñ视为一个独立的字母，位于n之后和o之前。立陶宛语将Y排在J之前，威尔士语将CH和DD等二合字母视为单个字母，CH排在C之后，DD排在D之后。
- en: If you want to display strings to a user in an order that they will find natural,
    it is not enough use the `sort()` method on an array of strings. But if you create
    an Intl.Collator object, you can pass the `compare()` method of that object to
    the `sort()` method to perform locale-appropriate sorting of the strings. Intl.Collator
    objects can be configured so that the `compare()` method performs case-insensitive
    comparisons or even comparisons that only consider the base letter and ignore
    accents and other diacritics.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要按用户自然顺序显示字符串，仅使用数组字符串的`sort()`方法是不够的。但是，如果创建Intl.Collator对象，可以将该对象的`compare()`方法传递给`sort()`方法，以执行符合区域设置的字符串排序。Intl.Collator对象可以配置为使`compare()`方法执行不区分大小写的比较，甚至只考虑基本字母并忽略重音和其他变音���号的比较。
- en: 'Like `Intl.NumberFormat()` and `Intl.DateTimeFormat()`, the `Intl.Collator()`
    constructor takes two arguments. The first specifies a locale or an array of locales,
    and the second is an optional object whose properties specify exactly what kind
    of string comparison is to be done. The supported properties are these:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Intl.NumberFormat()`和`Intl.DateTimeFormat()`一样，`Intl.Collator()`构造函数接受两个参数。第一个指定区域设置或区域设置数组，第二个是一个可选对象，其属性精确指定要执行的字符串比较类型。支持的属性如下：
- en: '`usage`'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`usage`'
- en: This property specifies how the collator object is to be used. The default value
    is `"sort"`, but you can also specify `"search"`. The idea is that, when sorting
    strings, you typically want a collator that differentiates as many strings as
    possible to produce a reliable ordering. But when comparing two strings, some
    locales may want a less strict comparison that ignores accents, for example.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定如何使用排序器对象。默认值为`"sort"`，但也可以指定`"search"`。想法是，在对字符串进行排序时，通常希望排序器尽可能区分多个字符串以产生可靠的排序。但是，在比较两个字符串时，某些区域设置可能希望进行较不严格的比较，例如忽略重音。
- en: '`sensitivity`'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensitivity`'
- en: This property specifies whether the collator is sensitive to letter case and
    accents when comparing strings. The value `"base"` causes comparisons that ignore
    case and accents, considering only the base letter for each character. (Note,
    however, that some languages consider certain accented characters to be distinct
    base letters.) `"accent"` considers accents in comparisons but ignores case. `"case"`
    considers case and ignores accents. And `"variant"` performs strict comparisons
    that consider both case and accents. The default value for this property is `"variant"`
    when `usage` is `"sort"`. If `usage` is `"search"`, then the default sensitivity
    depends on the locale.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定比较字符串时，排序器是否对大小写和重音敏感。值为`"base"`会忽略大小写和重音，只考虑每个字符的基本字母。（但请注意，某些语言认为某些带重音的字符是不同的基本字母。）`"accent"`考虑重音但忽略大小写。`"case"`考虑大小写但忽略重音。`"variant"`执行严格的比较，考虑大小写和重音。当`usage`为`"sort"`时，此属性的默认值为`"variant"`。如果`usage`为`"search"`，则默认灵敏度取决于区域设置。
- en: '`ignorePunctuation`'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`ignorePunctuation`'
- en: Set this property to `true` to ignore spaces and punctuation when comparing
    strings. With this property set to `true`, the strings “any one” and “anyone”,
    for example, will be considered equal.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 将此属性设置为`true`以在比较字符串时忽略空格和标点符号。将此属性设置为`true`后，例如，字符串“any one”和“anyone”将被视为相等。
- en: '`numeric`'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`numeric`'
- en: Set this property to `true` if the strings you are comparing are integers or
    contain integers and you want them to be sorted into numerical order instead of
    alphabetical order. With this option set, the string “Version 9” will be sorted
    before “Version 10”, for example.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要比较的字符串是整数或包含整数，并且希望它们按数字顺序而不是按字母顺序排序，请将此属性设置为`true`。设置此选项后，例如，字符串“Version
    9”将在“Version 10”之前排序。
- en: '`caseFirst`'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`caseFirst`'
- en: This property specifies which letter case should come first. If you specify
    `"upper"`, then “A” will sort before “a”. And if you specify `"lower"`, then “a”
    will sort before “A”. In either case, note that the upper- and lowercase variants
    of the same letter will be next to one another in sort order, which is different
    than Unicode lexicographic ordering (the default behavior of the Array `sort()`
    method) in which all ASCII uppercase letters come before all ASCII lowercase letters.
    The default for this property is locale dependent, and implementations may ignore
    this property and not allow you to override the case sort order.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指定哪种大小写应该优先。如果指定为`"upper"`，则“A”将在“a”之前排序。如果指定为`"lower"`，则“a”将在“A”之前排序。无论哪种情况，请注意相同字母的大写和小写变体将按顺序排列在一起，这与Unicode词典排序（数组`sort()`方法的默认行为）不同，在该排序中，所有ASCII大写字母都排在所有ASCII小写字母之前。此属性的默认值取决于区域设置，并且实现可能会忽略此属性并不允许您覆盖大小写排序顺序。
- en: Once you have created an Intl.Collator object for the desired locale and options,
    you can use its `compare()` method to compare two strings. This method returns
    a number. If the returned value is less than zero, then the first string comes
    before the second string. If it is greater than zero, then the first string comes
    after the second string. And if `compare()` returns zero, then the two strings
    are equal as far as this collator is concerned.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦为所需区域设置和选项创建了Intl.Collator对象，就可以使用其`compare()`方法比较两个字符串。此方法返回一个数字。如果返回值小于零，则第一个字符串在第二个字符串之前。如果大于零，则第一个字符串在第二个字符串之后。如果`compare()`返回零，则这两个字符串在此排序器的意义上相等。
- en: 'This `compare()` method that takes two strings and returns a number less than,
    equal to, or greater than zero is exactly what the Array `sort()` method expects
    for its optional argument. Also, Intl.Collator automatically binds the `compare()`
    method to its instance, so you can pass it directly to `sort()` without having
    to write a wrapper function and invoke it through the collator object. Here are
    some examples:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 此接受两个字符串并返回小于、等于或大于零的数字的`compare()`方法正是数组`sort()`方法期望的可选参数。此外，Intl.Collator会自动将`compare()`方法绑定到其实例，因此可以直接将其传递给`sort()`，而无需编写包装函数并通过排序器对象调用它。以下是一些示例：
- en: '[PRE80]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Some locales have more than one possible collation order. In Germany, for example,
    phone books use a slightly more phonetic sort order than dictionaries do. In Spain,
    before 1994, “ch” and “ll” were treated as separate letters, so that country now
    has a modern sort order and a traditional sort order. And in China, collation
    order can be based on character encodings, the base radical and strokes of each
    character, or on the Pinyin romanization of characters. These collation variants
    cannot be selected through the Intl.Collator options argument, but they can be
    selected by adding `-u-co-` to the locale string and adding the name of the desired
    variant. Use `"de-DE-u-co-phonebk"` for phone book ordering in Germany, for example,
    and `"zh-TW-u-co-pinyin"` for Pinyin ordering in Taiwan.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 一些地区有多种可能的排序顺序。例如，在德国，电话簿使用的排序顺序比字典稍微更加语音化。在西班牙，在 1994 年之前，“ch” 和 “ll” 被视为单独的字母，因此该国现在有现代排序顺序和传统排序顺序。在中国，排序顺序可以基于字符编码、每个字符的基本部首和笔画，或者基于字符的拼音罗马化。这些排序变体不能通过
    Intl.Collator 选项参数进行选择，但可以通过在区域设置字符串中添加 `-u-co-` 并添加所需变体的名称来选择。例如，在德国使用 `"de-DE-u-co-phonebk"`
    进行电话簿排序，在台湾使用 `"zh-TW-u-co-pinyin"` 进行拼音排序。
- en: '[PRE81]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 11.8 The Console API
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.8 控制台 API
- en: 'You’ve seen the `console.log()` function used throughout this book: in web
    browsers, it prints a string in the “Console” tab of the browser’s developer tools
    pane, which can be very helpful when debugging. In Node, `console.log()` is a
    general-purpose output function and prints its arguments to the process’s stdout
    stream, where it typically appears to the user in a terminal window as program
    output.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中看到了 `console.log()` 函数的使用：在网页浏览器中，它会在浏览器的开发者工具窗格的“控制台”选项卡中打印一个字符串，这在调试时非常有帮助。在
    Node 中，`console.log()` 是一个通用输出函数，将其参数打印到进程的 stdout 流中，在终端窗口中通常会显示给用户作为程序输出。
- en: The Console API defines a number of useful functions in addition to `console.log()`.
    The API is not part of any ECMAScript standard, but it is supported by browsers
    and by Node and has been formally written up and standardized at [*https://console.spec.whatwg.org*](https://console.spec.whatwg.org).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 API 除了 `console.log()` 外还定义了许多有用的函数。该 API 不是任何 ECMAScript 标准的一部分，但受到浏览器和
    Node 的支持，并已经正式编写和标准化在 [*https://console.spec.whatwg.org*](https://console.spec.whatwg.org)。
- en: 'The Console API defines the following functions:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台 API 定义了以下函数：
- en: '`console.log()`'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log()`'
- en: This is the most well-known of the console functions. It converts its arguments
    to strings and outputs them to the console. It includes spaces between the arguments
    and starts a new line after outputting all arguments.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 这是控制台函数中最为人熟知的。它将其参数转换为字符串并将它们输出到控制台。它在参数之间包含空格，并在输出所有参数后开始新的一行。
- en: '`console.debug()`, `console.info()`, `console.warn()`, `console.error()`'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.debug()`, `console.info()`, `console.warn()`, `console.error()`'
- en: These functions are almost identical to `console.log()`. In Node, `console.error()`
    sends its output to the stderr stream rather than the stdout stream, but the other
    functions are aliases of `console.log()`. In browsers, output messages generated
    by each of these functions may be prefixed by an icon that indicates its level
    or severity, and the developer console may also allow developers to filter console
    messages by level.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数几乎与 `console.log()` 完全相同。在 Node 中，`console.error()` 将其输出发送到 stderr 流而不是
    stdout 流，但其他函数是 `console.log()` 的别名。在浏览器中，每个函数生成的输出消息可能会以指示其级别或严重性的图标为前缀，并且开发者控制台还可以允许开发者按级别过滤控制台消息。
- en: '`console.assert()`'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.assert()`'
- en: If the first argument is truthy (i.e., if the assertion passes), then this function
    does nothing. But if the first argument is `false` or another falsy value, then
    the remaining arguments are printed as if they had been passed to `console.error()`
    with an “Assertion failed” prefix. Note that, unlike typical `assert()` functions,
    `console.assert()` does not throw an exception when an assertion fails.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个参数为真值（即如果断言通过），则此函数不执行任何操作。但如果第一个参数为 `false` 或其他假值，则剩余的参数将被打印，就像它们已经被传递给带有“Assertion
    failed”前缀的 `console.error()` 一样。请注意，与典型的 `assert()` 函数不同，当断言失败时，`console.assert()`
    不会抛出异常。
- en: '`console.clear()`'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.clear()`'
- en: This function clears the console when that is possible. This works in browsers
    and in Node when Node is displaying its output to a terminal. If Node’s output
    has been redirected to a file or a pipe, however, then calling this function has
    no effect.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在可能的情况下清除控制台。这在浏览器和在 Node 将其输出显示到终端时有效。但是，如果 Node 的输出已被重定向到文件或管道，则调用此函数没有效果。
- en: '`console.table()`'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.table()`'
- en: This function is a remarkably powerful but little-known feature for producing
    tabular output, and it is particularly useful in Node programs that need to produce
    output that summarizes data. `console.table()` attempts to display its argument
    in tabular form (although, if it can’t do that, it displays it using regular `console.log()`
    formatting). This works best when the argument is a relatively short array of
    objects, and all of the objects in the array have the same (relatively small)
    set of properties. In this case, each object in the array is formatted as a row
    of the table, and each property is a column of the table. You can also pass an
    array of property names as an optional second argument to specify the desired
    set of columns. If you pass an object instead of an array of objects, then the
    output will be a table with one column for property names and one column for property
    values. Or, if those property values are themselves objects, their property names
    will become columns in the table.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是一个非常强大但鲜为人知的功能，用于生成表格输出，特别适用于需要总结数据的Node程序。`console.table()`尝试以表格形式显示其参数（尽管如果无法做到这一点，它会使用常规的`console.log()`格式）。当参数是一个相对较短的对象数组，并且数组中的所有对象具有相同（相对较小）的属性集时，这种方法效果最佳。在这种情况下，数组中的每个对象被格式化为表格的一行，每个属性是表格的一列。您还可以将属性名称数组作为可选的第二个参数传递，以指定所需的列集。如果传递的是对象而不是对象数组，则输出将是一个具有属性名称列和属性值列的表格。或者，如果这些属性值本身是对象，则它们的属性名称将成为表格中的列。
- en: '`console.trace()`'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.trace()`'
- en: This function logs its arguments like `console.log()` does, and, in addition,
    follows its output with a stack trace. In Node, the output goes to stderr instead
    of stdout.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数像`console.log()`一样记录其参数，并且在输出后跟随一个堆栈跟踪。在Node中，输出会发送到stderr而不是stdout。
- en: '`console.count()`'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.count()`'
- en: This function takes a string argument and logs that string, followed by the
    number of times it has been called with that string. This can be useful when debugging
    an event handler, for example, if you need to keep track of how many times the
    event handler has been triggered.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串参数，并记录该字符串，然后记录调用该字符串的次数。在调试事件处理程序时，这可能很有用，例如，如果需要跟踪事件处理程序被触发的次数。
- en: '`console.countReset()`'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.countReset()`'
- en: This function takes a string argument and resets the counter for that string.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串参数，并重置该字符串的计数器。
- en: '`console.group()`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.group()`'
- en: This function prints its arguments to the console as if they had been passed
    to `console.log()`, then sets the internal state of the console so that all subsequent
    console messages (until the next `console.groupEnd()` call) will be indented relative
    to the message that it just printed. This allows a group of related messages to
    be visually grouped with indentation. In web browsers, the developer console typically
    allows grouped messages to be collapsed and expanded as a group. The arguments
    to `console.group()` are typically used to provide an explanatory name for the
    group.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将其参���打印到控制台，就像它们已被传递给`console.log()`一样，然后设置控制台的内部状态，以便所有后续的控制台消息（直到下一个`console.groupEnd()`调用）将相对于刚刚打印的消息进行缩进。这允许将一组相关消息视觉上分组并缩进。在Web浏览器中，开发者控制台通常允许将分组消息折叠和展开为一组。`console.group()`的参数通常用于为组提供解释性名称。
- en: '`console.groupCollapsed()`'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.groupCollapsed()`'
- en: This function works like `console.group()` except that in web browsers, the
    group will be “collapsed” by default and the messages it contains will be hidden
    unless the user clicks to expand the group. In Node, this function is a synonym
    for `console.group()`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与`console.group()`类似，但在Web浏览器中，默认情况下，该组将“折叠”，并且它包含的消息将被隐藏，除非用户点击以展开该组。在Node中，此函数是`console.group()`的同义词。
- en: '`console.groupEnd()`'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.groupEnd()`'
- en: This function takes no arguments. It produces no output of its own but ends
    the indentation and grouping caused by the most recent call to `console.group()`
    or `console.groupCollapsed()`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不接受任何参数。它不产生自己的输出，但结束了由最近调用的`console.group()`或`console.groupCollapsed()`引起的缩进和分组。
- en: '`console.time()`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.time()`'
- en: This function takes a single string argument, makes a note of the time it was
    called with that string, and produces no output.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串参数，记录调用该字符串的时间，并不产生输出。
- en: '`console.timeLog()`'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.timeLog()`'
- en: This function takes a string as its first argument. If that string had previously
    been passed to `console.time()`, then it prints that string followed by the elapsed
    time since the `console.time()` call. If there are any additional arguments to
    `console.timeLog()`, they are printed as if they had been passed to `console.log()`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将一个字符串作为其第一个参数。如果该字符串之前已传递给`console.time()`，则打印该字符串，然后是自`console.time()`调用以来经过的时间。如果`console.timeLog()`有任何额外的参数，它们将被打印，就像它们已被传递给`console.log()`一样。
- en: '`console.timeEnd()`'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.timeEnd()`'
- en: This function takes a single string argument. If that argument had previously
    been passed to `console.time()`, then it prints that argument and the elapsed
    time. After calling `console.timeEnd()`, it is no longer legal to call `console.timeLog()`
    without first calling `console.time()` again.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个字符串参数。如果之前已将该参数传递给`console.time()`，则打印该参数和经过的时间。在调用`console.timeEnd()`之后，再次调用`console.timeLog()`而不先调用`console.time()`是不合法的。
- en: 11.8.1 Formatted Output with Console
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8.1 使用控制台进行格式化输出
- en: 'Console functions that print their arguments like `console.log()` have a little-known
    feature: if the first argument is a string that includes `%s`, `%i`, `%d`, `%f`,
    `%o`, `%O`, or `%c`, then this first argument is treated as format string,^([6](ch11.xhtml#idm46198523009064))
    and the values of subsequent arguments are substituted into the string in place
    of the two-character `%` sequences.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 类似`console.log()`打印其参数的控制台函数有一个鲜为人知的功能：如果第一个参数是包含`%s`、`%i`、`%d`、`%f`、`%o`、`%O`或`%c`的字符串，则此第一个参数将被视为格式字符串，^([6](ch11.xhtml#idm46198523009064))，并且后续参数的值将替换两个字符`%`序列的位置。
- en: 'The meanings of the sequences are as follows:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 序列的含义如下：
- en: '`%s`'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s`'
- en: The argument is converted to a string.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 参数被转换为字符串。
- en: '`%i` and `%d`'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`%i` 和 `%d`'
- en: The argument is converted to a number and then truncated to an integer.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 参数被转换为数字，然后截断为整数。
- en: '`%f`'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`%f`'
- en: The argument is converted to a number
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 参数被转换为数字
- en: '`%o` and `%O`'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`%o` 和 `%O`'
- en: The argument is treated as an object, and property names and values are displayed.
    (In web browsers, this display is typically interactive, and users can expand
    and collapse properties to explore a nested data structure.) `%o` and `%O` both
    display object details. The uppercase variant uses an implementation-dependent
    output format that is judged to be most useful for software developers.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 参数被视为对象，并显示属性名称和值。（在 Web 浏览器中，此显示通常是交互式的，用户可以展开和折叠属性以探索嵌套的数据结构。）`%o` 和 `%O`
    都显示对象的详细信息。大写变体使用一个依赖于实现的输出格式，被认为对软件开发人员最有用。
- en: '`%c`'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`%c`'
- en: In web browsers, the argument is interpreted as a string of CSS styles and used
    to style any text that follows (until the next `%c` sequence or the end of the
    string). In Node, the `%c` sequence and its corresponding argument are simply
    ignored.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 浏览器中，参数被解释为一串 CSS 样式，并用于为接下来的任何文本设置样式（直到下一个 `%c` 序列或字符串结束）。在 Node 中，`%c`
    序列及其对应的参数会被简单地忽略。
- en: 'Note that it is not often necessary to use a format string with the console
    functions: it is usually easy to obtain suitable output by simply passing one
    or more values (including objects) to the function and allowing the implementation
    to display them in a useful way. As an example, note that, if you pass an Error
    object to `console.log()`, it is automatically printed along with its stack trace.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常不需要在控制台函数中使用格式字符串：通常只需将一个或多个值（包括对象）传递给函数，让实现以有用的方式显示它们即可。例如，请注意，如果将 Error
    对象传递给 `console.log()`，它将自动打印出其堆栈跟踪。
- en: 11.9 URL APIs
  id: totrans-548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.9 URL API
- en: Since JavaScript is so commonly used in web browsers and web servers, it is
    common for JavaScript code to need to manipulate URLs. The URL class parses URLs
    and also allows modification (adding search parameters or altering paths, for
    example) of existing URLs. It also properly handles the complicated topic of escaping
    and unescaping the various components of a URL.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 在 Web 浏览器和 Web 服务器中被广泛使用，JavaScript 代码通常需要操作 URL。URL 类解析 URL 并允许修改（例如添加搜索参数或更改路径）现有的
    URL。它还正确处理了 URL 的各个组件的转义和解码这一复杂主题。
- en: The URL class is not part of any ECMAScript standard, but it works in Node and
    all internet browsers other than Internet Explorer. It is standardized at [*https://url.spec.whatwg.org*](https://url.spec.whatwg.org).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: URL 类不是任何 ECMAScript 标准的一部分，但它在 Node 和除了 Internet Explorer 之外的所有互联网浏览器中都可以使用。它在
    [*https://url.spec.whatwg.org*](https://url.spec.whatwg.org) 上标准化。
- en: 'Create a URL object with the `URL()` constructor, passing an absolute URL string
    as the argument. Or pass a relative URL as the first argument and the absolute
    URL that it is relative to as the second argument. Once you have created the URL
    object, its various properties allow you to query unescaped versions of the various
    parts of the URL:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `URL()` 构造函数创建一个 URL 对象，将绝对 URL 字符串作为参数传递。或者将相对 URL 作为第一个参数传递，将其相对的绝对 URL
    作为第二个参数传递。一旦创建了 URL 对象，它的各种属性允许您查询 URL 的各个部分的未转义版本：
- en: '[PRE82]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Although it is not commonly used, URLs can include a username or a username
    and password, and the URL class can parse these URL components, too:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不常用，URL 可以包含用户名或用户名和密码，URL 类也可以解析这些 URL 组件：
- en: '[PRE83]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `origin` property here is a simple combination of the URL protocol and
    host (including the port if one is specified). As such, it is a read-only property.
    But each of the other properties demonstrated in the previous example is read/write:
    you can set any of these properties to set the corresponding part of the URL:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `origin` 属性是 URL 协议和主机（包括指定的端口）的简单组合。因此，它是一个只读属性。但前面示例中演示的每个其他属性都是读/写的：您可以设置这些属性中的任何一个来设置
    URL 的相应部分：
- en: '[PRE84]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'One of the important features of the URL class is that it correctly adds punctuation
    and escapes special characters in URLs when that is needed:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: URL 类的一个重要特性是在需要时正确添加标点符号并转义 URL 中的特殊字符：
- en: '[PRE85]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `href` property in these examples is a special one: reading `href` is equivalent
    to calling `toString()`: it reassembles all parts of the URL into the canonical
    string form of the URL. And setting `href` to a new string reruns the URL parser
    on the new string as if you had called the `URL()` constructor again.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的 `href` 属性是一个特殊的属性：读取 `href` 等同于调用 `toString()`：它将 URL 的所有部分重新组合成 URL
    的规范字符串形式。将 `href` 设置为新字符串会重新运行 URL 解析器，就好像再次调用 `URL()` 构造函数一样。
- en: In the previous examples, we’ve been using the `search` property to refer to
    the entire query portion of a URL, which consists of the characters from a question
    mark to the end of the URL or to the first hash character. Sometimes, it is sufficient
    to just treat this as a single URL property. Often, however, HTTP requests encode
    the values of multiple form fields or multiple API parameters into the query portion
    of a URL using the `application/x-www-form-urlencoded` format. In this format,
    the query portion of the URL is a question mark followed by one or more name/value
    pairs, which are separated from one another by ampersands. The same name can appear
    more than once, resulting in a named search parameter with more than one value.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们一直使用 `search` 属性来引用 URL 的整个查询部分，该部分由问号到 URL 结尾��第一个井号字符组成。有时，将其视为单个
    URL 属性就足够了。然而，HTTP 请求通常使用 `application/x-www-form-urlencoded` 格式将多个表单字段或多个 API
    参数的值编码到 URL 的查询部分中。在此格式中，URL 的查询部分是一个问号，后面跟着一个或多个名称/值对，它们之间用和号分隔。同一个名称可以出现多次，导致具有多个值的命名搜索参数。
- en: 'If you want to encode these kinds of name/value pairs into the query portion
    of a URL, then the `searchParams` property will be more useful than the `search`
    property. The `search` property is a read/write string that lets you get and set
    the entire query portion of the URL. The `searchParams` property is a read-only
    reference to a URLSearchParams object, which has an API for getting, setting,
    adding, deleting, and sorting the parameters encoded into the query portion of
    the URL:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将这些名称/值对编码到URL的查询部分中，那么`searchParams`属性比`search`属性更有用。`search`属性是一个可读/写的字符串，允许你获取和设置URL的整个查询部分。`searchParams`属性是一个只读引用，指向一个URLSearchParams对象，该对象具有用于获取、设置、添加、删除和排序编码到URL查询部分的参数的API：
- en: '[PRE86]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The value of the `searchParams` property is a URLSearchParams object. If you
    want to encode URL parameters into a query string, you can create a URLSearchParams
    object, append parameters, then convert it to a string and set it on the `search`
    property of a URL:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`searchParams`属性的值是一个URLSearchParams对象。如果你想将URL参数编码到查询字符串中，可以创建一个URLSearchParams对象，追加参数，然后将其转换为字符串并设置在URL的`search`属性上：'
- en: '[PRE87]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 11.9.1 Legacy URL Functions
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.9.1 传统URL函数
- en: Prior to the definition of the URL API described previously, there have been
    multiple attempts to support URL escaping and unescaping in the core JavaScript
    language. The first attempt was the globally defined `escape()` and `unescape()`
    functions, which are now deprecated but still widely implemented. They should
    not be used.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前描述的URL API定义之前，已经有多次尝试在核心JavaScript语言中支持URL转义和解码。第一次尝试是全局定义的`escape()`和`unescape()`函数，现在已经被弃用，但仍然被广泛实现。不应该使用它们。
- en: 'When `escape()` and `unescape()` were deprecated, ECMAScript introduced two
    pairs of alternative global functions:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当`escape()`和`unescape()`被弃用时，ECMAScript引入了两对替代的全局函数：
- en: '`encodeURI()` and `decodeURI()`'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURI()`和`decodeURI()`'
- en: '`encodeURI()` takes a string as its argument and returns a new string in which
    non-ASCII characters plus certain ASCII characters (such as space) are escaped.
    `decodeURI()` reverses the process. Characters that need to be escaped are first
    converted to their UTF-8 encoding, then each byte of that encoding is replaced
    with a `%`*xx* escape sequence, where *xx* is two hexadecimal digits. Because
    `encodeURI()` is intended for encoding entire URLs, it does not escape URL separator
    characters such as `/`, `?`, and `#`. But this means that `encodeURI()` cannot
    work correctly for URLs that have those characters within their various components.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURI()`以字符串作为参数，返回一个新字符串，其中非ASCII字符和某些ASCII字符（如空格）被转义。`decodeURI()`则相反。需要转义的字符首先被转换为它们的UTF-8编码，然后该编码的每个字节被替换为一个`%`*xx*转义序列，其中*xx*是两个十六进制数字。因为`encodeURI()`旨在对整个URL进行编码，它不会转义URL分隔符字符，如`/`、`?`和`#`。但这意味着`encodeURI()`无法正确处理URL中包含这些字符的各个组件的URL。'
- en: '`encodeURIComponent()` and `decodeURIComponent()`'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`encodeURIComponent()`和`decodeURIComponent()`'
- en: This pair of functions works just like `encodeURI()` and `decodeURI()` except
    that they are intended to escape individual components of a URI, so they also
    escape characters like `/`, `?`, and `#` that are used to separate those components.
    These are the most useful of the legacy URL functions, but be aware that `encodeURIComponent()`
    will escape `/` characters in a path name that you probably do not want escaped.
    And it will convert spaces in a query parameter to `%20`, even though spaces are
    supposed to be escaped with a `+` in that portion of a URL.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这一对函数的工作方式与`encodeURI()`和`decodeURI()`完全相同，只是它们旨在转义URI的各个组件，因此它们还会转义用于分隔这些组件的字符，如`/`、`?`和`#`。这些是传统URL函数中最有用的，但请注意，`encodeURIComponent()`会转义路径名中的`/`字符，这可能不是你想要的。它还会将查询参数中的空格转换为`%20`，尽管在URL的这部分中应该用`+`转义空格。
- en: The fundamental problem with all of these legacy functions is that they seek
    to apply a single encoding scheme to all parts of a URL when the fact is that
    different portions of a URL use different encodings. If you want a properly formatted
    and encoded URL, the solution is simply to use the URL class for all URL manipulation
    you do.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些传统函数的根本问题在于，它们试图对URL的所有部分应用单一的编码方案，而事实上URL的不同部分使用不同的编码。如果你想要一个格式正确且编码正确的URL，解决方案就是简单地使用URL类来进行所有的URL操作。
- en: 11.10 Timers
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.10 定时器
- en: Since the earliest days of JavaScript, web browsers have defined two functions—`setTimeout()`
    and `setInterval()`—that allow programs to ask the browser to invoke a function
    after a specified amount of time has elapsed or to invoke the function repeatedly
    at a specified interval. These functions have never been standardized as part
    of the core language, but they work in all browsers and in Node and are a de facto
    part of the JavaScript standard library.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 自JavaScript诞生以来，Web浏览器就定义了两个函数——`setTimeout()`和`setInterval()`——允许程序要求浏览器在指定的时间过去后调用一个函数，或者在指定的时间间隔内重复调用函数。这些函数从未作为核心语言的一部分标准化，但它们在所有浏览器和Node中都有效，并且是JavaScript标准库的事实部分。
- en: 'The first argument to `setTimeout()` is a function, and the second argument
    is a number that specifies how many milliseconds should elapse before the function
    is invoked. After the specified amount of time (and maybe a little longer if the
    system is busy), the function will be invoked with no arguments. Here, for example,
    are three `setTimeout()` calls that print console messages after one second, two
    seconds, and three seconds:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`的第一个参数是一个函数，第二个参数是一个数字，指定在调用函数之前应该经过多少毫秒。在指定的时间过去后（如果系统繁忙可能会稍长一些），函数将被调用，不带任何参数。这里，例如，是三个`setTimeout()`调用，分别在一秒、两秒和三秒后打印控制台消息：'
- en: '[PRE88]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that `setTimeout()` does not wait for the time to elapse before returning.
    All three lines of code in this example run almost instantly, but then nothing
    happens until 1,000 milliseconds elapse.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`setTimeout()`在返回之前不会等待时间过去。这个示例中的三行代码几乎立即运行，但在经过1,000毫秒后才会发生任何事情。
- en: If you omit the second argument to `setTimeout()`, it defaults to 0\. That does
    not mean, however, that the function you specify is invoked immediately. Instead,
    the function is registered to be called “as soon as possible.” If a browser is
    particularly busy handling user input or other events, it may take 10 milliseconds
    or more before the function is invoked.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`setTimeout()`的第二个参数，则默认为0。然而，这并不意味着您指定的函数会立即被调用。相反，该函数被注册为“尽快”调用。如果浏览器忙于处理用户输入或其他事件，可能需要10毫秒或更长时间才能调用该函数。
- en: '`setTimeout()` registers a function to be invoked once. Sometimes, that function
    will itself call `setTimeout()` to schedule another invocation at a future time.
    If you want to invoke a function repeatedly, however, it is often simpler to use
    `setInterval()`. `setInterval()` takes the same two arguments as `setTimeout()`
    but invokes the function repeatedly every time the specified number of milliseconds
    (approximately) have elapsed.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`注册一个函数，该函数将在一次调用后被调用。有时，该函数本身会调用`setTimeout()`以安排在将来的某个时间再次调用。然而，如果要重复调用一个函数，通常更简单的方法是使用`setInterval()`。`setInterval()`接受与`setTimeout()`相同的两个参数，但每当指定的毫秒数（大约）过去时，它会重复调用函数。'
- en: Both `setTimeout()` and `setInterval()` return a value. If you save this value
    in a variable, you can then use it later to cancel the execution of the function
    by passing it to `clearTimeout()` or `clearInterval()`. The returned value is
    typically a number in web browsers and is an object in Node. The actual type doesn’t
    matter, and you should treat it as an opaque value. The only thing you can do
    with this value is pass it to `clearTimeout()` to cancel the execution of a function
    registered with `setTimeout()` (assuming it hasn’t been invoked yet) or to stop
    the repeating execution of a function registered with `setInterval()`.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`和`setInterval()`都会返回一个值。如果将此值保存在变量中，您随后可以使用它通过传递给`clearTimeout()`或`clearInterval()`来取消函数的执行。返回的值在Web浏览器中通常是一个数字，在Node中是一个对象。实际类型并不重要，您应该将其视为不透明值。您可以使用此值的唯一操作是将其传递给`clearTimeout()`以取消使用`setTimeout()`注册的函数的执行（假设尚未调用）或停止使用`setInterval()`注册的函数的重复执行。'
- en: 'Here is an example that demonstrates the use of `setTimeout()`, `setInterval()`,
    and `clearInterval()` to display a simple digital clock with the Console API:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，演示了如何使用`setTimeout()`、`setInterval()`和`clearInterval()`来显示一个简单的数字时钟与Console
    API：
- en: '[PRE89]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We’ll see `setTimeout()` and `setInterval()` again when we cover asynchronous
    programming in [Chapter 13](ch13.xhtml#async).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论异步编程时，我们将再次看到`setTimeout()`和`setInterval()`，详见[第13章](ch13.xhtml#async)。
- en: 11.11 Summary
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.11 总结
- en: 'Learning a programming language is not just about mastering the grammar. It
    is equally important to study the standard library so that you are familiar with
    all the tools that are shipped with the language. This chapter has documented
    JavaScript’s standard library, which includes:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 学习一门编程语言不仅仅是掌握语法。同样重要的是研究标准库，以便熟悉语言附带的所有工具。本章记录了JavaScript的标准库，其中包括：
- en: Important data structures, such as Set, Map, and typed arrays.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的数据结构，如Set、Map和类型化数组。
- en: The Date and URL classes for working with dates and URLs.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于处理日期和URL的Date和URL类。
- en: JavaScript’s regular expression grammar and its RegExp class for textual pattern
    matching.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的正则表达式语法及其用于文本模式匹配的RegExp类。
- en: JavaScript’s internationalization library for formatting dates, time, and numbers
    and for sorting strings.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的国际化库，用于格式化日期、时间和数字以及对字符串进行排序。
- en: The `JSON` object for serializing and deserializing simple data structures and
    the `console` object for logging messages.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于序列化和反序列化简单数据结构的`JSON`对象和用于记录消息的`console`对象。
- en: '^([1](ch11.xhtml#idm46198529052360-marker)) Not everything documented here
    is defined by the JavaScript language specification: some of the classes and functions
    documented here were first implemented in web browsers and then adopted by Node,
    making them de facto members of the JavaScript standard library.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#idm46198529052360-marker)) 这里记录的并非JavaScript语言规范定义的所有内容：这里记录的一些类和函数首先是在Web浏览器中实现的，然后被Node采用，使它们成为JavaScript标准库的事实成员。
- en: ^([2](ch11.xhtml#idm46198528676184-marker)) This predictable iteration order
    is another thing about JavaScript sets that Python programmers may find surprising.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.xhtml#idm46198528676184-marker)) 这种可预测的迭代顺序是JavaScript集合中的另一件事，可能会让Python程序员感到惊讶。
- en: ^([3](ch11.xhtml#idm46198527893912-marker)) Typed arrays were first introduced
    to client-side JavaScript when web browsers added support for WebGL graphics.
    What is new in ES6 is that they have been elevated to a core language feature.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.xhtml#idm46198527893912-marker)) 当Web浏览器添加对WebGL图形的支持时，类型化数组首次引入到客户端JavaScript中。ES6中的新功能是它们已被提升为核心语言特性。
- en: ^([4](ch11.xhtml#idm46198526281256-marker)) Except within a character class
    (square brackets), where `\b` matches the backspace character.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.xhtml#idm46198526281256-marker)) 除了在字符类（方括号）内部，`\b`匹配退格字符。
- en: ^([5](ch11.xhtml#idm46198525964472-marker)) Parsing URLs with regular expressions
    is not a good idea. See [§11.9](#urlapi) for a more robust URL parser.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch11.xhtml#idm46198525964472-marker)) 使用正则表达式解析URL并不是一个好主意。请参见[§11.9](#urlapi)以获取更健壮的URL解析器。
- en: ^([6](ch11.xhtml#idm46198523009064-marker)) C programmers will recognize many
    of these character sequences from the `printf()` function.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch11.xhtml#idm46198523009064-marker)) C程序员将从`printf()`函数中认出许多这些字符序列。
