- en: Chapter 13\. Asynchronous JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 异步JavaScript
- en: 'Some computer programs, such as scientific simulations and machine learning
    models, are compute-bound: they run continuously, without pause, until they have
    computed their result. Most real-world computer programs, however, are significantly
    *asynchronous*. This means that they often have to stop computing while waiting
    for data to arrive or for some event to occur. JavaScript programs in a web browser
    are typically *event-driven*, meaning that they wait for the user to click or
    tap before they actually do anything. And JavaScript-based servers typically wait
    for client requests to arrive over the network before they do anything.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一些计算机程序，如科学模拟和机器学习模型，是计算密集型的：它们持续运行，不间断，直到计算出结果为止。然而，大多数现实世界的计算机程序都是显著*异步*的。这意味着它们经常需要在等待数据到达或某个事件发生时停止计算。在Web浏览器中，JavaScript程序通常是*事件驱动*的，这意味着它们等待用户点击或轻触才会实际执行任何操作。而基于JavaScript的服务器通常在等待客户端请求通过网络到达之前不会执行任何操作。
- en: This kind of asynchronous programming is commonplace in JavaScript, and this
    chapter documents three important language features that help make it easier to
    work with asynchronous code. Promises, new in ES6, are objects that represent
    the not-yet-available result of an asynchronous operation. The keywords `async`
    and `await` were introduced in ES2017 and provide new syntax that simplifies asynchronous
    programming by allowing you to structure your Promise-based code as if it was
    synchronous. Finally, asynchronous iterators and the `for/await` loop were introduced
    in ES2018 and allow you to work with streams of asynchronous events using simple
    loops that appear synchronous.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步编程在JavaScript中很常见，本章记录了三个重要的语言特性，帮助简化处理异步代码。Promise是ES6中引入的对象，表示尚未可用的异步操作的结果。关键字`async`和`await`是在ES2017中引入的，通过允许你将基于Promise的代码结构化为同步的形式，简化了异步编程的语法。最后，在ES2018中引入了异步迭代器和`for/await`循环，允许你使用看似同步的简单循环处理异步事件流。
- en: Ironically, even though JavaScript provides these powerful features for working
    with asynchronous code, there are no features of the core language that are themselves
    asynchronous. In order to demonstrate Promises, `async`, `await`, and `for/await`,
    therefore, we will first take a detour into client-side and server-side JavaScript
    to explain some of the asynchronous features of web browsers and Node. (You can
    learn more about client-side and server-side JavaScript in Chapters [15](ch15.xhtml#clientside)
    and [16](ch16.xhtml#serverside).)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，尽管JavaScript提供了这些强大的功能来处理异步代码，但核心语���本身没有异步特性。因此，为了演示Promise、`async`、`await`和`for/await`，我们将首先进入客户端和服务器端JavaScript，解释Web浏览器和Node的一些异步特性。（你可以在第[15](ch15.xhtml#clientside)章和第[16](ch16.xhtml#serverside)章了解更多关于客户端和服务器端JavaScript的内容。）
- en: 13.1 Asynchronous Programming with Callbacks
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.1 使用回调进行异步编程
- en: At its most fundamental level, asynchronous programming in JavaScript is done
    with *callbacks*. A callback is a function that you write and then pass to some
    other function. That other function then invokes (“calls back”) your function
    when some condition is met or some (asynchronous) event occurs. The invocation
    of the callback function you provide notifies you of the condition or event, and
    sometimes, the invocation will include function arguments that provide additional
    details. This is easier to understand with some concrete examples, and the subsections
    that follow demonstrate various forms of callback-based asynchronous programming
    using both client-side JavaScript and Node.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，异步编程的最基本层次是通过*回调*完成的。回调是你编写并传递给其他函数的函数。当满足某些条件或发生某些（异步）事件时，另一个函数会调用（“回调”）你的函数。你提供的回调函数的调用会通知你条件或事件，并有时，调用会包括提供额外细节的函数参数。通过一些具体的例子更容易理解，接下来的小节演示了使用客户端JavaScript和Node进行基于回调的异步编程的各种形式。
- en: 13.1.1 Timers
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.1 定时器
- en: 'One of the simplest kinds of asynchrony is when you want to run some code after
    a certain amount of time has elapsed. As we saw in [§11.10](ch11.xhtml#timerapi),
    you can do this with the `setTimeout()` function:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的异步之一是当你想在一定时间后运行一些代码时。正如我们在[§11.10](ch11.xhtml#timerapi)中看到的，你可以使用`setTimeout()`函数来实现：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first argument to `setTimeout()` is a function and the second is a time
    interval measured in milliseconds. In the preceding code, a hypothetical `checkForUpdates()`
    function will be called 60,000 milliseconds (1 minute) after the `setTimeout()`
    call. `checkForUpdates()` is a callback function that your program might define,
    and `setTimeout()` is the function that you invoke to register your callback function
    and specify under what asynchronous conditions it should be invoked.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`的第一个参数是一个函数，第二个是以毫秒为单位的时间间隔。在上述代码中，一个假设的`checkForUpdates()`函数将在`setTimeout()`调用后的60,000毫秒（1分钟）后被调用。`checkForUpdates()`是你的程序可能定义的回调函数，`setTimeout()`是你调用以注册回调函数并指定在何种异步条件下调用它的函数。'
- en: '`setTimeout()` calls the specified callback function one time, passing no arguments,
    and then forgets about it. If you are writing a function that really does check
    for updates, you probably want it to run repeatedly. You can do this by using
    `setInterval()` instead of `setTimeout()`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`调用指定的回调函数一次，不传递任何参数，然后忘记它。如果你正在编写一个真正检查更新的函数，你可能希望它重复运行。你可以使用`setInterval()`而不是`setTimeout()`来实现这一点：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 13.1.2 Events
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.2 事件
- en: 'Client-side JavaScript programs are almost universally event driven: rather
    than running some kind of predetermined computation, they typically wait for the
    user to do something and then respond to the user’s actions. The web browser generates
    an *event* when the user presses a key on the keyboard, moves the mouse, clicks
    a mouse button, or touches a touchscreen device. Event-driven JavaScript programs
    register callback functions for specified types of events in specified contexts,
    and the web browser invokes those functions whenever the specified events occur.
    These callback functions are called *event handlers* or *event listeners*, and
    they are registered with `addEventListener()`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 JavaScript 程序几乎普遍是事件驱动的：而不是运行某种预定的计算，它们通常等待用户执行某些操作，然后响应用户的动作。当用户在键盘上按键、移动鼠标、点击鼠标按钮或触摸触摸屏设备时，Web
    浏览器会生成一个*事件*。事件驱动的 JavaScript 程序在指定的上下文中为指定类型的事件注册回调函数，当指定的事件发生时，Web 浏览器会调用这些函数。这些回调函数称为*事件处理程序*或*事件监听器*，并使用`addEventListener()`进行注册：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `applyUpdate()` is a hypothetical callback function that we
    assume is implemented somewhere else. The call to `document.querySelector()` returns
    an object that represents a single specified element in the web page. We call
    `addEventListener()` on that element to register our callback. Then the first
    argument to `addEventListener()` is a string that specifies the kind of event
    we’re interested in—a mouse click or touchscreen tap, in this case. If the user
    clicks or taps on that specific element of the web page, then the browser will
    invoke our `applyUpdate()` callback function, passing an object that includes
    details (such as the time and the mouse pointer coordinates) about the event.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`applyUpdate()`是一个我们假设在其他地方实现的虚构回调函数。调用`document.querySelector()`返回一个表示
    Web 页面中单个指定元素的对象。我们在该元素上调用`addEventListener()`来注册我们的回调。然后`addEventListener()`的第一个参数是一个字符串，指定我们感兴趣的事件类型——在这种情况下是鼠标点击或触摸屏点击。如果用户点击或触摸
    Web 页面的特定元素，那么浏览器将调用我们的`applyUpdate()`回调函数，传递一个包含有关事件的详细信息（如时间和鼠标指针坐标）的对象。
- en: 13.1.3 Network Events
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.3 网络事件
- en: 'Another common source of asynchrony in JavaScript programming is network requests.
    JavaScript running in the browser can fetch data from a web server with code like
    this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 编程中另一个常见的异步来源是网络请求。在浏览器中运行的 JavaScript 可以使用以下代码从 Web 服务器获取数据：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Client-side JavaScript code can use the XMLHttpRequest class plus callback functions
    to make HTTP requests and asynchronously handle the server’s response when it
    arrives.^([1](ch13.xhtml#idm46198519434968)) The `getCurrentVersionNumber()` function
    defined here (we can imagine that it is used by the hypothetical `checkForUpdates()`
    function we discussed in [§13.1.1](#async-timers)) makes an HTTP request and defines
    event handlers that will be invoked when the server’s response is received or
    when a timeout or other error causes the request to fail.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 JavaScript 代码可以使用 XMLHttpRequest 类加上回调函数来进行 HTTP 请求，并在服务器响应到达时异步处理。^([1](ch13.xhtml#idm46198519434968))
    这里定义的`getCurrentVersionNumber()`函数（我们可以想象它被假设的`checkForUpdates()`函数使用，我们在[§13.1.1](#async-timers)中讨论过）发出
    HTTP 请求，并定义在接收到服务器响应或超时或其他错误导致请求失败时将被调用的事件处理程序。
- en: Notice that the code example above does not call `addEventListener()` as our
    previous example did. For most web APIs (including this one), event handlers can
    be defined by invoking `addEventListener()` on the object generating the event
    and passing the name of the event of interest along with the callback function.
    Typically, though, you can also register a single event listener by assigning
    it directly to a property of the object. That is what we do in this example code,
    assigning functions to the `onload`, `onerror`, and `ontimeout` properties. By
    convention, event listener properties like these always have names that begin
    with *on*. `addEventListener()` is the more flexible technique because it allows
    for multiple event handlers. But in cases where you are sure that no other code
    will need to register a listener for the same object and event type, it can be
    simpler to simply set the appropriate property to your callback.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的代码示例不���我们之前的示例那样调用`addEventListener()`。对于大多数 Web API（包括此示例），可以通过在生成事件的对象上调用`addEventListener()`并传递感兴趣的事件名称以及回调函数来定义事件处理程序。通常，您也可以通过将其直接分配给对象的属性来注册单个事件监听器。这就是我们在这个示例代码中所做的，将函数分配给`onload`、`onerror`和`ontimeout`属性。按照惯例，像这样的事件监听器属性总是以*on*开头的名称。`addEventListener()`是更灵活的技术，因为它允许注册多个事件处理程序。但在确保没有其他代码需要为相同的对象和事件类型注册监听器的情况下，直接将适当的属性设置为您的回调可能更简单。
- en: Another thing to note about the `getCurrentVersionNumber()` function in this
    example code is that, because it makes an asynchronous request, it cannot synchronously
    return the value (the current version number) that the caller is interested in.
    Instead, the caller passes a callback function, which is invoked when the result
    is ready or when an error occurs. In this case, the caller supplies a callback
    function that expects two arguments. If the XMLHttpRequest works correctly, then
    `getCurrentVersionNumber()` invokes the callback with a `null` first argument
    and the version number as the second argument. Or, if an error occurs, then `getCurrentVersionNumber()`
    invokes the callback with error details in the first argument and `null` as the
    second argument.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中关于`getCurrentVersionNumber()`函数的另一点需要注意的是，由于它发出了一个异步请求，它无法同步返回调用者感兴趣的值（当前版本号）。相反，调用者传递一个回调函数，当结果准备就绪或发生错误时调用。在这种情况下，调用者提供了一个期望两个参数的回调函数。如果
    XMLHttpRequest 正常工作，那么`getCurrentVersionNumber()`会用`null`作为第一个参数，版本号作为第二个参数调用回调。或者，如果发生错误，那么`getCurrentVersionNumber()`会用错误详细信息作为第一个参数，`null`作为第二个参数调用回调。
- en: 13.1.4 Callbacks and Events in Node
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1.4 Node 中的回调和事件
- en: 'The Node.js server-side JavaScript environment is deeply asynchronous and defines
    many APIs that use callbacks and events. The default API for reading the contents
    of a file, for example, is asynchronous and invokes a callback function when the
    contents of the file have been read:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 服务器端 JavaScript 环境是深度异步的，并定义了许多使用回调和事件的 API。例如，读取文件内容的默认 API 是异步的，并在文件内容被读取后调用回调函数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Node’s `fs.readFile()` function takes a two-parameter callback as its last argument.
    It reads the specified file asynchronously and then invokes the callback. If the
    file was read successfully, it passes the file contents as the second callback
    argument. If there was an error, it passes the error as the first callback argument.
    In this example, we express the callback as an arrow function, which is a succinct
    and natural syntax for this kind of simple operation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的`fs.readFile()`函数将一个两参数回调作为其最后一个参数。它异步读取指定的文件，然后调用回调。如果文件成功读取，它将文件内容作为第二个回调参数传递。如果出现错误，它将错误作为第一个回调参数传递。在这个例子中，我们将回调表达为箭头函数，这是一种简洁和自然的语法，适用于这种简单操作。
- en: 'Node also defines a number of event-based APIs. The following function shows
    how to make an HTTP request for the contents of a URL in Node. It has two layers
    of asynchronous code handled with event listeners. Notice that Node uses an `on()`
    method to register event listeners instead of `addEventListener()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Node 还定义了许多基于事件的 API。以下函数展示了如何在 Node 中请求 URL 的内容。它有两层通过事件监听器处理的异步代码。请注意，Node
    使用`on()`方法来注册事件监听器，而不是`addEventListener()`：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 13.2 Promises
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.2 承诺
- en: Now that we’ve seen examples of callback and event-based asynchronous programming
    in client-side and server-side JavaScript environments, we can introduce *Promises*,
    a core language feature designed to simplify asynchronous programming.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在客户端和服务器端 JavaScript 环境中看到了回调和基于事件的异步编程的示例，我们可以介绍*承诺*，这是一个旨在简化异步编程的核心语言特性。
- en: 'A Promise is an object that represents the result of an asynchronous computation.
    That result may or may not be ready yet, and the Promise API is intentionally
    vague about this: there is no way to synchronously get the value of a Promise;
    you can only ask the Promise to call a callback function when the value is ready.
    If you are defining an asynchronous API like the `getText()` function in the previous
    section, but want to make it Promise-based, omit the callback argument, and instead
    return a Promise object. The caller can then register one or more callbacks on
    this Promise object, and they will be invoked when the asynchronous computation
    is done.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺是表示异步计算结果的对象。该结果可能已经准备好，也可能尚未准备好，承诺 API 故意对此保持模糊：没有同步获取承诺值的方法；您只能要求承诺在值准备好时调用回调函数。如果您正在定义一个类似前一节中的`getText()`函数的异步
    API，但希望将其基于承诺，省略回调参数，而是返回一个承诺对象。调用者可以在这个承诺对象上注册一个或多个回调，当异步计算完成时，它们将被调用。
- en: So, at the simplest level, Promises are just a different way of working with
    callbacks. However, there are practical benefits to using them. One real problem
    with callback-based asynchronous programming is that it is common to end up with
    callbacks inside callbacks inside callbacks, with lines of code so highly indented
    that it is difficult to read. Promises allow this kind of nested callback to be
    re-expressed as a more linear *Promise chain* that tends to be easier to read
    and easier to reason about.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在最简单的层面上，承诺只是一种与回调一起工作的不同方式。然而，使用它们有实际的好处。基于回调的异步编程的一个真正问题是，通常会出现回调内嵌在回调内嵌在回调中的情况，代码行缩进如此之深，以至于难以阅读。承诺允许将这种嵌套回调重新表达为更线性的*承诺链*，这样更容易阅读和推理。
- en: 'Another problem with callbacks is that they can make handling errors difficult.
    If an asynchronous function (or an asynchronously invoked callback) throws an
    exception, there is no way for that exception to propagate back to the initiator
    of the asynchronous operation. This is a fundamental fact about asynchronous programming:
    it breaks exception handling. The alternative is to meticulously track and propagate
    errors with callback arguments and return values, but this is tedious and difficult
    to get right. Promises help here by standardizing a way to handle errors and providing
    a way for errors to propagate correctly through a chain of promises.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数的另一个问题是，它们可能会使处理错误变得困难。如果异步函数（或异步调用的回调）抛出异常，那么这个异常就无法传播回异步操作的发起者。这是关于异步编程的一个基本事实：它破坏了异常处理。另一种方法是通过回调参数和返回值来细致地跟踪和传播错误，但这样做很繁琐，很难做到正确。承诺在这里有所帮助，通过标准化处理错误的方式，并提供一种让错误正确传播通过一系列承诺的方法。
- en: Note that Promises represent the future results of single asynchronous computations.
    They cannot be used to represent repeated asynchronous computations, however.
    Later in this chapter, we’ll write a Promise-based alternative to the `setTimeout()`
    function, for example. But we can’t use Promises to replace `setInterval()` because
    that function invokes a callback function repeatedly, which is something that
    Promises are just not designed to do. Similarly, we could use a Promise instead
    of the “load” event handler of an XMLHttpRequest object, since that callback is
    only ever called once. But we typically would not use a Promise in place of a
    “click” event handler of an HTML button object, since we normally want to allow
    the user to click a button multiple times.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，承诺代表单个异步计算的未来结果。然而，它们不能用于表示重复的异步计算。在本章的后面，我们将编写一个基于承诺的`setTimeout()`函数的替代方案。但我们不能使用承诺来替代`setInterval()`，因为该函数会重复调用回调函数，而这是承诺设计上不支持的。同样地，我们可以使用承诺来替代
    XMLHttpRequest 对象的“load”事件处理程序，因为该回调只会被调用一次��但通常情况下，我们不会使用承诺来替代 HTML 按钮对象的“click”事件处理程序，因为我们通常希望允许用户多次点击按钮。
- en: 'The subsections that follow will:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节将：
- en: Explain Promise terminology and show basic Promise usage
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释承诺术语并展示基本承诺用法
- en: Show how promises can be chained
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示Promises如何被链式调用
- en: Demonstrate how to create your own Promise-based APIs
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示如何创建自己的基于Promise的API
- en: Important
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 重要
- en: Promises seem simple at first, and the basic use case for Promises is, in fact,
    straightforward and simple. But they can become surprisingly confusing for anything
    beyond the simplest use cases. Promises are a powerful idiom for asynchronous
    programming, but you need to understand them deeply to use them correctly and
    confidently. It is worth taking the time to develop that deep understanding, however,
    and I urge you to study this long chapter carefully.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，Promise似乎很简单，事实上，Promise的基本用例确实简单明了。但是，对于超出最简单用例的任何情况，它们可能变得令人惊讶地令人困惑。Promise是异步编程的强大习语，但你需要深入理解才能正确自信地使用它们。然而，花时间深入了解是值得的，我敦促你仔细研究这一长章节。
- en: 13.2.1 Using Promises
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.1 使用Promises
- en: 'With the advent of Promises in the core JavaScript language, web browsers have
    begun to implement Promise-based APIs. In the previous section, we implemented
    a `getText()` function that made an asynchronous HTTP request and passed the body
    of the HTTP response to a specified callback function as a string. Imagine a variant
    of this function, `getJSON()`, which parses the body of the HTTP response as JSON
    and returns a Promise instead of accepting a callback argument. We will implement
    a `getJSON()` function later in this chapter, but for now, let’s look at how we
    would use this Promise-returning utility function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Promises在核心JavaScript语言中的出现，Web浏览器已经开始实现基于Promise的API。在前一节中，我们实现了一个`getText()`函数，该函数发起了一个异步的HTTP请求，并将HTTP响应的主体作为字符串传递给指定的回调函数。想象一个这个函数的变体，`getJSON()`，它将HTTP响应的主体解析为JSON，并返回一个Promise，而不是接受一个回调参数。我们将在本章后面实现一个`getJSON()`函数，但现在，让我们看看如何使用这个返回Promise的实用函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`getJSON()` starts an asynchronous HTTP request for the URL you specify and
    then, while that request is pending, it returns a Promise object. The Promise
    object defines a `then()` instance method. Instead of passing our callback function
    directly to `getJSON()`, we instead pass it to the `then()` method. When the HTTP
    response arrives, the body of that response is parsed as JSON, and the resulting
    parsed value is passed to the function that we passed to `then()`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`getJSON()`启动一个异步的HTTP请求，请求指定的URL，然后，在该请求挂起期间，它返回一个Promise对象。Promise对象定义了一个`then()`实例方法。我们不直接将回调函数传递给`getJSON()`，而是将其传递给`then()`方法。当HTTP响应到达时，该响应的主体被解析为JSON，并将解析后的值传递给我们传递给`then()`的函数。'
- en: You can think of the `then()` method as a callback registration method like
    the `addEventListener()` method used for registering event handlers in client-side
    JavaScript. If you call the `then()` method of a Promise object multiple times,
    each of the functions you specify will be called when the promised computation
    is complete.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`then()`方法看作是一个回调注册方法，类似于用于在客户端JavaScript中注册事件处理程序的`addEventListener()`方法。如果多次调用Promise对象的`then()`方法，每个指定的函数都将在承诺的计算完成时被调用。
- en: Unlike many event listeners, though, a Promise represents a single computation,
    and each function registered with `then()` will be invoked only once. It is worth
    noting that the function you pass to `then()` is invoked asynchronously, even
    if the asynchronous computation is already complete when you call `then()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多事件侦听器不同，Promise代表一个单一的计算，每个注册到`then()`的函数只会被调用一次。值得注意的是，无论何时调用`then()`，你传递给`then()`的函数都会异步调用，即使异步计算在调用`then()`时已经完成。
- en: At a simple syntactical level, the `then()` method is the distinctive feature
    of Promises, and it is idiomatic to append `.then()` directly to the function
    invocation that returns the Promise, without the intermediate step of assigning
    the Promise object to a variable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的语法层面上，`then()`方法是Promise的独特特征，习惯上直接将`.then()`附加到返回Promise的函数调用上，而不是将Promise���象分配给变量的中间步骤。
- en: 'It is also idiomatic to name functions that return Promises and functions that
    use the results of Promises with verbs, and these idioms lead to code that is
    particularly easy to read:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯上，将返回Promises的函数和使用Promises结果的函数命名为动词，这些习惯导致的代码特别易于阅读：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Handling errors with Promises
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Promises处理错误
- en: Asynchronous operations, particularly those that involve networking, can typically
    fail in a number of ways, and robust code has to be written to handle the errors
    that will inevitably occur.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作，特别是涉及网络的操作，通常会以多种方式失败，必须编写健壮的代码来处理不可避免发生的错误。
- en: 'For Promises, we can do this by passing a second function to the `then()` method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Promises，我们可以通过将第二个函数传递给`then()`方法来实现：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A Promise represents the future result of an asynchronous computation that occurs
    after the Promise object is created. Because the computation is performed after
    the Promise object is returned to us, there is no way that the computation can
    traditionally return a value or throw an exception that we can catch. The functions
    that we pass to `then()` provide alternatives. When a synchronous computation
    completes normally, it simply returns its result to its caller. When a Promise-based
    asynchronous computation completes normally, it passes its result to the function
    that is the first argument to `then()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Promise代表在Promise对象创建后发生的异步计算的未来结果。因为计算是在Promise对象返回给我们后执行的，所以传统上计算无法返回一个值或抛出我们可以捕获的异常。我们传递给`then()`的函数提供了替代方案。当同步计算正常完成时，它只是将其结果返回给调用者。当基于Promise的异步计算正常完成时，它将其结果传递给作为`then()`的第一个参数的函数。
- en: When something goes wrong in a synchronous computation, it throws an exception
    that propagates up the call stack until there is a `catch` clause to handle it.
    When an asynchronous computation runs, its caller is no longer on the stack, so
    if something goes wrong, it is simply not possible to throw an exception back
    to the caller.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当同步计算出现问题时，它会抛出一个异常，该异常会向上传播到调用堆栈，直到有一个`catch`子句来处理它。当异步计算运行时，其调用者不再在堆栈上，因此如果出现问题，就不可能将异常抛回给调用者。
- en: Instead, Promise-based asynchronous computations pass the exception (typically
    as an Error object of some kind, though this is not required) to the second function
    passed to `then()`. So, in the code above, if `getJSON()` runs normally, it passes
    its result to `displayUserProfile()`. If there is an error (the user is not logged
    in, the server is down, the user’s internet connection dropped, the request timed
    out, etc.), then `getJSON()` passes an Error object to `handleProfileError()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，基于 Promise 的异步计算将异常（通常作为某种类型的 Error 对象，尽管这不是必需的）传递给`then()`的第二个函数。因此，在上面的代码中，如果`getJSON()`正常运行，它会将结果传递给`displayUserProfile()`。如果出现错误（用户未登录、服务器宕机、用户的互联网连接中断、请求超时等），那么`getJSON()`会将一个
    Error 对象传递给`handleProfileError()`。
- en: In practice, it is rare to see two functions passed to `then()`. There is a
    better and more idiomatic way of handling errors when working with Promises. To
    understand it, first consider what happens if `getJSON()` completes normally but
    an error occurs in `displayUserProfile()`. That callback function is invoked asynchronously
    when `getJSON()` returns, so it is also asynchronous and cannot meaningfully throw
    an exception (because there is no code on the call stack to handle it).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，很少看到两个函数传递给`then()`。在处理 Promise 时，有一种更好的、更符合习惯的处理错误的方式。要理解这一点，首先考虑一下如果`getJSON()`正常完成，但`displayUserProfile()`中出现错误会发生什么。当`getJSON()`返回时，回调函数会异步调用，因此它也是异步的，不能有意义地抛出异常（因为没有代码在调用堆栈上处理它）。
- en: 'The more idiomatic way to handle errors in this code looks like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中处理错误的更符合习惯的方式如下：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With this code, a normal result from `getJSON()` is still passed to `displayUserProfile()`,
    but any error in `getJSON()` or in `displayUserProfile()` (including any exceptions
    thrown by `displayUserProfile`) get passed to `handleProfileError()`. The `catch()`
    method is just a shorthand for calling `then()` with a `null` first argument and
    the specified error handler function as the second argument.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，`getJSON()`的正常结果仍然会传递给`displayUserProfile()`，但是`getJSON()`或`displayUserProfile()`中的任何错误（包括`displayUserProfile`抛出的任何异常）都会传递给`handleProfileError()`。`catch()`方法只是调用`then()`的一种简写形式，第一个参数为`null`，第二个参数为指定的错误处理函数。
- en: We’ll have more to say about `catch()` and this error-handling idiom when we
    discuss Promise chains in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论下一节的 Promise 链时，我们将会更多地谈到`catch()`和这种错误处理习惯。
- en: 13.2.2 Chaining Promises
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.2 链式 Promise
- en: 'One of the most important benefits of Promises is that they provide a natural
    way to express a sequence of asynchronous operations as a linear chain of `then()`
    method invocations, without having to nest each operation within the callback
    of the previous one. Here, for example, is a hypothetical Promise chain:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Promise 最重要的好处之一是它们提供了一种自然的方式来将一系列异步操作表达为`then()`方法调用的线性链，而无需将每个操作嵌套在前一个操作的回调中。例如，这里是一个假设的
    Promise 链：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code illustrates how a chain of Promises can make it easy to express a
    sequence of asynchronous operations. We’re not going to discuss this particular
    Promise chain at all, however. We will continue to explore the idea of using Promise
    chains to make HTTP requests, however.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码说明了一系列 Promise 如何简单地表达一系列异步操作的过程。然而，我们不会讨论这个特定的 Promise 链。不过，我们将继续探讨使用 Promise
    链进行 HTTP 请求的想法。
- en: 'Earlier in this chapter, we saw the XMLHttpRequest object used to make an HTTP
    request in JavaScript. That strangely named object has an old and awkward API,
    and it has largely been replaced by the newer, Promise-based Fetch API ([§15.11.1](ch15.xhtml#fetch)).
    In its simplest form, this new HTTP API is just the function `fetch()`. You pass
    it a URL, and it returns a Promise. That promise is fulfilled when the HTTP response
    begins to arrive and the HTTP status and headers are available:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们看到了在 JavaScript 中使用 XMLHttpRequest 对象进行 HTTP 请求。这个奇怪命名的对象具有一个古老且笨拙的
    API，它已经大部分被新的、基于 Promise 的 Fetch API（[§15.11.1](ch15.xhtml#fetch)）所取代。在其最简单的形式中，这个新的
    HTTP API 就是函数`fetch()`。你传递一个 URL 给它，它会返回一个 Promise。当 HTTP 响应开始到达并且 HTTP 状态和头部可用时，这个
    Promise 就会被实现：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the Promise returned by `fetch()` is fulfilled, it passes a Response object
    to the function you passed to its `then()` method. This response object gives
    you access to request status and headers, and it also defines methods like `text()`
    and `json()`, which give you access to the body of the response in text and JSON-parsed
    forms, respectively. But although the initial Promise is fulfilled, the body of
    the response may not yet have arrived. So these `text()` and `json()` methods
    for accessing the body of the response themselves return Promises. Here’s a naive
    way of using `fetch()` and the `response.json()` method to get the body of an
    HTTP response:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fetch()`返回的 Promise 被实现时，它会将一个 Response 对象传递给您传递给其`then()`方法的函数。这个响应对象让您可以访问请求状态和头部，并且还定义了像`text()`和`json()`这样的方法，分别以文本和
    JSON ��析形式访问响应主体。但是尽管初始 Promise 被实现，响应主体可能尚未到达。因此，用于访问响应主体的这些`text()`和`json()`方法本身返回
    Promise。以下是使用`fetch()`和`response.json()`方法获取 HTTP 响应主体的一种天真的方法：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a naive way to use Promises because we nested them, like callbacks,
    which defeats the purpose. The preferred idiom is to use Promises in a sequential
    chain with code like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种天真地使用 Promise 的方式，因为我们像回调一样嵌套它们，这违背了初衷。更好的习惯是使用 Promise 在一个顺序链中编写代码，就像这样：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s look at the method invocations in this code, ignoring the arguments that
    are passed to the methods:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这段代码中的方法调用，忽略传递给方法的参数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When more than one method is invoked in a single expression like this, we call
    it a *method chain*. We know that the `fetch()` function returns a Promise object,
    and we can see that the first `.then()` in this chain invokes a method on that
    returned Promise object. But there is a second `.then()` in the chain, which means
    that the first invocation of the `then()` method must itself return a Promise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个表达式中调用多个方法时，我们称之为*方法链*。我们知道`fetch()`函数返回一个Promise对象，我们可以看到这个链中的第一个`.then()`调用在返回的Promise对象上调用一个方法。但是链中还有第二个`.then()`，这意味着`then()`方法的第一次调用本身必须返回一个Promise。
- en: Sometimes, when an API is designed to use this kind of method chaining, there
    is just a single object, and each method of that object returns the object itself
    in order to facilitate chaining. That is not how Promises work, however. When
    we write a chain of `.then()` invocations, we are not registering multiple callbacks
    on a single Promise object. Instead, each invocation of the `then()` method returns
    a new Promise object. That new Promise object is not fulfilled until the function
    passed to `then()` is complete.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当设计API以使用这种方法链时，只有一个对象，并且该对象的每个方法都返回对象本身以便于链接。然而，这并不是Promise的工作方式。当我们编写一系列`.then()`调用时，我们并不是在单个Promise对象上注册多个回调。相反，`then()`方法的每次调用都会返回一个新的Promise对象。直到传递给`then()`的函数完成，新的Promise对象才会被实现。
- en: 'Let’s return to a simplified form of the original `fetch()` chain above. If
    we define the functions passed to the `then()` invocations elsewhere, we might
    refactor the code to look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上面原始`fetch()`链的简化形式。如果我们在其他地方定义传递给`then()`调用的函数，我们可以重构代码如下：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s walk through this code in detail:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论一下这段代码：
- en: On the first line, `fetch()` is invoked with a URL. It initiates an HTTP GET
    request for that URL and returns a Promise. We’ll call this HTTP request “task
    1” and we’ll call the Promise “promise 1”.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一行，使用一个URL调用`fetch()`。它为该URL发起一个HTTP GET请求并返回一个Promise。我们将这个HTTP请求称为“任务1”，将Promise称为“promise
    1”。
- en: On the second line, we invoke the `then()` method of promise 1, passing the
    `callback1` function that we want to be invoked when promise 1 is fulfilled. The
    `then()` method stores our callback somewhere, then returns a new Promise. We’ll
    call the new Promise returned at this step “promise 2”, and we’ll say that “task
    2” begins when `callback1` is invoked.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二行，我们调用promise 1的`then()`方法，传递我们希望在promise 1实现时调用的`callback1`函数。`then()`方法将我们的回调存储在某个地方，然后返回一个新的Promise。我们将在这一步返回的新Promise称为“promise
    2”，并且我们将说“任务2”在调用`callback1`时开始。
- en: On the third line, we invoke the `then()` method of promise 2, passing the `callback2`
    function we want invoked when promise 2 is fulfilled. This `then()` method remembers
    our callback and returns yet another Promise. We’ll say that “task 3” begins when
    `callback2` is invoked. We can call this latest Promise “promise 3”, but we don’t
    really need a name for it because we won’t be using it at all.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三行，我们调用promise 2的`then()`方法，传递我们希望在promise 2实现时调用的`callback2`函数。这个`then()`方法记住我们的回调并返回另一个Promise。我们将说“任务3”在调用`callback2`时开始。我们可以称这个最新的Promise为“promise
    3”，但实际上我们不需要为它命名，因为我们根本不会使用它。
- en: The previous three steps all happen synchronously when the expression is first
    executed. Now we have an asynchronous pause while the HTTP request initiated in
    step 1 is sent out across the internet.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前三个步骤都是在表达式首次执行时同步发生的。现在，在HTTP请求在步骤1中发出并通过互联网发送时，我们有一个异步暂停。
- en: Eventually, the HTTP response starts to arrive. The asynchronous part of the
    `fetch()` call wraps the HTTP status and headers in a Response object and fulfills
    promise 1 with that Response object as the value.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，HTTP响应开始到达。`fetch()`调用的异步部分将HTTP状态和标头包装在一个Response对象中，并使用该Response对象作为值来实现promise
    1。
- en: When promise 1 is fulfilled, its value (the Response object) is passed to our
    `callback1()` function, and task 2 begins. The job of this task, given a Response
    object as input, is to obtain the response body as a JSON object.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当promise 1被实现时，它的值（Response对象）被传递给我们的`callback1()`函数，任务2开始。这个任务的工作是，给定一个Response对象作为输入，获取响应主体作为JSON对象。
- en: Let’s assume that task 2 completes normally and is able to parse the body of
    the HTTP response to produce a JSON object. This JSON object is used to fulfill
    promise 2.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们假设任务2正常完成，并且能够解析HTTP响应的主体以生成一个JSON对象。这个JSON对象用于实现promise 2。
- en: The value that fulfills promise 2 becomes the input to task 3 when it is passed
    to the `callback2()` function. This third task now displays the data to the user
    in some unspecified way. When task 3 is complete (assuming it completes normally),
    then promise 3 will be fulfilled. But because we never did anything with promise
    3, nothing happens when that Promise settles, and the chain of asynchronous computation
    ends at this point.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现promise 2的值成为传递给`callback2()`函数时任务3的输入。当任务3完成（假设它正常完成）时，promise 3将被实现。但因为我们从未对promise
    3做任何操作，当该Promise完成时什么也不会发生，异步计算链在这一点结束。
- en: 13.2.3 Resolving Promises
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.3 解决Promise
- en: While explaining the URL-fetching Promise chain with the list in the last section,
    we talked about promises 1, 2, and 3\. But there is actually a fourth Promise
    object involved as well, and this brings us to our important discussion of what
    it means for a Promise to be “resolved.”
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中解释了与列表中的URL获取Promise链相关的内容时，我们谈到了promise 1、2和3。但实际上还涉及第四个Promise对象，这将引出我们对Promise“解决”意味着什么的重要讨论。
- en: Remember that `fetch()` returns a Promise object which, when fulfilled, passes
    a Response object to the callback function we register. This Response object has
    `.text()`, `.json()`, and other methods to request the body of the HTTP response
    in various forms. But since the body may not yet have arrived, these methods must
    return Promise objects. In the example we’ve been studying, “task 2” calls the
    `.json()` method and returns its value. This is the fourth Promise object, and
    it is the return value of the `callback1()` function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`fetch()`返回一个Promise对象，当实现时，将传递一个Response对象给我们注册的回调函数。这个Response对象有`.text()`、`.json()`和其他方法以各种形式请求HTTP响应的主体。但是由于主体可能尚未到达，这些方法必须返回Promise对象。在我们一直在研究的示例中，“任务2”调用`.json()`方法并返回其值。这是第四个Promise对象，也是`callback1()`函数的返回值。
- en: 'Let’s rewrite the URL-fetching code one more time in a verbose and nonidiomatic
    way that makes the callbacks and promises explicit:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次以冗长和非成语化的方式重写URL获取代码，使回调和Promises明确：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order for Promise chains to work usefully, the output of task 2 must become
    the input to task 3\. And in the example we’re considering here, the input to
    task 3 is the body of the URL that was fetched, parsed as a JSON object. But,
    as we’ve just discussed, the return value of callback `c1` is not a JSON object,
    but Promise `p4` for that JSON object. This seems like a contradiction, but it
    is not: when `p1` is fulfilled, `c1` is invoked, and task 2 begins. And when `p2`
    is fulfilled, `c2` is invoked, and task 3 begins. But just because task 2 begins
    when `c1` is invoked, it does not mean that task 2 must end when `c1` returns.
    Promises are about managing asynchronous tasks, after all, and if task 2 is asynchronous
    (which it is, in this case), then that task will not be complete by the time the
    callback returns.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Promise链有用地工作，任务2的输出必须成为任务3的输入。在我们正在考虑的示例中，任务3的输入是获取的URL主体，解析为JSON对象。但是，正如我们刚才讨论的，回调`c1`的返回值不是JSON对象，而是该JSON对象的Promise`p4`。这似乎是一个矛盾，但实际上不是：当`p1`被实现时，`c1`被调用，任务2开始。当`p2`被实现时，`c2`被调用，任务3开始。但是仅仅因为在调用`c1`时任务2开始，并不意味着任务2在`c1`返回时必须结束。毕竟，Promises是关于管理异步任务的，如果任务2是异步的（在这种情况下是），那么在回调返回时该任务将尚未完成。
- en: 'We are now ready to discuss the final detail that you need to understand to
    really master Promises. When you pass a callback `c` to the `then()` method, `then()`
    returns a Promise `p` and arranges to asynchronously invoke `c` at some later
    time. The callback performs some computation and returns a value `v`. When the
    callback returns, `p` is *resolved* with the value `v`. When a Promise is resolved
    with a value that is not itself a Promise, it is immediately fulfilled with that
    value. So if `c` returns a non-Promise, that return value becomes the value of
    `p`, `p` is fulfilled and we are done. But if the return value `v` is itself a
    Promise, then `p` is *resolved but not yet fulfilled*. At this stage, `p` cannot
    settle until the Promise `v` settles. If `v` is fulfilled, then `p` will be fulfilled
    to the same value. If `v` is rejected, then `p` will be rejected for the same
    reason. This is what the “resolved” state of a Promise means: the Promise has
    become associated with, or “locked onto,” another Promise. We don’t know yet whether
    `p` will be fulfilled or rejected, but our callback `c` no longer has any control
    over that. `p` is “resolved” in the sense that its fate now depends entirely on
    what happens to Promise `v`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备讨论您需要真正掌握Promises的最后一个细节。当您将回调`c`传递给`then()`方法时，`then()`返回一个Promise`p`并安排在稍后的某个时间异步调用`c`。回调执行一些计算并返回一个值`v`。当回调返回时，`p`被*解析*为值`v`。当一个Promise被解析为一个不是Promise的值时，它会立即被实现为该值。因此，如果`c`返回一个非Promise，那么返回值就成为`p`的值，`p`被实现，我们完成了。但是如果返回值`v`本身是一个Promise，那么`p`被*解析但尚未实现*。在这个阶段，`p`不能解决，直到Promise`v`解决。如果`v`被实现，那么`p`将被实现为相同的值。如果`v`被拒绝，那么`p`将因同样的原因被拒绝。这就是Promise“解析”状态的含义：Promise已经与另一个Promise关联或“锁定”。我们还不知道`p`是否会被实现或被拒绝，但是我们的回调`c`不再控制这一点。`p`“解析”意味着它的命运现在完全取决于Promise`v`的发生。
- en: Let’s bring this back to our URL-fetching example. When `c1` returns `p4`, `p2`
    is resolved. But being resolved is not the same as being fulfilled, so task 3
    does not begin yet. When the full body of the HTTP response becomes available,
    then the `.json()` method can parse it and use that parsed value to fulfill `p4`.
    When `p4` is fulfilled, `p2` is automatically fulfilled as well, with the same
    parsed JSON value. At this point, the parsed JSON object is passed to `c2`, and
    task 3 begins.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的URL获取示例。当`c1`返回`p4`时，`p2`被解析。但被解析并不意味着被实现，所以任务3还没有开始。当完整的HTTP响应主体可用时，`.json()`方法可以解析它并使用解析后的值来实现`p4`。当`p4`被实现时，`p2`也会自动被实现，具有相同的解析JSON值。此时，解析后的JSON对象被传递给`c2`，任务3开始。
- en: This can be one of the trickiest parts of JavaScript to understand, and you
    may need to read this section more than once. [Figure 13-1](#promise-chain-diagram)
    presents the process in visual form and may help clarify it for you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是JavaScript中最难理解的部分之一，您可能需要阅读本节不止一次。[图13-1](#promise-chain-diagram)以可视化形式呈现了这个过程，可能有助于为您澄清。
- en: '![js7e 1301](Images/js7e_1301.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1301](Images/js7e_1301.png)'
- en: Figure 13-1\. Fetching a URL with Promises
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图13-1\. 使用 Promises 获取 URL
- en: 13.2.4 More on Promises and Errors
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.4 更多关于Promises和错误
- en: Earlier in the chapter, we saw that you can pass a second callback function
    to the `.then()` method and that this second function will be invoked if the Promise
    is rejected. When that happens, the argument to this second callback function
    is a value—typically an Error object—that represents the reason for the rejection.
    We also learned that it is uncommon (and even unidiomatic) to pass two callbacks
    to a `.then()` method. Instead, Promise-related errors are typically handled by
    adding a `.catch()` method invocation to a Promise chain. Now that we have examined
    Promise chains, we can return to error handling and discuss it in more detail.
    To preface the discussion, I’d like to stress that careful error handling is really
    important when doing asynchronous programming. With synchronous code, if you leave
    out error-handling code, you’ll at least get an exception and a stack trace that
    you can use to figure out what is going wrong. With asynchronous code, unhandled
    exceptions will often go unreported, and errors can occur silently, making them
    much harder to debug. The good news is that the `.catch()` method makes it easy
    to handle errors when working with Promises.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们看到您可以将第二个回调函数传递给`.then()`方法，并且如果Promise被拒绝，则将调用此第二个函数。当发生这种情况时，传递给此第二个回调函数的参数是一个值—通常是代表拒绝原因的Error对象。我们还了解到，通过向Promise链中添加`.catch()`方法调用来处理Promise相关的错误是不常见的（甚至是不成文的）。现在我���已经检查了Promise链，我们可以回到错误处理并更详细地讨论它。在讨论之前，我想强调的是，在进行异步编程时，仔细处理错误非常重要。对于同步代码，如果您省略了错误处理代码，您至少会得到一个异常和堆栈跟踪，以便您可以找出出了什么问题。对于异步代码，未处理的异常通常不会被报告，错误可能会悄无声息地发生，使得调试变得更加困难。好消息是，`.catch()`方法使得在处理Promise时处理错误变得容易。
- en: The catch and finally methods
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: catch和finally方法
- en: 'The `.catch()` method of a Promise is simply a shorthand way to call `.then()`
    with `null` as the first argument and an error-handling callback as the second
    argument. Given any Promise `p` and a callback `c`, the following two lines are
    equivalent:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Promise的`.catch()`方法只是一种使用`null`作为第一个参数并将错误处理回调作为第二个参数调用`.then()`的简写方式。给定任何Promise`p`和回调`c`，以下两行是等效的：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `.catch()` shorthand is preferred because it is simpler and because the
    name matches the `catch` clause in a `try/catch` exception-handling statement.
    As we’ve discussed, normal exceptions don’t work with asynchronous code. The `.catch()`
    method of Promises is an alternative that does work for asynchronous code. When
    something goes wrong in synchronous code, we can speak of an exception “bubbling
    up the call stack” until it finds a `catch` block. With an asynchronous chain
    of Promises, the comparable metaphor might be of an error “trickling down the
    chain” until it finds a `.catch()` invocation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`.catch()`简写更受欢迎，因为它更简单，并且名称与`try/catch`异常处理语句中的`catch`子句匹配。正如我们讨论过的，普通异常在异步代码中不起作用。Promise的`.catch()`方法是一种适用于异步代码的替代方法。当同步代码出现问题时，我们可以说异常“沿着调用堆栈上升”直到找到`catch`块。对于Promise链的异步链，类似的隐喻可能是错误“沿着链路下滑”，直到找到`.catch()`调用。'
- en: In ES2018, Promise objects also define a `.finally()` method whose purpose is
    similar to the `finally` clause in a `try/catch/finally` statement. If you add
    a `.finally()` invocation to your Promise chain, then the callback you pass to
    `.finally()` will be invoked when the Promise you called it on settles. Your callback
    will be invoked if the Promise fulfills or rejects, and it will not be passed
    any arguments, so you can’t find out whether it fulfilled or rejected. But if
    you need to run some kind of cleanup code (such as closing open files or network
    connections) in either case, a `.finally()` callback is the ideal way to do that.
    Like `.then()` and `.catch()`, `.finally()` returns a new Promise object. The
    return value of a `.finally()` callback is generally ignored, and the Promise
    returned by `.finally()` will typically resolve or reject with the same value
    that the Promise that `.finally()` was invoked on resolves or rejects with. If
    a `.finally()` callback throws an exception, however, then the Promise returned
    by `.finally()` will reject with that value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2018中，Promise对象还定义了一个`.finally()`方法，其目的类似于`try/catch/finally`语句中的`finally`子句。如果您在Promise链中添加一个`.finally()`调用，那么您传递给`.finally()`的回调将在您调用它的Promise完成时被调用。如果Promise完成或拒绝，都会调用您的回调，并且不会传递任何参数，因此您无法找出它是完成还是拒绝。但是，如果您需要在任一情况下运行某种清理代码（例如关闭打开的文件或网络连接），则`.finally()`回调是执行此操作的理想方式。与`.then()`和`.catch()`一样，`.finally()`返回一个新的Promise对象。`.finally()`回调的返回值通常被忽略，而由`.finally()`返回的Promise通常将使用与调用`.finally()`的Promise解析或拒绝的相同值解析或拒绝。但是，如果`.finally()`回调引发异常，则由`.finally()`返回的Promise将以该值拒绝。
- en: 'The URL-fetching code that we studied in the previous sections did not do any
    error handling. Let’s correct that now with a more realistic version of the code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几节中学习的URL获取代码没有进行任何错误处理。现在让我们通过代码的更实际版本来纠正这一点：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s analyze this code by looking at what happens when things go wrong. We’ll
    use the naming scheme we used before: `p1` is the Promise returned by the `fetch()`
    call. `p2` is the Promise returned by the first `.then()` call, and `c1` is the
    callback that we pass to that `.then()` call. `p3` is the Promise returned by
    the second `.then()` call, and `c2` is the callback we pass to that call. Finally,
    `c3` is the callback that we pass to the `.catch()` call. (That call returns a
    Promise, but we don’t need to refer to it by name.)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析当事情出错时会发生什么来分析这段代码。我们将使用之前使用的命名方案：`p1`是`fetch()`调用返回的Promise。`p2`是第一个`.then()`调用返回的Promise，`c1`是我们传递给该`.then()`调用的回调。`p3`是第二个`.then()`调用返回的Promise，`c2`是我们传递给该调用的回调。最后，`c3`是我们传递给`.catch()`调用的回调。（该调用返回一个Promise，但我们不需要通过名称引用它。）
- en: The first thing that could fail is the `fetch()` request itself. If the network
    connection is down (or for some other reason an HTTP request cannot be made),
    then Promise `p1` will be rejected with a NetworkError object. We didn’t pass
    an error-handling callback function as the second argument to the `.then()` call,
    so `p2` rejects as well with the same NetworkError object. (If we had passed an
    error handler to that first `.then()` call, the error handler would be invoked,
    and if it returned normally, `p2` would be resolved and/or fulfilled with the
    return value from that handler.) Without a handler, though, `p2` is rejected,
    and then `p3` is rejected for the same reason. At this point, the `c3` error-handling
    callback is called, and the NetworkError-specific code within it runs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能失败的第一件事是 `fetch()` 请求本身。如果网络连接断开（或由于某种原因无法进行 HTTP 请求），那么 Promise `p1` 将被拒绝，并带有一个
    NetworkError 对象。我们没有将错误处理回调函数作为第二个参数传递给 `.then()` 调用，因此 `p2` 也将以相同的 NetworkError
    对象被拒绝。（如果我们向第一个 `.then()` 调用传递了错误处理程序，错误处理程序将被调用，如果它正常返回，`p2` 将被解析和/或完成，并带有该处理程序的返回值。）然而，没有处理程序，`p2`
    被拒绝，然后 `p3` 由于相同原因被拒绝。此时，`c3` 错误处理回调被调用，并其中的 NetworkError 特定代码运行。
- en: Another way our code could fail is if our HTTP request returns a 404 Not Found
    or another HTTP error. These are valid HTTP responses, so the `fetch()` call does
    not consider them errors. `fetch()` encapsulates a 404 Not Found in a Response
    object and fulfills `p1` with that object, causing `c1` to be invoked. Our code
    in `c1` checks the `ok` property of the Response object to detect that it has
    not received a normal HTTP response and handles that case by simply returning
    `null`. Because this return value is not a Promise, it fulfills `p2` right away,
    and `c2` is invoked with this value. Our code in `c2` explicitly checks for and
    handles falsy values by displaying a different result to the user. This is a case
    where we treat an abnormal condition as a nonerror and handle it without actually
    using an error handler.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码可能失败的另一种方式是，如果我们的 HTTP 请求返回 404 Not Found 或其他 HTTP 错误。这些是有效的 HTTP 响应，因此
    `fetch()` 调用不认为它们是错误。`fetch()` 将 404 Not Found 封装在一个 Response 对象中，并用该对象完成 `p1`，导致调用
    `c1`。我们在 `c1` 中的代码检查 Response 对象的 `ok` 属性，以检测是否收到了正常的 HTTP 响应，并通过简单返回 `null` 处理这种情况。因为这个返回值不是一个
    Promise，它立即完成 `p2`，并用这个值调用 `c2`。我们在 `c2` 中明确检查和处理 falsy 值，通过向用户显示不同的结果来处理这种情况。这是一个我们将异常条件视为非错误并在不使用错误处理程序的情况下处理它的案例。
- en: A more serious error occurs in `c1` if the we get a normal HTTP response code
    but the Content-Type header is not set appropriately. Our code expects a JSON-formatted
    response, so if the server is sending us HTML, XML, or plain text instead, we’re
    going to have a problem. `c1` includes code to check the Content-Type header.
    If the header is wrong, it treats this as a nonrecoverable problem and throws
    a TypeError. When a callback passed to `.then()` (or `.catch()`) throws a value,
    the Promise that was the return value of the `.then()` call is rejected with that
    thrown value. In this case, the code in `c1` that raises a TypeError causes `p2`
    to be rejected with that TypeError object. Since we did not specify an error handler
    for `p2`, `p3` will be rejected as well. `c2` will not be called, and the TypeError
    will be passed to `c3`, which has code to explicitly check for and handle this
    type of error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们得到一个正常的 HTTP 响应代码，但 Content-Type 头部未正确设置，`c1` 中会发生一个更严重的错误。我们的代码期望一个 JSON
    格式的响应，所以如果服务器发送给我们 HTML、XML 或纯文本，我们将会遇到问题。`c1` 包含了检查 Content-Type 头部的代码。如果头部错误，它将把这视为一个不可恢复的问题并抛出一个
    TypeError。当传递给 `.then()`（或 `.catch()`）的回调抛出一个值时，作为 `.then()` 调用的返回值的 Promise 将被拒绝，并带有该抛出的值。在这种情况下，引发
    TypeError 的 `c1` 中的代码导致 `p2` 被拒绝，并带有该 TypeError 对象。由于我们没有为 `p2` 指定错误处理程序，`p3`
    也将被拒绝。`c2` 将不会被调用，并且 TypeError 将传递给 `c3`，它具有明确检查和处理这种类型错误的代码。
- en: There are a couple of things worth noting about this code. First, notice that
    the error object thrown with a regular, synchronous `throw` statement ends up
    being handled asynchronously with a `.catch()` method invocation in a Promise
    chain. This should make it clear why this shorthand method is preferred over passing
    a second argument to `.then()`, and also why it is so idiomatic to end Promise
    chains with a `.catch()` call.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码有几点值得注意。首先，请注意，使用常规的同步 `throw` 语句抛出的错误对象最终会在 Promise 链中的 `.catch()` 方法调用中异步处理。这应该清楚地说明为什么这种简写方法优先于向
    `.then()` 传递第二个参数，并且为什么在 Promise 链末尾使用 `.catch()` 调用是如此习惯化的。
- en: 'Before we leave the topic of error handling, I want to point out that, although
    it is idiomatic to end every Promise chain with a `.catch()` to clean up (or at
    least log) any errors that occurred in the chain, it is also perfectly valid to
    use `.catch()` elsewhere in a Promise chain. If one of the stages in your Promise
    chain can fail with an error, and if the error is some kind of recoverable error
    that should not stop the rest of the chain from running, then you can insert a
    `.catch()` call in the chain, resulting in code that might look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开错误处理的话题之前，我想指出，虽然习惯于在每个 Promise 链的末尾使用 `.catch()` 来清理（或至少记录）链中发生的任何错误，但在
    Promise 链的其他地方使用 `.catch()` 也是完全有效的。如果你的 Promise 链中的某个阶段可能会因错误而失败，并且如果错误是某种可恢复的错误，不应该阻止链的其余部分运行，那么你可以在链中插入一个
    `.catch()` 调用，代码可能看起来像这样：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that the callback you pass to `.catch()` will only be invoked if the
    callback at a previous stage throws an error. If the callback returns normally,
    then the `.catch()` callback will be skipped, and the return value of the previous
    callback will become the input to the next `.then()` callback. Also remember that
    `.catch()` callbacks are not just for reporting errors, but for handling and recovering
    from errors. Once an error has been passed to a `.catch()` callback, it stops
    propagating down the Promise chain. A `.catch()` callback can throw a new error,
    but if it returns normally, than that return value is used to resolve and/or fulfill
    the associated Promise, and the error stops propagating.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您传递给 `.catch()` 的回调只有在前一个阶段的回调抛出错误时才会被调用。如果回调正常返回，那么 `.catch()` 回调将被跳过，并且前一个回调的返回值将成为下一个
    `.then()` 回调的输入。还要记住，`.catch()` 回调不仅用于报告错误，还用于处理和恢复错误。一旦错误传递给 `.catch()` 回调，它就会停止在
    Promise 链中传播。`.catch()` 回调可以抛出新错误，但如果它正常返回，那么返回值将用于解析和/或实现相关的 Promise，并且错误将停止传播。
- en: 'Let’s be concrete about this: in the preceding code example, if either `startAsyncOperation()`
    or `doStageTwo()` throws an error, then the `recoverFromStageTwoError()` function
    will be invoked. If `recoverFromStageTwoError()` returns normally, then its return
    value will be passed to `doStageThree()` and the asynchronous operation continues
    normally. On the other hand, if `recoverFromStageTwoError()` was unable to recover,
    it will itself throw an error (or it will rethrow the error that it was passed).
    In this case, neither `doStageThree()` nor `doStageFour()` will be invoked, and
    the error thrown by `recoverFromStageTwoError()` would be passed to `logStageThreeAndFourErrors()`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体说明一下：在前面的代码示例中，如果 `startAsyncOperation()` 或 `doStageTwo()` 抛出错误，则将调用 `recoverFromStageTwoError()`
    函数。如果 `recoverFromStageTwoError()` 正常返回，则其返回值将传递给 `doStageThree()`，异步操作将继续正常进行。另一方面，如果
    `recoverFromStageTwoError()` 无法恢复，则它将抛出错误（或重新抛出传递给它的错误）。在这种情况下，`doStageThree()`
    和 `doStageFour()` 都不会被调用，并且由 `recoverFromStageTwoError()` 抛��的错误将传递给 `logStageThreeAndFourErrors()`。
- en: 'Sometimes, in complex network environments, errors can occur more or less at
    random, and it can be appropriate to handle those errors by simply retrying the
    asynchronous request. Imagine you’ve written a Promise-based operation to query
    a database:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在复杂的网络环境中，错误可能更多或更少地随机发生，通过简单地重试异步请求来处理这些错误可能是合适的。想象一下，您已经编写了一个基于 Promise
    的操作来查询数据库：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now suppose that transient network load issues are causing this to fail about
    1% of the time. A simple solution might be to retry the query with a `.catch()`
    call:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设瞬时网络负载问题导致失败率约为 1%。一个简单的解决方案可能是使用 `.catch()` 调用重试查询：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the hypothetical failures are truly random, then adding this one line of
    code should reduce your error rate from 1% to .01%.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果假设的故障确实是随机的，那么添加这一行代码应该将您的错误率从 1% 降低到 0.01%。
- en: 13.2.5 Promises in Parallel
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.5 并行的 Promises
- en: 'We’ve spent a lot of time talking about Promise chains for sequentially running
    the asynchronous steps of a larger asynchronous operation. Sometimes, though,
    we want to execute a number of asynchronous operations in parallel. The function
    `Promise.all()` can do this. `Promise.all()` takes an array of Promise objects
    as its input and returns a Promise. The returned Promise will be rejected if any
    of the input Promises are rejected. Otherwise, it will be fulfilled with an array
    of the fulfillment values of each of the input Promises. So, for example, if you
    want to fetch the text content of multiple URLs, you could use code like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间讨论 Promise 链，用于顺序运行更大异步操作的异步步骤。但有时，我们希望并行执行多个异步操作。函数 `Promise.all()`
    可以做到这一点。`Promise.all()` 接受一个 Promise 对象数组作为输入，并返回一个 Promise。如果任何输入 Promise 被拒绝，则返回的
    Promise 将被拒绝。否则，它将以每个输入 Promise 的实现值数组实现。因此，例如，如果您想获取多个 URL 的文本内容，您可以使用以下代码：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Promise.all()` is slightly more flexible than described before. The input
    array can contain both Promise objects and non-Promise values. If an element of
    the array is not a Promise, it is treated as if it is the value of an already
    fulfilled Promise and is simply copied unchanged into the output array.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()` 稍微比之前描述的更灵活。输入数组可以包含 Promise 对象和非 Promise 值。如果数组的元素不是 Promise，则会被视为已实现
    Promise 的值，并且会被简单地复制到输出数组中。'
- en: 'The Promise returned by `Promise.all()` rejects when any of the input Promises
    is rejected. This happens immediately upon the first rejection and can happen
    while other input Promises are still pending. In ES2020, `Promise.allSettled()`
    takes an array of input Promises and returns a Promise, just like `Promise.all()`
    does. But `Promise.allSettled()` never rejects the returned Promise, and it does
    not fulfill that Promise until all of the input Promises have settled. The Promise
    resolves to an array of objects, with one object for each input Promise. Each
    of these returned objects has a `status` property set to “fulfilled” or “rejected.”
    If the status is “fulfilled”, then the object will also have a `value` property
    that gives the fulfillment value. And if the status is “rejected”, then the object
    will also have a `reason` property that gives the error or rejection value of
    the corresponding Promise:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()` 返回的 Promise 在任何输入 Promise 被拒绝时也会被拒绝。这会立即发生在第一个拒绝时，而其他输入 Promise
    仍在等待的情况下也可能发生。在 ES2020 中，`Promise.allSettled()` 接受一个输入 Promise 数组并返回一个 Promise，就像
    `Promise.all()` 一样。但是 `Promise.allSettled()` 永远不会拒绝返回的 Promise，并且在所有输入 Promise
    都已完成之前不会实现该 Promise。该 Promise 解析为一个对象数组，每个输入 Promise 都有一个对象。每个返回的对象都有一个 `status`
    属性，设置为“fulfilled”或“rejected”。如果状态是“fulfilled”，那么对象还将有一个 `value` 属性，给出实现值。如果状态是“rejected”，那么对象还将有一个
    `reason` 属性，给出相应 Promise 的错误或拒绝值：'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Occasionally, you may want to run a number of Promises at once but may only
    care about the value of the first one to fulfill. In that case, you can use `Promise.race()`
    instead of `Promise.all()`. It returns a Promise that is fulfilled or rejected
    when the first of the Promises in the input array is fulfilled or rejected. (Or,
    if there are any non-Promise values in the input array, it simply returns the
    first of those.)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望同时运行多个 Promise，但可能只关心第一个实现的值。在这种情况下，您可以使用`Promise.race()`而不是`Promise.all()`。它返回一个
    Promise，当输入数组中的 Promise 中的第一个实现或拒绝时，该 Promise 将实现或拒绝。（或者，如果输入数组中有任何非 Promise 值，则简单地返回其中的第一个。）
- en: 13.2.6 Making Promises
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.6 创建 Promises
- en: We’ve used the Promise-returning function `fetch()` in many of the previous
    examples because it is one of the simplest functions built in to web browsers
    that returns a Promise. Our discussion of Promises has also relied on hypothetical
    Promise-returning functions `getJSON()` and `wait()`. Functions written to return
    Promises really are quite useful, and this section shows how you can create your
    own Promise-based APIs. In particular, we’ll show implementations of `getJSON()`
    and `wait()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多先前的示例中，我们使用了返回 Promise 的函数`fetch()`，因为它是内置到 Web 浏览器中的最简单的返回 Promise 的函数之一。我们对
    Promises 的讨论还依赖于假设的返回 Promise 的函数`getJSON()`和`wait()`。编写返回 Promises 的函数确实非常有用，本节展示了如何创建基于
    Promise 的 API。特别是，我们将展示`getJSON()`和`wait()`的实现。
- en: Promises based on other Promises
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于其他 Promises 的 Promises
- en: 'It is easy to write a function that returns a Promise if you have some other
    Promise-returning function to start with. Given a Promise, you can always create
    (and return) a new one by calling `.then()`. So if we use the existing `fetch()`
    function as a starting point, we can write `getJSON()` like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有其他返回 Promise 的函数作为起点，编写返回 Promise 的函数就很容易。给定一个 Promise，您可以通过调用`.then()`来创建（并返回）一个新的
    Promise。因此，如果我们使用现有的`fetch()`函数作为起点，我们可以这样编写`getJSON()`：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The code is trivial because the Response object of the `fetch()` API has a predefined
    `json()` method. The `json()` method returns a Promise, which we return from our
    callback (the callback is an arrow function with a single-expression body, so
    the return is implicit), so the Promise returned by `getJSON()` resolves to the
    Promise returned by `response.json()`. When that Promise fulfills, the Promise
    returned by `getJSON()` fulfills to the same value. Note that there is no error
    handling in this `getJSON()` implementation. Instead of checking `response.ok`
    and the Content-Type header, we instead just allow the `json()` method to reject
    the Promise it returned with a SyntaxError if the response body cannot be parsed
    as JSON.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单，因为`fetch()`API的 Response 对象具有预定义的`json()`方法。`json()`方法返回一个 Promise，我们从回调中返回该
    Promise（回调是一个带有单表达式主体的箭头函数，因此返回是隐式的），因此`getJSON()`返回的 Promise 解析为`response.json()`返回的
    Promise。当该 Promise 实现时，由`getJSON()`返回的 Promise 也实现为相同的值。请注意，此`getJSON()`实现中没有错误处理。我们不检查`response.ok`和
    Content-Type 头，而是允许`json()`方法拒绝返回的 Promise，如果响应主体无法解析为 JSON，则会引发 SyntaxError。
- en: 'Let’s write another Promise-returning function, this time using `getJSON()`
    as the source of the initial Promise:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个返回 Promise 的函数，这次使用`getJSON()`作为初始 Promise 的来源。
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We’re assuming that this function is part of some sort of web-based game and
    that the URL “/api/user/profile” returns a JSON-formatted data structure that
    includes a `highScore` property.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设这个函数是某种基于 Web 的游戏的一部分，并且 URL“/api/user/profile”返回一个包含`highScore`属性的 JSON
    格式数据结构。
- en: Promises based on synchronous values
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于同步值的 Promises
- en: 'Sometimes, you may need to implement an existing Promise-based API and return
    a Promise from a function, even though the computation to be performed does not
    actually require any asynchronous operations. In that case, the static methods
    `Promise.resolve()` and `Promise.reject()` will do what you want. `Promise.resolve()`
    takes a value as its single argument and returns a Promise that will immediately
    (but asynchronously) be fulfilled to that value. Similarly, `Promise.reject()`
    takes a single argument and returns a Promise that will be rejected with that
    value as the reason. (To be clear: the Promises returned by these static methods
    are not already fulfilled or rejected when they are returned, but they will fulfill
    or reject immediately after the current synchronous chunk of code has finished
    running. Typically, this happens within a few milliseconds unless there are many
    pending asynchronous tasks waiting to run.)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要实现现有的基于 Promise 的 API，并从函数返回一个 Promise，即使要��行的计算实际上不需要任何异步操作。在这种情况下，静态方法`Promise.resolve()`和`Promise.reject()`将实现您想要的效果。`Promise.resolve()`以其单个参数作为值，并返回一个将立即（但异步地）实现为该值的
    Promise。类似地，`Promise.reject()`接受一个参数，并返回一个将以该值为原因拒绝的 Promise。（要明确：这些静态方法返回的 Promises
    在返回时并未已实现或已拒绝，但它们将在当前同步代码块运行完毕后立即实现或拒绝。通常，除非有许多待处理的异步任务等待运行，否则这将在几毫秒内发生。）
- en: Recall from [§13.2.3](#async-resolving-promises) that a resolved Promise is
    not the same thing as a fulfilled Promise. When we call `Promise.resolve()`, we
    typically pass the fulfillment value to create a Promise object that will very
    soon fulfill to that value. The method is not named `Promise.fulfill()`, however.
    If you pass a Promise `p1` to `Promise.resolve()`, it will return a new Promise
    `p2`, which is immediately resolved, but which will not be fulfilled or rejected
    until `p1` is fulfilled or rejected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾[§13.2.3](#async-resolving-promises)中的内容，已解决的 Promise 与已实现的 Promise 不是同一回事。当我们调用`Promise.resolve()`时，通常会传递实现值以创建一个
    Promise 对象，该对象将很快实现为该值。但是该方法的名称不是`Promise.fulfill()`。如果将 Promise`p1`传递给`Promise.resolve()`，它将返回一个新的
    Promise`p2`，该 Promise 立即解决，但直到`p1`实现或拒绝之前，它才会实现或拒绝。
- en: It is possible, but unusual, to write a Promise-based function where the value
    is computed synchronously and returned asynchronously with `Promise.resolve()`.
    It is fairly common, however, to have synchronous special cases within an asynchronous
    function, and you can handle these special cases with `Promise.resolve()` and
    `Promise.reject()`. In particular, if you detect error conditions (such as bad
    argument values) before beginning an asynchronous operation, you can report that
    error by returning a Promise created with `Promise.reject()`. (You could also
    just throw an error synchronously in that case, but that is considered poor form
    because then the caller of your function needs to write both a synchronous `catch`
    clause and use an asynchronous `.catch()` method to handle errors.) Finally, `Promise.resolve()`
    is sometimes useful to create the initial Promise in a chain of Promises. We’ll
    see a couple of examples that use it this way.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写一个基于Promise的函数，其中值是同步计算的，并使用`Promise.resolve()`异步返回，尽管这种情况可能不太常见。然而，在异步函数中有同步特殊情况是相当常见的，你可以使用`Promise.resolve()`和`Promise.reject()`来处理这些特殊情况。特别是，如果在开始异步操作之前检测到错误条件（例如错误的参数值），你可以通过返回使用`Promise.reject()`创建的Promise来报告该错误。（在这种情况下，你也可以同步抛出错误，但这被认为是不好的做法，因为调用者需要同时编写同步的`catch`子句和使用异步的`.catch()`方法来处理错误。）最后，`Promise.resolve()`有时用于在Promise链中创建初始Promise。我们将看到一些以这种方式使用它的示例。
- en: Promises from scratch
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从头开始的Promises
- en: 'For both `getJSON()` and `getHighScore()`, we started off by calling an existing
    function to get an initial Promise, and created and returned a new Promise by
    calling the `.then()` method of that initial Promise. But what about writing a
    Promise-returning function when you can’t use another Promise-returning function
    as the starting point? In that case, you use the `Promise()` constructor to create
    a new Promise object that you have complete control over. Here’s how it works:
    you invoke the `Promise()` constructor and pass a function as its only argument.
    The function you pass should be written to expect two parameters, which, by convention,
    should be named `resolve` and `reject`. The constructor synchronously calls your
    function with function arguments for the `resolve` and `reject` parameters. After
    calling your function, the `Promise()` constructor returns the newly created Promise.
    That returned Promise is under the control of the function you passed to the constructor.
    That function should perform some asynchronous operation and then call the `resolve`
    function to resolve or fulfill the returned Promise or call the `reject` function
    to reject the returned Promise. Your function does not have to be asynchronous:
    it can call `resolve` or `reject` synchronously, but the Promise will still be
    resolved, fulfilled, or rejected asynchronously if you do this.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`getJSON()`和`getHighScore()`，我们首先调用现有函数以获取初始Promise，并通过调用该初始Promise的`.then()`方法创建并返回一个新Promise。但是，当你无法使用另一个返回Promise的函数作为起点时，如何编写返回Promise的函数呢？在这种情况下，你可以使用`Promise()`构造函数创建一个全新的Promise对象，你可以完全控制它。操作如下：你调用`Promise()`构造函数并将一个函数作为其唯一参数传递。你传递的函数应该预期两个参数，按照惯例，应该命名为`resolve`和`reject`。构造函数会同步调用带有`resolve`和`reject`参数的函数。在调用你的函数后，`Promise()`构造函数会返回新创建的Promise。返回的Promise受你传递给构造函数的函数控制。该函数应执行一些异步操作，然后调用`resolve`函数以解析或实现返回的Promise，或调用`reject`函数以拒绝返回的Promise。你的函数不必是异步的：如果这样做，即使你同步调用`resolve`或`reject`，Promise仍将异步解析、实现或拒绝。
- en: 'It can be hard to understand the functions passed to a function passed to a
    constructor by just reading about it, but hopefully some examples will make this
    clear. Here’s how to write the Promise-based `wait()` function that we used in
    various examples earlier in the chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读关于将函数传递给构造函数的函数的功能可能很难理解，但希望一些示例能够澄清这一点。以下是如何编写基于Promise的`wait()`函数的方法，我们在本章的早期示例中使用过：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the pair of functions that you use to control the fate of a Promise
    created with the `Promise()` constructor are named `resolve()` and `reject()`,
    not `fulfill()` and `reject()`. If you pass a Promise to `resolve()`, the returned
    Promise will resolve to that new Promise. Often, however, you will pass a non-Promise
    value, which fulfills the returned Promise with that value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用于控制使用`Promise()`构造函数创建的Promise的命运的一对函数的名称分别为`resolve()`和`reject()`，而不是`fulfill()`和`reject()`。如果将一个Promise传递给`resolve()`，则返回的Promise将解析为该新Promise。然而，通常情况下，你会传递一个非Promise值，这将用该值实现返回的Promise。
- en: '[Example 13-1](#getJSON-js) is another example of using the `Promise()` constructor.
    This one implements our `getJSON()` function for use in Node, where the `fetch()`
    API is not built in. Remember that we started this chapter with a discussion of
    asynchronous callbacks and events. This example uses both callbacks and event
    handlers and is a good demonstration, therefore, of how we can implement Promise-based
    APIs on top of other styles of asynchronous programming.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-1](#getJSON-js) 是另一个使用`Promise()`构造函数的示例。这个示例实现了我们的`getJSON()`函数，用于在Node中使用，因为`fetch()`API没有内置。请记住，我们在本章一开始讨论了异步回调和事件。这个示例同时使用了回调和事件处理程序，因此很好地演示了我们如何在其他类型的异步编程风格之上实现基于Promise的API。'
- en: Example 13-1\. An asynchronous getJSON() function
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-1\. 一个异步的 getJSON() 函数
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 13.2.7 Promises in Sequence
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2.7 顺序执行的Promises
- en: '`Promise.all()` makes it easy to run an arbitrary number of Promises in parallel.
    And Promise chains make it easy to express a sequence of a fixed number of Promises.
    Running an arbitrary number of Promises in sequence is trickier, however. Suppose,
    for example, that you have an array of URLs to fetch, but that to avoid overloading
    your network, you want to fetch them one at a time. If the array is of arbitrary
    length and unknown content, you can’t write out a Promise chain in advance, so
    you need to build one dynamically, with code like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()` 让并行运行任意数量的 Promises 变得容易。Promise 链使得表达一系列固定数量的 Promises 变得容易。然而，按顺序运行任意数量的
    Promises 就比较棘手了。例如，假设你有一个要获取的 URL 数组，但为了避免过载网络，你希望一次只获取一个。如果数组长度和内容未知，你无法提前编写
    Promise 链，因此需要动态构建一个，代码如下：'
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With this `fetchSequentially()` function defined, we could fetch the URLs one
    at a time with code much like the fetch-in-parallel code we used earlier to demonstrate
    `Promise.all()`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了定义的 `fetchSequentially()` 函数，我们可以一次获取一个 URL，代码与我们之前用来演示 `Promise.all()` 的并行获取代码类似：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `fetchSequentially()` function starts by creating a Promise that will fulfill
    immediately after it returns. It then builds a long, linear Promise chain off
    of that initial Promise and returns the last Promise in the chain. It is like
    setting up a row of dominoes and then knocking the first one over.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchSequentially()` 函数首先创建一个 Promise，在返回后立即实现。然后，它基于该初始 Promise 构建一个长的线性
    Promise 链，并返回链中的最后一个 Promise。这就像设置一排多米诺骨牌，然后推倒第一个。'
- en: 'There is another (possibly more elegant) approach that we can take. Rather
    than creating the Promises in advance, we can have the callback for each Promise
    create and return the next Promise. That is, instead of creating and chaining
    a bunch of Promises, we instead create Promises that resolve to other Promises.
    Rather than creating a domino-like chain of Promises, we are instead creating
    a sequence of Promises nested one inside the other like a set of matryoshka dolls.
    With this approach, our code can return the first (outermost) Promise, knowing
    that it will eventually fulfill (or reject!) to the same value that the last (innermost)
    Promise in the sequence does. The `promiseSequence()` function that follows is
    written to be generic and is not specific to URL fetching. It is here at the end
    of our discussion of Promises because it is complicated. If you’ve read this chapter
    carefully, however, I hope you’ll be able to understand how it works. In particular,
    note that the nested function inside `promiseSequence()` appears to call itself
    recursively, but because the “recursive” call is through a `then()` method, there
    is not actually any traditional recursion happening:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取另一种（可能更优雅）的方法。与其提前创建 Promises，我们可以让每个 Promise 的回调创建并返回下一个 Promise。也就是说，我们不是创建和链接一堆
    Promises，而是创建解析为其他 Promises 的 Promises。我们不是创建一条多米诺般的 Promise 链，而是创建一个嵌套在另一个内部的
    Promise 序列，就像一组套娃一样。采用这种方法，我们的代码可以返回第一个（最外层）Promise，知道它最终会实现（或拒绝！）与序列中最后一个（最内层）Promise
    相同的��。接下来的 `promiseSequence()` 函数编写为通用的，不特定于 URL 获取。它在我们讨论 Promises 的最后，因为它很复杂。然而，如果你仔细阅读了本章，希望你能理解它是如何工作的。特别要注意的是，`promiseSequence()`
    中的嵌套函数似乎递归调用自身，但因为“递归”调用是通过 `then()` 方法进行的，实际上并没有传统的递归发生：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This `promiseSequence()` function is intentionally generic. We can use it to
    fetch URLs with code like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `promiseSequence()` 函数是故意通用的。我们可以用它来获取 URL，代码如下：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 13.3 async and await
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.3 async 和 await
- en: ES2017 introduces two new keywords—`async` and `await`—that represent a paradigm
    shift in asynchronous JavaScript programming. These new keywords dramatically
    simplify the use of Promises and allow us to write Promise-based, asynchronous
    code that looks like synchronous code that blocks while waiting for network responses
    or other asynchronous events. Although it is still important to understand how
    Promises work, much of their complexity (and sometimes even their very presence!)
    vanishes when you use them with `async` and `await`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ES2017 引入了两个新关键字——`async` 和 `await`——代表了 JavaScript 异步编程的范式转变。这些新关键字极大地简化了 Promises
    的使用，并允许我们编写基于 Promise 的异步代码，看起来像阻塞的同步代码，等待网络响应或其他异步事件。虽然理解 Promises 如何工作仍然很重要，但当与
    `async` 和 `await` 一起使用时，它们的复杂性（有时甚至是它们的存在本身！）会消失。
- en: As we discussed earlier in the chapter, asynchronous code can’t return a value
    or throw an exception the way that regular synchronous code can. And this is why
    Promises are designed the way the are. The value of a fulfilled Promise is like
    the return value of a synchronous function. And the value of a rejected Promise
    is like a value thrown by a synchronous function. This latter similarity is made
    explicit by the naming of the `.catch()` method. `async` and `await` take efficient,
    Promise-based code and hide the Promises so that your asynchronous code can be
    as easy to read and as easy to reason about as inefficient, blocking, synchronous
    code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论的那样，异步代码无法像常规同步代码那样返回值或抛出异常。这就是 Promises 设计的原因。已实现的 Promise 的值就像同步函数的返回值一样。而拒绝的
    Promise 的值就像同步函数抛出的值一样。后者的相似性通过 `.catch()` 方法的命名得到明确体现。`async` 和 `await` 采用高效的基于
    Promise 的代码，并隐藏了 Promises，使得你的异步代码可以像低效、阻塞的同步代码一样易于阅读和推理。
- en: 13.3.1 await Expressions
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.1 await 表达式
- en: 'The `await` keyword takes a Promise and turns it back into a return value or
    a thrown exception. Given a Promise object `p`, the expression `await p` waits
    until `p` settles. If `p` fulfills, then the value of `await p` is the fulfillment
    value of `p`. On the other hand, if `p` is rejected, then the `await p` expression
    throws the rejection value of `p`. We don’t usually use `await` with a variable
    that holds a Promise; instead, we use it before the invocation of a function that
    returns a Promise:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`关键字接受一个Promise并将其转换为返回值或抛出异常。给定一个Promise对象`p`，表达式`await p`会等待直到`p`完成。如果`p`成功，那么`await
    p`的值就是`p`的成功值。另一方面，如果`p`被拒绝，那么`await p`表达式会抛出`p`的拒绝值。我们通常不会使用一个保存Promise的变量来使用`await`；相反，我们会在返回Promise的函数调用之前使用它：'
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is critical to understand right away that the `await` keyword does not cause
    your program to block and literally do nothing until the specified Promise settles.
    The code remains asynchronous, and the `await` simply disguises this fact. This
    means that *any code that uses* `await` *is itself asynchronous*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 立即理解`await`关键字不会导致程序阻塞并直到指定的Promise完成。代码仍然是异步的，`await`只是掩饰了这一事实。这意味着*任何使用*`await`*的代码本身都是异步的*。
- en: 13.3.2 async Functions
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.2 async函数
- en: 'Because any code that uses `await` is asynchronous, there is one critical rule:
    *you can only use the `await` keyword within functions that have been declared
    with the `async` keyword*. Here’s a version of the `getHighScore()` function from
    earlier in the chapter, rewritten to use `async` and `await`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因为任何使用`await`的代码都是异步的，有一个关键规则：*只能在使用`async`关键字声明的函数内部使用`await`关键字*。以下是本章前面提到的`getHighScore()`函数的一个使用`async`和`await`重写的版本：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Declaring a function `async` means that the return value of the function will
    be a Promise even if no Promise-related code appears in the body of the function.
    If an `async` function appears to return normally, then the Promise object that
    is the real return value of the function will resolve to that apparent return
    value. And if an `async` function appears to throw an exception, then the Promise
    object that it returns will be rejected with that exception.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个函数为`async`意味着函数的返回值将是一个Promise，即使函数体中没有任何与Promise相关的代码���如果一个`async`函数看起来正常返回，那么作为真正返回值的Promise对象将解析为该表面返回值。如果一个`async`函数看起来抛出异常，那么它返回的Promise对象将被拒绝并带有该异常。
- en: 'The `getHighScore()` function is declared `async`, so it returns a Promise.
    And because it returns a Promise, we can use the `await` keyword with it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`getHighScore()`函数被声明为`async`，因此它返回一个Promise。由于它返回一个Promise，我们可以使用`await`关键字：'
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'But remember, that line of code will only work if it is inside another `async`
    function! You can nest `await` expressions within `async` functions as deeply
    as you want. But if you’re at the top level^([2](ch13.xhtml#idm46198516659992))
    or are inside a function that is not `async` for some reason, then you can’t use
    `await` and have to deal with a returned Promise in the regular way:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，那行代码只有在另一个`async`函数内部才能起作用！你可以无限嵌套`await`表达式在`async`函数内部。但如果你在顶层^([2](ch13.xhtml#idm46198516659992))或者由于某种原因在一个非`async`函数内部，那么你就不能使用`await`，而必须以常规方式处理返回的Promise：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can use the `async` keyword with any kind of function. It works with the
    `function` keyword as a statement or as an expression. It works with arrow functions
    and with the method shortcut form in classes and object literals. (See [Chapter 8](ch08.xhtml#functions)
    for more about the various ways to write functions.)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何类型的函数中使用`async`关键字。它可以与`function`关键字一起作为语句或表达式使用。它可以与箭头函数一起使用，也可以与类和对象字面量中的方法快捷形式一起使用。（有关编写函数的各种方式，请参见[第8章](ch08.xhtml#functions)。）
- en: 13.3.3 Awaiting Multiple Promises
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.3 等待多个Promises
- en: 'Suppose that we’ve written our `getJSON()` function using `async`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`async`编写了我们的`getJSON()`函数：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And now suppose that we want to fetch two JSON values with this function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要使用这个函数获取两个JSON值：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The problem with this code is that it is unnecessarily sequential: the fetch
    of the second URL will not begin until the first fetch is complete. If the second
    URL does not depend on the value obtained from the first URL, then we should probably
    try to fetch the two values at the same time. This is a case where the Promise-based
    nature of `async` functions shows. In order to await a set of concurrently executing
    `async` functions, we use `Promise.all()` just as we would if working with Promises
    directly:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于它是不必要的顺序执行：第二个URL的获取将等到第一个URL的获取完成后才开始。如果第二个URL不依赖于从第一个URL获取的值，那么我们可能应该尝试同时获取这两个值。这是`async`函数的基于Promise的特性的一个案例。为了等待一组并发执行的`async`函数，我们使用`Promise.all()`，就像直接使用Promises一样：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 13.3.4 Implementation Details
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3.4 实现细节
- en: Finally, in order to understand how `async` functions work, it may help to think
    about what is going on under the hood.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了理解`async`函数的工作原理，可能有助于思考底层发生了什么。
- en: 'Suppose you write an `async` function like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你写了一个这样的`async`函数：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can think about this as a Promise-returning function wrapped around the
    body of your original function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这看作是一个包装在原始函数体周围的返回Promise的函数：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is harder to express the `await` keyword in terms of a syntax transformation
    like this one. But think of the `await` keyword as a marker that breaks a function
    body up into separate, synchronous chunks. An ES2017 interpreter can break the
    function body up into a sequence of separate subfunctions, each of which gets
    passed to the `then()` method of the `await`-marked Promise that precedes it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用这种方式来表达`await`关键字比较困难。但可以将`await`关键字看作是一个标记，将函数体分解为单独的同步块。ES2017解释器可以将函数体分解为一系列单独的子函数，每个子函数都会传递给前面的`await`标记的Promise的`then()`方法。
- en: 13.4 Asynchronous Iteration
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.4 异步迭代
- en: We began this chapter with a discussion of callback- and event-based asynchrony,
    and when we introduced Promises, we noted that they were useful for single-shot
    asynchronous computations but were not suitable for use with sources of repetitive
    asynchronous events, such as `setInterval()`, the “click” event in a web browser,
    or the “data” event on a Node stream. Because single Promises do not work for
    sequences of asynchronous events, we also cannot use regular `async` functions
    and the `await` statements for these things.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从回调和基于事件的异步性讨论开始了本章，当我们介绍Promise时，我们注意到它们对于单次异步计算很有用，但不适用于重复异步事件的源，比如`setInterval()`、Web浏览器中的“click”事件或Node流上的“data”事件。因为单个Promise不能用于序列的异步事件，所以我们也不能使用常规的`async`函数和`await`语句来处理这些事情。
- en: 'ES2018 provides a solution, however. Asynchronous iterators are like the iterators
    described in [Chapter 12](ch12.xhtml#itergene), but they are Promise-based and
    are meant to be used with a new form of the `for/of` loop: `for/await`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ES2018提供了一个解决方案。异步迭代器类似于[第12章](ch12.xhtml#itergene)中描述的迭代器，但它们是基于Promise的，并且旨在与一种新形式的`for/of`循环一起使用：`for/await`。
- en: 13.4.1 The for/await Loop
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.1 `for/await`循环
- en: 'Node 12 makes its readable streams asynchronously iterable. This means you
    can read successive chunks of data from a stream with a `for/await` loop like
    this one:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Node 12使其可读流异步可迭代。这意味着您可以使用像这样的`for/await`循环从流中读取连续的数据块：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Like a regular `await` expression, the `for/await` loop is Promise-based. Roughly
    speaking, the asynchronous iterator produces a Promise and the `for/await` loop
    waits for that Promise to fulfill, assigns the fulfillment value to the loop variable,
    and runs the body of the loop. And then it starts over, getting another Promise
    from the iterator and waiting for that new Promise to fulfill.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 像常规的`await`表达式一样，`for/await`循环是基于Promise的。粗略地说，异步迭代器生成一个Promise，`for/await`循环等待该Promise实现，将实现值分配给循环变量，并运行循环体。然后它重新开始，从迭代器获取另一个Promise并等待该新Promise实现。
- en: 'Suppose you have an array of URLs:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个URL数组：
- en: '[PRE42]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can call `fetch()` on each URL to get an array of Promises:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以对每个URL调用`fetch()`以获取Promise数组：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We saw earlier in the chapter that we could now use `Promise.all()` to wait
    for all the Promises in the array to be fulfilled. But suppose we want the results
    of the first fetch as soon as they become available and don’t want to wait for
    all the URLs to be fetched. (Of course, the first fetch might take longer than
    any of the others, so this is not necessarily faster than using `Promise.all()`.)
    Arrays are iterable, so we can iterate through the array of promises with a regular
    `for/of` loop:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的前面看到，现在我们可以使用`Promise.all()`等待数组中所有Promise被实现。但假设我们希望在第一个fetch的结果变为可用时获取结果，并且不想等待所有URL被获取。
    （当然，第一个fetch可能比其他任何fetch都要花费更长的时间，因此这不一定比使用`Promise.all()`更快。）数组是可迭代的，因此我们可以使用常规的`for/of`循环遍历Promise数组：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This example code uses a regular `for/of` loop with a regular iterator. But
    because this iterator returns Promises, we can also use the new `for/await` for
    slightly simpler code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码使用了一个常规的`for/of`循环和一个常规的迭代器。但由于这个迭代器返回的是Promise，我们也可以使用新的`for/await`来编写稍微更简单的代码：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this case, the `for/await` loop just builds the `await` call into the loop
    and makes our code slightly more compact, but the two examples do exactly the
    same thing. Importantly, both examples will only work if they are within functions
    declared `async`; a `for/await` loop is no different than a regular `await` expression
    in that way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`for/await`循环只是将`await`调用嵌入到循环中，使我们的代码稍微更加紧凑，但这两个例子实际上做的事情是完全一样的。重要的是，这两个例子只有在声明为`async`的函数内部才能工作；`for/await`循环在这方面与常规的`await`表达式没有区别。
- en: It is important to realize, however, that we’re using `for/await` with a regular
    iterator in this example. Things are more interesting with fully asynchronous
    iterators.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要意识到，在这个例子中我们使用`for/await`与一个常规迭代器。使用完全异步迭代器会更有趣。
- en: 13.4.2 Asynchronous Iterators
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.2 异步迭代器
- en: Let’s review some terminology from [Chapter 12](ch12.xhtml#itergene). An *iterable*
    object is one that can be used with a `for/of` loop. It defines a method with
    the symbolic name `Symbol.iterator`. This method returns an *iterator* object.
    The iterator object has a `next()` method, which can be called repeatedly to obtain
    the values of the iterable object. The `next()` method of the iterator object
    returns *iteration result* objects. The iteration result object has a `value`
    property and/or a `done` property.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下[第12章](ch12.xhtml#itergene)中的一些术语。*可迭代*对象是可以与`for/of`循环一起使用的对象。它定义了一个符号名称为`Symbol.iterator`的方法。该方法返回一个*迭代器*对象。迭代器对象具有一个`next()`方法，可以重复调用以获取可迭代对象的值。迭代器对象的`next()`方法返回*迭代结果*对象。迭代结果对象具有一个`value`属性和/或一个`done`属性。
- en: Asynchronous iterators are quite similar to regular iterators, but there are
    two important differences. First, an asynchronously iterable object implements
    a method with the symbolic name `Symbol.asyncIterator` instead of `Symbol.iterator`.
    (As we saw earlier, `for/await` is compatible with regular iterable objects but
    it prefers asynchronously iterable objects, and tries the `Symbol.asyncIterator`
    method before it tries the `Symbol.iterator` method.) Second, the `next()` method
    of an asynchronous iterator returns a Promise that resolves to an iterator result
    object instead of returning an iterator result object directly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代器与常规迭代器非常相似，但有两个重要的区别。首先，异步可迭代对象实现了一个符号名称为`Symbol.asyncIterator`的方法，而不是`Symbol.iterator`。
    （正如我们之前看到的，`for/await`与常规可迭代对象兼容，但它更喜欢异步可迭代对象，并在尝试`Symbol.iterator`方法之前尝试`Symbol.asyncIterator`方法。）其次，异步迭代器的`next()`方法返回一个解析为迭代器结果对象的Promise，而不是直接返回迭代器结果对象。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the previous section, when we used `for/await` on a regular, synchronously
    iterable array of Promises, we were working with synchronous iterator result objects
    in which the `value` property was a Promise object but the `done` property was
    synchronous. True asynchronous iterators return Promises for iteration result
    objects, and both the `value` and the `done` properties are asynchronous. The
    difference is a subtle one: with asynchronous iterators, the choice about when
    iteration ends can be made asynchronously.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，当我们在常规的同步可迭代的Promise数组上使用`for/await`时，我们正在处理同步迭代器结果对象，其中`value`属性是一个Promise对象，但`done`属性是同步的。真正的异步迭代器会返回Promise以进行迭代结果对象，并且`value`和`done`属性都是异步的。区别是微妙的：使用异步迭代器时，关于何时结束迭代的选择可以异步进行。
- en: 13.4.3 Asynchronous Generators
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.3 异步生成器
- en: 'As we saw in [Chapter 12](ch12.xhtml#itergene), the easiest way to implement
    an iterator is often to use a generator. The same is true for asynchronous iterators,
    which we can implement with generator functions that we declare `async`. An async
    generator has the features of async functions and the features of generators:
    you can use `await` as you would in a regular async function, and you can use
    `yield` as you would in a regular generator. But values that you `yield` are automatically
    wrapped in Promises. Even the syntax for async generators is a combination: `async
    function` and `function *` combine into `async function *`. Here is an example
    that shows how you might use an async generator and a `for/await` loop to repetitively
    run code at fixed intervals using loop syntax instead of a `setInterval()` callback
    function:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第12章](ch12.xhtml#itergene)中看到的，实现迭代器的最简单方法通常是使用生成器。对于异步迭代器也是如此，我们可以使用声明为`async`的生成器函数来实现。异步生成器具有异步函数和生成器的特性：你可以像在常规异步函数中一样使用`await`，也可以像在常规生成器中一样使用`yield`。但你`yield`的值会自动包装在Promise中。甚至异步生成器的语法也是一个组合：`async
    function`和`function *`组合成`async function *`。下面是一个示例，展示了如何使用异步生成器和`for/await`循环以循环语法而不是`setInterval()`回调函数重复在固定间隔运行代码：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 13.4.4 Implementing Asynchronous Iterators
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4.4 实现异步迭代器
- en: 'Instead of using async generators to implement asynchronous iterators, it is
    also possible to implement them directly by defining an object with a `Symbol.asyncIterator()`
    method that returns an object with a `next()` method that returns a Promise that
    resolves to an iterator result object. In the following code, we re-implement
    the `clock()` function from the preceding example so that it is not a generator
    and instead just returns an asynchronously iterable object. Notice that the `next()`
    method in this example does not explicitly return a Promise; instead, we just
    declare `next()` to be async:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用异步生成器来实现异步迭代器外，还可以通过定义一个具有返回一个返回解析为迭代器结果对象的Promise的`next()`方法的对象的`Symbol.asyncIterator()`方法来直接实现它们。在下面的代码中，我们重新实现了前面示例中的`clock()`函数，使其不是一个生成器，而是只返回一个异步可迭代对象。请注意，在这个示例中，`next()`方法并没有显式返回一个Promise；相��，我们只是声明`next()`为async：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This iterator-based version of the `clock()` function fixes a flaw in the generator-based
    version. Note that, in this newer code, we target the absolute time at which each
    iteration should begin and subtract the current time from that in order to compute
    the interval that we pass to `setTimeout()`. If we use `clock()` with a `for/await`
    loop, this version will run loop iterations more precisely at the specified interval
    because it accounts for the time required to actually run the body of the loop.
    But this fix isn’t just about timing accuracy. The `for/await` loop always waits
    for the Promise returned by one iteration to be fulfilled before it begins the
    next iteration. But if you use an asynchronous iterator without a `for/await`
    loop, there is nothing to prevent you from calling the `next()` method whenever
    you want. With the generator-based version of `clock()`, if you call the `next()`
    method three times sequentially, you’ll get three Promises that will all fulfill
    at almost exactly the same time, which is probably not what you want. The iterator-based
    version we’ve implemented here does not have that problem.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基于迭代器的`clock()`函数版本修复了基于生成器的版本中的一个缺陷。请注意，在这个更新的代码中，我们针对每次迭代应该开始的绝对时间，并从中减去当前时间以计算传递给`setTimeout()`的间隔。如果我们在`for/await`循环中使用`clock()`，这个版本将更精确地按照指定的间隔运行循环迭代，因为它考虑了实际运行循环体所需的时间。但这个修复不仅仅是关于时间精度。`for/await`循环总是在开始下一次迭代之前等待一个迭代返回的Promise被实现。但如果你在没有`for/await`循环的情况下使用异步迭代器，就没有任何阻止你在想要的任何时候调用`next()`方法。使用基于生成器的`clock()`版本，如果连续调用`next()`方法三次，你将得到三个几乎在同一时间实现的Promise，这可能不是你想要的。我们在这里实现的基于迭代器的版本没有这个问题。
- en: The benefit of asynchronous iterators is that they allow us to represent streams
    of asynchronous events or data. The `clock()` function discussed previously was
    fairly simple to write because the source of the asynchrony was the `setTimeout()`
    calls we were making ourselves. But when we are trying to work with other asynchronous
    sources, such as the triggering of event handlers, it becomes substantially harder
    to implement asynchronous iterators—we typically have a single event handler function
    that responds to events, but each call to the iterator’s `next()` method must
    return a distinct Promise object, and multiple calls to `next()` may occur before
    the first Promise resolves. This means that any asynchronous iterator method must
    be able to maintain an internal queue of Promises that it resolves in order as
    asynchronous events are occurring. If we encapsulate this Promise-queueing behavior
    into an AsyncQueue class, then it becomes much easier to write asynchronous iterators
    based on AsyncQueue.^([3](ch13.xhtml#idm46198515815416))
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代器的好处在于它们允许我们表示异步事件或数据流。之前讨论的`clock()`函数相对简单，因为异步性的源是我们自己进行的`setTimeout()`调用。但是当我们尝试处理其他异步源时，比如触发事件处理程序，实现异步迭代器就变得相当困难——通常我们有一个响应事件的单个事件处理程序函数，但��迭代器的每次调用`next()`方法必须返回一个不同的
    Promise 对象，并且在第一个 Promise 解析之前可能会多次调用`next()`。这意味着任何异步迭代器方法必须能够维护一个内部 Promise
    队列，以便按顺序解析异步事件。如果我们将这种 Promise 队列行为封装到一个 AsyncQueue 类中，那么基于 AsyncQueue 编写异步迭代器就会变得更容易。^([3](ch13.xhtml#idm46198515815416))
- en: The AsyncQueue class that follows has `enqueue()` and `dequeue()` methods as
    you’d expect for a queue class. The `dequeue()` method returns a Promise rather
    than an actual value, however, which means that it is OK to call `dequeue()` before
    `enqueue()` has ever been called. The AsyncQueue class is also an asynchronous
    iterator, and is intended to be used with a `for/await` loop whose body runs once
    each time a new value is asynchronously enqueued. (AsyncQueue has a `close()`
    method. Once called, no more values can be enqueued. When a closed queue is empty,
    the `for/await` loop will stop looping.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的 AsyncQueue 类具有`enqueue()`和`dequeue()`方法，就像你期望的队列类一样。然而，`dequeue()`方法返回一个
    Promise 而不是实际值，这意味着在调用`enqueue()`之前调用`dequeue()`是可以的。AsyncQueue 类也是一个异步迭代器，并且旨在与一个`for/await`循环一起使用，其主体在每次异步排队新值时运行一次。
    （AsyncQueue 有一个`close()`方法。一旦调用，就不能再排队更多的值。当一个关闭的队列为空时，`for/await`循环将停止循环。）
- en: 'Note that the implementation of AsyncQueue does not use `async` or `await`
    and instead works directly with Promises. The code is somewhat complicated, and
    you can use it to test your understanding of the material we’ve covered in this
    long chapter. Even if you don’t fully understand the AsyncQueue implementation,
    do take a look at the shorter example that follows it: it implements a simple
    but very interesting asynchronous iterator on top of AsyncQueue.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，AsyncQueue 的实现不使用`async`或`await`，而是直接使用 Promises。这段代码有些复杂，你可以用它来测试你对我们在这一长章节中涵盖的内容的理解。即使你不完全理解
    AsyncQueue 的实现，也请看一下后面的简短示例：它在 AsyncQueue 的基础上实现了一个简单但非常有趣的异步迭代器。
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Because this AsyncQueue class defines the asynchronous iteration basics, we
    can create our own, more interesting asynchronous iterators simply by asynchronously
    queueing values. Here’s an example that uses AsyncQueue to produce a stream of
    web browser events that can be handled with a `for/await` loop:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个 AsyncQueue 类定义了异步迭代的基础，我们可以通过异步排队值来创建自己的更有趣的异步迭代器。下面是一个示例，它使用 AsyncQueue
    生成一个可以用`for/await`循环处理的 web 浏览器事件流：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 13.5 Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13.5 总结
- en: 'In this chapter, you have learned:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学到了：
- en: Most real-world JavaScript programming is asynchronous.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数真实世界的 JavaScript 编程是异步的。
- en: Traditionally, asynchrony has been handled with events and callback functions.
    This can get complicated, however, because you can end up with multiple levels
    of callbacks nested inside other callbacks, and because it is difficult to do
    robust error handling.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统上，异步性是通过事件和回调函数来处理的。然而，这可能会变得复杂，因为你可能会得到多层嵌套在其他回调内部的回调，并且很难进行健壮的错误处理。
- en: Promises provide a new way of structuring callback functions. If used correctly
    (and unfortunately, Promises are easy to use incorrectly), they can convert asynchronous
    code that would have been nested into linear chains of `then()` calls where one
    asynchronous step of a computation follows another. Also, Promises allow you to
    centralize your error-handling code into a single `catch()` call at the end of
    a chain of `then()` calls.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises 提供了一种新的组织回调函数的方式。如果使用正确（不幸的是，Promises 很容易被错误使用），它们可以将原本嵌套的异步代码转换为`then()`调用的线性链，其中一个计算的异步步骤跟随另一个。此外，Promises
    允许你将错误处理代码集中到一条`catch()`调用中，放在`then()`调用链的末尾。
- en: The `async` and `await` keywords allow us to write asynchronous code that is
    Promise-based under the hood but that looks like synchronous code. This makes
    the code easier to understand and reason about. If a function is declared `async`,
    it will implicitly return a Promise. Inside an `async` function, you can `await`
    a Promise (or a function that returns a Promise) as if the Promise value was synchronously
    computed.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async`和`await`关键字允许我们编写基于 Promise 的异步代码，但看起来像同步代码。这使得代码更容易理解和推理。如果一个函数声明为`async`，它将隐式返回一个
    Promise。在`async`函数内部，你可以像同步计算 Promise 值一样`await`一个 Promise（或返回 Promise 的函数）。'
- en: Objects that are asynchronously iterable can be used with a `for/await` loop.
    You can create asynchronously iterable objects by implementing a `[Symbol.asyncIterator]()`
    method or by invoking an `async function *` generator function. Asynchronous iterators
    provide an alternative to “data” events on streams in Node and can be used to
    represent a stream of user input events in client-side JavaScript.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`for/await`循环处理异步可迭代对象。你可以通过实现`[Symbol.asyncIterator]()`方法或调用`async function
    *`生成器函数来创建异步可迭代对象。异步迭代器提供了一种替代Node中“data”事件的方式，并可用于表示客户端JavaScript中用户输入事件的流。
- en: ^([1](ch13.xhtml#idm46198519434968-marker)) The XMLHttpRequest class has nothing
    in particular to do with XML. In modern client-side JavaScript, it has largely
    been replaced by the `fetch()` API, which is covered in [§15.11.1](ch15.xhtml#fetch).
    The code example shown here is the last XMLHttpRequest-based example remaining
    in this book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.xhtml#idm46198519434968-marker)) XMLHttpRequest类与XML无关。在现代客户端JavaScript中，它大部分被`fetch()`
    API取代，该API在[§15.11.1](ch15.xhtml#fetch)中有介绍。这里展示的代码示例是本书中仅剩的基于XMLHttpRequest的示例。
- en: ^([2](ch13.xhtml#idm46198516659992-marker)) You can typically use `await` at
    the top level in a browser’s developer console. And there is a pending proposal
    to allow top-level `await` in a future version of JavaScript.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.xhtml#idm46198516659992-marker)) 通常可以在浏览器的开发者控制台中的顶层使用`await`。而且有一个未决提案，允许在未来版本的JavaScript中使用顶层`await`。
- en: ^([3](ch13.xhtml#idm46198515815416-marker)) I learned about this approach to
    asynchronous iteration from the blog of Dr. Axel Rauschmayer, [*https://2ality.com*](https://2ality.com).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.xhtml#idm46198515815416-marker)) 我从[*https://2ality.com*](https://2ality.com)博客中了解到了这种异步迭代的方法，作者是Axel
    Rauschmayer博士。
