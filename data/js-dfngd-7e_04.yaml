- en: Chapter 4\. Expressions and Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 表达式和运算符
- en: This chapter documents JavaScript expressions and the operators with which many
    of those expressions are built. An *expression* is a phrase of JavaScript that
    can be *evaluated* to produce a value. A constant embedded literally in your program
    is a very simple kind of expression. A variable name is also a simple expression
    that evaluates to whatever value has been assigned to that variable. Complex expressions
    are built from simpler expressions. An array access expression, for example, consists
    of one expression that evaluates to an array followed by an open square bracket,
    an expression that evaluates to an integer, and a close square bracket. This new,
    more complex expression evaluates to the value stored at the specified index of
    the specified array. Similarly, a function invocation expression consists of one
    expression that evaluates to a function object and zero or more additional expressions
    that are used as the arguments to the function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章记录了 JavaScript 表达式以及构建许多这些表达式的运算符。*表达式* 是 JavaScript 的短语，可以 *评估* 以产生一个值。在程序中直接嵌入的常量是一种非常简单的表达式。变量名也是一个简单表达式，它评估为分配给该变量的任何值。复杂表达式是由简单表达式构建的。例如，一个数组访问表达式由一个评估为数组的表达式、一个开放方括号、一个评估为整数���表达式和一个闭合方括号组成。这个新的、更复杂的表达式评估为存储在指定数组索引处的值。类似地，函数调用表达式由一个评估为函数对象的表达式和零个或多个额外表达式组成，这些额外表达式用作函数的参数。
- en: The most common way to build a complex expression out of simpler expressions
    is with an *operator*. An operator combines the values of its operands (usually
    two of them) in some way and evaluates to a new value. The multiplication operator
    `*` is a simple example. The expression `x * y` evaluates to the product of the
    values of the expressions `x` and `y`. For simplicity, we sometimes say that an
    operator *returns* a value rather than “evaluates to” a value.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从简单表达式中构建复杂表达式的最常见方法是使用 *运算符*。运算符以某种方式结合其操作数的值（通常是两个操作数中的一个）并评估为一个新值。乘法运算符 `*`
    是一个简单的例子。表达式 `x * y` 评估为表达式 `x` 和 `y` 的值的乘积。为简单起见，我们有时说一个运算符 *返回* 一个值，而不是“评估为”一个值。
- en: This chapter documents all of JavaScript’s operators, and it also explains expressions
    (such as array indexing and function invocation) that do not use operators. If
    you already know another programming language that uses C-style syntax, you’ll
    find that the syntax of most of JavaScript’s expressions and operators is already
    familiar to you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章记录了 JavaScript 的所有运算符，并解释了不使用运算符的表达式（如数组索引和函数调用）。如果您已经了解使用 C 风格语法的其他编程语言，您会发现大多数
    JavaScript 表达式和运算符的语法已经很熟悉了。
- en: 4.1 Primary Expressions
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 主要表达式
- en: The simplest expressions, known as *primary expressions*, are those that stand
    alone—they do not include any simpler expressions. Primary expressions in JavaScript
    are constant or *literal* values, certain language keywords, and variable references.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的表达式，称为 *主要表达式*，是那些独立存在的表达式——它们不包括任何更简单的表达式。JavaScript 中的主要表达式是常量或 *字面值*、某些语言关键字和变量引用。
- en: 'Literals are constant values that are embedded directly in your program. They
    look like these:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是直接嵌入到程序中的常量值。它们看起来像这样：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: JavaScript syntax for number literals was covered in [§3.2](ch03.xhtml#numbers).
    String literals were documented in [§3.3](ch03.xhtml#text). The regular expression
    literal syntax was introduced in [§3.3.5](ch03.xhtml#regexpintro) and will be
    documented in detail in [§11.3](ch11.xhtml#regexps).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中关于数字字面量的语法已在 [§3.2](ch03.xhtml#numbers) 中介绍过。字符串字面量在 [§3.3](ch03.xhtml#text)
    中有文档记录。正则表达式字面量语法在 [§3.3.5](ch03.xhtml#regexpintro) 中介绍过，并将在 [§11.3](ch11.xhtml#regexps)
    中详细记录。
- en: 'Some of JavaScript’s reserved words are primary expressions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一些保留字是主要表达式：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We learned about `true`, `false`, and `null` in [§3.4](ch03.xhtml#booleans)
    and [§3.5](ch03.xhtml#nullundefined). Unlike the other keywords, `this` is not
    a constant—it evaluates to different values in different places in the program.
    The `this` keyword is used in object-oriented programming. Within the body of
    a method, `this` evaluates to the object on which the method was invoked. See
    [§4.5](#invocationexprs), [Chapter 8](ch08.xhtml#functions) (especially [§8.2.2](ch08.xhtml#methodinvocation)),
    and [Chapter 9](ch09.xhtml#classes) for more on `this`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [§3.4](ch03.xhtml#booleans) 和 [§3.5](ch03.xhtml#nullundefined) 中学习了 `true`、`false`
    和 `null`。与其他关键字不同，`this` 不是一个常量——它在程序中的不同位置评估为不同的值。`this` 关键字用于面向对象编程。在方法体内，`this`
    评估为调用该方法的对象。查看 [§4.5](#invocationexprs)、[第8章](ch08.xhtml#functions)（特别是 [§8.2.2](ch08.xhtml#methodinvocation)）和
    [第9章](ch09.xhtml#classes) 了解更多关于 `this` 的内容。
- en: 'Finally, the third type of primary expression is a reference to a variable,
    constant, or property of the global object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三种主要表达式是对变量、常量或全局对象属性的引用：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When any identifier appears by itself in a program, JavaScript assumes it is
    a variable or constant or property of the global object and looks up its value.
    If no variable with that name exists, an attempt to evaluate a nonexistent variable
    throws a ReferenceError instead.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中出现任何标识符时，JavaScript 假定它是一个变量、常量或全局对象的属性，并查找其值。如果不存在具有该名称的变量，则尝试评估不存在的变量会抛出
    ReferenceError。
- en: 4.2 Object and Array Initializers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 对象和数组初始化器
- en: '*Object* and *array initializers* are expressions whose value is a newly created
    object or array. These initializer expressions are sometimes called *object literals*
    and *array literals*. Unlike true literals, however, they are not primary expressions,
    because they include a number of subexpressions that specify property and element
    values. Array initializers have a slightly simpler syntax, and we’ll begin with
    those.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象* 和 *数组初始化器* 是值为新创建的对象或数组的表达式。这些初始化器表达式有时被称为 *对象字面量* 和 *数组字面量*。然而，与真正的字面量不同，它们不是主要表达式，因为它们包括一些指定属性和元素值的子表达式。数组初始化器具有稍微简单的语法，我们将从这些开始。'
- en: 'An array initializer is a comma-separated list of expressions contained within
    square brackets. The value of an array initializer is a newly created array. The
    elements of this new array are initialized to the values of the comma-separated
    expressions:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组初始化器是方括号内包含的逗号分隔的表达式列表。数组初始化器的值是一个新创建的数组。这个新数组的元素被初始化为逗号分隔表达式的值：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The element expressions in an array initializer can themselves be array initializers,
    which means that these expressions can create nested arrays:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数组初始化器中的元素表达式本身可以是数组初始化器，这意味着这些表达式可以创建嵌套数组：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The element expressions in an array initializer are evaluated each time the
    array initializer is evaluated. This means that the value of an array initializer
    expression may be different each time it is evaluated.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数组初始化器中的元素表达式在每次评估数组初始化器时都会被评估。这意味着数组初始化器表达式的值在每次评估时可能会有所不同。
- en: 'Undefined elements can be included in an array literal by simply omitting a
    value between commas. For example, the following array contains five elements,
    including three undefined elements:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过简单地在逗号之间省略值来在数组文字中包含未定义的元素。例如，以下数组包含五个元素，包括三个未定义的元素：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A single trailing comma is allowed after the last expression in an array initializer
    and does not create an undefined element. However, any array access expression
    for an index after that of the last expression will necessarily evaluate to undefined.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组初始化器中，最后一个表达式后允许有一个逗号，并且不会创建未定义的元素。然而，对于最后一个表达式之后的索引的任何数组访问表达式都将必然评估为未定义。
- en: 'Object initializer expressions are like array initializer expressions, but
    the square brackets are replaced by curly brackets, and each subexpression is
    prefixed with a property name and a colon:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化器表达式类似于数组初始化器表达式，但方括号被花括号替换，每个子表达式前缀都带有属性名和冒号：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In ES6, object literals have a much more feature-rich syntax (you can find
    details in [§6.10](ch06.xhtml#extended-object-literal-syntax)). Object literals
    can be nested. For example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，对象文字具有更丰富的语法（详细信息请参见[§6.10](ch06.xhtml#extended-object-literal-syntax)）。对象文字可以嵌套。例如：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ll see object and array initializers again in Chapters [6](ch06.xhtml#objects)
    and [7](ch07.xhtml#arrays).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第[6章](ch06.xhtml#objects)和第[7章](ch07.xhtml#arrays)再次看到对象和数组初始化器。
- en: 4.3 Function Definition Expressions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 函数定义表达式
- en: 'A *function definition expression* defines a JavaScript function, and the value
    of such an expression is the newly defined function. In a sense, a function definition
    expression is a “function literal” in the same way that an object initializer
    is an “object literal.” A function definition expression typically consists of
    the keyword `function` followed by a comma-separated list of zero or more identifiers
    (the parameter names) in parentheses and a block of JavaScript code (the function
    body) in curly braces. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数定义表达式* 定义了一个JavaScript函数，这种表达式的值是新定义的函数。在某种意义上，函数定义表达式是“函数文字”的一种方式，就像对象初始化器是“对象文字”一样。函数定义表达式通常由关键字`function`后跟一个逗号分隔的零个或多个标识符（参数名称）的列表（在括号中）和一个JavaScript代码块（函数体）在花括号中组成。例如：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A function definition expression can also include a name for the function. Functions
    can also be defined using a function statement rather than a function expression.
    And in ES6 and later, function expressions can use a compact new “arrow function”
    syntax. Complete details on function definition are in [Chapter 8](ch08.xhtml#functions).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义表达式也可以包括函数的名称。函数也可以使用函数语句而不是函数表达式来定义。在ES6及更高版本中，函数表达式可以使用紧凑的新“箭头函数”语法。有关函数定义的完整详细信息请参见[第8章](ch08.xhtml#functions)。
- en: 4.4 Property Access Expressions
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 属性访问表达式
- en: 'A *property access expression* evaluates to the value of an object property
    or an array element. JavaScript defines two syntaxes for property access:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性访问表达式* 评估为对象属性或数组元素的值。JavaScript为属性访问定义了两种语法：'
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first style of property access is an expression followed by a period and
    an identifier. The expression specifies the object, and the identifier specifies
    the name of the desired property. The second style of property access follows
    the first expression (the object or array) with another expression in square brackets.
    This second expression specifies the name of the desired property or the index
    of the desired array element. Here are some concrete examples:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 属性访问的第一种风格是一个表达式后跟一个句点和一个标识符。表达式指定对象，标识符指定所需属性的名称。属性访问的第二种风格在第一个表达式（对象或数组）后跟另一个方括号中的表达式。这第二个表达式指定所需属性的名称或所需数组元素的索引。以下是一些具体示例：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With either type of property access expression, the expression before the `.`
    or `[` is first evaluated. If the value is `null` or `undefined`, the expression
    throws a TypeError, since these are the two JavaScript values that cannot have
    properties. If the object expression is followed by a dot and an identifier, the
    value of the property named by that identifier is looked up and becomes the overall
    value of the expression. If the object expression is followed by another expression
    in square brackets, that second expression is evaluated and converted to a string.
    The overall value of the expression is then the value of the property named by
    that string. In either case, if the named property does not exist, then the value
    of the property access expression is `undefined`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任一类型的属性访问表达式时，首先评估`.`或`[`之前的表达式。如果值为`null`或`undefined`，则该表达式会抛出TypeError，因为这是两个JavaScript值，不能具有属性。如果对象表达式后跟一个句点和一个标识符，则查找该标识符命名的属性的值，并成为表达式的整体值。如果对象表达式后跟另一个方括号中的表达式，则评估并转换为字符串。然后，表达式的整体值是由该字符串命名的属性的值。在任一情况下，如果命名属性不存在，则属性访问表达式的值为`undefined`。
- en: The *.identifier* syntax is the simpler of the two property access options,
    but notice that it can only be used when the property you want to access has a
    name that is a legal identifier, and when you know the name when you write the
    program. If the property name includes spaces or punctuation characters, or when
    it is a number (for arrays), you must use the square bracket notation. Square
    brackets are also used when the property name is not static but is itself the
    result of a computation (see [§6.3.1](ch06.xhtml#associativearrays) for an example).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*.identifier*语法是两种属性访问选项中更简单的一种，但请注意，只有当要访问的属性具有合法标识符名称，并且在编写程序时知道名称时才能使用。如果属性名称包含空格或标点符号，或者是数字（对于数组），则必须使用方括号表示法。当属性名称不是静态的，而是计算结果时，也使用方括号（参见[§6.3.1](ch06.xhtml#associativearrays)中的示例）。'
- en: Objects and their properties are covered in detail in [Chapter 6](ch06.xhtml#objects),
    and arrays and their elements are covered in [Chapter 7](ch07.xhtml#arrays).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对象及其属性在[第6章](ch06.xhtml#objects)中有详细介绍，数组及其元素在[第7章](ch07.xhtml#arrays)中有介绍。
- en: 4.4.1 Conditional Property Access
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4.1 条件属性访问
- en: 'ES2020 adds two new kinds of property access expressions:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ES2020添加了两种新的属性访问表达式：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In JavaScript, the values `null` and `undefined` are the only two values that
    do not have properties. In a regular property access expression using `.` or `[]`,
    you get a TypeError if the expression on the left evaluates to `null` or `undefined`.
    You can use `?.` and `?.[]` syntax to guard against errors of this type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，值`null`和`undefined`是唯一没有属性的两个值。在使用`.`或`[]`的常规属性访问表达式中，如果左侧的表达式评估为`null`或`undefined`，则会收到TypeError。您可以使用`?.`和`?.[]`语法来防止此类错误。
- en: Consider the expression `a?.b`. If `a` is `null` or `undefined`, then the expression
    evaluates to `undefined` without any attempt to access the property `b`. If `a`
    is some other value, then `a?.b` evaluates to whatever `a.b` would evaluate to
    (and if `a` does not have a property named `b`, then the value will again be `undefined`).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式`a?.b`。如果`a`是`null`或`undefined`，那么该表达式将评估为`undefined`，而不会尝试访问属性`b`。如果`a`是其他值，则`a?.b`将评估为`a.b`的评估结果（如果`a`没有名为`b`的属性，则该值将再次为`undefined`）。
- en: 'This form of property access expression is sometimes called “optional chaining”
    because it also works for longer “chained” property access expressions like this
    one:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的属性访问表达式有时被称为“可选链”，因为它也适用于像这样的更长的“链式”属性访问表达式：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`a` is an object, so `a.b` is a valid property access expression. But the value
    of `a.b` is `null`, so `a.b.c` would throw a TypeError. By using `?.` instead
    of `.` we avoid the TypeError, and `a.b?.c` evaluates to `undefined`. This means
    that `(a.b?.c).d` will throw a TypeError, because that expression attempts to
    access a property of the value `undefined`. But—and this is a very important part
    of “optional chaining”—`a.b?.c.d` (without the parentheses) simply evaluates to
    `undefined` and does not throw an error. This is because property access with
    `?.` is “short-circuiting”: if the subexpression to the left of `?.` evaluates
    to `null` or `undefined`, then the entire expression immediately evaluates to
    `undefined` without any further property access attempts.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`是一个对象，因此`a.b`是一个有效的属性访问表达式。但是`a.b`的值是`null`，所以`a.b.c`会抛出TypeError。通过使用`?.`而不是`.`，我们避免了TypeError，`a.b?.c`评估为`undefined`。这意味着`(a.b?.c).d`将抛出TypeError，因为该表达式尝试访问值`undefined`的属性。但是——这是“可选链”非常重要的一部分——`a.b?.c.d`（不带括号）简单地评估为`undefined`，不会抛出错误。这是因为使用`?.`的属性访问是“短路”的：如果`?.`左侧的子表达式评估为`null`或`undefined`，则整个表达式立即评估为`undefined`，而不会进一步尝试访问属性。'
- en: 'Of course, if `a.b` is an object, and if that object has no property named
    `c`, then `a.b?.c.d` will again throw a TypeError, and we will want to use another
    conditional property access:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果`a.b`是一个对象，并且该对象没有名为`c`的属性，则`a.b?.c.d`将再次抛出TypeError，我们将需要使用另一种条件属性访问：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Conditional property access is also possible using `?.[]` instead of `[]`.
    In the expression `a?.[b][c]`, if the value of `a` is `null` or `undefined`, then
    the entire expression immediately evaluates to `undefined`, and subexpressions
    `b` and `c` are never even evaluated. If either of those expressions has side
    effects, the side effect will not occur if `a` is not defined:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`?.[]`而不是`[]`也可以进行条件属性访问。在表达式`a?.[b][c]`中，如果`a`的值为`null`或`undefined`，则整个表达式立即评估为`undefined`，并且子表达式`b`和`c`甚至不会被评估。如果其中任何一个表达式具有副作用，则如果`a`未定义，则副作��不会发生：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Conditional property access with `?.` and `?.[]` is one of the newest features
    of JavaScript. As of early 2020, this new syntax is supported in the current or
    beta versions of most major browsers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`?.`和`?.[]`进行条件属性访问是JavaScript的最新功能之一。截至2020年初，这种新语法在大多数主要浏览器的当前或测试版本中得到支持。
- en: 4.5 Invocation Expressions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 调用表达式
- en: 'An *invocation expression* is JavaScript’s syntax for calling (or executing)
    a function or method. It starts with a function expression that identifies the
    function to be called. The function expression is followed by an open parenthesis,
    a comma-separated list of zero or more argument expressions, and a close parenthesis.
    Some examples:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用表达式*是JavaScript用于调用（或执行）函数或方法的语法。它以标识要调用的函数的函数表达式开头。函数表达式后跟一个开括号，一个逗号分隔的零个或多个参数表达式列表，以及一个闭括号。一些示例：'
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When an invocation expression is evaluated, the function expression is evaluated
    first, and then the argument expressions are evaluated to produce a list of argument
    values. If the value of the function expression is not a function, a TypeError
    is thrown. Next, the argument values are assigned, in order, to the parameter
    names specified when the function was defined, and then the body of the function
    is executed. If the function uses a `return` statement to return a value, then
    that value becomes the value of the invocation expression. Otherwise, the value
    of the invocation expression is `undefined`. Complete details on function invocation,
    including an explanation of what happens when the number of argument expressions
    does not match the number of parameters in the function definition, are in [Chapter 8](ch08.xhtml#functions).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用表达式被评估时，首先评估函数表达式，然后评估参数表达式以生成参数值列表。如果函数表达式的值不是函数，则会抛出TypeError。接下来，按顺序将参数值分配给函数定义时指定的参数名，然后执行函数体。如果函数使用`return`语句返回一个值，则该值成为调用表达式的值。否则，调用表达式的值为`undefined`。有关函数调用的完整详细信息，包括当参数表达式的数量与函数定义中的参数数量不匹配时会发生什么的解释，请参阅[第8章](ch08.xhtml#functions)。
- en: Every invocation expression includes a pair of parentheses and an expression
    before the open parenthesis. If that expression is a property access expression,
    then the invocation is known as a *method invocation*. In method invocations,
    the object or array that is the subject of the property access becomes the value
    of the `this` keyword while the body of the function is being executed. This enables
    an object-oriented programming paradigm in which functions (which we call “methods”
    when used this way) operate on the object of which they are part. See [Chapter 9](ch09.xhtml#classes)
    for details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调用表达式都包括一对括号和开括号前的表达式。如果该表达式是一个属性访问表达式，则调用被称为*方法调用*。在方法调用中，作为属性访问主题的对象或数组在执行函数体时成为`this`关键字的值。这使得面向对象编程范式成为可能，其中函数（当以这种方式使用时我们称之为“方法”）在其所属对象上操作。详细信息请参阅[第9章](ch09.xhtml#classes)。
- en: 4.5.1 Conditional Invocation
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5.1 条件调用
- en: In ES2020, you can also invoke a function using `?.()` instead of `()`. Normally
    when you invoke a function, if the expression to the left of the parentheses is
    `null` or `undefined` or any other non-function, a TypeError is thrown. With the
    new `?.()` invocation syntax, if the expression to the left of the `?.` evaluates
    to `null` or `undefined`, then the entire invocation expression evaluates to `undefined`
    and no exception is thrown.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2020中，你也可以使用`?.()`而不是`()`来调用函数。通常当你调用一个函数时，如果括号左侧的表达式为`null`或`undefined`或任何其他非函数值，将抛出TypeError。使用新的`?.()`调用语法，如果`?.`左侧的表达式评估为`null`或`undefined`，那么整个调用表达式将评估为`undefined`，不会抛出异常。
- en: 'Array objects have a `sort()` method that can optionally be passed a function
    argument that defines the desired sorting order for the array elements. Before
    ES2020, if you wanted to write a method like `sort()` that takes an optional function
    argument, you would typically use an `if` statement to check that the function
    argument was defined before invoking it in the body of the `if`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象有一个`sort()`方法，可以选择性地传递一个函数参数，该函数定义了数组元素的期望排序顺序。在ES2020之前，如果你想编写一个像`sort()`这样的方法，它接受一个可选的函数参数，你通常会使用一个`if`语句来检查函数参数在`if`体中调用之前是否已定义：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this conditional invocation syntax of ES2020, however, you can simply
    write the function invocation using `?.()`, knowing that invocation will only
    happen if there is actually a value to be invoked:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用ES2020的这种条件调用语法，你可以简单地使用`?.()`编写函数调用，只有在实际有值可调用时才会发生调用：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note, however, that `?.()` only checks whether the lefthand side is `null` or
    `undefined`. It does not verify that the value is actually a function. So the
    `square()` function in this example would still throw an exception if you passed
    two numbers to it, for example.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，`?.()`仅检查左侧是否为`null`或`undefined`。它不验证该值实际上是否为函数。因此，在这个例子中，如果你向`square()`函数传递两个数字，它仍会抛出异常。
- en: 'Like conditional property access expressions ([§4.4.1](#conditionalpropertyaccess)),
    function invocation with `?.()` is short-circuiting: if the value to the left
    of `?.` is `null` or `undefined`, then none of the argument expressions within
    the parentheses are evaluated:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于条件属性访问表达式（[§4.4.1](#conditionalpropertyaccess)），带有`?.()`的函数调用是短路的：如果`?.`左侧的值为`null`或`undefined`，则括号内的参数表达式都不会被评估：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Conditional invocation expressions with `?.()` work just as well for methods
    as they do for functions. But because method invocation also involves property
    access, it is worth taking a moment to be sure you understand the differences
    between the following expressions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`?.()`的条件调用表达式对方法和函数同样有效。但是因为方法调用还涉及属性访问，所以值得花点时间确保你理解以下表达式之间的区别：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the first expression, `o` must be an object with a property `m` and the value
    of that property must be a function. In the second expression, if `o` is `null`
    or `undefined`, then the expression evaluates to `undefined`. But if `o` has any
    other value, then it must have a property `m` whose value is a function. And in
    the third expression, `o` must not be `null` or `undefined`. If it does not have
    a property `m`, or if the value of that property is `null`, then the entire expression
    evaluates to `undefined`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个表达式中，`o`必须是一个具有属性`m`且该属性的值必须是一个函数的对象。在第二个表达式中，如果`o`为`null`或`undefined`，则表达式评估为`undefined`。但如果`o`有任何其他值，则它必须具有一个值为函数的属性`m`。在第三个表达式中，`o`不能为`null`或`undefined`。如果它没有属性`m`，或者该属性的值为`null`，则整个表达式评估为`undefined`。
- en: Conditional invocation with `?.()` is one of the newest features of JavaScript.
    As of the first months of 2020, this new syntax is supported in the current or
    beta versions of most major browsers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`?.()`进行条件调用是JavaScript的最新功能之一。截至2020年初，这种新语法在大多数主要浏览器的当前或测试版本中得到支持。
- en: 4.6 Object Creation Expressions
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 对象创建表达式
- en: 'An *object creation expression* creates a new object and invokes a function
    (called a constructor) to initialize the properties of that object. Object creation
    expressions are like invocation expressions except that they are prefixed with
    the keyword `new`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象创建表达式*创建一个新对象，并调用一个函数（称为构造函数）来初始化该对象的属性。对象创建表达式类似于调用表达式，只是它们以关键字`new`为前缀：'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If no arguments are passed to the constructor function in an object creation
    expression, the empty pair of parentheses can be omitted:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在对象创建表达式中未传递参数给构造函数，则可以省略空括号对：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The value of an object creation expression is the newly created object. Constructors
    are explained in more detail in [Chapter 9](ch09.xhtml#classes).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对象创建表达式的值是新创建的对象。构造函数在[第9章](ch09.xhtml#classes)中有更详细的解释。
- en: 4.7 Operator Overview
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 运算符概述
- en: Operators are used for JavaScript’s arithmetic expressions, comparison expressions,
    logical expressions, assignment expressions, and more. [Table 4-1](#operators)
    summarizes the operators and serves as a convenient reference.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符用于JavaScript的算术表达式，比较表达式，逻辑表达式，赋值表达式等。[表 4-1](#operators)总结了这些运算符，并作为一个方便的参考。
- en: Note that most operators are represented by punctuation characters such as `+`
    and `=`. Some, however, are represented by keywords such as `delete` and `instanceof`.
    Keyword operators are regular operators, just like those expressed with punctuation;
    they simply have a less succinct syntax.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数运算符由标点字符表示，如`+`和`=`。但是，有些运算符由关键字表示，如`delete`和`instanceof`。关键字运算符是常规运算符，就像用标点符号表示的那些一样；它们只是具有不太简洁的语法。
- en: '[Table 4-1](#operators) is organized by operator precedence. The operators
    listed first have higher precedence than those listed last. Operators separated
    by a horizontal line have different precedence levels. The column labeled A gives
    the operator associativity, which can be L (left-to-right) or R (right-to-left),
    and the column N specifies the number of operands. The column labeled Types lists
    the expected types of the operands and (after the → symbol) the result type for
    the operator. The subsections that follow the table explain the concepts of precedence,
    associativity, and operand type. The operators themselves are individually documented
    following that discussion.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](#operators)按运算符优先级进行组织。列出的运算符比最后列出的运算符具有更高的优先级。由水平线分隔的运算符具有不同的优先级级别。标记为A的列给出了运算符的结合性，可以是L（从左到右）或R（从右到左），列N指定了操作数的数量。标记为Types的列列出了操作数的预期类型和（在→符号之后）运算符的结果类型。表后面的子章节解释了优先级，结合性和操作数类型的概念。这些运算符本身在讨论之后分别进行了文档化。'
- en: Table 4-1\. JavaScript operators
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1\. JavaScript运算符
- en: '| Operator | Operation | A | N | Types |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 操作 | A | N | 类型 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `++` | Pre- or post-increment | R | 1 | lval→num |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 前置或后置递增 | R | 1 | lval→num |'
- en: '| `--` | Pre- or post-decrement | R | 1 | lval→num |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 前置或后置递减 | R | 1 | lval→num |'
- en: '| `-` | Negate number | R | 1 | num→num |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 取反数 | R | 1 | num→num |'
- en: '| `+` | Convert to number | R | 1 | any→num |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 转换为数字 | R | 1 | any→num |'
- en: '| `~` | Invert bits | R | 1 | int→int |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 反转位 | R | 1 | int→int |'
- en: '| `!` | Invert boolean value | R | 1 | bool→bool |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 反转布尔值 | R | 1 | bool→bool |'
- en: '| `delete` | Remove a property | R | 1 | lval→bool |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 删除属性 | R | 1 | lval→bool |'
- en: '| `typeof` | Determine type of operand | R | 1 | any→str |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `typeof` | 确定操作数的类型 | R | 1 | any→str |'
- en: '| `void` | Return undefined value | R | 1 | any→undef |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `void` | 返回未定义的值 | R | 1 | any→undef |'
- en: '| `**` | Exponentiate | R | 2 | num,num→num |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 指数 | R | 2 | num,num→num |'
- en: '| `*`, `/`, `%` | Multiply, divide, remainder | L | 2 | num,num→num |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `*`, `/`, `%` | 乘法，除法，取余 | L | 2 | num,num→num |'
- en: '| `+`, `-` | Add, subtract | L | 2 | num,num→num |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `+`, `-` | 加法，减法 | L | 2 | num,num→num |'
- en: '| `+` | Concatenate strings | L | 2 | str,str→str |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 连接字符串 | L | 2 | str,str→str |'
- en: '| `<<` | Shift left | L | 2 | int,int→int |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `<<` | 左移 | L | 2 | int,int→int |'
- en: '| `>>` | Shift right with sign extension | L | 2 | int,int→int |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 右移并用符号扩展 | L | 2 | int,int→int |'
- en: '| `>>>` | Shift right with zero extension | L | 2 | int,int→int |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `>>>` | 右移并用零扩展 | L | 2 | int,int→int |'
- en: '| `<`, `<=`,`>`, `>=` | Compare in numeric order | L | 2 | num,num→bool |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `<=`,`>`, `>=` | 按数字顺序比较 | L | 2 | num,num→bool |'
- en: '| `<`, `<=`,`>`, `>=` | Compare in alphabetical order | L | 2 | str,str→bool
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `<=`,`>`, `>=` | 按字母顺序比较 | L | 2 | str,str→bool |'
- en: '| `instanceof` | Test object class | L | 2 | obj,func→bool |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `instanceof` | 测试对象类 | L | 2 | obj,func→bool |'
- en: '| `in` | Test whether property exists | L | 2 | any,obj→bool |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `in` | 测试属性是否存在 | L | 2 | any,obj→bool |'
- en: '| `==` | Test for non-strict equality | L | 2 | any,any→bool |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 测试非严格相等性 | L | 2 | any,any→bool |'
- en: '| `!=` | Test for non-strict inequality | L | 2 | any,any→bool |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 测试非严格不等式 | L | 2 | any,any→bool |'
- en: '| `===` | Test for strict equality | L | 2 | any,any→bool |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `===` | 测试严格相等性 | L | 2 | any,any→bool |'
- en: '| `!==` | Test for strict inequality | L | 2 | any,any→bool |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `!==` | 测试严格不等式 | L | 2 | any,any→bool |'
- en: '| `&` | Compute bitwise AND | L | 2 | int,int→int |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 计算按位与 | L | 2 | int,int→int |'
- en: '| `^` | Compute bitwise XOR | L | 2 | int,int→int |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 计算按位异或 | L | 2 | int,int→int |'
- en: '| `&#124;` | Compute bitwise OR | L | 2 | int,int→int |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 计算按位或 | L | 2 | int,int→int |'
- en: '| `&&` | Compute logical AND | L | 2 | any,any→any |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 计算逻辑与 | L | 2 | any,any→any |'
- en: '| `&#124;&#124;` | Compute logical OR | L | 2 | any,any→any |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 计算逻辑或 | L | 2 | any,any→any |'
- en: '| `??` | Choose 1st defined operand | L | 2 | any,any→any |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `??` | 选择第一个定义的操作数 | L | 2 | any,any→any |'
- en: '| `?:` | Choose 2nd or 3rd operand | R | 3 | bool,any,any→any |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `?:` | 选择第二或第三个操作数 | R | 3 | bool,any,any→any |'
- en: '| `=` | Assign to a variable or property | R | 2 | lval,any→any |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 分配给变量或属性 | R | 2 | lval,any→any |'
- en: '| `**=`, `*=`, `/=`, `%=`, | Operate and assign | R | 2 | lval,any→any |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `**=`, `*=`, `/=`, `%=`, | 运算并赋值 | R | 2 | lval,any→any |'
- en: '| `+=`, `-=`, `&=`, `^=`, `&#124;=`, |  |  |  |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `+=`, `-=`, `&=`, `^=`, `&#124;=`, |  |  |  |  |'
- en: '| `<<=`, `>>=`, `>>>=` |  |  |  |  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `<<=`, `>>=`, `>>>=` |  |  |  |  |'
- en: '| `,` | Discard 1st operand, return 2nd | L | 2 | any,any→any |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 丢弃第一个操作数，返回第二个 | L | 2 | any,any→any |'
- en: 4.7.1 Number of Operands
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.1 操作数的数量
- en: Operators can be categorized based on the number of operands they expect (their
    *arity*). Most JavaScript operators, like the `*` multiplication operator, are
    *binary operators* that combine two expressions into a single, more complex expression.
    That is, they expect two operands. JavaScript also supports a number of *unary
    operators*, which convert a single expression into a single, more complex expression.
    The `−` operator in the expression `−x` is a unary operator that performs the
    operation of negation on the operand `x`. Finally, JavaScript supports one *ternary
    operator*, the conditional operator `?:`, which combines three expressions into
    a single expression.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符可以根据它们期望的操作数数量（它们的*arity*）进行分类。大多数 JavaScript 运算符，如 `*` 乘法运算符，都是将两个表达式组合成单个更复杂表达式的*二元运算符*。也就是说，它们期望两个操作数。JavaScript
    还支持许多*一元运算符*，它们将单个表达式转换为单个更复杂表达式。表达式 `−x` 中的 `−` 运算符是一个一元运算符，它对操作数 `x` 执行否定操作。最后，JavaScript
    支持一个*三元运算符*，条件运算符 `?:`，它将三个表达式组合成单个表达式。
- en: 4.7.2 Operand and Result Type
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.2 操作数和结果类型
- en: Some operators work on values of any type, but most expect their operands to
    be of a specific type, and most operators return (or evaluate to) a value of a
    specific type. The Types column in [Table 4-1](#operators) specifies operand types
    (before the arrow) and result type (after the arrow) for the operators.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运算符适用于任何类型的值，但大多数期望它们的操作数是特定类型的，并且大多数运算符返回（或计算为）特定类型的值。[表 4-1](#operators)
    中的类型列指定了运算符的操作数类型（箭头前）和结果类型（箭头后）。
- en: JavaScript operators usually convert the type (see [§3.9](ch03.xhtml#conversions))
    of their operands as needed. The multiplication operator `*` expects numeric operands,
    but the expression `"3" * "5"` is legal because JavaScript can convert the operands
    to numbers. The value of this expression is the number 15, not the string “15”,
    of course. Remember also that every JavaScript value is either “truthy” or “falsy,”
    so operators that expect boolean operands will work with an operand of any type.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 运算符通常根据需要转换操作数的类型（参见 [§3.9](ch03.xhtml#conversions)）。乘法运算符 `*` 需要数字操作数，但表达式
    `"3" * "5"` 是合法的，因为 JavaScript 可以将操作数转换为数字。这个表达式的值是数字 15，而不是字符串“15”，当然。还要记住，每个
    JavaScript 值都是“真值”或“假值”，因此期望布尔操作数的运算符将使用任何类型的操作数。
- en: Some operators behave differently depending on the type of the operands used
    with them. Most notably, the `+` operator adds numeric operands but concatenates
    string operands. Similarly, the comparison operators such as `<` perform comparison
    in numerical or alphabetical order depending on the type of the operands. The
    descriptions of individual operators explain their type-dependencies and specify
    what type conversions they perform.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运算符的行为取决于与它们一起使用的操作数的类型。最值得注意的是，`+` 运算符添加数字操作数，但连接字符串操作数。类似地，诸如 `<` 的比较运算符根据操作数的类型以数字或字母顺序执行比较。各个运算符的描述解释了它们的类型依赖性，并指定它们执行的类型转换。
- en: Notice that the assignment operators and a few of the other operators listed
    in [Table 4-1](#operators) expect an operand of type `lval`. *lvalue* is a historical
    term that means “an expression that can legally appear on the left side of an
    assignment expression.” In JavaScript, variables, properties of objects, and elements
    of arrays are lvalues.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注���，赋值运算符和 [表 4-1](#operators) 中列出的其他一些运算符期望类型为 `lval` 的操作数。*lvalue* 是一个历史术语，意思是“一个可以合法出现在赋值表达式左侧的表达式”。在
    JavaScript 中，变量、对象的属性和数组的元素都是 lvalues。
- en: 4.7.3 Operator Side Effects
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.3 运算符副作用
- en: 'Evaluating a simple expression like `2 * 3` never affects the state of your
    program, and any future computation your program performs will be unaffected by
    that evaluation. Some expressions, however, have *side effects*, and their evaluation
    may affect the result of future evaluations. The assignment operators are the
    most obvious example: if you assign a value to a variable or property, that changes
    the value of any expression that uses that variable or property. The `++` and
    `--` increment and decrement operators are similar, since they perform an implicit
    assignment. The `delete` operator also has side effects: deleting a property is
    like (but not the same as) assigning `undefined` to the property.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 评估简单表达式如 `2 * 3` 不会影响程序的状态，程序执行的任何未来计算也不会受到该评估的影响。然而，一些表达式具有*副作用*，它们的评估可能会影响未来评估的结果。赋值运算符是最明显的例子：如果将一个值赋给变量或属性，那么使用该变量或属性的任何表达式的值都会发生变化。`++`
    和 `--` 递增和递减运算符也类似，因为它们执行隐式赋值。`delete` 运算符也具有副作用：删除属性就像（但不完全相同于）将 `undefined`
    赋给属性。
- en: No other JavaScript operators have side effects, but function invocation and
    object creation expressions will have side effects if any of the operators used
    in the function or constructor body have side effects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他 JavaScript 运算符会产生副作用，但是如果函数调用和对象创建表达式中使用的任何运算符具有副作用，则会产生副作用。
- en: 4.7.4 Operator Precedence
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.4 运算符优先级
- en: The operators listed in [Table 4-1](#operators) are arranged in order from high
    precedence to low precedence, with horizontal lines separating groups of operators
    at the same precedence level. Operator precedence controls the order in which
    operations are performed. Operators with higher precedence (nearer the top of
    the table) are performed before those with lower precedence (nearer to the bottom).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](#operators) 中列出的运算符按照从高优先级到低优先级的顺序排列，水平线将同一优先级的运算符分组。运算符优先级控制操作执行的顺序。优先级较高的运算符（在表的顶部附近）在优先级较低的运算符（在表的底部附近）之前执行。'
- en: 'Consider the following expression:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表达式：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The multiplication operator `*` has a higher precedence than the addition operator
    `+`, so the multiplication is performed before the addition. Furthermore, the
    assignment operator `=` has the lowest precedence, so the assignment is performed
    after all the operations on the right side are completed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符`*`的优先级高于加法运算符`+`，因此先执行乘法。此外，赋值运算符`=`的优先级最低，因此在右侧所有操作完成后执行赋值。
- en: 'Operator precedence can be overridden with the explicit use of parentheses.
    To force the addition in the previous example to be performed first, write:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过显式使用括号来覆盖运算符的优先级。要求在上一个示例中首先执行加法，写成：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that property access and invocation expressions have higher precedence
    than any of the operators listed in [Table 4-1](#operators). Consider this expression:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性访问和调用表达式的优先级高于[表4-1](#operators)中列出的任何运算符。考虑以下表达式：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although `typeof` is one of the highest-priority operators, the `typeof` operation
    is performed on the result of the property access, array index, and function invocation,
    all of which have higher priority than operators.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`typeof`是优先级最高的运算符之一，但`typeof`操作是在属性访问、数组索引和函数调用的结果上执行的，所有这些操作的优先级都高于运算符。
- en: 'In practice, if you are at all unsure about the precedence of your operators,
    the simplest thing to do is to use parentheses to make the evaluation order explicit.
    The rules that are important to know are these: multiplication and division are
    performed before addition and subtraction, and assignment has very low precedence
    and is almost always performed last.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您对运算符的优先级有任何疑问，最简单的方法是使用括号使评估顺序明确。重要的规则是：乘法和除法在加法和减法之前执行��赋值的优先级非常低，几乎总是最后执行。
- en: When new operators are added to JavaScript, they do not always fit naturally
    into this precedence scheme. The `??` operator ([§4.13.2](#firstdefined)) is shown
    in the table as lower-precedence than `||` and `&&`, but, in fact, its precedence
    relative to those operators is not defined, and ES2020 requires you to explicitly
    use parentheses if you mix `??` with either `||` or `&&`. Similarly, the new `**`
    exponentiation operator does not have a well-defined precedence relative to the
    unary negation operator, and you must use parentheses when combining negation
    with exponentiation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的运算符添加到JavaScript时，它们并不总是自然地适应这个优先级方案。`??`运算符([§4.13.2](#firstdefined))在表中显示为比`||`和`&&`低优先级，但实际上，它相对于这些运算符的优先级没有定义，并且ES2020要求您在混合`??`与`||`或`&&`时明确使用括号。同样，新的`**`乘幂运算符相对于一元否定运算符没有明确定义的优先级，当将否定与乘幂结合时，必须使用括号。
- en: 4.7.5 Operator Associativity
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.5 运算符结合性
- en: 'In [Table 4-1](#operators), the column labeled A specifies the *associativity*
    of the operator. A value of L specifies left-to-right associativity, and a value
    of R specifies right-to-left associativity. The associativity of an operator specifies
    the order in which operations of the same precedence are performed. Left-to-right
    associativity means that operations are performed from left to right. For example,
    the subtraction operator has left-to-right associativity, so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表4-1](#operators)中，标记为A的列指定了运算符的*结合性*。L值指定左到右的结合性，R值指定右到左的结合性。运算符的结合性指定了相同优先级操作的执行顺序。左到右的结合性意味着操作从左到右执行。例如，减法运算符具有左到右的结合性，因此：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'is the same as:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On the other hand, the following expressions:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下表达式：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'are equivalent to:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: because the exponentiation, unary, assignment, and ternary conditional operators
    have right-to-left associativity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为乘幂、一元、赋值和三元条件运算符具有从右到左的结合性。
- en: 4.7.6 Order of Evaluation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7.6 评估顺序
- en: Operator precedence and associativity specify the order in which operations
    are performed in a complex expression, but they do not specify the order in which
    the subexpressions are evaluated. JavaScript always evaluates expressions in strictly
    left-to-right order. In the expression `w = x + y * z`, for example, the subexpression
    `w` is evaluated first, followed by `x`, `y`, and `z`. Then the values of `y`
    and `z` are multiplied, added to the value of `x`, and assigned to the variable
    or property specified by expression `w`. Adding parentheses to the expressions
    can change the relative order of the multiplication, addition, and assignment,
    but not the left-to-right order of evaluation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符的优先级和结合性指定复杂表达式中操作的执行顺序，但它们不指定子表达式的评估顺序。JavaScript总是严格按照从左到右的顺序评估表达式。例如，在表达式`w
    = x + y * z`中，首先评估子表达式`w`，然后是`x`、`y`和`z`。然后将`y`和`z`的值相乘，加上`x`的值，并将结果赋给表达式`w`指定的变量或属性。添加括号可以改变乘法、加法和赋值的相对顺序，但不能改变从左到右的评估顺序。
- en: Order of evaluation only makes a difference if any of the expressions being
    evaluated has side effects that affect the value of another expression. If expression
    `x` increments a variable that is used by expression `z`, then the fact that `x`
    is evaluated before `z` is important.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 评估顺序只有在正在评估的任何表达式具有影响另一个表达式值的副作用时才会有所不同。如果表达式`x`增加了一个被表达式`z`使用的变量，那么评估`x`在`z`之前的事实就很重要。
- en: 4.8 Arithmetic Expressions
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 算术表达式
- en: This section covers the operators that perform arithmetic or other numerical
    manipulations on their operands. The exponentiation, multiplication, division,
    and subtraction operators are straightforward and are covered first. The addition
    operator gets a subsection of its own because it can also perform string concatenation
    and has some unusual type conversion rules. The unary operators and the bitwise
    operators are also covered in subsections of their own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖对操作数执行算术或其他数值操作的运算符。乘幂、乘法、除法和减法运算符是直接的，并且首先进行讨论。加法运算符有自己的子节，因为它还可以执行字符串连接，并且具有一些不寻常的类型转换规则。一元运算符和位运算符也有自己的子节。
- en: Most of these arithmetic operators (except as noted as follows) can be used
    with BigInt (see [§3.2.5](ch03.xhtml#bigint)) operands or with regular numbers,
    as long as you don’t mix the two types.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算术运算符中的大多数（除非另有说明如下）可以与 BigInt（参见 [§3.2.5](ch03.xhtml#bigint)）操作数或常规数字一起使用，只要不混合这两种类型。
- en: 'The basic arithmetic operators are `**` (exponentiation), `*` (multiplication),
    `/` (division), `%` (modulo: remainder after division), `+` (addition), and `-`
    (subtraction). As noted, we’ll discuss the `+` operator in a section of its own.
    The other five basic operators simply evaluate their operands, convert the values
    to numbers if necessary, and then compute the power, product, quotient, remainder,
    or difference. Non-numeric operands that cannot convert to numbers convert to
    the `NaN` value. If either operand is (or converts to) `NaN`, the result of the
    operation is (almost always) `NaN`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基本算术运算符包括 `**`（指数运算），`*`（乘法），`/`（除法），`%`（取模：除法后的余数），`+`（加法）和 `-`（减法）。正如前面所述，我们将在单独的章节讨论
    `+` 运算符。其他五个基本运算符只是评估它们的操作数，必要时将值转换为数字，然后计算幂、乘积、商、余数或差。无法转换为数字的非数字操作数将转换为 `NaN`
    值。如果任一操作数为（或转换为）`NaN`，则操作的结果（几乎总是）为 `NaN`。
- en: 'The `**` operator has higher precedence than `*`, `/`, and `%` (which in turn
    have higher precedence than `+` and `-`). Unlike the other operators, `**` works
    right-to-left, so `2**2**3` is the same as `2**8`, not `4**3`. There is a natural
    ambiguity to expressions like `-3**2`. Depending on the relative precedence of
    unary minus and exponentiation, that expression could mean `(-3)**2` or `-(3**2)`.
    Different languages handle this differently, and rather than pick sides, JavaScript
    simply makes it a syntax error to omit parentheses in this case, forcing you to
    write an unambiguous expression. `**` is JavaScript’s newest arithmetic operator:
    it was added to the language with ES2016\. The `Math.pow()` function has been
    available since the earliest versions of JavaScript, however, and it performs
    exactly the same operation as the `**` operator.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`**` 运算符的优先级高于 `*`，`/` 和 `%`（这些运算符的优先级又高于 `+` 和 `-`）。与其他运算符不同，`**` 从右到左工作，因此
    `2**2**3` 等同于 `2**8`，而不是 `4**3`。表达式 `-3**2` 存在自然的歧义。根据一元减号和指数运算符的相对优先级，该表达式可能表示
    `(-3)**2` 或 `-(3**2)`。不同的语言处理方式不同，而 JavaScript 简单地使得在这种情况下省略括号成为语法错误，强制您编写一个明确的表达式。`**`
    是 JavaScript 最新的算术运算符：它是在 ES2016 版本中添加到语言中的。然而，`Math.pow()` 函数自最早版本的 JavaScript
    就已经可用，并且执行的操作与 `**` 运算符完全相同。'
- en: 'The `/` operator divides its first operand by its second. If you are used to
    programming languages that distinguish between integer and floating-point numbers,
    you might expect to get an integer result when you divide one integer by another.
    In JavaScript, however, all numbers are floating-point, so all division operations
    have floating-point results: `5/2` evaluates to `2.5`, not `2`. Division by zero
    yields positive or negative infinity, while `0/0` evaluates to `NaN`: neither
    of these cases raises an error.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 运算符将其第一个操作数除以第二个操作数。如果您习惯于区分整数和浮点数的编程语言，当您将一个整数除以另一个整数时，您可能期望得到一个整数结果。然而，在
    JavaScript 中，所有数字都是浮点数，因此所有除法操作都具有浮点结果：`5/2` 的结果为 `2.5`，而不是 `2`。除以零会产生正无穷大或负无穷大，而
    `0/0` 的结果为 `NaN`：这两种情况都不会引发错误。'
- en: The `%` operator computes the first operand modulo the second operand. In other
    words, it returns the remainder after whole-number division of the first operand
    by the second operand. The sign of the result is the same as the sign of the first
    operand. For example, `5 % 2` evaluates to `1`, and `-5 % 2` evaluates to `-1`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`%` 运算符计算第一个操作数对第二个操作数的模。换句话说，它返回第一个操作数除以第二个操作数的整数除法后的余数。结果的符号与第一个操作数的符号相同。例如，`5
    % 2` 的结果为 `1`，`-5 % 2` 的结果为 `-1`。'
- en: While the modulo operator is typically used with integer operands, it also works
    for floating-point values. For example, `6.5 % 2.1` evaluates to `0.2`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管取模运算符通常用于整数操作数，但它也适用于浮点值。例如，`6.5 % 2.1` 的结果为 `0.2`。
- en: 4.8.1 The + Operator
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.1 `+` 运算符
- en: 'The binary `+` operator adds numeric operands or concatenates string operands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 二元 `+` 运算符添加数字操作数或连接字符串操作数：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the values of both operands are numbers, or are both strings, then it
    is obvious what the `+` operator does. In any other case, however, type conversion
    is necessary, and the operation to be performed depends on the conversion performed.
    The conversion rules for `+` give priority to string concatenation: if either
    of the operands is a string or an object that converts to a string, the other
    operand is converted to a string and concatenation is performed. Addition is performed
    only if neither operand is string-like.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个操作数的值都是数字，或者都是字符串时，`+` 运算符的作用是显而易见的。然而，在任何其他情况下，都需要进行类型转换，并且要执行的操作取决于所执行的转换。`+`
    的转换规则优先考虑字符串连接：如果其中一个操作数是字符串或可转换为字符串的对象，则另一个操作数将被转换为字符串并执行连接。只有当两个操作数都不像字符串时才执行加法。
- en: 'Technically, the `+` operator behaves like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`+` 运算符的行为如下：
- en: If either of its operand values is an object, it converts it to a primitive
    using the object-to-primitive algorithm described in [§3.9.3](ch03.xhtml#objtoprim).
    Date objects are converted by their `toString()` method, and all other objects
    are converted via `valueOf()`, if that method returns a primitive value. However,
    most objects do not have a useful `valueOf()` method, so they are converted via
    `toString()` as well.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果其操作数值中的任一值为对象，则它将使用 [§3.9.3](ch03.xhtml#objtoprim) 中描述的对象转换为原始值算法将其转换为原始值。日期对象通过其
    `toString()` 方法转换，而所有其他对象通过 `valueOf()` 转换，如果该方法返回原始值。然而，大多数对象没有有用的 `valueOf()`
    方法，因此它们也通过 `toString()` 转换。
- en: After object-to-primitive conversion, if either operand is a string, the other
    is converted to a string and concatenation is performed.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象转换为原始值之后，如果其中一个操作数是字符串，则另一个操作数将被转换为字符串并执行连接。
- en: Otherwise, both operands are converted to numbers (or to `NaN`) and addition
    is performed.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，两个操作数将被转换为数字（或 `NaN`），然后执行加法。
- en: 'Here are some examples:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, it is important to note that when the `+` operator is used with strings
    and numbers, it may not be associative. That is, the result may depend on the
    order in which operations are performed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要注意，当 `+` 运算符与字符串和数字一起使用时，它可能不是结合的。也就是说，结果可能取决于操作执行的顺序。
- en: 'For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first line has no parentheses, and the `+` operator has left-to-right associativity,
    so the two numbers are added first, and their sum is concatenated with the string.
    In the second line, parentheses alter this order of operations: the number 2 is
    concatenated with the string to produce a new string. Then the number 1 is concatenated
    with the new string to produce the final result.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行没有括号，`+` 运算符具有从左到右的结合性，因此先将两个数字相加，然后将它们的和与字符串连接起来。在第二行中，括号改变了操作顺序：数字 2 与字符串连接以产生一个新字符串。然后数字
    1 与新字符串连接以产生最终结果。
- en: 4.8.2 Unary Arithmetic Operators
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.2 一元算术运算符
- en: Unary operators modify the value of a single operand to produce a new value.
    In JavaScript, the unary operators all have high precedence and are all right-associative.
    The arithmetic unary operators described in this section (`+`, `-`, `++`, and
    `--`) all convert their single operand to a number, if necessary. Note that the
    punctuation characters `+` and `-` are used as both unary and binary operators.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符修改单个操作数的值以产生一个新值。在 JavaScript 中，所有一元运算符都具有高优先级，并且都是右结合的。本节描述的算术一元运算符（`+`、`-`、`++`
    和 `--`）都将其单个操作数转换为数字（如果需要的话）。请注意，标点字符 `+` 和 `-` 既用作一元运算符又用作二元运算符。
- en: 'The unary arithmetic operators are the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一元算术运算符：
- en: '*Unary plus* (`+`)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元加*（`+`）'
- en: The unary plus operator converts its operand to a number (or to `NaN`) and returns
    that converted value. When used with an operand that is already a number, it doesn’t
    do anything. This operator may not be used with BigInt values, since they cannot
    be converted to regular numbers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一元加运算符将其操作数转换为数字（或 `NaN`）并返回该转换后的值。当与已经是数字的操作数一起使用时，它不会执行任何操作。由于 BigInt 值无法转换为常规数字，因此不能使用此运算符。
- en: '*Unary minus* (`-`)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*一元减*（`-`）'
- en: When `-` is used as a unary operator, it converts its operand to a number, if
    necessary, and then changes the sign of the result.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `-` 作为一元运算符使用时，它将其操作数转换为数字（如果需要的话），然后改变结果的符号。
- en: '*Increment* (`++`)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*递增*（`++`）'
- en: The `++` operator increments (i.e., adds 1 to) its single operand, which must
    be an lvalue (a variable, an element of an array, or a property of an object).
    The operator converts its operand to a number, adds 1 to that number, and assigns
    the incremented value back into the variable, element, or property.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 运算符递增（即加 1）其单个操作数，该操作数必须是左值（变量、数组元素或对象的属性）。该运算符将其操作数转换为数字，将 1 添加到该数字，并将递增后的值重新赋给变量、元素或属性。'
- en: 'The return value of the `++` operator depends on its position relative to the
    operand. When used before the operand, where it is known as the pre-increment
    operator, it increments the operand and evaluates to the incremented value of
    that operand. When used after the operand, where it is known as the post-increment
    operator, it increments its operand but evaluates to the *unincremented* value
    of that operand. Consider the difference between these two lines of code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`++` 运算符的返回值取决于其相对于操作数的位置。当在操作数之前使用时，称为前增量运算符，它递增操作数并计算该操作数的递增值。当在操作数之后使用时，称为后增量运算符，它递增其操作数但计算该操作数的*未递增*值。考虑以下两行代码之间的区别：'
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that the expression `x++` is not always the same as `x=x+1`. The `++`
    operator never performs string concatenation: it always converts its operand to
    a number and increments it. If `x` is the string “1”, `++x` is the number 2, but
    `x+1` is the string “11”.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意表达式 `x++` 不总是等同于 `x=x+1`。`++` 运算符永远不会执行字符串连接：它总是将其操作数转换为数字并递增。如果 `x` 是字符串“1”，`++x`
    是数字 2，但 `x+1` 是字符串“11”。
- en: Also note that, because of JavaScript’s automatic semicolon insertion, you cannot
    insert a line break between the post-increment operator and the operand that precedes
    it. If you do so, JavaScript will treat the operand as a complete statement by
    itself and insert a semicolon before it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，由于 JavaScript 的自动分号插入，您不能在后增量运算符和其前面的操作数之间插入换行符。如果这样做，JavaScript 将把操作数视为一个独立的完整语句，并在其前插入一个分号。
- en: This operator, in both its pre- and post-increment forms, is most commonly used
    to increment a counter that controls a `for` loop ([§5.4.3](ch05.xhtml#forloop)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符，在其前增量和后增量形式中，最常用于递增控制 `for` 循环的计数器（[§5.4.3](ch05.xhtml#forloop)）。
- en: '*Decrement* (`--`)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*递减*（`--`）'
- en: The `--` operator expects an lvalue operand. It converts the value of the operand
    to a number, subtracts 1, and assigns the decremented value back to the operand.
    Like the `++` operator, the return value of `--` depends on its position relative
    to the operand. When used before the operand, it decrements and returns the decremented
    value. When used after the operand, it decrements the operand but returns the
    *undecremented* value. When used after its operand, no line break is allowed between
    the operand and the operator.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`--` 运算符期望一个左值操作数。它将操作数的值转换为数字，减去 1，并将减少后的值重新赋给操作数。与 `++` 运算符一样，`--` 的返回值取决于其相对于操作数的位置。当在操作数之前使用时，它减少并返回减少后的值。当在操作数之后使用时，它减少操作数但返回*未减少*的值。在操作数之后使用时，不允许换行符。'
- en: 4.8.3 Bitwise Operators
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8.3 位运算符
- en: The bitwise operators perform low-level manipulation of the bits in the binary
    representation of numbers. Although they do not perform traditional arithmetic
    operations, they are categorized as arithmetic operators here because they operate
    on numeric operands and return a numeric value. Four of these operators perform
    Boolean algebra on the individual bits of the operands, behaving as if each bit
    in each operand were a boolean value (1=true, 0=false). The other three bitwise
    operators are used to shift bits left and right. These operators are not commonly
    used in JavaScript programming, and if you are not familiar with the binary representation
    of integers, including the two’s complement representation of negative integers,
    you can probably skip this section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符对数字的二进制表示中的位进行低级别操作。虽然它们不执行传统的算术运算，但在这里被归类为算术运算符，因为它们对数字操作并返回一个数字值。这四个运算符对操作数的各个位执行布尔代数运算，表现得好像每个操作数中的每个位都是一个布尔值（1=true，0=false）。另外三个位运算符用于左移和右移位。这些运算符在JavaScript编程中并不常用，如果你不熟悉整数的二进制表示，包括负整数的二进制补码表示，那么你可能可以跳过这一部分。
- en: The bitwise operators expect integer operands and behave as if those values
    were represented as 32-bit integers rather than 64-bit floating-point values.
    These operators convert their operands to numbers, if necessary, and then coerce
    the numeric values to 32-bit integers by dropping any fractional part and any
    bits beyond the 32nd. The shift operators require a right-side operand between
    0 and 31. After converting this operand to an unsigned 32-bit integer, they drop
    any bits beyond the 5th, which yields a number in the appropriate range. Surprisingly,
    `NaN`, `Infinity`, and `-Infinity` all convert to 0 when used as operands of these
    bitwise operators.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符期望整数操作数，并表现得好像这些值被表示为32位整数而不是64位浮点值。这些运算符将它们的操作数转换为数字，如果需要的话，然后通过丢弃任何小数部分和超过第32位的任何位来将数值值强制转换为32位整数。移位运算符需要一个右侧操作数，介于0和31之间。在将此操作数转换为无符号32位整数后，它们会丢弃超过第5位的任何位，从而得到适当范围内的数字。令人惊讶的是，当这些位运算符的操作数时，`NaN`、`Infinity`
    和 `-Infinity` 都会转换为0。
- en: All of these bitwise operators except `>>>` can be used with regular number
    operands or with BigInt (see [§3.2.5](ch03.xhtml#bigint)) operands.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些位运算符除了 `>>>` 都可以与常规数字操作数或 BigInt（参见 [§3.2.5](ch03.xhtml#bigint)）操作数一起使用。
- en: '*Bitwise AND* (`&`)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*位与* (`&`)'
- en: The `&` operator performs a Boolean AND operation on each bit of its integer
    arguments. A bit is set in the result only if the corresponding bit is set in
    both operands. For example, `0x1234 & 0x00FF` evaluates to `0x0034`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 运算符对其整数参数的每个位执行布尔与操作。只有在两个操作数中相应的位都设置时，结果中才设置一个位。例如，`0x1234 & 0x00FF` 的计算结果为
    `0x0034`。'
- en: '*Bitwise OR* (`|`)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*位或* (`|`)'
- en: The `|` operator performs a Boolean OR operation on each bit of its integer
    arguments. A bit is set in the result if the corresponding bit is set in one or
    both of the operands. For example, `0x1234 | 0x00FF` evaluates to `0x12FF`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 运算符对其整数参数的每个位执行布尔或操作。如果相应的位在一个或两个操作数中的一个或两个中设置，则结果中设置一个位。例如，`0x1234 | 0x00FF`
    的计算结果为 `0x12FF`。'
- en: '*Bitwise XOR* (`^`)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*位异或* (`^`)'
- en: The `^` operator performs a Boolean exclusive OR operation on each bit of its
    integer arguments. Exclusive OR means that either operand one is `true` or operand
    two is `true`, but not both. A bit is set in this operation’s result if a corresponding
    bit is set in one (but not both) of the two operands. For example, `0xFF00 ^ 0xF0F0`
    evaluates to `0x0FF0`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`^` 运算符对其整数参数的每个位执行布尔异或操作。异或意味着操作数一为 `true` 或操作数二为 `true`，但不是两者都为 `true`。如果在这个操作的结果中设置了一个相应的位，则表示两个操作数中的一个（但不是两个）中设置了一个位。例如，`0xFF00
    ^ 0xF0F0` 的计算结果为 `0x0FF0`。'
- en: '*Bitwise NOT* (`~`)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*位非* (`~`)'
- en: The `~` operator is a unary operator that appears before its single integer
    operand. It operates by reversing all bits in the operand. Because of the way
    signed integers are represented in JavaScript, applying the `~` operator to a
    value is equivalent to changing its sign and subtracting 1\. For example, `~0x0F`
    evaluates to `0xFFFFFFF0`, or −16.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`~` 运算符是一个一元运算符，出现在其单个整数操作数之前。它通过反转操作数中的所有位来运行。由于JavaScript中有符号整数的表示方式，将 `~`
    运算符应用于一个值等同于改变其符号并减去1。例如，`~0x0F` 的计算结果为 `0xFFFFFFF0`，或者 −16。'
- en: '*Shift left* (`<<`)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*左移* (`<<`)'
- en: The `<<` operator moves all bits in its first operand to the left by the number
    of places specified in the second operand, which should be an integer between
    0 and 31\. For example, in the operation `a << 1`, the first bit (the ones bit)
    of `a` becomes the second bit (the twos bit), the second bit of `a` becomes the
    third, etc. A zero is used for the new first bit, and the value of the 32nd bit
    is lost. Shifting a value left by one position is equivalent to multiplying by
    2, shifting two positions is equivalent to multiplying by 4, and so on. For example,
    `7 << 2` evaluates to 28.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<` 运算符将其第一个操作数中的所有位向左移动指定的位数，该位数应为介于0和31之间的整数。例如，在操作 `a << 1` 中，`a` 的第一位（个位）变为第二位（十位），`a`
    的第二位变为第三位，依此类推。新的第一位使用零，第32位的值丢失。将一个值左移一位等同于乘以2，将两个位置左移等同于乘以4，依此类推。例如，`7 << 2`
    的计算结果为28。'
- en: '*Shift right with sign* (`>>`)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*带符号右移* (`>>`)'
- en: The `>>` operator moves all bits in its first operand to the right by the number
    of places specified in the second operand (an integer between 0 and 31). Bits
    that are shifted off the right are lost. The bits filled in on the left depend
    on the sign bit of the original operand, in order to preserve the sign of the
    result. If the first operand is positive, the result has zeros placed in the high
    bits; if the first operand is negative, the result has ones placed in the high
    bits. Shifting a positive value right one place is equivalent to dividing by 2
    (discarding the remainder), shifting right two places is equivalent to integer
    division by 4, and so on. `7 >> 1` evaluates to 3, for example, but note that
    and `−7 >> 1` evaluates to −4.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>` 运算符将其第一个操作数中的所有位向右移动指定的位数（一个介于0和31之间的整数）。向右移动的位将丢失。左侧填充的位取决于原始操作数的符号位，以保留结果的符号。如果第一个操作数是正数，则结果的高位为零；如果第一个操作数是负数，则结果的高位为一。向右移动一个正值相当于除以2（舍弃余数），向右移动两个位置相当于整数除以4，依此类推。例如，`7
    >> 1` 的结果为3，但请注意`−7 >> 1` 的结果为−4。'
- en: '*Shift right with zero fill* (`>>>`)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*零填充右移* (`>>>`)'
- en: The `>>>` operator is just like the `>>` operator, except that the bits shifted
    in on the left are always zero, regardless of the sign of the first operand. This
    is useful when you want to treat signed 32-bit values as if they are unsigned
    integers. `−1 >> 4` evaluates to −1, but `−1 >>> 4` evaluates to `0x0FFFFFFF`,
    for example. This is the only one of the JavaScript bitwise operators that cannot
    be used with BigInt values. BigInt does not represent negative numbers by setting
    the high bit the way that 32-bit integers do, and this operator only makes sense
    for that particular two’s complement representation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>` 运算符与 `>>` 运算符类似，只是左侧移入的位始终为零，不管第一个操作数的符号如何。当您希望将有符号的32位值视为无符号整数时，这很有用。例如，`−1
    >> 4` 的结果为−1，但`−1 >>> 4` 的结果为`0x0FFFFFFF`。这是JavaScript按位运算符中唯一不能与BigInt值一起使用的运算符。BigInt不通过设置高位来表示负数，而是通过特定的二进制补码表示。'
- en: 4.9 Relational Expressions
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.9 关系表达式
- en: This section describes JavaScript’s relational operators. These operators test
    for a relationship (such as “equals,” “less than,” or “property of”) between two
    values and return `true` or `false` depending on whether that relationship exists.
    Relational expressions always evaluate to a boolean value, and that value is often
    used to control the flow of program execution in `if`, `while`, and `for` statements
    (see [Chapter 5](ch05.xhtml#statements)). The subsections that follow document
    the equality and inequality operators, the comparison operators, and JavaScript’s
    other two relational operators, `in` and `instanceof`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了JavaScript的关系运算符。这些运算符测试两个值之间的关系（如“相等”，“小于”或“属性”），并根据该关系是否存在返回`true`或`false`。关系表达式始终评估为布尔值，并且该值通常用于控制程序执行在`if`，`while`和`for`语句中的流程（参见[第5章](ch05.xhtml#statements)）。接下来的小节记录了相等和不等运算符，比较运算符以及JavaScript的另外两个关系运算符`in`和`instanceof`。
- en: 4.9.1 Equality and Inequality Operators
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.1 相等和不等运算符
- en: The `==` and `===` operators check whether two values are the same, using two
    different definitions of sameness. Both operators accept operands of any type,
    and both return `true` if their operands are the same and `false` if they are
    different. The `===` operator is known as the strict equality operator (or sometimes
    the identity operator), and it checks whether its two operands are “identical”
    using a strict definition of sameness. The `==` operator is known as the equality
    operator; it checks whether its two operands are “equal” using a more relaxed
    definition of sameness that allows type conversions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`==` 和 `===` 运算符检查两个值是否相同，使用两种不同的相同定义。这两个运算符接受任何类型的操作数，并且如果它们的操作数相同则返回`true`，如果它们不同则返回`false`。`===`
    运算符被称为严格相等运算符（有时称为身份运算符），它使用严格的相同定义来检查其两个操作数是否“相同”。`==` 运算符被称为相等运算符；它使用更宽松的相同定义来检查其两个操作数是否“相等”，允许类型转换。'
- en: The `!=` and `!==` operators test for the exact opposite of the `==` and `===`
    operators. The `!=` inequality operator returns `false` if two values are equal
    to each other according to `==` and returns `true` otherwise. The `!==` operator
    returns `false` if two values are strictly equal to each other and returns `true`
    otherwise. As you’ll see in [§4.10](#logicalexprs), the `!` operator computes
    the Boolean NOT operation. This makes it easy to remember that `!=` and `!==`
    stand for “not equal to” and “not strictly equal to.”
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`!=` 和 `!==` 运算符测试`==` 和 `===` 运算符的确刚好相反。`!=` 不等运算符如果两个值根据`==`相等则返回`false`，否则返回`true`。`!==`
    运算符如果两个值严格相等则返回`false`，否则返回`true`。正如您将在[§4.10](#logicalexprs)中看到的，`!` 运算符计算布尔非操作。这使得很容易记住`!=`
    和 `!==` 代表“不等于”和“不严格相等于”。'
- en: As mentioned in [§3.8](ch03.xhtml#mutableandimmutable), JavaScript objects are
    compared by reference, not by value. An object is equal to itself, but not to
    any other object. If two distinct objects have the same number of properties,
    with the same names and values, they are still not equal. Similarly, two arrays
    that have the same elements in the same order are not equal to each other.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如[§3.8](ch03.xhtml#mutableandimmutable)中所述，JavaScript对象通过引用而不是值进��比较。对象等于自身，但不等于任何其他对象。如果两个不同的对象具有相同数量的属性，具有相同名称和值，则它们仍然不相等。同样，具有相同顺序的相同元素的两个数组也不相等。
- en: Strict equality
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格相等
- en: 'The strict equality operator `===` evaluates its operands, then compares the
    two values as follows, performing no type conversion:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等运算符`===`评估其操作数，然后按照以下方式比较两个值，不执行任何类型转换：
- en: If the two values have different types, they are not equal.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值具有不同的类型，则它们不相等。
- en: If both values are `null` or both values are `undefined`, they are equal.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值都是`null`或两个值都是`undefined`，它们是相等的。
- en: If both values are the boolean value `true` or both are the boolean value `false`,
    they are equal.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值都是布尔值`true`或都是布尔值`false`，它们是相等的。
- en: If one or both values is `NaN`, they are not equal. (This is surprising, but
    the `NaN` value is never equal to any other value, including itself! To check
    whether a value `x` is `NaN`, use `x !== x`, or the global `isNaN()` function.)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个或两个值是`NaN`，它们不相等。（这很令人惊讶，但`NaN`值永远不等于任何其他值，包括它自己！要检查值`x`是否为`NaN`，请使用`x !==
    x`或全局的`isNaN()`函数。）
- en: If both values are numbers and have the same value, they are equal. If one value
    is `0` and the other is `-0`, they are also equal.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值都是数字且具有相同的值，则它们是相等的。如果一个值是`0`，另一个是`-0`，它们也是相等的。
- en: If both values are strings and contain exactly the same 16-bit values (see the
    sidebar in [§3.3](ch03.xhtml#text)) in the same positions, they are equal. If
    the strings differ in length or content, they are not equal. Two strings may have
    the same meaning and the same visual appearance, but still be encoded using different
    sequences of 16-bit values. JavaScript performs no Unicode normalization, and
    a pair of strings like this is not considered equal to the `===` or `==` operators.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值都是字符串且包含完全相同的16位值（参见[§3.3](ch03.xhtml#text)中的侧边栏）且位置相同，则它们是相等的。如果字符串在长度或内容上有所不同，则它们不相等。两个字符串可能具有相同的含义和相同的视觉外观，但仍然使用不同的16位值序列进行编码。JavaScript不执行Unicode规范化，因此这样的一对字符串不被认为等于`===`或`==`运算符。
- en: If both values refer to the same object, array, or function, they are equal.
    If they refer to different objects, they are not equal, even if both objects have
    identical properties.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值引用相同的对象、数组或函数，则它们是相等的。如果它们引用不同的对象，则它们不相等，即使两个对象具有相同的属性。
- en: Equality with type conversion
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带类型转换的相等性
- en: 'The equality operator `==` is like the strict equality operator, but it is
    less strict. If the values of the two operands are not the same type, it attempts
    some type conversions and tries the comparison again:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 相等运算符`==`类似于严格相等运算符，但它不那么严格。如果两个操作数的值不是相同类型，则它尝试一些类型转换并再次尝试比较：
- en: If the two values have the same type, test them for strict equality as described
    previously. If they are strictly equal, they are equal. If they are not strictly
    equal, they are not equal.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值具有相同的类型，请按照前面描述的严格相等性进行测试。如果它们严格相等，则它们是相等的。如果它们不严格相等，则它们不相等。
- en: 'If the two values do not have the same type, the `==` operator may still consider
    them equal. It uses the following rules and type conversions to check for equality:'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值的类型不同，`==`运算符可能仍然认为它们相等。它使用以下规则和类型转换来检查相等性：
- en: If one value is `null` and the other is `undefined`, they are equal.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个值是`null`，另一个是`undefined`，它们是相等的。
- en: If one value is a number and the other is a string, convert the string to a
    number and try the comparison again, using the converted value.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个值是数字，另一个是字符串，则将字符串转换为数字，然后使用转换后的值再次尝试比较。
- en: If either value is `true`, convert it to 1 and try the comparison again. If
    either value is `false`, convert it to 0 and try the comparison again.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一值为`true`，则将其转换为1，然后再次尝试比较。如果任一值为`false`，则将其转换为0，然后再次尝试比较。
- en: If one value is an object and the other is a number or string, convert the object
    to a primitive using the algorithm described in [§3.9.3](ch03.xhtml#objtoprim)
    and try the comparison again. An object is converted to a primitive value by either
    its `toString()` method or its `valueOf()` method. The built-in classes of core
    JavaScript attempt `valueOf()` conversion before `toString()` conversion, except
    for the Date class, which performs `toString()` conversion.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个值是对象，另一个是数字或字符串，则使用[§3.9.3](ch03.xhtml#objtoprim)中描述的算法将对象转换为原始值，然后再次尝试比较。对象通过其`toString()`方法或`valueOf()`方法转换为原始值。核心JavaScript的内置类在执行`toString()`转换之前尝试`valueOf()`转换，但Date类除外，它执行`toString()`转换。
- en: Any other combinations of values are not equal.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他值的组合都不相等。
- en: 'As an example of testing for equality, consider the comparison:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为相等性测试的一个例子，考虑比较：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This expression evaluates to `true`, indicating that these very different-looking
    values are in fact equal. The boolean value `true` is first converted to the number
    1, and the comparison is done again. Next, the string `"1"` is converted to the
    number 1\. Since both values are now the same, the comparison returns `true`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此表达式求值为`true`，表示这些外观非常不同的值实际上是相等的。布尔值`true`首先转换为数字1，然后再次进行比较。接下来，字符串`"1"`转换为数字1。由于现在两个值相同，比较返回`true`。
- en: 4.9.2 Comparison Operators
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.2 比较运算符
- en: 'The comparison operators test the relative order (numerical or alphabetical)
    of their two operands:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较运算符测试它们的两个操作数的相对顺序（数字或字母）：
- en: '*Less than* (`<`)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*小于* (`<`)'
- en: The `<` operator evaluates to `true` if its first operand is less than its second
    operand; otherwise, it evaluates to `false`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`运算符在其第一个操作数小于第二个操作数时求值为`true`；否则，求值为`false`。'
- en: '*Greater than* (`>`)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*大于* (`>`)'
- en: The `>` operator evaluates to `true` if its first operand is greater than its
    second operand; otherwise, it evaluates to `false`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`运算符在其第一个操作数大于第二个操作数时求值为`true`；否则，求值为`false`。'
- en: '*Less than or equal* (`<=`)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*小于或等于* (`<=`)'
- en: The `<=` operator evaluates to `true` if its first operand is less than or equal
    to its second operand; otherwise, it evaluates to `false`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`<=`运算符在其第一个操作数小于或等于第二个操作数时求值为`true`；否则，求值为`false`。'
- en: '*Greater than or equal* (`>=`)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*大于或等于* (`>=`)'
- en: The `>=` operator evaluates to `true` if its first operand is greater than or
    equal to its second operand; otherwise, it evaluates to `false`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`>=`运算符在其第一个操作数大于或等于第二个操作数时求值为`true`；否则，求值为`false`。'
- en: The operands of these comparison operators may be of any type. Comparison can
    be performed only on numbers and strings, however, so operands that are not numbers
    or strings are converted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些比较运算符的操作数可以是任何类型。但是，比较只能在数字和字符串上执行，因此不��数字或字符串的操作数将被转换。
- en: 'Comparison and conversion occur as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 比较和转换如下进行：
- en: If either operand evaluates to an object, that object is converted to a primitive
    value, as described at the end of [§3.9.3](ch03.xhtml#objtoprim); if its `valueOf()`
    method returns a primitive value, that value is used. Otherwise, the return value
    of its `toString()` method is used.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任一操作数评估为对象，则将该对象转换为原始值，如[§3.9.3](ch03.xhtml#objtoprim)末尾所述；如果其`valueOf()`方法返回原始值，则使用该值。否则，使用其`toString()`方法的返回值。
- en: If, after any required object-to-primitive conversion, both operands are strings,
    the two strings are compared, using alphabetical order, where “alphabetical order”
    is defined by the numerical order of the 16-bit Unicode values that make up the
    strings.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在任何必要的对象到原始值转换后，两个操作数都是字符串，则比较这两个字符串，使用字母顺序，其中“字母顺序”由组成字符串的16位Unicode值的数值顺序定义。
- en: If, after object-to-primitive conversion, at least one operand is not a string,
    both operands are converted to numbers and compared numerically. `0` and `-0`
    are considered equal. `Infinity` is larger than any number other than itself,
    and `-Infinity` is smaller than any number other than itself. If either operand
    is (or converts to) `NaN`, then the comparison operator always returns `false`.
    Although the arithmetic operators do not allow BigInt values to be mixed with
    regular numbers, the comparison operators do allow comparisons between numbers
    and BigInts.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在对象到原始值转换后，至少有一个操作数不是字符串，则两个操作数都将转换为数字并进行数值比较。`0`和`-0`被视为相等。`Infinity`大于除自身以外的任何数字，而`-Infinity`小于除自身以外的任何数字。如果任一操作数是（或转换为）`NaN`，��比较运算符始终返回`false`。尽管算术运算符不允许BigInt值与常规数字混合使用，但比较运算符允许数字和BigInt之间的比较。
- en: Remember that JavaScript strings are sequences of 16-bit integer values, and
    that string comparison is just a numerical comparison of the values in the two
    strings. The numerical encoding order defined by Unicode may not match the traditional
    collation order used in any particular language or locale. Note in particular
    that string comparison is case-sensitive, and all capital ASCII letters are “less
    than” all lowercase ASCII letters. This rule can cause confusing results if you
    do not expect it. For example, according to the `<` operator, the string “Zoo”
    comes before the string “aardvark”.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，JavaScript字符串是16位整数值的序列，并且字符串比较只是对两个字符串中的值进行数值比较。Unicode定义的数值编码顺序可能与任何特定语言或区域设置中使用的传统排序顺序不匹配。特别注意，字符串比较区分大小写，所有大写ASCII字母都“小于”所有小写ASCII字母。如果您没有预期，此规则可能导致令人困惑的结果。例如，根据`<`运算符，字符串“Zoo”在字符串“aardvark”之前。
- en: For a more robust string-comparison algorithm, try the `String.localeCompare()`
    method, which also takes locale-specific definitions of alphabetical order into
    account. For case-insensitive comparisons, you can convert the strings to all
    lowercase or all uppercase using `String.toLowerCase()` or `String.toUpperCase()`.
    And, for a more general and better localized string comparison tool, use the Intl.Collator
    class described in [§11.7.3](ch11.xhtml#collator).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更强大的字符串比较算法，请尝试`String.localeCompare()`方法，该方法还考虑了特定区域设置的字母顺序定义。对于不区分大小写的比较，您可以使用`String.toLowerCase()`或`String.toUpperCase()`将字符串转换为全小写或全大写。而且，为了使用更通用且更好本地化的字符串比较工具，请使用[§11.7.3](ch11.xhtml#collator)中描述的Intl.Collator类。
- en: 'Both the `+` operator and the comparison operators behave differently for numeric
    and string operands. `+` favors strings: it performs concatenation if either operand
    is a string. The comparison operators favor numbers and only perform string comparison
    if both operands are strings:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`运算符和比较运算符对数字和字符串操作数的行为不同。`+`偏向于字符串：如果任一操作数是字符串，则执行连接操作。比较运算符偏向于数字，只有在两个操作数都是字符串时才执行字符串比较：'
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, note that the `<=` (less than or equal) and `>=` (greater than or equal)
    operators do not rely on the equality or strict equality operators for determining
    whether two values are “equal.” Instead, the less-than-or-equal operator is simply
    defined as “not greater than,” and the greater-than-or-equal operator is defined
    as “not less than.” The one exception occurs when either operand is (or converts
    to) `NaN`, in which case, all four comparison operators return `false`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意`<=`（小于或等于）和`>=`（大于或等于）运算符不依赖于相等或严格相等运算符来确定两个值是否“相等”。相反，小于或等于运算符简单地定义为“不大于”，大于或等于运算符定义为“不小于”。唯一的例外是当任一操作数是（或转换为）`NaN`时，此时所有四个比较运算符都返回`false`。
- en: 4.9.3 The in Operator
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.3 in运算符
- en: 'The `in` operator expects a left-side operand that is a string, symbol, or
    value that can be converted to a string. It expects a right-side operand that
    is an object. It evaluates to `true` if the left-side value is the name of a property
    of the right-side object. For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符期望左侧操作数是一个字符串、符号或可转换为字符串的值。它期望右侧操作数是一个对象。如果左侧值是右侧对象的属性名称，则评估为`true`。例如：'
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 4.9.4 The instanceof Operator
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9.4 instanceof运算符
- en: 'The `instanceof` operator expects a left-side operand that is an object and
    a right-side operand that identifies a class of objects. The operator evaluates
    to `true` if the left-side object is an instance of the right-side class and evaluates
    to `false` otherwise. [Chapter 9](ch09.xhtml#classes) explains that, in JavaScript,
    classes of objects are defined by the constructor function that initializes them.
    Thus, the right-side operand of `instanceof` should be a function. Here are examples:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符期望左侧操作数是一个对象，右侧操作数标识对象类。如果左侧对象是右侧类的实例，则运算符评估为`true`，否则评估为`false`。[第9章](ch09.xhtml#classes)解释了在JavaScript中，对象类由初始化它们的构造函数定义。因此，`instanceof`的右侧操作数应该是一个函数。以下是示例：'
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that all objects are instances of `Object`. `instanceof` considers the
    “superclasses” when deciding whether an object is an instance of a class. If the
    left-side operand of `instanceof` is not an object, `instanceof` returns `false`.
    If the righthand side is not a class of objects, it throws a `TypeError`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有对象都是`Object`的实例。`instanceof`在判断一个对象是否是某个类的实例时会考虑“超类”。如果`instanceof`的左操作数不是对象，则返回`false`。如果右操作数不是对象类，则抛出`TypeError`。
- en: In order to understand how the `instanceof` operator works, you must understand
    the “prototype chain.” This is JavaScript’s inheritance mechanism, and it is described
    in [§6.3.2](ch06.xhtml#inheritance). To evaluate the expression `o instanceof
    f`, JavaScript evaluates `f.prototype`, and then looks for that value in the prototype
    chain of `o`. If it finds it, then `o` is an instance of `f` (or of a subclass
    of `f`) and the operator returns `true`. If `f.prototype` is not one of the values
    in the prototype chain of `o`, then `o` is not an instance of `f` and `instanceof`
    returns `false`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`instanceof`运算符的工作原理，您必须了解“原型链”。这是JavaScript的继承机制，描述在[§6.3.2](ch06.xhtml#inheritance)中。要评估表达式`o
    instanceof f`，JavaScript会评估`f.prototype`，然后在`o`的原型链中查找该值。如果找到，则`o`是`f`的实例（或`f`的子类），运算符返回`true`。如果`f.prototype`不是`o`的原型链中的值之一，则`o`不是`f`的实例，`instanceof`返回`false`。
- en: 4.10 Logical Expressions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.10 逻辑表达式
- en: The logical operators `&&`, `||`, and `!` perform Boolean algebra and are often
    used in conjunction with the relational operators to combine two relational expressions
    into one more complex expression. These operators are described in the subsections
    that follow. In order to fully understand them, you may want to review the concept
    of “truthy” and “falsy” values introduced in [§3.4](ch03.xhtml#booleans).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符`&&`、`||`和`!`执行布尔代数，通常与关系运算符结合使用，将两个关系表达式组合成一个更复杂的表达式。这些运算符在接下来的小节中描述。为了完全理解它们，您可能需要回顾[§3.4](ch03.xhtml#booleans)中介绍的“真值”和“假值”概念。
- en: 4.10.1 Logical AND (&&)
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10.1 逻辑AND（&&）
- en: 'The `&&` operator can be understood at three different levels. At the simplest
    level, when used with boolean operands, `&&` performs the Boolean AND operation
    on the two values: it returns `true` if and only if both its first operand *and*
    its second operand are `true`. If one or both of these operands is `false`, it
    returns `false`.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`运算符可以在三个不同级别理解。在最简单的级别上，当与布尔操作数一起使用时，`&&`对这两个值执行布尔AND操作：仅当其第一个操作数和第二个操作数都为`true`时才返回`true`。如果其中一个或两个操作数为`false`，则返回`false`。'
- en: '`&&` is often used as a conjunction to join two relational expressions:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`经常用作连接两个关系表达式的连接词：'
- en: '[PRE37]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Relational expressions always evaluate to `true` or `false`, so when used like
    this, the `&&` operator itself returns `true` or `false`. Relational operators
    have higher precedence than `&&` (and `||`), so expressions like these can safely
    be written without parentheses.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 关系表达式始终评估为`true`或`false`，因此在这种情况下，`&&`运算符本身返回`true`或`false`。关系运算符的优先级高于`&&`（和`||`），因此可以安全地写出不带括号的表达式。
- en: But `&&` does not require that its operands be boolean values. Recall that all
    JavaScript values are either “truthy” or “falsy.” (See [§3.4](ch03.xhtml#booleans)
    for details. The falsy values are `false`, `null`, `undefined`, `0`, `-0`, `NaN`,
    and `""`. All other values, including all objects, are truthy.) The second level
    at which `&&` can be understood is as a Boolean AND operator for truthy and falsy
    values. If both operands are truthy, the operator returns a truthy value. Otherwise,
    one or both operands must be falsy, and the operator returns a falsy value. In
    JavaScript, any expression or statement that expects a boolean value will work
    with a truthy or falsy value, so the fact that `&&` does not always return `true`
    or `false` does not cause practical problems.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`&&`不要求其操作数是布尔值。回想一下，所有JavaScript值都是“真值”或“假值”。（有关详细信息，请参阅[§3.4](ch03.xhtml#booleans)。假值包括`false`、`null`、`undefined`、`0`、`-0`、`NaN`和`""`。所有其他值，包括所有对象，都是真值。）`&&`的第二个级别可以理解为真值和假值的布尔AND运算符。如果两个操作数都是真值，则运算符返回真值。否则，一个或两个操作数必须是假值，运算符返回假值��在JavaScript中，任何期望布尔值的表达式或语句都可以使用真值或假值，因此`&&`并不总是返回`true`或`false`不会造成实际问题。
- en: Notice that this description says that the operator returns “a truthy value”
    or “a falsy value” but does not specify what that value is. For that, we need
    to describe `&&` at the third and final level. This operator starts by evaluating
    its first operand, the expression on its left. If the value on the left is falsy,
    the value of the entire expression must also be falsy, so `&&` simply returns
    the value on the left and does not even evaluate the expression on the right.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此描述指出该运算符返回“真值”或“假值”，但没有指定该值是什么。为此，我们需要在第三个最终级别描述`&&`。该运算符首先评估其第一个操作数，即左侧的表达式。如果左侧的值为假，整个表达式的值也必须为假，因此`&&`只返回左侧的值，甚至不评估右侧的表达式。
- en: 'On the other hand, if the value on the left is truthy, then the overall value
    of the expression depends on the value on the righthand side. If the value on
    the right is truthy, then the overall value must be truthy, and if the value on
    the right is falsy, then the overall value must be falsy. So when the value on
    the left is truthy, the `&&` operator evaluates and returns the value on the right:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果左侧的值为真值，则表达式的整体值取决于右侧的值。如果右侧的值为真值，则整体值必须为真值，如果右侧的值为假值，则整体值必须为假值。因此，当左侧的值为真值时，`&&`运算符评估并返回右侧的值：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is important to understand that `&&` may or may not evaluate its right-side
    operand. In this code example, the variable `p` is set to `null`, and the expression
    `p.x` would, if evaluated, cause a TypeError. But the code uses `&&` in an idiomatic
    way so that `p.x` is evaluated only if `p` is truthy—not `null` or `undefined`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要理解 `&&` 可能会或可能不会评估其右侧操作数。在这个代码示例中，变量 `p` 被设置为 `null`，并且表达式 `p.x` 如果被评估，将导致
    TypeError。但是代码以一种惯用的方式使用 `&&`，以便仅在 `p` 为真值时才评估 `p.x`，而不是 `null` 或 `undefined`。 '
- en: 'The behavior of `&&` is sometimes called short circuiting, and you may sometimes
    see code that purposely exploits this behavior to conditionally execute code.
    For example, the following two lines of JavaScript code have equivalent effects:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 的行为有时被称为短路，你可能会看到故意利用这种行为有条件地执行代码的代码。例如，下面两行 JavaScript 代码具有等效的效果：'
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In general, you must be careful whenever you write an expression with side effects
    (assignments, increments, decrements, or function invocations) on the righthand
    side of `&&`. Whether those side effects occur depends on the value of the lefthand
    side.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你在 `&&` 的右侧写一个具有副作用（赋值、递增、递减或函数调用）的表达式时，你必须小心。这些副作用是否发生取决于左侧的值。
- en: Despite the somewhat complex way that this operator actually works, it is most
    commonly used as a simple Boolean algebra operator that works on truthy and falsy
    values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个运算符实际上的工作方式有些复杂，但它最常用作一个简单的布尔代数运算符，适用于真值和假值。
- en: 4.10.2 Logical OR (||)
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10.2 逻辑 OR (||)
- en: The `||` operator performs the Boolean OR operation on its two operands. If
    one or both operands is truthy, it returns a truthy value. If both operands are
    falsy, it returns a falsy value.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`||` 运算符对其两个操作数执行布尔 OR 操作。如果一个或两个操作数为真值，则返回真值。如果两个操作数都为假值，则返回假值。'
- en: Although the `||` operator is most often used simply as a Boolean OR operator,
    it, like the `&&` operator, has more complex behavior. It starts by evaluating
    its first operand, the expression on its left. If the value of this first operand
    is truthy, it short-circuits and returns that truthy value without ever evaluating
    the expression on the right. If, on the other hand, the value of the first operand
    is falsy, then `||` evaluates its second operand and returns the value of that
    expression.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `||` 运算符通常被简单地用作布尔 OR 运算符，但它和 `&&` 运算符一样，具有更复杂的行为。它首先评估其第一个操作数，即左侧的表达式。如果这个第一个操作数的值为真值，它会短路并返回该真值，而不会评估右侧的表达式。另一方面，如果第一个操作数的值为假值，则
    `||` 评估其第二个操作数并返回该表达式的值。
- en: As with the `&&` operator, you should avoid right-side operands that include
    side effects, unless you purposely want to use the fact that the right-side expression
    may not be evaluated.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `&&` 运算符一样，你应该避免包含副作用的右侧操作数，除非你故意想要利用右侧表达式可能不会被评估的事实。
- en: 'An idiomatic usage of this operator is to select the first truthy value in
    a set of alternatives:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符的一个惯用用法是在一组备选项中选择第一个真值：
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that if 0 is a legal value for `maxWidth`, then this code will not work
    correctly, since 0 is a falsy value. See the `??` operator ([§4.13.2](#firstdefined))
    for an alternative.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果 0 是 `maxWidth` 的合法值，则此代码将无法正常工作，因为 0 是一个假值。参见 `??` 运算符（[§4.13.2](#firstdefined)）以获取替代方案。
- en: 'Prior to ES6, this idiom is often used in functions to supply default values
    for parameters:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 之前，这种习惯通常用于函数中为参数提供默认值：
- en: '[PRE41]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In ES6 and later, however, this trick is no longer needed because the default
    parameter value could simply be written in the function definition itself: `function
    copy(o, p={}) { ... }`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ES6 及以后，这个技巧不再需要，因为默认参数值可以直接写在函数定义中：`function copy(o, p={}) { ... }`。
- en: 4.10.3 Logical NOT (!)
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10.3 逻辑 NOT (!)
- en: The `!` operator is a unary operator; it is placed before a single operand.
    Its purpose is to invert the boolean value of its operand. For example, if `x`
    is truthy, `!x` evaluates to `false`. If `x` is falsy, then `!x` is `true`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`!` 运算符是一个一元运算符；它放在单个操作数之前。它的目的是反转其操作数的布尔值。例如，如果 `x` 是真值，`!x` 评估为 `false`。如果
    `x` 是假值，则 `!x` 是 `true`。'
- en: 'Unlike the `&&` and `||` operators, the `!` operator converts its operand to
    a boolean value (using the rules described in [Chapter 3](ch03.xhtml#datatypes))
    before inverting the converted value. This means that `!` always returns `true`
    or `false` and that you can convert any value `x` to its equivalent boolean value
    by applying this operator twice: `!!x` (see [§3.9.2](ch03.xhtml#explicitconversions)).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `&&` 和 `||` 运算符不同，`!` 运算符在反转转换其操作数为布尔值（使用 [第 3 章](ch03.xhtml#datatypes) 中描述的规则）之前。这意味着
    `!` 总是返回 `true` 或 `false`，你可以通过两次应用这个运算符将任何值 `x` 转换为其等效的布尔值：`!!x`（参见 [§3.9.2](ch03.xhtml#explicitconversions)）。
- en: 'As a unary operator, `!` has high precedence and binds tightly. If you want
    to invert the value of an expression like `p && q`, you need to use parentheses:
    `!(p && q)`. It is worth noting two laws of Boolean algebra here that we can express
    using JavaScript syntax:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一元运算符，`!` 具有高优先级并且紧密绑定。如果你想反转类似 `p && q` 的表达式的值，你需要使用括号：`!(p && q)`。值得注意的是，我们可以使用
    JavaScript 语法表达布尔代数的两个定律：
- en: '[PRE42]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 4.11 Assignment Expressions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.11 赋值表达式
- en: 'JavaScript uses the `=` operator to assign a value to a variable or property.
    For example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用 `=` 运算符将一个值分配给一个变量或属性。例如：
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `=` operator expects its left-side operand to be an lvalue: a variable
    or object property (or array element). It expects its right-side operand to be
    an arbitrary value of any type. The value of an assignment expression is the value
    of the right-side operand. As a side effect, the `=` operator assigns the value
    on the right to the variable or property on the left so that future references
    to the variable or property evaluate to the value.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`=` 运算符期望其左侧操作数是一个 lvalue：一个变量或对象属性（或数组元素）。它期望其右侧操作数是任何类型的任意值。赋值表达��的值是右侧操作数的值。作为副作用，`=`
    运算符将右侧的值分配给左侧的变量或属性，以便将来对变量或属性的引用评估为该值。'
- en: 'Although assignment expressions are usually quite simple, you may sometimes
    see the value of an assignment expression used as part of a larger expression.
    For example, you can assign and test a value in the same expression with code
    like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然赋值表达式通常相当简单，但有时您可能会看到赋值表达式的值作为更大表达式的一部分使用。例如，您可以使用以下代码在同一表达式中赋值和测试一个值：
- en: '[PRE44]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you do this, be sure you are clear on the difference between the `=` and
    `===` operators! Note that `=` has very low precedence, and parentheses are usually
    necessary when the value of an assignment is to be used in a larger expression.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，请确保您清楚`=`和`===`运算符之间的区别！请注意，`=`的优先级非常低，当赋值的值要在更大的表达式中使用时，通常需要括号。
- en: 'The assignment operator has right-to-left associativity, which means that when
    multiple assignment operators appear in an expression, they are evaluated from
    right to left. Thus, you can write code like this to assign a single value to
    multiple variables:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符具有从右到左的结合性，这意味着当表达式中出现多个赋值运算符时，它们将从右到左进行评估。因此，您可以编写如下代码将单个值分配给多个变量：
- en: '[PRE45]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 4.11.1 Assignment with Operation
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11.1 带操作符的赋值
- en: 'Besides the normal `=` assignment operator, JavaScript supports a number of
    other assignment operators that provide shortcuts by combining assignment with
    some other operation. For example, the `+=` operator performs addition and assignment.
    The following expression:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的`=`赋值运算符外，JavaScript 还支持许多其他赋值运算符，通过将赋值与其他操作结合起来提供快捷方式。例如，`+=`运算符执行加法和赋值。以下表达式：
- en: '[PRE46]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'is equivalent to this one:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于这个：
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you might expect, the `+=` operator works for numbers or strings. For numeric
    operands, it performs addition and assignment; for string operands, it performs
    concatenation and assignment.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的那样，`+=`运算符适用于数字或字符串。对于数字操作数，它执行加法和赋值；对于字符串操作数，它执行连接和赋值。
- en: Similar operators include `-=`, `*=`, `&=`, and so on. [Table 4-2](#expressions-TABLE-2)
    lists them all.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的运算符包括`-=`、`*=`、`&=`等。[表 4-2](#expressions-TABLE-2)列出了它们全部。
- en: Table 4-2\. Assignment operators
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. 赋值运算符
- en: '| Operator | Example | Equivalent |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 示例 | 等价 |'
- en: '| --- | --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `+=` | `a += b` | `a = a + b` |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | `a += b` | `a = a + b` |'
- en: '| `-=` | `a -= b` | `a = a - b` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `-=` | `a -= b` | `a = a - b` |'
- en: '| `*=` | `a *= b` | `a = a * b` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `*=` | `a *= b` | `a = a * b` |'
- en: '| `/=` | `a /= b` | `a = a / b` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `/=` | `a /= b` | `a = a / b` |'
- en: '| `%=` | `a %= b` | `a = a % b` |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `%=` | `a %= b` | `a = a % b` |'
- en: '| `**=` | `a **= b` | `a = a ** b` |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `**=` | `a **= b` | `a = a ** b` |'
- en: '| `<<=` | `a <<= b` | `a = a << b` |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `<<=` | `a <<= b` | `a = a << b` |'
- en: '| `>>=` | `a >>= b` | `a = a >> b` |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `>>=` | `a >>= b` | `a = a >> b` |'
- en: '| `>>>=` | `a >>>= b` | `a = a >>> b` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `>>>=` | `a >>>= b` | `a = a >>> b` |'
- en: '| `&=` | `a &= b` | `a = a & b` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `&=` | `a &= b` | `a = a & b` |'
- en: '| `&#124;=` | `a &#124;= b` | `a = a &#124; b` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;=` | `a &#124;= b` | `a = a &#124; b` |'
- en: '| `^=` | `a ^= b` | `a = a ^ b` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `^=` | `a ^= b` | `a = a ^ b` |'
- en: 'In most cases, the expression:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，表达式：
- en: '[PRE48]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'where `op` is an operator, is equivalent to the expression:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`op`是一个运算符，等价于表达式：
- en: '[PRE49]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the first line, the expression `a` is evaluated once. In the second, it
    is evaluated twice. The two cases will differ only if `a` includes side effects
    such as a function call or an increment operator. The following two assignments,
    for example, are not the same:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，表达式`a`被评估一次。在第二行中，它被评估两次。这两种情况只有在`a`包含函数调用或增量运算符等副作用时才会有所不同。例如，以下两个赋值是不同的：
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 4.12 Evaluation Expressions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.12 评估表达式
- en: 'Like many interpreted languages, JavaScript has the ability to interpret strings
    of JavaScript source code, evaluating them to produce a value. JavaScript does
    this with the global function `eval()`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多解释性语言一样，JavaScript 有解释 JavaScript 源代码字符串并对其进行评估以生成值的能力。JavaScript 使用全局函数`eval()`来实现这一点：
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Dynamic evaluation of strings of source code is a powerful language feature
    that is almost never necessary in practice. If you find yourself using `eval()`,
    you should think carefully about whether you really need to use it. In particular,
    `eval()` can be a security hole, and you should never pass any string derived
    from user input to `eval()`. With a language as complicated as JavaScript, there
    is no way to sanitize user input to make it safe to use with `eval()`. Because
    of these security issues, some web servers use the HTTP “Content-Security-Policy”
    header to disable `eval()` for an entire website.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 动态评估源代码字符串是一种强大的语言特性，在实践中几乎从不需要。如果您发现自己使用`eval()`，您应该仔细考虑是否真的需要使用它。特别是，`eval()`可能存在安全漏洞，您绝不应将任何源自用户输入的字符串传递给`eval()`。由于
    JavaScript 这样复杂的语言，没有办法对用户输入进行清理以使其安全用于`eval()`。由于这些安全问题，一些 Web 服务器使用 HTTP 的“内容安全策略”头部来禁用整个网站的`eval()`。
- en: The subsections that follow explain the basic use of `eval()` and explain two
    restricted versions of it that have less impact on the optimizer.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节将解释`eval()`的基本用法，并解释两个对优化器影响较小的受限版本。
- en: 4.12.1 eval()
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12.1 eval()
- en: '`eval()` expects one argument. If you pass any value other than a string, it
    simply returns that value. If you pass a string, it attempts to parse the string
    as JavaScript code, throwing a SyntaxError if it fails. If it successfully parses
    the string, then it evaluates the code and returns the value of the last expression
    or statement in the string or `undefined` if the last expression or statement
    had no value. If the evaluated string throws an exception, that exception propogates
    from the call to `eval()`.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`期望一个参数。如果传递的值不是字符串，则它只是返回该值。如果传递一个字符串，则它尝试将字符串解析为 JavaScript 代码，如果失败则抛出
    SyntaxError。如果成功解析字符串，则评估代码并返回字符串中最���一个表达式或语句的值，如果最后一个表达式或语句没有值，则返回`undefined`。如果评估的字符串引发异常，则该异常从调用`eval()`传播出来。'
- en: The key thing about `eval()` (when invoked like this) is that it uses the variable
    environment of the code that calls it. That is, it looks up the values of variables
    and defines new variables and functions in the same way that local code does.
    If a function defines a local variable `x` and then calls `eval("x")`, it will
    obtain the value of the local variable. If it calls `eval("x=1")`, it changes
    the value of the local variable. And if the function calls `eval("var y = 3;")`,
    it declares a new local variable `y`. On the other hand, if the evaluated string
    uses `let` or `const`, the variable or constant declared will be local to the
    evaluation and will not be defined in the calling environment.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`的关键之处（在这种情况下调用）是它使用调用它的代码的变量环境。也就是说，它查找变量的值，并以与局部代码相同的方式定义新变量和函数。如果一个函数定义了一个局部变量`x`，然后调用`eval("x")`，它将获得局部变量的值。如果它调用`eval("x=1")`，它会改变局部变量的值。如果函数调用`eval("var
    y = 3;")`，它会声明一个新的局部变量`y`。另一方面，如果被评估的字符串使用`let`或`const`，则声明的变量或常量将局部于评估，并不会在调用环境中定义。'
- en: 'Similarly, a function can declare a local function with code like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，函数可以使用以下代码声明一个局部函数：
- en: '[PRE52]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you call `eval()` from top-level code, it operates on global variables and
    global functions, of course.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从顶层代码调用`eval()`，它当然会操作全局变量和全局函数。
- en: 'Note that the string of code you pass to `eval()` must make syntactic sense
    on its own: you cannot use it to paste code fragments into a function. It makes
    no sense to write `eval("return;")`, for example, because `return` is only legal
    within functions, and the fact that the evaluated string uses the same variable
    environment as the calling function does not make it part of that function. If
    your string would make sense as a standalone script (even a very short one like
    `x=0` ), it is legal to pass to `eval()`. Otherwise, `eval()` will throw a SyntaxError.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给`eval()`的代码字符串必须在语法上是合理的：你不能使用它来将代码片段粘贴到函数中。例如，写`eval("return;")`是没有意义的，因为`return`只在函数内部合法，而被评估的字符串使用与调用函数相同的变量环境并不使其成为该函数的一部分。如果你的字符串作为独立脚本是合理的（即使是非常简短的像`x=0`），那么它是可以传递给`eval()`的。否则，`eval()`会抛出SyntaxError。
- en: 4.12.2 Global eval()
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12.2 全局 eval()
- en: It is the ability of `eval()` to change local variables that is so problematic
    to JavaScript optimizers. As a workaround, however, interpreters simply do less
    optimization on any function that calls `eval()`. But what should a JavaScript
    interpreter do, however, if a script defines an alias for `eval()` and then calls
    that function by another name? The JavaScript specification declares that when
    `eval()` is invoked by any name other than “eval”, it should evaluate the string
    as if it were top-level global code. The evaluated code may define new global
    variables or global functions, and it may set global variables, but it will not
    use or modify any variables local to the calling function, and will not, therefore,
    interfere with local optimizations.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正是`eval()`改变局部变量的能力让JavaScript优化器感到困扰。然而，作为一种解决方法，解释器只是对调用`eval()`的任何函数进行较少的优化。但是，如果一个脚本定义了`eval()`的别名，然后通过另一个名称调用该函数，JavaScript规范声明，当`eval()`被任何名称调用时，除了“eval”之外，它应该评估字符串，就像它是顶层全局代码一样。被评估的代码可以定义新的全局变量或全局函数，并且可以设置全局变量，但不会使用或修改调用函数的局部变量，因此不会干扰局部优化。
- en: A “direct eval” is a call to the `eval()` function with an expression that uses
    the exact, unqualified name “eval” (which is beginning to feel like a reserved
    word). Direct calls to `eval()` use the variable environment of the calling context.
    Any other call—an indirect call—uses the global object as its variable environment
    and cannot read, write, or define local variables or functions. (Both direct and
    indirect calls can define new variables only with `var`. Uses of `let` and `const`
    inside an evaluated string create variables and constants that are local to the
    evaluation and do not alter the calling or global environment.)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: “直接 eval”是使用确切的、未限定名称“eval”调用`eval()`函数的表达式（开始感觉像是一个保留字）。直接调用`eval()`使用调用上下文的变量环境。任何其他调用——间接调用——使用全局对象作为其变量环境，不能读取、写入或定义局部变量或函数。（直接和间接调用只能使用`var`定义新变量。在评估的字符串中使用`let`和`const`会创建仅在评估中局部的变量和常量，不会改变调用或全局环境。）
- en: 'The following code demonstrates:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示：
- en: '[PRE53]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice that the ability to do a global eval is not just an accommodation to
    the needs of the optimizer; it is actually a tremendously useful feature that
    allows you to execute strings of code as if they were independent, top-level scripts.
    As noted at the beginning of this section, it is rare to truly need to evaluate
    a string of code. But if you do find it necessary, you are more likely to want
    to do a global eval than a local eval.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，进行全局 eval 的能力不仅仅是为了优化器的需要；实际上，这是一个非常有用的功能，允许你执行字符串代码，就像它们是独立的顶层脚本一样。正如本节开头所述，真正需要评估代码字符串是罕见的。但是如果你确实发现有必要，你更可能想要进行全局
    eval 而不是局部 eval。
- en: 4.12.3 Strict eval()
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12.3 严格 eval()
- en: Strict mode (see [§5.6.3](ch05.xhtml#strictmode)) imposes further restrictions
    on the behavior of the `eval()` function and even on the use of the identifier
    “eval”. When `eval()` is called from strict-mode code, or when the string of code
    to be evaluated itself begins with a “use strict” directive, then `eval()` does
    a local eval with a private variable environment. This means that in strict mode,
    evaluated code can query and set local variables, but it cannot define new variables
    or functions in the local scope.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式（参见[§5.6.3](ch05.xhtml#strictmode)）对`eval()`函数的行为甚至对标识符“eval”的使用施加了进一步的限制。当从严格���式代码中调用`eval()`，或者当要评估的代码字符串本身以“use
    strict”指令开头时，`eval()`会使用私有变量环境进行局部评估。这意味着在严格模式下，被评估的代码可以查询和设置局部变量，但不能在局部范围内定义新变量或函数。
- en: Furthermore, strict mode makes `eval()` even more operator-like by effectively
    making “eval” into a reserved word. You are not allowed to overwrite the `eval()`
    function with a new value. And you are not allowed to declare a variable, function,
    function parameter, or catch block parameter with the name “eval”.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，严格模式使 `eval()` 更像是一个运算符，有效地将“eval”变成了一个保留字。你不能用新值覆盖 `eval()` 函数。你也不能声明一个名为“eval”的变量、函数、函数参数或
    catch 块参数。
- en: 4.13 Miscellaneous Operators
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.13 其他运算符
- en: JavaScript supports a number of other miscellaneous operators, described in
    the following sections.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 支持许多其他杂项运算符，详细描述在以下章节。
- en: 4.13.1 The Conditional Operator (?:)
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.1 条件运算符 (?:)
- en: 'The conditional operator is the only ternary operator (three operands) in JavaScript
    and is sometimes actually called the *ternary operator*. This operator is sometimes
    written `?:`, although it does not appear quite that way in code. Because this
    operator has three operands, the first goes before the `?`, the second goes between
    the `?` and the `:`, and the third goes after the `:`. It is used like this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符是 JavaScript 中唯一的三元运算符，有时实际上被称为*三元运算符*。这个运算符有时被写为 `?:`，尽管在代码中看起来并不完全是这样。因为这个运算符有三个操作数，第一个在
    `?` 前面，第二个在 `?` 和 `:` 之间，第三个在 `:` 后面。使用方法如下：
- en: '[PRE54]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The operands of the conditional operator may be of any type. The first operand
    is evaluated and interpreted as a boolean. If the value of the first operand is
    truthy, then the second operand is evaluated, and its value is returned. Otherwise,
    if the first operand is falsy, then the third operand is evaluated and its value
    is returned. Only one of the second and third operands is evaluated; never both.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符的操作数可以是任何类型。第一个操作数被评估并解释为布尔值。如果第一个操作数的值为真值，则评估第二个操作数，并返回其值。否则，如果第一个操作数为假值，则评估第三个操作数，并返回其值。第二个和第三个操作数中只有一个被评估；永远不会同时评估两个。
- en: 'While you can achieve similar results using the `if` statement ([§5.3.1](ch05.xhtml#ifstatement)),
    the `?:` operator often provides a handy shortcut. Here is a typical usage, which
    checks to be sure that a variable is defined (and has a meaningful, truthy value)
    and uses it if so or provides a default value if not:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以使用 `if` 语句 ([§5.3.1](ch05.xhtml#ifstatement)) 实现类似的结果，但 `?:` 运算符通常提供了一个便捷的快捷方式。以下是一个典型的用法，检查变量是否已定义（并具有有意义的真值），如果是，则使用它，否则提供默认值：
- en: '[PRE55]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is equivalent to, but more compact than, the following `if` statement:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下 `if` 语句，但更简洁：
- en: '[PRE56]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 4.13.2 First-Defined (??)
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.2 第一个定义的 (??)
- en: 'The first-defined operator `??` evaluates to its first defined operand: if
    its left operand is not `null` and not `undefined`, it returns that value. Otherwise,
    it returns the value of the right operand. Like the `&&` and `||` operators, `??`
    is short-circuiting: it only evaluates its second operand if the first operand
    evaluates to `null` or `undefined`. If the expression `a` has no side effects,
    then the expression `a ?? b` is equivalent to:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个定义运算符 `??` 的值为其第一个定义的操作数：如果其左操作数不是 `null` 且不是 `undefined`，则返回该值。否则，返回右操作数的值。与
    `&&` 和 `||` 运算符一样，`??` 是短路运算：只有在第一个操作数评估为 `null` 或 `undefined` 时才评估第二个操作数。如果表达式
    `a` 没有副作用，那么表达式 `a ?? b` 等效于：
- en: '[PRE57]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`??` is a useful alternative to `||` ([§4.10.2](#logicalor)) when you want
    to select the first *defined* operand rather than the first truthy operand. Although
    `||` is nominally a logical OR operator, it is also used idiomatically to select
    the first non-falsy operand with code like this:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想选择第一个*定义*的操作数而不是第一个真值操作数时，`??` 是 `||` ([§4.10.2](#logicalor)) 的一个有用替代。虽然
    `||` 名义上是一个逻辑 OR 运算符，但它也被习惯性地用来选择第一个非假值操作数，例如以下代码：
- en: '[PRE58]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The problem with this idiomatic use is that zero, the empty string, and `false`
    are all falsy values that may be perfectly valid in some circumstances. In this
    code example, if `maxWidth` is zero, that value will be ignored. But if we change
    the `||` operator to `??`, we end up with an expression where zero is a valid
    value:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这种习惯用法的问题在于零、空字符串和 `false` 都是假值，在某些情况下可能是完全有效的值。在这个代码示例中，如果 `maxWidth` 是零，则该值将被忽略���但如果我们将
    `||` 运算符改为 `??`，我们最终得到一个零是有效值的表达式：
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here are more examples showing how `??` works when the first operand is falsy.
    If that operand is falsy but defined, then `??` returns it. It is only when the
    first operand is “nullish” (i.e., `null` or `undefined`) that this operator evaluates
    and returns the second operand:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更多示例，展示了当第一个操作数为假值时 `??` 的工作原理。如果该操作数为假值但已定义，则 `??` 返回它。只有当第一个操作数为“nullish”（即
    `null` 或 `undefined`）时，该运算符才会评估并返回第二个操作数：
- en: '[PRE60]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that the `timeout`, `title`, and `verbose` expressions here would have
    different values if we used `||` instead of `??`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们使用 `||` 而不是 `??`，这里的 `timeout`、`title` 和 `verbose` 表达式将具有不同的值。
- en: 'The `??` operator is similar to the `&&` and `||` operators but does not have
    higher precedence or lower precedence than they do. If you use it in an expression
    with either of those operators, you must use explicit parentheses to specify which
    operation you want to perform first:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 运算符类似于 `&&` 和 `||` 运算符，但它的优先级既不高于它们，也不低于它们。如果你在一个表达式中使用它与这些运算符之一，你必须使用显式括号来指定你想要先执行哪个操作：'
- en: '[PRE61]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `??` operator is defined by ES2020, and as of early 2020, is newly supported
    by current or beta versions of all major browsers. This operator is formally called
    the “nullish coalescing” operator, but I avoid that term because this operator
    selects one of its operands but does not “coalesce” them in any way that I can
    see.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`??` 运算符由 ES2020 定义，在 2020 年初，所有主要浏览器的当前版本或 beta 版本都新支持该运算符。这个运算符正式称为“nullish
    coalescing”运算符，但我避免使用这个术语，因为这个运算符选择其操作数之一，但在我看来并没有以任何方式“合并”它们。'
- en: 4.13.3 The typeof Operator
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.3 typeof 运算符
- en: '`typeof` is a unary operator that is placed before its single operand, which
    can be of any type. Its value is a string that specifies the type of the operand.
    [Table 4-3](#typeoftable) specifies the value of the `typeof` operator for any
    JavaScript value.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeof` 是一个一元运算符，放置在其单个操作数之前，该操作数可以是任何类型。它的值是一个指定操作数类型的字符串。[Table 4-3](#typeoftable)
    指定了`typeof` 运算符对任何 JavaScript 值的值。'
- en: Table 4-3\. Values returned by the typeof operator
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-3。typeof运算符返回的值
- en: '| `x` | `typeof x` |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `x` | `typeof x` |'
- en: '| --- | --- |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `undefined` | `"undefined"` |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `undefined` | `"undefined"` |'
- en: '| `null` | `"object"` |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `"object"` |'
- en: '| `true` or `false` | `"boolean"` |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `true` 或 `false` | `"boolean"` |'
- en: '| any number or `NaN` | `"number"` |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| 任何数字或 `NaN` | `"number"` |'
- en: '| any BigInt | `"bigint"` |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 任何 BigInt | `"bigint"` |'
- en: '| any string | `"string"` |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 任何字符串 | `"string"` |'
- en: '| any symbol | `"symbol"` |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 任何符号 | `"symbol"` |'
- en: '| any function | `"function"` |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 任何函数 | `"function"` |'
- en: '| any nonfunction object | `"object"` |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 任何非函数对象 | `"object"` |'
- en: 'You might use the `typeof` operator in an expression like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在表达式中使用`typeof` 运算符，如下所示：
- en: '[PRE62]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that `typeof` returns “object” if the operand value is `null`. If you want
    to distinguish `null` from objects, you’ll have to explicitly test for this special-case
    value.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果操作数值为`null`，`typeof` 返回“object”。如果要区分`null` 和对象，您必须明确测试这种特殊情况的值。
- en: Although JavaScript functions are a kind of object, the `typeof` operator considers
    functions to be sufficiently different that they have their own return value.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 函数是一种对象，但`typeof` 运算符认为函数与其他对象有足够大的不同，因此它们有自己的返回值。
- en: Because `typeof` evaluates to “object” for all object and array values other
    than functions, it is useful only to distinguish objects from other, primitive
    types. In order to distinguish one class of object from another, you must use
    other techniques, such as the `instanceof` operator (see [§4.9.4](#instanceof)),
    the `class` attribute (see [§14.4.3](ch14.xhtml#tostringtag)), or the `constructor`
    property (see [§9.2.2](ch09.xhtml#constructorproperty) and [§14.3](ch14.xhtml#prototypeattr)).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 因为对于除函数之外的所有对象和数组值，`typeof` 都会评估为“object”，所以它只��在区分对象和其他原始类型时才有用。为了区分一个类的对象与另一个类的对象，您必须使用其他技术，如`instanceof`
    运算符（参见[§4.9.4](#instanceof)）、`class` 属性（参见[§14.4.3](ch14.xhtml#tostringtag)）或`constructor`
    属性（参见[§9.2.2](ch09.xhtml#constructorproperty)和[§14.3](ch14.xhtml#prototypeattr)）。
- en: 4.13.4 The delete Operator
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.4 delete 运算符
- en: '`delete` is a unary operator that attempts to delete the object property or
    array element specified as its operand. Like the assignment, increment, and decrement
    operators, `delete` is typically used for its property deletion side effect and
    not for the value it returns. Some examples:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 是一个一元运算符，试图删除指定为其操作数的对象属性或数组元素。与赋值、递增和递减运算符一样，`delete` 通常用于其属性删除副作用，而不是用于其返回的值。一些例子：'
- en: '[PRE63]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that a deleted property or array element is not merely set to the `undefined`
    value. When a property is deleted, the property ceases to exist. Attempting to
    read a nonexistent property returns `undefined`, but you can test for the actual
    existence of a property with the `in` operator ([§4.9.3](#inoperator)). Deleting
    an array element leaves a “hole” in the array and does not change the array’s
    length. The resulting array is *sparse* ([§7.3](ch07.xhtml#sparsearrays)).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，删除的属性或数组元素不仅仅被设置为`undefined` 值。当删除属性时，该属性将不再存在。尝试读取不存在的属性会返回`undefined`，但您可以使用`in`
    运算符（[§4.9.3](#inoperator)）测试属性的实际存在性。删除数组元素会在数组中留下一个“空洞”，并且不会更改数组的长度。结果数组是*稀疏的*（[§7.3](ch07.xhtml#sparsearrays)）。
- en: '`delete` expects its operand to be an lvalue. If it is not an lvalue, the operator
    takes no action and returns `true`. Otherwise, `delete` attempts to delete the
    specified lvalue. `delete` returns `true` if it successfully deletes the specified
    lvalue. Not all properties can be deleted, however: non-configurable properties
    ([§14.1](ch14.xhtml#propertydescriptors)) are immune from deletion.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 期望其操作数为左值。如果它不是左值，则运算符不起作用并返回`true`。否则，`delete` 会尝试删除指定的左值。如果成功删除指定的左值，则`delete`
    返回`true`。然而，并非所有属性都可以被删除：不可配置的属性（[§14.1](ch14.xhtml#propertydescriptors)）不受删除的影响。'
- en: 'In strict mode, `delete` raises a SyntaxError if its operand is an unqualified
    identifier such as a variable, function, or function parameter: it only works
    when the operand is a property access expression ([§4.4](#propertyexprs)). Strict
    mode also specifies that `delete` raises a TypeError if asked to delete any non-configurable
    (i.e., nondeleteable) property. Outside of strict mode, no exception occurs in
    these cases, and `delete` simply returns `false` to indicate that the operand
    could not be deleted.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在严格模式下，如果其操作数是未经限定的标识符，如变量、函数或函数参数，则`delete` 会引发 SyntaxError：它仅在操作数为属性访问表达式时起作用（[§4.4](#propertyexprs)）。严格模式还指定，如果要删除任何不可配置的（即不可删除的）属性，则`delete`
    会引发 TypeError。在严格模式之外，这些情况不会发生异常，`delete` 简单地返回`false`，表示无法删除操作数。
- en: 'Here are some example uses of the `delete` operator:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`delete` 运算符的一些示例用法：
- en: '[PRE64]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We’ll see the `delete` operator again in [§6.4](ch06.xhtml#deletingproperties).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[§6.4](ch06.xhtml#deletingproperties)中再次看到`delete` 运算符。
- en: 4.13.5 The await Operator
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.5 await 运算符
- en: '`await` was introduced in ES2017 as a way to make asynchronous programming
    more natural in JavaScript. You will need to read [Chapter 13](ch13.xhtml#async)
    to understand this operator. Briefly, however, `await` expects a Promise object
    (representing an asynchronous computation) as its sole operand, and it makes your
    program behave as if it were waiting for the asynchronous computation to complete
    (but it does this without actually blocking, and it does not prevent other asynchronous
    operations from proceeding at the same time). The value of the `await` operator
    is the fulfillment value of the Promise object. Importantly, `await` is only legal
    within functions that have been declared asynchronous with the `async` keyword.
    Again, see [Chapter 13](ch13.xhtml#async) for full details.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`在 ES2017 中引入，作为使 JavaScript 中的异步编程更自然的一种方式。您需要阅读[第13章](ch13.xhtml#async)以了解此运算符。简而言之，`await`期望一个
    Promise 对象（表示异步计算）作为其唯一操作数，并使您的程序表现得好像正在等待异步计算完成（但实际上不会阻塞，并且不会阻止其他异步操作同时进行）。`await`运算符的值是
    Promise 对象的完成值。重要的是，`await`只在使用`async`关键字声明的函数内部合法。再次查看[第13章](ch13.xhtml#async)获取完整详情。'
- en: 4.13.6 The void Operator
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.6 void 运算符
- en: '`void` is a unary operator that appears before its single operand, which may
    be of any type. This operator is unusual and infrequently used; it evaluates its
    operand, then discards the value and returns `undefined`. Since the operand value
    is discarded, using the `void` operator makes sense only if the operand has side
    effects.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`是一个一元运算符，出现在其单个操作数之前，该操作数可以是任何类型。这个运算符是不寻常且很少使用的；它评估其操作数，然后丢弃值并返回`undefined`。由于操作数值被丢弃，只有在操作数具有副作用时使用`void`运算符才有意义。'
- en: 'The `void` operator is so obscure that it is difficult to come up with a practical
    example of its use. One case would be when you want to define a function that
    returns nothing but also uses the arrow function shortcut syntax (see [§8.1.3](ch08.xhtml#arrowfunctions))
    where the body of the function is a single expression that is evaluated and returned.
    If you are evaluating the expression solely for its side effects and do not want
    to return its value, then the simplest thing is to use curly braces around the
    function body. But, as an alternative, you could also use the void operator in
    this case:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`void`运算符如此隐晦，以至于很难想出其使用的实际示例。一个情况是当您想要定义一个什么都不返回但也使用箭头函数快捷语法的函数时（参见[§8.1.3](ch08.xhtml#arrowfunctions)），其中函数体是一个被评估并返回的单个表达式。如果您仅仅为了其副作用而评估表达式，并且不想返回其值，那么最简单的方法是在函数体周围使用大括号。但是，作为替代方案，在这种情况下您也可以使用`void`运算符：'
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 4.13.7 The comma Operator (,)
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13.7 逗号运算符（,）
- en: 'The `comma` operator is a binary operator whose operands may be of any type.
    It evaluates its left operand, evaluates its right operand, and then returns the
    value of the right operand. Thus, the following line:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符是一个二��运算符，其操作数可以是任何类型。它评估其左操作数，评估其右操作数，然后返回右操作数的值。因此，以下行：
- en: '[PRE66]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'evaluates to 2 and is basically equivalent to:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 评估为2，基本上等同于：
- en: '[PRE67]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The lefthand expression is always evaluated, but its value is discarded, which
    means that it only makes sense to use the comma operator when the lefthand expression
    has side effects. The only situation in which the comma operator is commonly used
    is with a `for` loop ([§5.4.3](ch05.xhtml#forloop)) that has multiple loop variables:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧表达式始终被评估，但其值被丢弃，这意味着只有在左侧表达式具有副作用时才有意义使用逗号运算符。逗号运算符通常使用的唯一情况是在具有多个循环变量的`for`循环（[§5.4.3](ch05.xhtml#forloop)）中：
- en: '[PRE68]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 4.14 Summary
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.14 总结
- en: 'This chapter covers a wide variety of topics, and there is lots of reference
    material here that you may want to reread in the future as you continue to learn
    JavaScript. Some key points to remember, however, are these:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了各种主题，并且这里有很多参考资料，您可能希望在未来继续学习 JavaScript 时重新阅读。然而，需要记住的一些关键点是：
- en: Expressions are the phrases of a JavaScript program.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式是 JavaScript 程序的短语。
- en: Any expression can be *evaluated* to a JavaScript value.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何表达式都可以*评估*为 JavaScript 值。
- en: Expressions can also have side effects (such as variable assignment) in addition
    to producing a value.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式除了产生一个值外，还可能具有副作用（如变量赋值）。
- en: Simple expressions such as literals, variable references, and property accesses
    can be combined with operators to produce larger expressions.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单表达式，如文字，变量引用和属性访问，可以与运算符结合以产生更大的表达式。
- en: JavaScript defines operators for arithmetic, comparisons, Boolean logic, assignment,
    and bit manipulation, along with some miscellaneous operators, including the ternary
    conditional operator.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 定义了用于算术，比较，布尔逻辑，赋值和位操作的运算符，以及一些其他运算符，包括三元条件运算符。
- en: The JavaScript `+` operator is used to both add numbers and concatenate strings.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript `+` 运算符用于添加数字和连接字符串。
- en: The logical operators `&&` and `||` have special “short-circuiting” behavior
    and sometimes only evaluate one of their arguments. Common JavaScript idioms require
    you to understand the special behavior of these operators.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符`&&`和`||`具有特殊的“短路”行为，有时只评估它们的一个参数。常见的 JavaScript 习语要求您了解这些运算符的特殊行为。
