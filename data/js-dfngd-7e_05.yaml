- en: Chapter 5\. Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。语句
- en: '[Chapter 4](ch04.xhtml#expressions) described expressions as JavaScript phrases.
    By that analogy, *statements* are JavaScript sentences or commands. Just as English
    sentences are terminated and separated from one another with periods, JavaScript
    statements are terminated with semicolons ([§2.6](ch02.xhtml#optionalsemicolons)).
    Expressions are *evaluated* to produce a value, but statements are *executed*
    to make something happen.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第四章](ch04.xhtml#expressions)将表达式描述为 JavaScript 短语。按照这个类比，*语句*是 JavaScript
    句子或命令。就像英语句子用句号终止并用句号分隔开一样，JavaScript 语句用分号终止（[§2.6](ch02.xhtml#optionalsemicolons)）。表达式*被评估*以产生一个值，但语句*被执行*以使某事发生。'
- en: One way to “make something happen” is to evaluate an expression that has side
    effects. Expressions with side effects, such as assignments and function invocations,
    can stand alone as statements, and when used this way are known as *expression
    statements*. A similar category of statements are the *declaration statements*
    that declare new variables and define new functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使某事发生的一种方法是评估具有副作用的表达式。具有副作用的表达式，如赋值和函数调用，可以独立作为语句存在，当以这种方式使用时被称为*表达式语句*。另一类语句是*声明语句*，它声明新变量并定义新函数。
- en: 'JavaScript programs are nothing more than a sequence of statements to execute.
    By default, the JavaScript interpreter executes these statements one after another
    in the order they are written. Another way to “make something happen” is to alter
    this default order of execution, and JavaScript has a number of statements or
    *control structures* that do just this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 程序只不过是一系列要执行的语句。默认情况下，JavaScript 解释器按照它们编写的顺序一个接一个地执行这些语句。改变这种默认执行顺序的另一种方法是使用
    JavaScript 中的一些语句或*控制结构*：
- en: Conditionals
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句
- en: Statements like `if` and `switch` that make the JavaScript interpreter execute
    or skip other statements depending on the value of an expression
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`if`和`switch`这样的语句根据表达式的值使 JavaScript 解释器执行或跳过其他语句
- en: Loops
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 循环
- en: Statements like `while` and `for` that execute other statements repetitively
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`while`和`for`这样重复执行其他语句的语句
- en: Jumps
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转
- en: Statements like `break`, `return`, and `throw` that cause the interpreter to
    jump to another part of the program
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`break`、`return`和`throw`这样的语句会导致解释器跳转到程序的另一个部分
- en: The sections that follow describe the various statements in JavaScript and explain
    their syntax. [Table 5-1](#statementssummary), at the end of the chapter, summarizes
    the syntax. A JavaScript program is simply a sequence of statements, separated
    from one another with semicolons, so once you are familiar with the statements
    of JavaScript, you can begin writing JavaScript programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节描述了 JavaScript 中的各种语句并解释了它们的语法。[表5-1](#statementssummary)在本章末尾总结了语法。JavaScript
    程序只不过是一系列语句，用分号分隔开，因此一旦熟悉了 JavaScript 的语句，就可以开始编写 JavaScript 程序。
- en: 5.1 Expression Statements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 表达式语句
- en: 'The simplest kinds of statements in JavaScript are expressions that have side
    effects. This sort of statement was shown in [Chapter 4](ch04.xhtml#expressions).
    Assignment statements are one major category of expression statements. For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中最简单的语句是具有副作用的表达式。这种语句在[第四章](ch04.xhtml#expressions)中有所展示。赋值语句是表达式语句的一个主要类别。例如：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The increment and decrement operators, `++` and `--`, are related to assignment
    statements. These have the side effect of changing a variable value, just as if
    an assignment had been performed:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 递增和递减运算符`++`和`--`与赋值语句相关。它们具有改变变量值的副作用，就像执行了一个赋值一样：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `delete` operator has the important side effect of deleting an object property.
    Thus, it is almost always used as a statement, rather than as part of a larger
    expression:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 运算符的重要副作用是删除对象属性。因此，它几乎总是作为语句使用，而不是作为更大表达式的一部分：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Function calls are another major category of expression statements. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用是另一种重要的表达式语句。例如：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These function calls are expressions, but they have side effects that affect
    the host environment or program state, and they are used here as statements. If
    a function does not have any side effects, there is no sense in calling it, unless
    it is part of a larger expression or an assignment statement. For example, you
    wouldn’t just compute a cosine and discard the result:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数调用是表达式，但它们具有影响主机环境或程序状态的副作用，并且在这里被用作语句。如果一个函数没有任何副作用，那么调用它就没有意义，除非它是更大表达式或赋值语句的一部分。例如，你不会仅仅计算余弦值然后丢弃结果：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But you might well compute the value and assign it to a variable for future
    use:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能会计算值并将其赋给一个变量以备将来使用：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that each line of code in each of these examples is terminated with a semicolon.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些示例中的每行代码都以分号结束。
- en: 5.2 Compound and Empty Statements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 复合语句和空语句
- en: 'Just as the comma operator ([§4.13.7](ch04.xhtml#commaoperator)) combines multiple
    expressions into a single expression, a *statement block* combines multiple statements
    into a single *compound statement*. A statement block is simply a sequence of
    statements enclosed within curly braces. Thus, the following lines act as a single
    statement and can be used anywhere that JavaScript expects a single statement:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像逗号运算符（[§4.13.7](ch04.xhtml#commaoperator)）将多个表达式组合成一个单一表达式一样，*语句块*将多个语句组合成一个*复合语句*。语句块只是一系列语句被花括号包围起来。因此，以下行作为单个语句，并可以在
    JavaScript 需要单个语句的任何地方使用：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are a few things to note about this statement block. First, it does *not*
    end with a semicolon. The primitive statements within the block end in semicolons,
    but the block itself does not. Second, the lines inside the block are indented
    relative to the curly braces that enclose them. This is optional, but it makes
    the code easier to read and understand.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个语句块有几点需要注意。首先，它*不*以分号结束。块内的原始语句以分号结束，但块本身不以分号结束。其次，块内的行相对于包围它们的花括号缩进。这是可选的，但它使代码更易于阅读和理解。
- en: Just as expressions often contain subexpressions, many JavaScript statements
    contain substatements. Formally, JavaScript syntax usually allows a single substatement.
    For example, the `while` loop syntax includes a single statement that serves as
    the body of the loop. Using a statement block, you can place any number of statements
    within this single allowed substatement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 就像表达式经常包含子表达式一样，许多JavaScript语句包含子语句。形式上，JavaScript语法通常允许单个子语句。例如，`while`循环语法包括一个作为循环体的单个语句。使用语句块，您可以在这个单个允许的子语句中放置任意数量的语句。
- en: 'A compound statement allows you to use multiple statements where JavaScript
    syntax expects a single statement. The *empty statement* is the opposite: it allows
    you to include no statements where one is expected. The empty statement looks
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 复合语句允许您在JavaScript语法期望单个语句的地方使用多个语句。*空语句*则相反：它允许您在期望一个语句的地方不包含任何语句。空语句如下所示：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The JavaScript interpreter takes no action when it executes an empty statement.
    The empty statement is occasionally useful when you want to create a loop that
    has an empty body. Consider the following `for` loop (`for` loops will be covered
    in [§5.4.3](#forloop)):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当执��空语句时，JavaScript解释器不会采取任何操作。空语句偶尔在您想要创建一个空循环体的循环时很有用。考虑以下`for`循环（`for`循环将在[§5.4.3](#forloop)中介绍）：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this loop, all the work is done by the expression `a[i++] = 0`, and no loop
    body is necessary. JavaScript syntax requires a statement as a loop body, however,
    so an empty statement—just a bare semicolon—is used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，所有工作都由表达式`a[i++] = 0`完成，不需要循环体。然而，JavaScript语法要求循环体作为一个语句，因此使用了一个空语句——只是一个裸分号。
- en: 'Note that the accidental inclusion of a semicolon after the right parenthesis
    of a `for` loop, `while` loop, or `if` statement can cause frustrating bugs that
    are difficult to detect. For example, the following code probably does not do
    what the author intended:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`for`循环、`while`循环或`if`语句的右括号后意外包含分号可能导致难以检测的令人沮丧的错误。例如，以下代码可能不会按照作者的意图执行：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you intentionally use the empty statement, it is a good idea to comment
    your code in a way that makes it clear that you are doing it on purpose. For example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有意使用空语句时，最好以一种清晰表明您是有意这样做的方式对代码进行注释。例如：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 5.3 Conditionals
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 条件语句
- en: Conditional statements execute or skip other statements depending on the value
    of a specified expression. These statements are the decision points of your code,
    and they are also sometimes known as “branches.” If you imagine a JavaScript interpreter
    following a path through your code, the conditional statements are the places
    where the code branches into two or more paths and the interpreter must choose
    which path to follow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句根据指定表达式的值执行或跳过其他语句。这些语句是您代码的决策点，有时也被称为“分支”。如果想象一个JavaScript解释器沿着代码路径执行，条件语句是代码分支成两个或多个路径的地方，解释器必须选择要遵循的路径。
- en: The following subsections explain JavaScript’s basic conditional, the `if/else`
    statement, and also cover `switch`, a more complicated, multiway branch statement.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节解释了JavaScript的基本条件语句`if/else`，并介绍了更复杂的多路分支语句`switch`。
- en: 5.3.1 if
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.1 if
- en: 'The `if` statement is the fundamental control statement that allows JavaScript
    to make decisions, or, more precisely, to execute statements conditionally. This
    statement has two forms. The first is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句是允许JavaScript做出决策的基本控制语句，更准确地说，是有条件地执行语句。该语句有两种形式。第一种是：'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this form, *expression* is evaluated. If the resulting value is truthy,
    *statement* is executed. If *expression* is falsy, *statement* is not executed.
    (See [§3.4](ch03.xhtml#booleans) for a definition of truthy and falsy values.)
    For example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式中，*expression*被评估。如果结果值为真值，将执行*statement*。如果*expression*为假值，则不执行*statement*。（有关真值和假值的定义，请参见[§3.4](ch03.xhtml#booleans)。）例如：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or similarly:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者类似地：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the parentheses around the *expression* are a required part of the
    syntax for the `if` statement.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，围绕*expression*的括号是`if`语句语法的必需部分。
- en: 'JavaScript syntax requires a single statement after the `if` keyword and parenthesized
    expression, but you can use a statement block to combine multiple statements into
    one. So the `if` statement might also look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语法要求在`if`关键字和括号表达式之后有一个语句，但您可以使用语句块将多个语句组合成一个。因此，`if`语句也可能如下所示：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second form of the `if` statement introduces an `else` clause that is executed
    when *expression* is `false`. Its syntax is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式的`if`语句引入了一个`else`子句，当*expression*为`false`时执行。其语法如下：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This form of the statement executes `statement1` if *expression* is truthy
    and executes `statement2` if *expression* is falsy. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句形式在*expression*为真值时执行`statement1`，在*expression*为假值时执行`statement2`。例如：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When you have nested `if` statements with `else` clauses, some caution is required
    to ensure that the `else` clause goes with the appropriate `if` statement. Consider
    the following lines:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有嵌套的带有`else`子句的`if`语句时，需要谨慎确保`else`子句与适当的`if`语句配对。考虑以下行：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, the inner `if` statement forms the single statement allowed
    by the syntax of the outer `if` statement. Unfortunately, it is not clear (except
    from the hint given by the indentation) which `if` the `else` goes with. And in
    this example, the indentation is wrong, because a JavaScript interpreter actually
    interprets the previous example as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，内部的`if`语句形成了外部`if`语句语法允许的单个语句。不幸的是，不清楚（除了缩进给出的提示外）`else`与哪个`if`配对。而且在这个例子中，缩进是错误的，因为JavaScript解释器实际上将前一个例子解释为：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The rule in JavaScript (as in most programming languages) is that by default
    an `else` clause is part of the nearest `if` statement. To make this example less
    ambiguous and easier to read, understand, maintain, and debug, you should use
    curly braces:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript（与大多数编程语言一样）的规则是，默认情况下`else`子句是最近的`if`语句的一部分。为了使这个例子不那么模棱两可，更容易阅读、理解、维护和调试，您应该使用花括号：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Many programmers make a habit of enclosing the bodies of `if` and `else` statements
    (as well as other compound statements, such as `while` loops) within curly braces,
    even when the body consists of only a single statement. Doing so consistently
    can prevent the sort of problem just shown, and I advise you to adopt this practice.
    In this printed book, I place a premium on keeping example code vertically compact,
    and I do not always follow my own advice on this matter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员习惯将 `if` 和 `else` 语句的主体（以及其他复合语句，如 `while` 循环）放在花括号中，即使主体只包含一个语句。始终如此可以防止刚才显示的问题，我建议你采用这种做法。在这本印刷书中，我非常重视保持示例代码的垂直紧凑性，并且并不总是遵循自己在这个问题上的建议。
- en: 5.3.2 else if
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.2 else if
- en: 'The `if/else` statement evaluates an expression and executes one of two pieces
    of code, depending on the outcome. But what about when you need to execute one
    of many pieces of code? One way to do this is with an `else if` statement. `else
    if` is not really a JavaScript statement, but simply a frequently used programming
    idiom that results when repeated `if/else` statements are used:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`if/else` 语句评估一个表达式并根据结果执行两个代码块中的一个。但是当你需要执行多个代码块中的一个时怎么办？一种方法是使用 `else if`
    语句。`else if` 实际上不是一个 JavaScript 语句，而只是一个经常使用的编程习惯，当使用重复的 `if/else` 语句时会出现：'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There is nothing special about this code. It is just a series of `if` statements,
    where each following `if` is part of the `else` clause of the previous statement.
    Using the `else if` idiom is preferable to, and more legible than, writing these
    statements out in their syntactically equivalent, fully nested form:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码没有什么特别之处。它只是一系列 `if` 语句，每个后续的 `if` 都是前一个语句的 `else` 子句的一部分。使用 `else if` 习惯比在其语法上等效的完全嵌套形式中编写这些语句更可取，也更易读：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 5.3.3 switch
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3.3 switch
- en: An `if` statement causes a branch in the flow of a program’s execution, and
    you can use the `else if` idiom to perform a multiway branch. This is not the
    best solution, however, when all of the branches depend on the value of the same
    expression. In this case, it is wasteful to repeatedly evaluate that expression
    in multiple `if` statements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句会导致程序执行流程的分支，你可以使用 `else if` 习惯来执行多路分支。然而，当所有分支都依赖于相同表达式的值时，这并不是最佳解决方案。在这种情况下，多次在多个
    `if` 语句中评估该表达式是浪费的。'
- en: 'The `switch` statement handles exactly this situation. The `switch` keyword
    is followed by an expression in parentheses and a block of code in curly braces:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句正好处理这种情况。`switch` 关键字后跟着括号中的表达式和花括号中的代码块：'
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, the full syntax of a `switch` statement is more complex than this.
    Various locations in the block of code are labeled with the `case` keyword followed
    by an expression and a colon. When a `switch` executes, it computes the value
    of *expression* and then looks for a `case` label whose expression evaluates to
    the same value (where sameness is determined by the `===` operator). If it finds
    one, it starts executing the block of code at the statement labeled by the `case`.
    If it does not find a `case` with a matching value, it looks for a statement labeled
    `default:`. If there is no `default:` label, the `switch` statement skips the
    block of code altogether.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`switch` 语句的完整语法比这更复杂。代码块中的各个位置都用 `case` 关键字标记，后跟一个表达式和一个冒号。当 `switch` 执行时，它计算*表达式*的值，然后寻找一个
    `case` 标签，其表达式的值与之相同（相同性由 `===` 运算符确定）。如果找到一个匹配值的 `case`，它会从标记为 `case` 的语句开始执行代码块。如果找不到具有匹配值的
    `case`，它会寻找一个标记为 `default:` 的语句。如果没有 `default:` 标签，`switch` 语句会跳过整个代码块。
- en: '`switch` is a confusing statement to explain; its operation becomes much clearer
    with an example. The following `switch` statement is equivalent to the repeated
    `if/else` statements shown in the previous section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 是一个很难解释的语句；通过一个例子，它的操作会变得更加清晰。下面的 `switch` 语句等同于前一节中展示的重复的 `if/else`
    语句：'
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the `break` keyword used at the end of each `case` in this code. The `break`
    statement, described later in this chapter, causes the interpreter to jump to
    the end (or “break out”) of the `switch` statement and continue with the statement
    that follows it. The `case` clauses in a `switch` statement specify only the *starting
    point* of the desired code; they do not specify any ending point. In the absence
    of `break` statements, a `switch` statement begins executing its block of code
    at the `case` label that matches the value of its *expression* and continues executing
    statements until it reaches the end of the block. On rare occasions, it is useful
    to write code like this that “falls through” from one `case` label to the next,
    but 99% of the time you should be careful to end every `case` with a `break` statement.
    (When using `switch` inside a function, however, you may use a `return` statement
    instead of a `break` statement. Both serve to terminate the `switch` statement
    and prevent execution from falling through to the next `case`.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这段代码中每个 `case` 结尾使用的 `break` 关键字。`break` 语句会在本章后面描述，它会导致解释器跳出（或“中断”）`switch`
    语句并继续执行后面的语句。`switch` 语句中的 `case` 子句只指定所需代码的*起始点*；它们不指定任何结束点。在没有 `break` 语句的情况下，`switch`
    语句会从与其*表达式*值匹配的 `case` 标签开始执行其代码块，并继续执行语句直到达到代码块的末尾。在极少数情况下，编写“穿透”从一个 `case` 标签到下一个的代码是有用的，但99%
    的情况下，你应该小心地用 `break` 语句结束每个 `case`。（然而，在函数内部使用 `switch` 时，你可以使用 `return` 语句代替
    `break` 语句。两者都用于终止 `switch` 语句并防止执行穿透到下一个 `case`。）
- en: 'Here is a more realistic example of the `switch` statement; it converts a value
    to a string in a way that depends on the type of the value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `switch` 语句的一个更加现实的例子；它根据值的类型将值转换为字符串：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that in the two previous examples, the `case` keywords are followed by
    number and string literals, respectively. This is how the `switch` statement is
    most often used in practice, but note that the ECMAScript standard allows each
    `case` to be followed by an arbitrary expression.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前两个示例中，`case`关键字分别后跟数字和字符串字面量。这是`switch`语句在实践中最常用的方式，但请注意，ECMAScript标准允许每个`case`后跟任意表达式。
- en: The `switch` statement first evaluates the expression that follows the `switch`
    keyword and then evaluates the `case` expressions, in the order in which they
    appear, until it finds a value that matches.^([1](ch05.xhtml#idm46198554953944))
    The matching case is determined using the `===` identity operator, not the `==`
    equality operator, so the expressions must match without any type conversion.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句首先评估跟在`switch`关键字后面的表达式，然后按照它们出现的顺序评估`case`表达式，直到找到匹配的值。匹配的情况是使用`===`身份运算符确定的，而不是`==`相等运算符，因此表达式必须在没有任何类型转换的情况下匹配。'
- en: Because not all of the `case` expressions are evaluated each time the `switch`
    statement is executed, you should avoid using `case` expressions that contain
    side effects such as function calls or assignments. The safest course is simply
    to limit your `case` expressions to constant expressions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因为并非每次执行`switch`语句时都会评估所有`case`表达式，所以应避免使用包含函数调用或赋值等副作用的`case`表达式。最安全的做法是将`case`表达式限制为常量表达式。
- en: As explained earlier, if none of the `case` expressions match the `switch` expression,
    the `switch` statement begins executing its body at the statement labeled `default:`.
    If there is no `default:` label, the `switch` statement skips its body altogether.
    Note that in the examples shown, the `default:` label appears at the end of the
    `switch` body, following all the `case` labels. This is a logical and common place
    for it, but it can actually appear anywhere within the body of the statement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果没有`case`表达式与`switch`表达式匹配，`switch`语句将从标记为`default:`的语句处开始执行其主体。如果没有`default:`标签，则`switch`语句将完全跳过其主体。请注意，在所示示例中，`default:`标签出现在`switch`主体的末尾，跟在所有`case`标签后面。这是一个逻辑和常见的位置，但实际上它可以出现在语句主体的任何位置。
- en: 5.4 Loops
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 循环
- en: 'To understand conditional statements, we imagined the JavaScript interpreter
    following a branching path through your source code. The *looping statements*
    are those that bend that path back upon itself to repeat portions of your code.
    JavaScript has five looping statements: `while`, `do/while`, `for`, `for/of` (and
    its `for/await` variant), and `for/in`. The following subsections explain each
    in turn. One common use for loops is to iterate over the elements of an array.
    [§7.6](ch07.xhtml#iteratingarrays) discusses this kind of loop in detail and covers
    special looping methods defined by the Array class.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解条件语句，我们可以想象JavaScript解释器通过源代码的分支路径。*循环语句*是将该路径弯回自身以重复代码部分的语句。JavaScript有五个循环语句：`while`、`do/while`、`for`、`for/of`（及其`for/await`变体）和`for/in`。以下各小节依次解释每个循环语句。循环的一个常见用途是遍历数组元素。[§7.6](ch07.xhtml#iteratingarrays)详细讨论了这种循环，并涵盖了Array类定义的特殊循环方法。
- en: 5.4.1 while
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.1 while
- en: 'Just as the `if` statement is JavaScript’s basic conditional, the `while` statement
    is JavaScript’s basic loop. It has the following syntax:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`if`语句是JavaScript的基本条件语句一样，`while`语句是JavaScript的基本循环语句。它的语法如下：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To execute a `while` statement, the interpreter first evaluates *expression*.
    If the value of the expression is falsy, then the interpreter skips over the *statement*
    that serves as the loop body and moves on to the next statement in the program.
    If, on the other hand, the *expression* is truthy, the interpreter executes the
    *statement* and repeats, jumping back to the top of the loop and evaluating *expression*
    again. Another way to say this is that the interpreter executes *statement* repeatedly
    *while* the *expression* is truthy. Note that you can create an infinite loop
    with the syntax `while(true)`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`while`语句，解释器首先评估*expression*。如果表达式的值为假值，则解释器跳过作为循环体的*statement*并继续执行程序中的下一条语句。另一方面，如果*expression*为真值，则解释器执行*statement*并重复，跳回循环的顶部并再次评估*expression*。另一种说法是，解释器在*expression*为真值时重复执行*statement*。请注意，您可以使用`while(true)`语法创建一个无限循环。
- en: 'Usually, you do not want JavaScript to perform exactly the same operation over
    and over again. In almost every loop, one or more variables change with each *iteration*
    of the loop. Since the variables change, the actions performed by executing *statement*
    may differ each time through the loop. Furthermore, if the changing variable or
    variables are involved in *expression*, the value of the expression may be different
    each time through the loop. This is important; otherwise, an expression that starts
    off truthy would never change, and the loop would never end! Here is an example
    of a `while` loop that prints the numbers from 0 to 9:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不希望JavaScript一遍又一遍地执行完全相同的操作。在几乎每个循环中，一个或多个变量会随着循环的每次*迭代*而改变。由于变量会改变，执行*statement*的操作可能每次循环时都不同。此外，如果涉及到*expression*中的变化变量，那么表达式的值可能每次循环时都不同。这很重要；否则，一开始为真值的表达式永远不会改变，循环永远不会结束！以下是一个打印从0到9的数字的`while`循环示例：
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the variable `count` starts off at 0 and is incremented each
    time the body of the loop runs. Once the loop has executed 10 times, the expression
    becomes `false` (i.e., the variable `count` is no longer less than 10), the `while`
    statement finishes, and the interpreter can move on to the next statement in the
    program. Many loops have a counter variable like `count`. The variable names `i`,
    `j`, and `k` are commonly used as loop counters, though you should use more descriptive
    names if it makes your code easier to understand.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，变量`count`从0开始，并且在循环体运行每次后递增。一旦循环执行了10次，表达式变为`false`（即变量`count`不再小于10），`while`语句结束，解释器可以继续执行程序中的下一条语句。许多循环都有像`count`这样的计数变量。变量名`i`、`j`和`k`通常用作循环计数器，但如果使用更具描述性的名称可以使代码更易于理解。
- en: 5.4.2 do/while
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.2 do/while
- en: 'The `do/while` loop is like a `while` loop, except that the loop expression
    is tested at the bottom of the loop rather than at the top. This means that the
    body of the loop is always executed at least once. The syntax is:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`do/while`循环类似于`while`循环，不同之处在于循环表达式在循环底部测试而不是在顶部测试。这意味着循环体始终至少执行一次。语法是：'
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `do/while` loop is less commonly used than its `while` cousin—in practice,
    it is somewhat uncommon to be certain that you want a loop to execute at least
    once. Here’s an example of a `do/while` loop:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`do/while`循环比其`while`表亲更少使用——实际上，很少有确定要执行至少一次循环的情况。以下是`do/while`循环的示例：'
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are a couple of syntactic differences between the `do/while` loop and
    the ordinary `while` loop. First, the `do` loop requires both the `do` keyword
    (to mark the beginning of the loop) and the `while` keyword (to mark the end and
    introduce the loop condition). Also, the `do` loop must always be terminated with
    a semicolon. The `while` loop doesn’t need a semicolon if the loop body is enclosed
    in curly braces.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`do/while`循环和普通的`while`循环之间有一些语法上的差异。首先，`do`循环需要`do`关键字（标记循环开始）和`while`关键字（标记结束并引入循环条件）。此外，`do`循环必须始终以分号结尾。如果循环体用大括号括起来，则`while`循环不需要分号。'
- en: 5.4.3 for
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.3 for
- en: 'The `for` statement provides a looping construct that is often more convenient
    than the `while` statement. The `for` statement simplifies loops that follow a
    common pattern. Most loops have a counter variable of some kind. This variable
    is initialized before the loop starts and is tested before each iteration of the
    loop. Finally, the counter variable is incremented or otherwise updated at the
    end of the loop body, just before the variable is tested again. In this kind of
    loop, the initialization, the test, and the update are the three crucial manipulations
    of a loop variable. The `for` statement encodes each of these three manipulations
    as an expression and makes those expressions an explicit part of the loop syntax:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句提供了一个循环结构，通常比`while`语句更方便。`for`语句简化了遵循常见模式的循环。大多数循环都有某种计数变量。该变量在循环开始之前初始化，并在每次循环迭代之前进行测试。最后，在循环体结束之前，计数变量会递增或以其他方式更新，然后再次测试该变量。在这种循环中，初始化、测试和更新是循环变量的三个关键操作。`for`语句将这三个操作编码为表达式，并将这些表达式作为循环语法的显式部分：'
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*initialize*, *test*, and *increment* are three expressions (separated by semicolons)
    that are responsible for initializing, testing, and incrementing the loop variable.
    Putting them all in the first line of the loop makes it easy to understand what
    a `for` loop is doing and prevents mistakes such as forgetting to initialize or
    increment the loop variable.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*initialize*、*test*和*increment*是三个（用分号分隔的）表达式，负责初始化、测试和递增循环变量。将它们都放在循环的第一行中可以轻松理解`for`循环正在做什么，并防止遗漏初始化或递增循环变量等错误。'
- en: The simplest way to explain how a `for` loop works is to show the equivalent
    `while` loop:^([2](ch05.xhtml#idm46198554759768))
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解释`for`循环如何工作的最简单方法是展示等效的`while`循环：^([2](ch05.xhtml#idm46198554759768))
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In other words, the *initialize* expression is evaluated once, before the loop
    begins. To be useful, this expression must have side effects (usually an assignment).
    JavaScript also allows *initialize* to be a variable declaration statement so
    that you can declare and initialize a loop counter at the same time. The *test*
    expression is evaluated before each iteration and controls whether the body of
    the loop is executed. If *test* evaluates to a truthy value, the *statement* that
    is the body of the loop is executed. Finally, the *increment* expression is evaluated.
    Again, this must be an expression with side effects in order to be useful. Generally,
    it is either an assignment expression, or it uses the `++` or `--` operators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*initialize*表达式在循环开始之前只计算一次。为了有用，此表达式必须具有副作用（通常是赋值）。JavaScript 还允许*initialize*是一个变量声明语句，这样您可以同时声明和初始化循环计数器。*test*表达式在每次迭代之前进行评估，并控制循环体是否执行。如果*test*评估为真值，则执行循环体的*statement*。最后，评估*increment*表达式。同样，这必须是具有副作用的表达式才能有��。通常，它是一个赋值表达式，或者使用`++`或`--`运算符。
- en: 'We can print the numbers from 0 to 9 with a `for` loop like the following.
    Contrast it with the equivalent `while` loop shown in the previous section:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下`for`循环打印从0到9的数字。将其与前一节中显示的等效`while`循环进行对比：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Loops can become a lot more complex than this simple example, of course, and
    sometimes multiple variables change with each iteration of the loop. This situation
    is the only place that the comma operator is commonly used in JavaScript; it provides
    a way to combine multiple initialization and increment expressions into a single
    expression suitable for use in a `for` loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，循环可能比这个简单示例复杂得多，有时多个变量在循环的每次迭代中都会发生变化。这种情况是 JavaScript 中唯一常用逗号运算符的地方；它提供了一种将多个初始化和递增表达式组合成适合在`for`循环中使用的单个表达式的方法：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In all our loop examples so far, the loop variable has been numeric. This is
    quite common but is not necessary. The following code uses a `for` loop to traverse
    a linked list data structure and return the last object in the list (i.e., the
    first object that does not have a `next` property):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的循环示例中，循环变量都是数字。这是很常见的，但并非必须的。以下代码使用`for`循环遍历一个链表数据结构并返回列表中的最后一个对象（即，第一个没有`next`属性的对象）：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that this code has no *initialize* expression. Any of the three expressions
    may be omitted from a `for` loop, but the two semicolons are required. If you
    omit the *test* expression, the loop repeats forever, and `for(;;)` is another
    way of writing an infinite loop, like `while(true)`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码没有*初始化*表达式。`for`循环中的三个表达式中的任何一个都可以省略，但两个分号是必需的。如果省略*测试*表达式，则循环将永远重复，`for(;;)`就像`while(true)`一样是写无限循环的另一种方式。
- en: 5.4.4 for/of
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.4 `for/of`
- en: 'ES6 defines a new loop statement: `for/of`. This new kind of loop uses the
    `for` keyword but is a completely different kind of loop than the regular `for`
    loop. (It is also completely different than the older `for/in` loop that we’ll
    describe in [§5.4.5](#forinloop).)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ES6定义了一种新的循环语句：`for/of`。这种新类型的循环使用`for`关键字，但是与常规的`for`循环完全不同。（它也与我们将在[§5.4.5](#forinloop)中描述的旧的`for/in`循环完全不同。）
- en: 'The `for/of` loop works with *iterable* objects. We’ll explain exactly what
    it means for an object to be iterable in [Chapter 12](ch12.xhtml#itergene), but
    for this chapter, it is enough to know that arrays, strings, sets, and maps are
    iterable: they represent a sequence or set of elements that you can loop or iterate
    through using a `for/of` loop.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/of`循环适用于*可迭代*对象。我们将在[第12章](ch12.xhtml#itergene)中详细解释对象何时被视为可迭代，但在本章中，只需知道数组、字符串、集合和映射是可迭代的：它们代表一个序列或一组元素，您可以使用`for/of`循环进行循环或迭代。'
- en: 'Here, for example, is how we can use `for/of` to loop through the elements
    of an array of numbers and compute their sum:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是我们如何使用`for/of`循环遍历一个数字数组的元素并计算它们的总和：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Superficially, the syntax looks like a regular `for` loop: the `for` keyword
    is followed by parentheses that contain details about what the loop should do.
    In this case, the parentheses contain a variable declaration (or, for variables
    that have already been declared, simply the name of the variable) followed by
    the `of` keyword and an expression that evaluates to an iterable object, like
    the `data` array in this case. As with all loops, the body of a `for/of` loop
    follows the parentheses, typically within curly braces.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，语法看起来像是常规的`for`循环：`for`关键字后面跟着包含有关循环应该执行的详细信息的括号。在这种情况下，括号包含一个变量声明（或者对于已经声明的变量，只是变量的名称），后面跟着`of`关键字和一个求值为可迭代对象的表达式，就像这种情况下的`data`数组一样。与所有循环一样，`for/of`循环的主体跟在括号后面，通常在花括号内。
- en: In the code just shown, the loop body runs once for each element of the `data`
    array. Before each execution of the loop body, the next element of the array is
    assigned to the element variable. Array elements are iterated in order from first
    to last.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚才显示的代码中，循环体会针对`data`数组的每个元素运行一次。在执行循环体之前，数组的下一个元素会被��配给元素变量。数组元素按顺序从第一个到最后一个进行迭代。
- en: Arrays are iterated “live”—changes made during the iteration may affect the
    outcome of the iteration. If we modify the preceding code by adding the line `data.push(sum);`
    inside the loop body, then we create an infinite loop because the iteration can
    never reach the last element of the array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是“实时”迭代的——在迭代过程中进行的更改可能会影响迭代的结果。如果我们在循环体内添加`data.push(sum);`这行代码，那么我们将创建一个无限循环，因为迭代永远无法到达数组的最后一个元素。
- en: for/of with objects
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象进行`for/of`循环
- en: 'Objects are not (by default) iterable. Attempting to use `for/of` on a regular
    object throws a TypeError at runtime:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对象默认情况下不可迭代。尝试在常规对象上使用`for/of`会在运行时引发TypeError：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to iterate through the properties of an object, you can use the
    `for/in` loop (introduced in [§5.4.5](#forinloop)), or use `for/of` with the `Object.keys()`
    method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要遍历对象的属性，可以使用`for/in`循环（在[§5.4.5](#forinloop)中介绍），或者使用`for/of`与`Object.keys()`方法：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This works because `Object.keys()` returns an array of property names for an
    object, and arrays are iterable with `for/of`. Note also that this iteration of
    the keys of an object is not live as the array example above was—changes to the
    object `o` made in the loop body will have no effect on the iteration. If you
    don’t care about the keys of an object, you can also iterate through their corresponding
    values like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Object.keys()`返回一个对象的属性名称数组，数组可以使用`for/of`进行迭代。还要注意，与上面的数组示例不同，对象的键的这种迭代不是实时的——在循环体中对对象`o`进行的更改不会影响迭代。如果您不关心对象的键，也可以像这样迭代它们对应的值：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And if you are interested in both the keys and the values of an object’s properties,
    you can use `for/of` with `Object.entries()` and destructuring assignment:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对对象属性的键和值都感兴趣，可以使用`for/of`与`Object.entries()`和解构赋值：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`Object.entries()` returns an array of arrays, where each inner array represents
    a key/value pair for one property of the object. We use destructuring assignment
    in this code example to unpack those inner arrays into two individual variables.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.entries()`返回一个数组，其中每个内部数组表示对象的一个属性的键/值对。在这个代码示例中，我们使用解构赋值来将这些内部数组解包成两个单独的变量。'
- en: for/of with strings
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串进行`for/of`循环
- en: 'Strings are iterable character-by-character in ES6:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，字符串是逐个字符可迭代的：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that strings are iterated by Unicode codepoint, not by UTF-16 character.
    The string “I ❤ ![](Images/cat.png)” has a `.length` of 5 (because the two emoji
    characters each require two UTF-16 characters to represent). But if you iterate
    that string with `for/of`, the loop body will run three times, once for each of
    the three code points “I”, “❤”, and “![](Images/cat.png).”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符串是按Unicode代码点迭代的，而不是按UTF-16字符。字符串“I ❤ ![](Images/cat.png)”的`.length`为5（因为两个表情符号字符分别需要两个UTF-16字符来表示）。但如果您使用`for/of`迭代该字符串，循环体将运行三次，分别为每个代码点“I”、“❤”和“![](Images/cat.png)”。
- en: for/of with Set and Map
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Set 和 Map 进行 `for/of`
- en: 'The built-in ES6 Set and Map classes are iterable. When you iterate a Set with
    `for/of`, the loop body runs once for each element of the set. You could use code
    like this to print the unique words in a string of text:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 ES6 Set 和 Map 类是可迭代的。当您使用 `for/of` 迭代 Set 时，循环体会为集合的每个元素运行一次。您可以使用以下代码打印文本字符串中的唯一单词：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Maps are an interesting case because the iterator for a Map object does not
    iterate the Map keys, or the Map values, but key/value pairs. Each time through
    the iteration, the iterator returns an array whose first element is a key and
    whose second element is the corresponding value. Given a Map `m`, you could iterate
    and destructure its key/value pairs like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Map 是一个有趣的情况，因为 Map 对象的迭代器不会迭代 Map 键或 Map 值，而是键/值对。在每次迭代中，迭代器返回一个数组，其第一个元素是键，第二个元素是相应的值。给定一个
    Map `m`，您可以像这样迭代并解构其键/值对：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Asynchronous iteration with for/await
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `for/await` 进行异步迭代
- en: ES2018 introduces a new kind of iterator, known as an *asynchronous iterator*,
    and a variant on the `for/of` loop, known as the `for/await` loop that works with
    asynchronous iterators.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ES2018 引入了一种新类型的迭代器，称为*异步迭代器*，以及与之配套的 `for/of` 循环的变体，称为 `for/await` 循环，可与异步迭代器一起使用。
- en: 'You’ll need to read Chapters [12](ch12.xhtml#itergene) and [13](ch13.xhtml#async)
    in order to understand the `for/await` loop, but here is how it looks in code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要阅读第 [12](ch12.xhtml#itergene) 章和第 [13](ch13.xhtml#async) 章才能理解 `for/await`
    循环，但以下是代码示例：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 5.4.5 for/in
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4.5 for/in
- en: A `for/in` loop looks a lot like a `for/of` loop, with the `of` keyword changed
    to `in`. While a `for/of` loop requires an iterable object after the `of`, a `for/in`
    loop works with any object after the `in`. The `for/of` loop is new in ES6, but
    `for/in` has been part of JavaScript since the very beginning (which is why it
    has the more natural sounding syntax).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/in` 循环看起来很像 `for/of` 循环，只是将 `of` 关键字更改为 `in`。在 `of` 之后，`for/of` 循环需要一个可迭代对象，而
    `for/in` 循环在 `in` 之后可以使用任何对象。`for/of` 循环是 ES6 中的新功能，但 `for/in` 从 JavaScript 最初就存在（这就是为什么它具有更自然的语法）。'
- en: 'The `for/in` statement loops through the property names of a specified object.
    The syntax looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/in` 语句循环遍历指定对象的属性名称。语法如下：'
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '*variable* typically names a variable, but it may be a variable declaration
    or anything suitable as the left-hand side of an assignment expression. *object*
    is an expression that evaluates to an object. As usual, *statement* is the statement
    or statement block that serves as the body of the loop.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*variable* 通常命名一个变量，但它也可以是一个变量声明或任何适合作为赋值表达式左侧的内容。*object* 是一个求值为对象的表达式。通常情况下，*statement*
    是作为循环主体的语句或语句块。'
- en: 'And you might use a `for/in` loop like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会像这样使用 `for/in` 循环：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To execute a `for/in` statement, the JavaScript interpreter first evaluates
    the *object* expression. If it evaluates to `null` or `undefined`, the interpreter
    skips the loop and moves on to the next statement. The interpreter now executes
    the body of the loop once for each enumerable property of the object. Before each
    iteration, however, the interpreter evaluates the *variable* expression and assigns
    the name of the property (a string value) to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 `for/in` 语句，JavaScript 解释器首先评估 *object* 表达式。如果它评估为 `null` 或 `undefined`，解释器将跳过循环并继续执行下一条语句。解释器现在会为对象的每��可枚举属性执行循环体。然而，在每次迭代之前，解释器会评估
    *variable* 表达式并将属性的名称（一个字符串值）赋给它。
- en: 'Note that the *variable* in the `for/in` loop may be an arbitrary expression,
    as long as it evaluates to something suitable for the left side of an assignment.
    This expression is evaluated each time through the loop, which means that it may
    evaluate differently each time. For example, you can use code like the following
    to copy the names of all object properties into an array:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 `for/in` 循环中的 *variable* 可以是任意表达式，只要它评估为适合赋值左侧的内容。这个表达式在每次循环时都会被评估，这意味着它可能每次评估的结果都不同。例如，您可以使用以下代码将所有对象属性的名称复制到数组中：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'JavaScript arrays are simply a specialized kind of object, and array indexes
    are object properties that can be enumerated with a `for/in` loop. For example,
    following the previous code with this line enumerates the array indexes 0, 1,
    and 2:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 数组只是一种特殊类型的对象，数组索引是可以用 `for/in` 循环枚举的对象属性。例如，以下代码后面加上这行代码，将枚举数组索引
    0、1 和 2：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I find that a common source of bugs in my own code is the accidental use of
    `for/in` with arrays when I meant to use `for/of`. When working with arrays, you
    almost always want to use `for/of` instead of `for/in`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现在我的代码中常见的错误来源是意外使用数组时使用 `for/in` 而不是 `for/of`。在处理数组时，您几乎总是希望使用 `for/of` 而不是
    `for/in`。
- en: The `for/in` loop does not actually enumerate all properties of an object. It
    does not enumerate properties whose names are symbols. And of the properties whose
    names are strings, it only loops over the *enumerable* properties (see [§14.1](ch14.xhtml#propertydescriptors)).
    The various built-in methods defined by core JavaScript are not enumerable. All
    objects have a `toString()` method, for example, but the `for/in` loop does not
    enumerate this `toString` property. In addition to built-in methods, many other
    properties of the built-in objects are non-enumerable. All properties and methods
    defined by your code are enumerable, by default. (You can make them non-enumerable
    using techniques explained in [§14.1](ch14.xhtml#propertydescriptors).)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/in` 循环实际上并不枚举对象的所有属性。它不会枚举名称为符号的属性。对于名称为字符串的属性，它只循环遍历*可枚举*属性（参见[§14.1](ch14.xhtml#propertydescriptors)）。核心
    JavaScript 定义的各种内置方法都不可枚举。例如，所有对象都有一个 `toString()` 方法，但 `for/in` 循环不会枚举这个 `toString`
    属性。除了内置方法，许多内置对象的其他属性也是不可枚举的。默认情况下，您代码定义的所有属性和方法都是可枚举的（您可以使用[§14.1](ch14.xhtml#propertydescriptors)中解释的技术使它们变为不可枚举）。'
- en: Enumerable inherited properties (see [§6.3.2](ch06.xhtml#inheritance)) are also
    enumerated by the `for/in` loop. This means that if you use `for/in` loops and
    also use code that defines properties that are inherited by all objects, then
    your loop may not behave in the way you expect. For this reason, many programmers
    prefer to use a `for/of` loop with `Object.keys()` instead of a `for/in` loop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可枚举的继承属性（参见[§6.3.2](ch06.xhtml#inheritance)）也会被`for/in`循环枚举。这意味着如果您使用`for/in`循环，并且还使用定义了所有对象都继承的属性的代码，那么您的循环可能不会按您的预期方式运行。因此，许多程序员更喜欢使用`Object.keys()`的`for/of`循环而不是`for/in`循环。
- en: If the body of a `for/in` loop deletes a property that has not yet been enumerated,
    that property will not be enumerated. If the body of the loop defines new properties
    on the object, those properties may or may not be enumerated. See [§6.6.1](ch06.xhtml#property-enumeration-order)
    for more information on the order in which `for/in` enumerates the properties
    of an object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`for/in`���环的主体删除尚未枚举的属性，则该属性将不会被枚举。如果循环的主体在对象上定义了新属性，则这些属性可能会被枚举，也可能不会被枚举。有关`for/in`枚举对象属性的顺序的更多信息，请参见[§6.6.1](ch06.xhtml#property-enumeration-order)。
- en: 5.5 Jumps
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 跳转
- en: Another category of JavaScript statements are *jump statements*. As the name
    implies, these cause the JavaScript interpreter to jump to a new location in the
    source code. The `break` statement makes the interpreter jump to the end of a
    loop or other statement. `continue` makes the interpreter skip the rest of the
    body of a loop and jump back to the top of a loop to begin a new iteration. JavaScript
    allows statements to be named, or *labeled*, and `break` and `continue` can identify
    the target loop or other statement label.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类 JavaScript 语句是*跳转语句*。顾名思义，这些语句会导致 JavaScript 解释器跳转到源代码中的新位置。`break`语句使解释器跳转到循环或其他语句的末尾。`continue`使解释器跳过循环体的其余部分，并跳回到循环的顶部开始新的迭代。JavaScript
    允许对语句进行命名，或*标记*，`break`和`continue`可以标识目标循环或其他语句标签。
- en: 'The `return` statement makes the interpreter jump from a function invocation
    back to the code that invoked it and also supplies the value for the invocation.
    The `throw` statement is a kind of interim return from a generator function. The
    `throw` statement raises, or *throws*, an exception and is designed to work with
    the `try/catch/finally` statement, which establishes a block of exception-handling
    code. This is a complicated kind of jump statement: when an exception is thrown,
    the interpreter jumps to the nearest enclosing exception handler, which may be
    in the same function or up the call stack in an invoking function.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句使解释器从函数调用跳回到调用它的代码，并提供调用的值。`throw`语句是一种临时从生成器函数返回的方式。`throw`语句引发异常，并设计用于与`try/catch/finally`语句一起工作，后者建立了一个异常处理代码块。这是一种复杂的跳转语句：当抛出异常时，解释器会跳转到最近的封闭异常处理程序，该处理程序可能在同一函数中或在调用函数的调用堆栈中。'
- en: Details about each of these jump statements are in the sections that follow.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些跳转语句的详细信息在接下来的章节中。
- en: 5.5.1 Labeled Statements
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.1 标记语句
- en: 'Any statement may be *labeled* by preceding it with an identifier and a colon:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 任何语句都可以通过在其前面加上标识符和冒号来*标记*：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By labeling a statement, you give it a name that you can use to refer to it
    elsewhere in your program. You can label any statement, although it is only useful
    to label statements that have bodies, such as loops and conditionals. By giving
    a loop a name, you can use `break` and `continue` statements inside the body of
    the loop to exit the loop or to jump directly to the top of the loop to begin
    the next iteration. `break` and `continue` are the only JavaScript statements
    that use statement labels; they are covered in the following subsections. Here
    is an example of a labeled `while` loop and a `continue` statement that uses the
    label.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给语句加上标签，您为其赋予一个名称，以便在程序的其他地方引用它。您可以为任何语句加上标签，尽管只有为具有主体的语句加上标签才有用，例如循环和条件语句。通过给循环命名，您可以在循环体内使用`break`和`continue`语句来退出循环或直接跳转到循环的顶部开始下一次迭代。`break`和`continue`是唯一使用语句标签的
    JavaScript 语句；它们在以下子节中介绍。这里是一个带有标签的`while`循环和使用标签的`continue`语句的示例。
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The *identifier* you use to label a statement can be any legal JavaScript identifier
    that is not a reserved word. The namespace for labels is different than the namespace
    for variables and functions, so you can use the same identifier as a statement
    label and as a variable or function name. Statement labels are defined only within
    the statement to which they apply (and within its substatements, of course). A
    statement may not have the same label as a statement that contains it, but two
    statements may have the same label as long as neither one is nested within the
    other. Labeled statements may themselves be labeled. Effectively, this means that
    any statement may have multiple labels.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用于标记语句的*标识符*可以是任何合法的 JavaScript 标识符，不能是保留字。标签的命名空间与变量和函数的命名空间不同，因此您可以将相同的标识符用作语句标签和变量或函数名称。语句标签仅在其适用的语句内部定义（当然也包括其子语句）。语句不能具有包含它的语句相同的标签，但是只要一个语句不嵌套在另一个语句内，两个语句可以具有相同的标签。标记的语句本身也可以被标记。实际上，这意味着任何语句可以具有多个标签。
- en: 5.5.2 break
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.2 break
- en: 'The `break` statement, used alone, causes the innermost enclosing loop or `switch`
    statement to exit immediately. Its syntax is simple:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用的`break`语句会导致最内层的循环或`switch`语句立即退出。其语法很简单：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because it causes a loop or `switch` to exit, this form of the `break` statement
    is legal only if it appears inside one of these statements.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它导致循环或`switch`退出，所以这种形式的`break`语句只有在出现在这些语句内部时才合法。
- en: 'You’ve already seen examples of the `break` statement within a `switch` statement.
    In loops, it is typically used to exit prematurely when, for whatever reason,
    there is no longer any need to complete the loop. When a loop has complex termination
    conditions, it is often easier to implement some of these conditions with `break`
    statements rather than trying to express them all in a single loop expression.
    The following code searches the elements of an array for a particular value. The
    loop terminates in the normal way when it reaches the end of the array; it terminates
    with a `break` statement if it finds what it is looking for in the array:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了`switch`语句中`break`语句的示例。在循环中，当不再需要完成循环时，通常会提前退出。当循环具有复杂的终止条件时，通常更容易使用`break`语句实现其中一些条件，而不是尝试在单个循环表达式中表达所有条件。以下代码搜索数组元素以找到特定值。当它在数组中找到所需的内容时，循环以正常方式终止；如果在数组中找到所需的内容，则使用`break`语句终止：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'JavaScript also allows the `break` keyword to be followed by a statement label
    (just the identifier, with no colon):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript还允许在`break`关键字后面跟着一个语句标签（只是标识符，没有冒号）：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When `break` is used with a label, it jumps to the end of, or terminates, the
    enclosing statement that has the specified label. It is a syntax error to use
    `break` in this form if there is no enclosing statement with the specified label.
    With this form of the `break` statement, the named statement need not be a loop
    or `switch`: `break` can “break out of” any enclosing statement. This statement
    can even be a statement block grouped within curly braces for the sole purpose
    of naming the block with a label.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当`break`与标签一起使用时，它会跳转到具有指定标签的结束语句，或终止该结束语句。如果没有具有指定标签的结束语句，则以这种形式使用`break`语句是语法错误。使用这种形式的`break`语句时，命名的语句不必是循环或`switch`：`break`可以“跳出”任何包含语句。这个语句甚至可以是一个仅用于使用标签命名块的大括号组成的语句块。
- en: 'A newline is not allowed between the `break` keyword and the *labelname*. This
    is a result of JavaScript’s automatic insertion of omitted semicolons: if you
    put a line terminator between the `break` keyword and the label that follows,
    JavaScript assumes you meant to use the simple, unlabeled form of the statement
    and treats the line terminator as a semicolon. (See [§2.6](ch02.xhtml#optionalsemicolons).)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`break`关键字和*labelname*之间不允许换行。这是由于JavaScript自动插入省略的分号：如果在`break`关键字和后面的标签之间放置换行符，JavaScript会认为您想使用简单的、无标签的语句形式，并将换行符视为分号。（参见[§2.6](ch02.xhtml#optionalsemicolons)。）
- en: 'You need the labeled form of the `break` statement when you want to break out
    of a statement that is not the nearest enclosing loop or a `switch`. The following
    code demonstrates:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要跳出不是最近的循环或`switch`的语句时，您需要带标签的`break`语句。以下代码演示了：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, note that a `break` statement, with or without a label, can not transfer
    control across function boundaries. You cannot label a function definition statement,
    for example, and then use that label inside the function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，`break`语句，无论是否带有标签，都不能跨越函数边界转移控制。例如，您不能给函数定义语句加上标签，然后在函数内部使用该标签。
- en: 5.5.3 continue
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.3 continue
- en: 'The `continue` statement is similar to the `break` statement. Instead of exiting
    a loop, however, `continue` restarts a loop at the next iteration. The `continue`
    statement’s syntax is just as simple as the `break` statement’s:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句类似于`break`语句。但是，`continue`不是退出循环，而是在下一次迭代时重新开始循环。`continue`语句的语法与`break`语句一样简单：'
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `continue` statement can also be used with a label:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句也可以与标签一起使用：'
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `continue` statement, in both its labeled and unlabeled forms, can be used
    only within the body of a loop. Using it anywhere else causes a syntax error.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句，无论是带标签还是不带标签，只能在循环体内使用。在其他任何地方使用它都会导致语法错误。'
- en: 'When the `continue` statement is executed, the current iteration of the enclosing
    loop is terminated, and the next iteration begins. This means different things
    for different types of loops:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`continue`语句时，将终止当前循环的迭代，并开始下一次迭代。对于不同类型的循环，这意味着不同的事情：
- en: In a `while` loop, the specified *expression* at the beginning of the loop is
    tested again, and if it’s `true`, the loop body is executed starting from the
    top.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`while`循环中，循环开始时测试循环开头的指定*表达式*，如果为`true`，则从顶部执行循环体。
- en: In a `do/while` loop, execution skips to the bottom of the loop, where the loop
    condition is tested again before restarting the loop at the top.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`do/while`循环中，执行跳转到循环底部，然后再次测试循环条件，然后重新开始循环。
- en: In a `for` loop, the *increment* expression is evaluated, and the *test* expression
    is tested again to determine if another iteration should be done.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`for`循环中，将评估*增量*表达式，并再次测试*测试*表达式以确定是否应进行另一次迭代。
- en: In a `for/of` or `for/in` loop, the loop starts over with the next iterated
    value or next property name being assigned to the specified variable.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`for/of`或`for/in`循环中，循环将重新开始，下一个迭代值或下一个属性名将被赋给指定的变量。
- en: 'Note the difference in behavior of the `continue` statement in the `while`
    and `for` loops: a `while` loop returns directly to its condition, but a `for`
    loop first evaluates its *increment* expression and then returns to its condition.
    Earlier, we considered the behavior of the `for` loop in terms of an “equivalent”
    `while` loop. Because the `continue` statement behaves differently for these two
    loops, however, it is not actually possible to perfectly simulate a `for` loop
    with a `while` loop alone.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`while`和`for`循环中`continue`语句的行为差异：`while`循环直接返回到其条件，但`for`循环首先评���其*增量*表达式，然后返回到其条件。之前，我们考虑了`for`循环的行为，以等效的`while`循环来描述。然而，由于`continue`语句对这两种循环的行为不同，因此仅使用`while`循环无法完全模拟`for`循环。
- en: 'The following example shows an unlabeled `continue` statement being used to
    skip the rest of the current iteration of a loop when an error occurs:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在发生错误时使用未标记的`continue`语句跳过当前迭代的其余部分的情况：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Like the `break` statement, the `continue` statement can be used in its labeled
    form within nested loops when the loop to be restarted is not the immediately
    enclosing loop. Also, as with the `break` statement, line breaks are not allowed
    between the `continue` statement and its *labelname*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与`break`语句类似，`continue`语句可以在嵌套循环中的标记形式中使用，当要重新启动的循环不是直接包围的循环时。同样，与`break`语句一样，`continue`语句和其*labelname*之间不允许换行。
- en: 5.5.4 return
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.4 return
- en: 'Recall that function invocations are expressions and that all expressions have
    values. A `return` statement within a function specifies the value of invocations
    of that function. Here’s the syntax of the `return` statement:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住函数调用是表达式，所有表达式都有值。函数内部的`return`语句指定了该函数调用的值。下面是`return`语句的语法：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A `return` statement may appear only within the body of a function. It is a
    syntax error for it to appear anywhere else. When the `return` statement is executed,
    the function that contains it returns the value of *expression* to its caller.
    For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句只能出现在函数体内部。在其他任何地方出现都会导致语法错误。当执行`return`语句时，包含它的函数将*expression*的值返回给调用者。例如：'
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'With no `return` statement, a function invocation simply executes each of the
    statements in the function body in turn until it reaches the end of the function
    and then returns to its caller. In this case, the invocation expression evaluates
    to `undefined`. The `return` statement often appears as the last statement in
    a function, but it need not be last: a function returns to its caller when a `return`
    statement is executed, even if there are other statements remaining in the function
    body.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`return`语句时，函数调用会依次执行函数体中的每个语句，直到到达函数末尾然后返回给调用者。在这种情况下，调用表达式评估为`undefined`。`return`语句通常出现在函数中的最后一个语句，但不一定非得是最后一个：当执行`return`语句时，函数返回给调用者，即使函数体中还有其他语句。
- en: 'The `return` statement can also be used without an *expression* to make the
    function return `undefined` to its caller. For example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句也可以在没有*expression*的情况下使用，使函数返回`undefined`给调用者。例如：'
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Because of JavaScript’s automatic semicolon insertion ([§2.6](ch02.xhtml#optionalsemicolons)),
    you cannot include a line break between the `return` keyword and the expression
    that follows it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript的自动分号插入（[§2.6](ch02.xhtml#optionalsemicolons)），你不能在`return`关键字和其后的表达式之间插入换行符。
- en: 5.5.5 yield
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.5 yield
- en: 'The `yield` statement is much like the `return` statement but is used only
    in ES6 generator functions (see [§12.3](ch12.xhtml#generators)) to produce the
    next value in the generated sequence of values without actually returning:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`语句与`return`语句非常相似，但仅在ES6生成器函数（参见[§12.3](ch12.xhtml#generators)）中使用，用于生成值序列中的下一个值而不实际返回：'
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In order to understand `yield`, you must understand iterators and generators,
    which will not be covered until [Chapter 12](ch12.xhtml#itergene). `yield` is
    included here for completeness, however. (Technically, though, `yield` is an operator
    rather than a statement, as explained in [§12.4.2](ch12.xhtml#yieldexpression).)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`yield`，你必须理解迭代器和生成器，这将在[第12章](ch12.xhtml#itergene)中介绍。然而，为了完整起见，这里包括了`yield`。（严格来说，`yield`是一个运算符而不是语句，如[§12.4.2](ch12.xhtml#yieldexpression)中所解释的。）
- en: 5.5.6 throw
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.6 throw
- en: An *exception* is a signal that indicates that some sort of exceptional condition
    or error has occurred. To *throw* an exception is to signal such an error or exceptional
    condition. To *catch* an exception is to handle it—to take whatever actions are
    necessary or appropriate to recover from the exception. In JavaScript, exceptions
    are thrown whenever a runtime error occurs and whenever the program explicitly
    throws one using the `throw` statement. Exceptions are caught with the `try/catch/finally`
    statement, which is described in the next section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*异常*是指示发生了某种异常情况或错误的信号。*抛出*异常是指示发生了这样的错误或异常情况。*捕获*异常是处理它 - 采取必要或适当的措施来从异常中恢复。在JavaScript中，每当发生运行时错误或程序明确使用`throw`语句抛出异常时，都会抛出异常。异常可以通过`try/catch/finally`语句捕获，下一节将对此进行描述。'
- en: 'The `throw` statement has the following syntax:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`语句的语法如下：'
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '*expression* may evaluate to a value of any type. You might throw a number
    that represents an error code or a string that contains a human-readable error
    message. The Error class and its subclasses are used when the JavaScript interpreter
    itself throws an error, and you can use them as well. An Error object has a `name`
    property that specifies the type of error and a `message` property that holds
    the string passed to the constructor function. Here is an example function that
    throws an Error object when invoked with an invalid argument:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*expression*可能会评估为任何类型的值。你可以抛出一个代表错误代码的数字，或者包含人类可读错误消息的字符串。当JavaScript解释器本身抛出错误时，会使用Error类及其子类，你也可以使用它们。一个Error对象有一个`name`属性指定错误类型，一个`message`属性保存传递给构造函数的字符串。下面是一个示例函数，当使用无效参数调用时会抛出一个Error对象：'
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When an exception is thrown, the JavaScript interpreter immediately stops normal
    program execution and jumps to the nearest exception handler. Exception handlers
    are written using the `catch` clause of the `try/catch/finally` statement, which
    is described in the next section. If the block of code in which the exception
    was thrown does not have an associated `catch` clause, the interpreter checks
    the next-highest enclosing block of code to see if it has an exception handler
    associated with it. This continues until a handler is found. If an exception is
    thrown in a function that does not contain a `try/catch/finally` statement to
    handle it, the exception propagates up to the code that invoked the function.
    In this way, exceptions propagate up through the lexical structure of JavaScript
    methods and up the call stack. If no exception handler is ever found, the exception
    is treated as an error and is reported to the user.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常时，JavaScript解释器立即停止正常程序执行，并跳转到最近的异常处理程序。异常处理程序使用`try/catch/finally`语句的`catch`子句编写，下一节将对其进行描述。如果抛出异常的代码块没有关联的`catch`子句，解释器将检查下一个最高级别的封闭代码块，看看它是否有与之关联的异常处理程序。这将一直持续下去，直到找到处理程序。如果在一个不包含`try/catch/finally`语句来处理异常的函数中抛出异常，异常将传播到调用该函数的代码。通过这种方式，异常通过JavaScript方法的词法结构向上传播，并沿着调用堆栈向上传播。如果从未找到异常处理程序，异常将被视为错误并报告给用户。
- en: 5.5.7 try/catch/finally
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5.7 try/catch/finally
- en: The `try/catch/finally` statement is JavaScript’s exception handling mechanism.
    The `try` clause of this statement simply defines the block of code whose exceptions
    are to be handled. The `try` block is followed by a `catch` clause, which is a
    block of statements that are invoked when an exception occurs anywhere within
    the `try` block. The `catch` clause is followed by a `finally` block containing
    cleanup code that is guaranteed to be executed, regardless of what happens in
    the `try` block. Both the `catch` and `finally` blocks are optional, but a `try`
    block must be accompanied by at least one of these blocks. The `try`, `catch`,
    and `finally` blocks all begin and end with curly braces. These braces are a required
    part of the syntax and cannot be omitted, even if a clause contains only a single
    statement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`try/catch/finally`语句是JavaScript的异常处理机制。该语句的`try`子句简单地定义了要处理异常的代码块。`try`块后面是一个`catch`子句，当`try`块内部发生异常时，将调用一组语句。`catch`子句后面是一个`finally`块，其中包含清理代码，无论`try`块中发生了什么，都保证会执行。`catch`和`finally`块都是可选的，但`try`块必须至少伴随其中一个。`try`、`catch`和`finally`块都以大括号开始和结束。这些大括号是语法的必要部分，即使一个子句只包含一个语句也不能省略。'
- en: 'The following code illustrates the syntax and purpose of the `try/catch/finally`
    statement:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例说明了`try/catch/finally`语句的语法和目的：
- en: '[PRE62]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that the `catch` keyword is generally followed by an identifier in parentheses.
    This identifier is like a function parameter. When an exception is caught, the
    value associated with the exception (an Error object, for example) is assigned
    to this parameter. The identifier associated with a `catch` clause has block scope—it
    is only defined within the `catch` block.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`catch`关键字通常后面跟着一个括号中的标识符。这个标识符类似于函数参数。当捕获到异常时，与异常相关联的值（例如一个Error对象）将被分配给这个参数。与`catch`子句关联的标识符具有块作用域——它只在`catch`块内定义。
- en: 'Here is a realistic example of the `try/catch` statement. It uses the `factorial()`
    method defined in the previous section and the client-side JavaScript methods
    `prompt()` and `alert()` for input and output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`try/catch`语句的一个实际例子。它使用了前一节中定义的`factorial()`方法以及客户端JavaScript方法`prompt()`和`alert()`来进行输入和输出：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This example is a `try/catch` statement with no `finally` clause. Although `finally`
    is not used as often as `catch`, it can be useful. However, its behavior requires
    additional explanation. The `finally` clause is guaranteed to be executed if any
    portion of the `try` block is executed, regardless of how the code in the `try`
    block completes. It is generally used to clean up after the code in the `try`
    clause.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个没有`finally`子句的`try/catch`语句。虽然`finally`不像`catch`那样经常使用，但它也是有用的。然而，它的行为需要额外的解释。如果`try`块的任何部分被执行，`finally`子句将被执行。它通常用于在`try`子句中的代码执行完毕后进行清理。
- en: In the normal case, the JavaScript interpreter reaches the end of the `try`
    block and then proceeds to the `finally` block, which performs any necessary cleanup.
    If the interpreter left the `try` block because of a `return`, `continue`, or
    `break` statement, the `finally` block is executed before the interpreter jumps
    to its new destination.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，JavaScript解释器执行完`try`块后，然后继续执行`finally`块，执行任何必要的清理工作。如果解释器因为`return`、`continue`或`break`语句而离开`try`块，那么在解释器跳转到新目的地之前，将执行`finally`块。
- en: If an exception occurs in the `try` block and there is an associated `catch`
    block to handle the exception, the interpreter first executes the `catch` block
    and then the `finally` block. If there is no local `catch` block to handle the
    exception, the interpreter first executes the `finally` block and then jumps to
    the nearest containing `catch` clause.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`try`块中发生异常，并且有一个关联的`catch`块来处理异常，解释器首先执行`catch`块，然后执行`finally`块。如果没有本地`catch`块来处理异常，解释器首先执行`finally`块，然后跳转到最近的包含`catch`子句。
- en: If a `finally` block itself causes a jump with a `return`, `continue`, `break`,
    or `throw` statement, or by calling a method that throws an exception, the interpreter
    abandons whatever jump was pending and performs the new jump. For example, if
    a `finally` clause throws an exception, that exception replaces any exception
    that was in the process of being thrown. If a `finally` clause issues a `return`
    statement, the method returns normally, even if an exception has been thrown and
    has not yet been handled.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`finally`块本身导致使用`return`、`continue`、`break`或`throw`语句跳转，或通过调用抛出异常的方法，解释器会放弃任何待处理的跳转并执行新的跳转。例如，如果`finally`子句抛出异常，那个异常会替换正在被抛出的任何异常。如果`finally`子句发出`return`语句，方法会正常返回，即使已经抛出异常但尚未处理。
- en: '`try` and `finally` can be used together without a `catch` clause. In this
    case, the `finally` block is simply cleanup code that is guaranteed to be executed,
    regardless of what happens in the `try` block. Recall that we can’t completely
    simulate a `for` loop with a `while` loop because the `continue` statement behaves
    differently for the two loops. If we add a `try/finally` statement, we can write
    a `while` loop that works like a `for` loop and that handles `continue` statements
    correctly:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`和`finally`可以在没有`catch`子句的情况下一起使用。在这种情况下，`finally`块只是保证会被执行的清理代码，无论`try`块中发生了什么。请记住，我们无法完全用`while`循环模拟`for`循环，因为`continue`语句对这两种循环的行为是不同的。如果我们添加一个`try/finally`语句，我们可以编写一个像`for`循环一样工作并正确处理`continue`语句的`while`循环：'
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note, however, that a *body* that contains a `break` statement behaves slightly
    differently (causing an extra increment before exiting) in the `while` loop than
    it does in the `for` loop, so even with the `finally` clause, it is not possible
    to completely simulate the `for` loop with `while`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，包含`break`语句的*body*在`while`循环中的行为略有不同（导致在退出之前额外增加一次递增）与在`for`循环中的行为不同，因此即使有`finally`子句，也无法完全用`while`模拟`for`循环。
- en: 5.6 Miscellaneous Statements
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 其他语句
- en: This section describes the remaining three JavaScript statements—`with`, `debugger`,
    and `"use strict"`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了剩余的三个JavaScript语句——`with`、`debugger`和`"use strict"`。
- en: 5.6.1 with
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.1 with
- en: 'The `with` statement runs a block of code as if the properties of a specified
    object were variables in scope for that code. It has the following syntax:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句会将指定对象的属性作为作用域内的变量运行一段代码块。它的语法如下：'
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This statement creates a temporary scope with the properties of *object* as
    variables and then executes *statement* within that scope.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句创建一个临时作用域，将*object*的属性作为变量，然后在该作用域内执行*statement*。
- en: 'The `with` statement is forbidden in strict mode (see [§5.6.3](#strictmode))
    and should be considered deprecated in non-strict mode: avoid using it whenever
    possible. JavaScript code that uses `with` is difficult to optimize and is likely
    to run significantly more slowly than the equivalent code written without the
    `with` statement.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句在严格模式下是被禁止的（参见[§5.6.3](#strictmode)），在非严格模式下应被视为已弃用：尽量避免使用。使用`with`的JavaScript代码很难优化，并且可能比不使用`with`语句编写的等效代码运行得慢得多。'
- en: 'The common use of the `with` statement is to make it easier to work with deeply
    nested object hierarchies. In client-side JavaScript, for example, you may have
    to type expressions like this one to access elements of an HTML form:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句的常见用法是使得在深度嵌套的对象层次结构中更容易工作。例如，在客户端JavaScript中，你可能需要输入这样的表达式来访问HTML表单的元素：'
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you need to write expressions like this a number of times, you can use the
    `with` statement to treat the properties of the form object like variables:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要多次编写这样的表达式，你可以使用`with`语句将表单对象的属性视为变量处理：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This reduces the amount of typing you have to do: you no longer need to prefix
    each form property name with `document.forms[0]`. It is just as simple, of course,
    to avoid the `with` statement and write the preceding code like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以减少你需要输入的内容：你不再需要在每个表单属性名称前加上`document.forms[0]`。当然，避免使用`with`语句并像这样编写前面的代码同样简单：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that if you use `const` or `let` or `var` to declare a variable or constant
    within the body of a `with` statement, it creates an ordinary variable and does
    not define a new property within the specified object.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果在`with`语句的主体中使用`const`、`let`或`var`声明变量或常量，它会创建一个普通变量，而不会在指定对象中定义一个新属性。
- en: 5.6.2 debugger
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.2 debugger
- en: 'The `debugger` statement normally does nothing. If, however, a debugger program
    is available and is running, then an implementation may (but is not required to)
    perform some kind of debugging action. In practice, this statement acts like a
    breakpoint: execution of JavaScript code stops, and you can use the debugger to
    print variables’ values, examine the call stack, and so on. Suppose, for example,
    that you are getting an exception in your function `f()` because it is being called
    with an undefined argument, and you can’t figure out where this call is coming
    from. To help you in debugging this problem, you might alter `f()` so that it
    begins like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugger`语句通常不会执行任何操作。然而，如果一个调试器程序可用且正在运行，那么实现可能（但不是必须）执行某种调试操作。实际上，这个语句就像一个断点：JavaScript代码的执行会停止，你可以使用调试器打印变量的值，检查调用堆栈等。例如，假设你在函数`f()`中遇到异常，因为它被使用未定义的参数调用，而你无法弄清楚这个调用是从哪里来的。为了帮助你调试这个问题，你可以修改`f()`，使其如下所示开始：'
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, when `f()` is called with no argument, execution will stop, and you can
    use the debugger to inspect the call stack and find out where this incorrect call
    is coming from.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当没有参数调用`f()`时，执行会停止，你可以使用调试器检查调用堆栈，并找出这个错误调用是从哪里来的。
- en: 'Note that it is not enough to have a debugger available: the `debugger` statement
    won’t start the debugger for you. If you’re using a web browser and have the developer
    tools console open, however, this statement will cause a breakpoint.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅仅拥有一个调试器是不够的：`debugger`语句不会为你启动调试器。然而，如果你正在使用一个网页浏览器并且打开了开发者工具控制台，这个语句会导致断点。
- en: 5.6.3 “use strict”
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6.3 “use strict”
- en: '`"use strict"` is a *directive* introduced in ES5. Directives are not statements
    (but are close enough that `"use strict"` is documented here). There are two important
    differences between the `"use strict"` directive and regular statements:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: “use strict”是ES5中引入的*指令*。 指令不是语句（但足够接近，以至于在此处记录了“use strict”）。 “use strict”指令和常规语句之间有两个重要区别：
- en: 'It does not include any language keywords: the directive is just an expression
    statement that consists of a special string literal (in single or double quotes).'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不包括任何语言关键字：该指令只是一个表达式语句，由一个特殊的字符串文字（单引号或双引号）组成。
- en: It can appear only at the start of a script or at the start of a function body,
    before any real statements have appeared.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只能出现在脚本的开头或函数体的开头，在任何真实语句出现之前。
- en: The purpose of a `"use strict"` directive is to indicate that the code that
    follows (in the script or function) is *strict code*. The top-level (nonfunction)
    code of a script is strict code if the script has a `"use strict"` directive.
    A function body is strict code if it is defined within strict code or if it has
    a `"use strict"` directive. Code passed to the `eval()` method is strict code
    if `eval()` is called from strict code or if the string of code includes a `"use
    strict"` directive. In addition to code explicitly declared to be strict, any
    code in a `class` body ([Chapter 9](ch09.xhtml#classes)) or in an ES6 module ([§10.3](ch10.xhtml#es6modules))
    is automatically strict code. This means that if all of your JavaScript code is
    written as modules, then it is all automatically strict, and you will never need
    to use an explicit `"use strict"` directive.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: “use strict”指令的目的是指示随后的代码（在脚本或函数中）是*严格代码*。 如果脚本有“use strict”指令，则脚本的顶级（非函数）代码是严格代码。
    如果函数体在严格代码中定义或具有“use strict”指令，则函数体是严格代码。 如果从严格代码调用`eval()`方法，则传递给`eval()`的代码是严格代码，或者如果代码字符串包含“use
    strict”指令。 除了明确声明为严格的代码外，`class`体（[第9章](ch09.xhtml#classes)）中的任何代码或ES6模块（[§10.3](ch10.xhtml#es6modules)）中的任何代码都自动成为严格代码。
    这意味着如果所有JavaScript代码都编写为模块，则所有代码都自动成为严格代码，您将永远不需要使用显式的“use strict”指令。
- en: 'Strict code is executed in *strict mode*. Strict mode is a restricted subset
    of the language that fixes important language deficiencies and provides stronger
    error checking and increased security. Because strict mode is not the default,
    old JavaScript code that still uses the deficient legacy features of the language
    will continue to run correctly. The differences between strict mode and non-strict
    mode are the following (the first three are particularly important):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式下执行*严格模式*。 严格模式是语言的受限子集，修复了重要的语言缺陷，并提供了更强的错误检查和增强的安全性。 由于严格模式不是默认设置，仍然使用语言的不足遗留功能的旧JavaScript代码将继续正确运行。
    严格模式和非严格模式之间的区别如下（前三个特别重要）：
- en: The `with` statement is not allowed in strict mode.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，不允许使用`with`语句。
- en: 'In strict mode, all variables must be declared: a ReferenceError is thrown
    if you assign a value to an identifier that is not a declared variable, function,
    function parameter, `catch` clause parameter, or property of the global object.
    (In non-strict mode, this implicitly declares a global variable by adding a new
    property to the global object.)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，所有变量必须声明：如果将值分配给未声明的变量、函数、函数参数、`catch`子句参数或全局对象的属性，则会抛出ReferenceError。（在非严格模式下，这将通过向全局对象添加新属性来隐式声明全局变量。）
- en: In strict mode, functions invoked as functions (rather than as methods) have
    a `this` value of `undefined`. (In non-strict mode, functions invoked as functions
    are always passed the global object as their `this` value.) Also, in strict mode,
    when a function is invoked with `call()` or `apply()` ([§8.7.4](ch08.xhtml#applyandcall)),
    the `this` value is exactly the value passed as the first argument to `call()`
    or `apply()`. (In non-strict mode, `null` and `undefined` values are replaced
    with the global object and nonobject values are converted to objects.)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，作为函数调用的函数（而不是作为方法）的`this`值为`undefined`。（在非严格模式下，作为函数调用的函数始终将全局对象作为其`this`值传递。）此外，在严格模式下，当使用`call()`或`apply()`（[§8.7.4](ch08.xhtml#applyandcall)）调用函数时，`this`值正好是传递给`call()`或`apply()`的第一个参数的值。（在非严格模式下，`null`和`undefined`值将替换为全局对象，非对象值将转换为对象。）
- en: In strict mode, assignments to nonwritable properties and attempts to create
    new properties on non-extensible objects throw a TypeError. (In non-strict mode,
    these attempts fail silently.)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，对不可写属性的赋值和尝试在不可扩展对象上创建新属性会抛出TypeError。（在非严格模式下，这些尝试会静默失败。）
- en: In strict mode, code passed to `eval()` cannot declare variables or define functions
    in the caller’s scope as it can in non-strict mode. Instead, variable and function
    definitions live in a new scope created for the `eval()`. This scope is discarded
    when the `eval()` returns.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，传递给`eval()`的代码不能在调用者的范围内声明变量或定义函数，就像在非严格模式下那样。 相反，变量和函数定义存在于为`eval()`创建的新作用域中。
    当`eval()`返回时，此作用域将被丢弃。
- en: In strict mode, the Arguments object ([§8.3.3](ch08.xhtml#argumentsobject))
    in a function holds a static copy of the values passed to the function. In non-strict
    mode, the Arguments object has “magical” behavior in which elements of the array
    and named function parameters both refer to the same value.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，函数中的Arguments对象（[§8.3.3](ch08.xhtml#argumentsobject)）保存传递给函数的值的静态副本。
    在非严格模式下，Arguments对象具有“神奇”的行为，其中数组的元素和命名函数参数都指向相同的值。
- en: In strict mode, a SyntaxError is thrown if the `delete` operator is followed
    by an unqualified identifier such as a variable, function, or function parameter.
    (In nonstrict mode, such a `delete` expression does nothing and evaluates to `false`.)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，如果`delete`运算符后跟未经限定的标识符（如变量、函数或函数参数），则会抛出SyntaxError。（在非严格模式下，这样的`delete`表达式不起作用并计算为`false`。）
- en: In strict mode, an attempt to delete a nonconfigurable property throws a TypeError.
    (In non-strict mode, the attempt fails and the `delete` expression evaluates to
    `false`.)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，尝试删除不可配置属性会抛出TypeError。 （在非严格模式下，尝试失败，`delete`表达式的值为`false`。）
- en: In strict mode, it is a syntax error for an object literal to define two or
    more properties by the same name. (In non-strict mode, no error occurs.)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，对象字面量定义具有相同名称的两个或更多属性是语法错误。（在非严格模式下，不会发生错误。）
- en: In strict mode, it is a syntax error for a function declaration to have two
    or more parameters with the same name. (In non-strict mode, no error occurs.)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，函数声明具有两个或更多具有相同名称的参数是语法错误。（在非严格模式下，不会发生错误。）
- en: In strict mode, octal integer literals (beginning with a 0 that is not followed
    by an x) are not allowed. (In non-strict mode, some implementations allow octal
    literals.)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，不允许使用八进制整数字面量（以0开头且后面不跟x）。（在非严格模式下，一些实现允许八进制字面量。）
- en: In strict mode, the identifiers `eval` and `arguments` are treated like keywords,
    and you are not allowed to change their value. You cannot assign a value to these
    identifiers, declare them as variables, use them as function names, use them as
    function parameter names, or use them as the identifier of a `catch` block.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，标识符`eval`和`arguments`被视为关键字，不���许更改它们的值。不能为这些标识符分配值，将它们声明为变量，将它们用作函数名称，将它们用作函数参数名称，或将它们用作`catch`块的标识符。
- en: In strict mode, the ability to examine the call stack is restricted. `arguments.caller`
    and `arguments.callee` both throw a TypeError within a strict mode function. Strict
    mode functions also have `caller` and `arguments` properties that throw TypeError
    when read. (Some implementations define these nonstandard properties on non-strict
    functions.)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在严格模式下，限制了检查调用堆栈的能力。在严格模式函数内，`arguments.caller`和`arguments.callee`都会抛出TypeError。严格模式函数还具有`caller`和`arguments`属性，当读取时会抛出TypeError。（一些实现在非严格函数上定义这些非标准属性。）
- en: 5.7 Declarations
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 声明
- en: The keywords `const`, `let`, `var`, `function`, `class`, `import`, and `export`
    are not technically statements, but they look a lot like statements, and this
    book refers informally to them as statements, so they deserve a mention in this
    chapter.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`const`、`let`、`var`、`function`、`class`、`import`和`export`在技术上不是语句，但它们看起来很像语句，因此本书非正式地将它们称为语句，因此它们在本章中值得一提。
- en: These keywords are more accurately described as *declarations* rather than statements.
    We said at the start of this chapter that statements “make something happen.”
    Declarations serve to define new values and give them names that we can use to
    refer to those values. They don’t make much happen themselves, but by providing
    names for values they, in an important sense, define the meaning of the other
    statements in your program.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键字更准确地描述为*声明*而不是语句。我们在本章开头说过语句“让某事发生”。声明用于定义新值并为其赋予我们可以用来引用这些值的名称。它们本身并没有做太多事情，但通过为值提供名称，它们在重要意义上定义了程序中其他语句的含义。
- en: 'When a program runs, it is the program’s expressions that are being evaluated
    and the program’s statements that are being executed. The declarations in a program
    don’t “run” in the same way: instead, they define the structure of the program
    itself. Loosely, you can think of declarations as the parts of the program that
    are processed before the code starts running.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，程序的表达式正在被评估，程序的语句正在被执行。程序中的声明不会像语句一样“运行”：相反，它们定义了程序本身的结构。可以粗略地将声明视为在代码开始运行之前处理的程序部分。
- en: JavaScript declarations are used to define constants, variables, functions,
    and classes and for importing and exporting values between modules. The next subsections
    give examples of all of these declarations. They are all covered in much more
    detail elsewhere in this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript声明用于定义常量、变量、函数和类，并用于在模块之间导入和导出值。下一小节将给出所有这些声明的示例。它们在本书的其他地方都有更详细的介绍。
- en: 5.7.1 const, let, and var
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.1 const、let和var
- en: The `const`, `let`, and `var` declarations are covered in [§3.10](ch03.xhtml#variabledeclaration).
    In ES6 and later, `const` declares constants, and `let` declares variables. Prior
    to ES6, the `var` keyword was the only way to declare variables and there was
    no way to declare constants. Variables declared with `var` are scoped to the containing
    function rather than the containing block. This can be a source of bugs, and in
    modern JavaScript there is really no reason to use `var` instead of `let`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`、`let`和`var`声明在[§3.10](ch03.xhtml#variabledeclaration)中有介绍。在ES6及更高版本中，`const`声明常量，`let`声明变量。在ES6之前，`var`关键字是声明变量的唯一方式，没有办法声明常量。使用`var`声明的变量的作用域是包含函数而不是包含块。这可能导致错误，并且在现代JavaScript中，没有理由使用`var`而不是`let`。'
- en: '[PRE70]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 5.7.2 function
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.2 function
- en: 'The `function` declaration is used to define functions, which are covered in
    detail in [Chapter 8](ch08.xhtml#functions). (We also saw `function` in [§4.3](ch04.xhtml#functionexprs),
    where it was used as part of a function expression rather than a function declaration.)
    A function declaration looks like this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`function`声明用于定义函数，在[第8章](ch08.xhtml#functions)中有详细介绍。（我们还在[§4.3](ch04.xhtml#functionexprs)中看到`function`，那里它被用作函数表达式的一部分而不是函数声明。）函数声明如下所示：'
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: A function declaration creates a function object and assigns it to the specified
    name—`area` in this example. Elsewhere in our program, we can refer to the function—and
    run the code inside it—by using this name. The function declarations in any block
    of JavaScript code are processed before that code runs, and the function names
    are bound to the function objects throughout the block. We say that function declarations
    are “hoisted” because it is as if they had all been moved up to the top of whatever
    scope they are defined within. The upshot is that code that invokes a function
    can exist in your program before the code that declares the function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明创建一个函数对象并将其分配给指定的名称—在这个例子中是`area`。 在程序的其他地方，我们可以通过使用这个名称引用函数—并运行其中的代码。 JavaScript
    代码块中的函数声明在代码运行之前被处理，并且函数名称在整个代码块中绑定到函数对象。 我们说函数声明被“提升”，因为它就好像它们都被移动到它们所在的作用域的顶部一样。
    结果是调用函数的代码可以存在于程序中，在声明函数的代码之前。
- en: '[§12.3](ch12.xhtml#generators) describes a special kind of function known as
    a *generator*. Generator declarations use the `function` keyword but follow it
    with an asterisk. [§13.3](ch13.xhtml#async-await) describes asynchronous functions,
    which are also declared using the `function` keyword but are prefixed with the
    `async` keyword.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[§12.3](ch12.xhtml#generators)描述了一种特殊类型的函数，称为*生成器*。 生成器声明使用`function`关键字，但后面跟着一个星号。
    [§13.3](ch13.xhtml#async-await)描述了异步函数，也是使用`function`关键字声明的，但前面加上`async`关键字。'
- en: 5.7.3 class
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.3 类
- en: 'In ES6 and later, the `class` declaration creates a new class and gives it
    a name that we can use to refer to it. Classes are described in detail in [Chapter 9](ch09.xhtml#classes).
    A simple class declaration might look like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 及更高版本中，`class`声明创建一个新的类，并为其赋予一个我们可以用来引用它的名称。 类在[第9章](ch09.xhtml#classes)中有详细描述。
    一个简单的类声明可能如下所示：
- en: '[PRE72]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Unlike functions, class declarations are not hoisted, and you cannot use a class
    declared this way in code that appears before the declaration.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不同，类声明不会被提升，你不能在类声明之前的代码中使用以这种方式声明的类。
- en: 5.7.4 import and export
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7.4 导入和导出
- en: The `import` and `export` declarations are used together to make values defined
    in one module of JavaScript code available in another module. A module is a file
    of JavaScript code with its own global namespace, completely independent of all
    other modules. The only way that a value (such as function or class) defined in
    one module can be used in another module is if the defining module exports it
    with `export` and the using module imports it with `import`. Modules are the subject
    of [Chapter 10](ch10.xhtml#modules), and `import` and `export` are covered in
    detail in [§10.3](ch10.xhtml#es6modules).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`和`export`声明一起使用，使得在 JavaScript 代码的一个模块中定义的值可以在另一个模块中使用。 模块是具有自己全局命名空间的
    JavaScript 代码文件，完全独立于所有其他模块。 一个值（如函数或类）在一个模块中定义后，只有通过`export`导出并在另一个模块中使用`import`导入，才能在另一个模块中使用。
    模块是[第10章](ch10.xhtml#modules)的主题，`import`和`export`在[§10.3](ch10.xhtml#es6modules)中有详细介绍。'
- en: '`import` directives are used to import one or more values from another file
    of JavaScript code and give them names within the current module. `import` directives
    come in a few different forms. Here are some examples:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`指令用于从另一个 JavaScript 代码文件中导入一个或多个值，并在当前模块中为它们命名。 `import`指令有几种不同的形式。
    以下是一些示例：'
- en: '[PRE73]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Values within a JavaScript module are private and cannot be imported into other
    modules unless they have been explicitly exported. The `export` directive does
    this: it declares that one or more values defined in the current module are exported
    and therefore available for import by other modules. The `export` directive has
    more variants than the `import` directive does. Here is one of them:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 模块中的值是私有的，除非它们已经被明确导出，否则不能被导入到其他模块中。 `export`指令可以实现这一点：它声明当前模块中定义的一个或多个值被导出，因此可以被其他模块导入。
    `export`指令比`import`指令有更多的变体。 这是其中之一：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `export` keyword is sometimes used as a modifier on other declarations,
    resulting in a kind of compound declaration that defines a constant, variable,
    function, or class and exports it at the same time. And when a module exports
    only a single value, this is typically done with the special form `export default`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`关键字有时用作其他声明的修饰符，从而形成一种复合声明，同时定义一个常量、变量、函数或类并将其导出。 当一个模块只导出一个值时，通常使用特殊形式`export
    default`：'
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 5.8 Summary of JavaScript Statements
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 JavaScript 语句总结
- en: This chapter introduced each of the JavaScript language’s statements, which
    are summarized in [Table 5-1](#statementssummary).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 JavaScript 语言的每个语句，总结在[表5-1](#statementssummary)中。
- en: Table 5-1\. JavaScript statement syntax
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1\. JavaScript 语句语法
- en: '| Statement | Purpose |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 目的 |'
- en: '| --- | --- |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| break | Exit from the innermost loop or `switch` or from named enclosing
    statement |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| break | 退出最内层循环或`switch`或从命名封闭语句中退出 |'
- en: '| case | Label a statement within a `switch` |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| case | 在`switch`语句中标记一个语句 |'
- en: '| class | Declare a class |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| class | 声明一个类 |'
- en: '| const | Declare and initialize one or more constants |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| const | 声明和初始化一个或多个常量 |'
- en: '| continue | Begin next iteration of the innermost loop or the named loop |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| continue | 开始最内层循环或命名循环的下一次迭代 |'
- en: '| debugger | Debugger breakpoint |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| debugger | 调试器断点 |'
- en: '| default | Label the default statement within a `switch` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| default | 标记`switch`语句中的默认语句 |'
- en: '| do/while | An alternative to the `while` loop |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| do/while | `while`循环的替代方案 |'
- en: '| export | Declare values that can be imported into other modules |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| export | 声明可以被其他模块导入的值 |'
- en: '| for | An easy-to-use loop |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| for | 一个易于使用的循环 |'
- en: '| for/await | Asynchronously iterate the values of an async iterator |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| for/await | 异步迭代异步迭代器的值 |'
- en: '| for/in | Enumerate the property names of an object |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| for/in | 枚举对象的属性名称 |'
- en: '| for/of | Enumerate the values of an iterable object such as an array |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| for/of | 枚举可迭代对象（如数组）的值 |'
- en: '| function | Declare a function |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| function | 声明一个函数 |'
- en: '| if/else | Execute one statement or another depending on a condition |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| if/else | 根据条件执行一个语句或另一个 |'
- en: '| import | Declare names for values defined in other modules |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| import | 声明在其他模块中定义的值的名称 |'
- en: '| label | Give statement a name for use with `break` and `continue` |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| label | 为`break`和`continue`给语句命名 |'
- en: '| let | Declare and initialize one or more block-scoped variables (new syntax)
    |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| let | 声明并初始化一个或多个块作用域变量（新语法） |'
- en: '| return | Return a value from a function |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| return | 从函数中返回一个值 |'
- en: '| switch | Multiway branch to `case` or `default:` labels |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| switch | 多路分支到`case`或`default:`标签 |'
- en: '| throw | Throw an exception |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| throw | 抛出异常 |'
- en: '| try/catch/finally | Handle exceptions and code cleanup |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| try/catch/finally | 处理异常和代码清理 |'
- en: '| “use strict” | Apply strict mode restrictions to script or function |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| “use strict” | 将严格模式限制应用于脚本或函数 |'
- en: '| var | Declare and initialize one or more variables (old syntax) |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| var | 声明并初始化一个或多个变量（旧语法） |'
- en: '| while | A basic loop construct |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| while | 基本的循环结构 |'
- en: '| with | Extend the scope chain (deprecated and forbidden in strict mode) |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| with | 扩展作用域链（已弃用且在严格模式下禁止使用） |'
- en: '| yield | Provide a value to be iterated; only used in generator functions
    |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| yield | 提供一个要迭代的值；仅在生成器函数中使用 |'
- en: ^([1](ch05.xhtml#idm46198554953944-marker)) The fact that the `case` expressions
    are evaluated at runtime makes the JavaScript `switch` statement much different
    from (and less efficient than) the `switch` statement of C, C++, and Java. In
    those languages, the `case` expressions must be compile-time constants of the
    same type, and `switch` statements can often compile down to highly efficient
    *jump tables*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#idm46198554953944-marker)) `case`表达式在运行时评估的事实使得JavaScript的`switch`语句与C、C++和Java的`switch`语句有很大不同（且效率较低）。在那些语言中，`case`表达式必须是相同类型的编译时常量，并且`switch`语句通常可以编译为高效的*跳转表*。
- en: ^([2](ch05.xhtml#idm46198554759768-marker)) When we consider the `continue`
    statement in [§5.5.3](#continue), we’ll see that this `while` loop is not an exact
    equivalent of the `for` loop.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.xhtml#idm46198554759768-marker)) 当我们考虑在[§5.5.3](#continue)中的`continue`语句时，我们会发现这个`while`循环并不是`for`循环的精确等价。
