- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: HANDLING EVENTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: Some programs work with direct user input, such as mouse and keyboard actions.
    That kind of input isn’t available ahead of time, as a well-organized data structure—it
    comes in piece by piece, in real time, and the program must respond to it as it
    happens.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序处理直接的用户输入，例如鼠标和键盘操作。这种输入无法提前以良好组织的数据结构获取——它是实时逐步到达的，程序必须在发生时对此作出反应。
- en: Event Handlers
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理程序
- en: Imagine an interface where the only way to find out whether a key on the keyboard
    is being pressed is to read the current state of that key. To be able to react
    to keypresses, you would have to constantly read the key’s state to catch it before
    it is released again. It would be dangerous to perform other time-intensive computations,
    since you might miss a keypress.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个界面，唯一知道键盘上的某个键是否被按下的方法是读取该键的当前状态。要能够对按键反应，你必须不断读取该键的状态，以便在其再次释放之前捕捉到它。进行其他耗时的计算是危险的，因为你可能会错过一个按键。
- en: Some primitive machines handle input like this. A step up from this is for the
    hardware or operating system to notice the keypress and put it in a queue. A program
    can then periodically check the queue for new events and react to what it finds
    there.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些原始机器以这种方式处理输入。更高级的做法是让硬件或操作系统注意到按键并将其放入队列。然后程序可以定期检查队列中的新事件，并对所找到的事件作出反应。
- en: Of course, the program has to remember to look at the queue, and to do it often
    because any time between the key being pressed and the program noticing the event
    will cause the software to feel unresponsive. This approach is called *polling*.
    Most programmers prefer to avoid it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，程序必须记得查看队列，并且要经常查看，因为在按键被按下和程序注意到事件之间的任何时间都会导致软件感觉无响应。这种方法称为 *轮询*。大多数程序员倾向于避免它。
- en: A better mechanism is for the system to actively notify the code when an event
    occurs. Browsers do this by allowing us to register functions as *handlers* for
    specific events.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的机制是让系统在事件发生时主动通知代码。浏览器通过允许我们注册函数作为特定事件的 *处理程序* 来做到这一点。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The window binding refers to a built-in object provided by the browser. It represents
    the browser window that contains the document. Calling its addEventListener method
    registers the second argument to be called whenever the event described by its
    first argument occurs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口绑定是浏览器提供的一个内置对象。它代表包含文档的浏览器窗口。调用它的 addEventListener 方法会注册第二个参数，以便在第一个参数描述的事件发生时被调用。
- en: Events and DOM Nodes
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件与 DOM 节点
- en: Each browser event handler is registered in a context. In the previous example,
    we called addEventListener on the window object to register a handler for the
    whole window. Such a method can also be found on DOM elements and some other types
    of objects. Event listeners are called only when the event happens in the context
    of the object on which they are registered.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器事件处理程序在一个上下文中注册。在前面的例子中，我们在窗口对象上调用 addEventListener 来注册整个窗口的处理程序。这样的一个方法也可以在
    DOM 元素和其他类型的对象上找到。事件监听器仅在事件发生在其注册对象的上下文中时被调用。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That example attaches a handler to the button node. Clicks on the button cause
    that handler to run, but clicks on the rest of the document do not.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将一个处理程序附加到按钮节点上。点击按钮会导致该处理程序运行，但点击文档的其他部分则不会。
- en: Giving a node an onclick attribute has a similar effect. This works for most
    types of events—you can attach a handler through the attribute whose name is the
    event name with on in front of it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 给节点一个 onclick 属性有类似的效果。这适用于大多数类型的事件——你可以通过名称为事件名称并在前面加上 on 的属性来附加处理程序。
- en: But a node can have only one onclick attribute, so you can register only one
    handler per node that way. The addEventListener method allows you to add any number
    of handlers, meaning it’s safe to add handlers even if there is already another
    handler on the element.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一个节点只能有一个 onclick 属性，因此你只能通过这种方式为每个节点注册一个处理程序。addEventListener 方法允许你添加任意数量的处理程序，这意味着即使元素上已经有另一个处理程序，也可以安全地添加新的处理程序。
- en: The removeEventListener method, called with arguments similar to add EventListener,
    removes a handler.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: removeEventListener 方法与 addEventListener 的参数类似，用于移除一个处理程序。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function given to removeEventListener has to be the same function value
    given to addEventListener. When you need to unregister a handler, you’ll want
    to give the handler function a name (once, in the example) to be able to pass
    the same function value to both methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 removeEventListener 的函数必须是传递给 addEventListener 的同一个函数值。当你需要注销一个处理程序时，你会想给处理程序函数一个名称（在示例中只需一次），以便能够将相同的函数值传递给这两个方法。
- en: Event Objects
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件对象
- en: 'Though we have ignored it so far, event handler functions are passed an argument:
    the *event object*. This object holds additional information about the event.
    For example, if we want to know *which* mouse button was pressed, we can look
    at the event object’s button property.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们到目前为止忽略了这一点，事件处理函数会接收一个参数：*事件对象*。这个对象包含关于事件的附加信息。例如，如果我们想知道*哪个*鼠标按钮被按下，我们可以查看事件对象的
    button 属性。
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The information stored in an event object differs per type of event. (We’ll
    discuss different types later in the chapter.) The object’s type property always
    holds a string identifying the event (such as “click” or “mousedown”).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在事件对象中的信息因事件类型而异。（我们将在本章后面讨论不同的类型。）对象的 type 属性始终保存一个字符串，用于标识事件（例如“click”或“mousedown”）。
- en: Propagation
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传播
- en: For most event types, handlers registered on nodes with children will also receive
    events that happen in the children. If a button inside a paragraph is clicked,
    event handlers on the paragraph will also see the click event.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数事件类型，在具有子节点的节点上注册的处理程序也会接收子节点发生的事件。如果段落内部的按钮被点击，段落上的事件处理程序也会看到点击事件。
- en: But if both the paragraph and the button have a handler, the more specific handler—the
    one on the button—gets to go first. The event is said to *propagate* outward from
    the node where it happened to that node’s parent node and on to the root of the
    document. Finally, after all handlers registered on a specific node have had their
    turn, handlers registered on the whole window get a chance to respond to the event.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果段落和按钮都有处理程序，更具体的处理程序——按钮上的那个——将优先执行。事件被称为从发生的节点*传播*到该节点的父节点，再到文档的根节点。最后，在特定节点上注册的所有处理程序轮流执行后，注册在整个窗口上的处理程序也会有机会响应该事件。
- en: At any point, an event handler can call the stopPropagation method on the event
    object to prevent handlers further up from receiving the event. This can be useful
    when, for example, you have a button inside another clickable element and you
    don’t want clicks on the button to activate the outer element’s click behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，事件处理程序都可以在事件对象上调用 stopPropagation 方法，以防止更高层的处理程序接收该事件。这在某些情况下是有用的，例如，当你在另一个可点击元素内部有一个按钮时，你不希望按钮的点击激活外部元素的点击行为。
- en: The following example registers “mousedown” handlers on both a button and the
    paragraph around it. When clicked with the right mouse button, the handler for
    the button calls stopPropagation, which will prevent the handler on the paragraph
    from running. When the button is clicked with another mouse button, both handlers
    will run.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在按钮和周围的段落上注册“mousedown”处理程序。当用右键点击时，按钮的处理程序调用 stopPropagation，这将防止段落上的处理程序运行。当用其他鼠标按钮点击按钮时，两个处理程序都会运行。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Most event objects have a target property that refers to the node where they
    originated. You can use this property to ensure that you’re not accidentally handling
    something that propagated up from a node you do not want to handle.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数事件对象都有一个指向其来源节点的 target 属性。你可以使用这个属性确保你不会意外处理来自不想处理的节点的传播事件。
- en: It is also possible to use the target property to cast a wide net for a specific
    type of event. For example, if you have a node containing a long list of buttons,
    it may be more convenient to register a single click handler on the outer node
    and have it use the target property to figure out whether a button was clicked,
    rather than registering individual handlers on all of the buttons.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用 target 属性对特定类型的事件进行广泛捕获。例如，如果你有一个包含长列表按钮的节点，注册一个点击处理程序在外部节点上可能更方便，并使用
    target 属性来判断是否点击了某个按钮，而不是在所有按钮上注册单独的处理程序。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Default Actions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认行为
- en: Many events have a default action. If you click a link, you will be taken to
    the link’s target. If you press the down arrow, the browser will scroll the page
    down. If you right-click, you’ll get a context menu. And so on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多事件都有默认行为。如果你点击一个链接，你将被带到链接的目标。如果你按下向下箭头，浏览器会向下滚动页面。如果你右键单击，你将获得一个上下文菜单。等等。
- en: For most types of events, the JavaScript event handlers are called *before*
    the default behavior takes place. If the handler doesn’t want this normal behavior
    to happen, typically because it has already taken care of handling the event,
    it can call the preventDefault method on the event object.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数类型的事件，JavaScript事件处理程序在默认行为发生*之前*被调用。如果处理程序不希望发生这种正常行为，通常是因为它已经处理了事件，可以在事件对象上调用preventDefault方法。
- en: 'This can be used to implement your own keyboard shortcuts or context menu.
    It can also be used to obnoxiously interfere with the behavior that users expect.
    For example, here is a link that cannot be followed:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来实现你自己的键盘快捷键或上下文菜单。它也可以用来干扰用户期望的行为。例如，这里有一个无法被点击的链接：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Try not to do such things without a really good reason. It’ll be unpleasant
    for people who use your page when expected behavior is broken.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要在没有充分理由的情况下这样做。当预期的行为被打破时，这会让使用你页面的人感到不愉快。
- en: Depending on the browser, some events can’t be intercepted at all. On Chrome,
    for example, the keyboard shortcut to close the current tab (CTRL-W or COMMAND-W)
    cannot be handled by JavaScript.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据浏览器的不同，有些事件根本无法被拦截。在Chrome中，例如，关闭当前标签页的键盘快捷键（CTRL-W或COMMAND-W）无法通过JavaScript处理。
- en: Key Events
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键事件
- en: When a key on the keyboard is pressed, your browser fires a “keydown” event.
    When it is released, you get a “keyup” event.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当键盘上的一个键被按下时，你的浏览器会触发一个“keydown”事件。当它被释放时，你会得到一个“keyup”事件。
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Despite its name, “keydown” fires not only when the key is physically pushed
    down. When a key is pressed and held, the event fires again every time the key
    *repeats*. Sometimes you have to be careful about this. For example, if you add
    a button to the DOM when a key is pressed and remove it again when the key is
    released, you might accidentally add hundreds of buttons when the key is held
    down longer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称如此，“keydown”不仅在键被物理按下时触发。当一个键被按下并保持时，该事件会在每次键*重复*时再次触发。有时你需要对此格外小心。例如，如果你在按下键时向DOM添加一个按钮，并在释放键时将其移除，可能在按住键的过程中意外添加数百个按钮。
- en: The previous example looks at the key property of the event object to see which
    key the event is about. This property holds a string that, for most keys, corresponds
    to the thing that pressing that key would type. For special keys such as ENTER,
    it holds a string that names the key (”Enter”, in this case). If you hold SHIFT
    while pressing a key, that might also influence the name of the key—”v” becomes
    “V”, and “1” may become “!”, if that is what pressing SHIFT-1 produces on your
    keyboard.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例查看事件对象的key属性，以了解该事件是关于哪个键的。该属性保存一个字符串，对于大多数键，对应于按下该键时会输入的内容。对于特殊键，如ENTER，它保存一个字符串来命名该键（在本例中为“Enter”）。如果你在按下键时同时按住SHIFT，这可能也会影响键的名称——“v”变为“V”，而“1”可能变为“!”（如果按SHIFT-1时你键盘上产生这样的结果）。
- en: Modifier keys such as SHIFT, CTRL, ALT, and META (COMMAND on Mac) generate key
    events just like normal keys. When looking for key combinations, you can also
    find out whether these keys are held down by looking at the shiftKey, ctrlKey,
    altKey, and metaKey properties of keyboard and mouse events.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰键，如SHIFT、CTRL、ALT和META（在Mac上为COMMAND），生成的键事件与普通键一样。当查找键组合时，你也可以通过查看键盘和鼠标事件的shiftKey、ctrlKey、altKey和metaKey属性来了解这些键是否被按下。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The DOM node where a key event originates depends on the element that has focus
    when the key is pressed. Most nodes cannot have focus unless you give them a tabindex
    attribute, but things like links, buttons, and form fields can. We’ll come back
    to form fields in [Chapter 18](ch18.xhtml#ch18). When nothing in particular has
    focus, document.body acts as the target node of key events.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 键事件来源的DOM节点取决于按下键时哪个元素具有焦点。大多数节点无法获得焦点，除非你给它们一个tabindex属性，但像链接、按钮和表单字段这样的元素可以获得焦点。我们将在[第18章](ch18.xhtml#ch18)中再次讨论表单字段。当没有特别的元素获得焦点时，document.body会作为键事件的目标节点。
- en: When the user is typing text, using key events to figure out what is being typed
    is problematic. Some platforms, most notably the virtual keyboard on Android phones,
    don’t fire key events. But even when you have an old-fashioned keyboard, some
    types of text input don’t match keypresses in a straightforward way, such as *input
    method editor (IME)* software used by people whose scripts don’t fit on a keyboard,
    where multiple keystrokes are combined to create characters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入文本时，使用键事件来判断正在输入的内容是有问题的。一些平台，尤其是安卓手机上的虚拟键盘，不会触发键事件。但即使你使用的是传统键盘，有些类型的文本输入也不会简单地与按键相匹配，例如*输入法编辑器（IME）*软件，它用于那些脚本无法在键盘上完全适配的人，其中多个按键组合以创建字符。
- en: To notice when something was typed, elements that you can type into, such as
    the <input> and <textarea> tags, fire “input” events whenever the user changes
    their content. To get the actual content typed, it is best to directly read it
    from the focused field, which we discuss in [Chapter 18](ch18.xhtml#ch18).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了注意到何时输入了内容，可以输入的元素，如<input>和<textarea>标签，每当用户更改其内容时会触发“input”事件。要获取实际输入的内容，最好直接从聚焦的字段中读取，我们在[第18章](ch18.xhtml#ch18)中讨论了这一点。
- en: Pointer Events
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针事件
- en: 'There are currently two widely used ways to point at things on a screen: mice
    (including devices that act like mice, such as touchpads and trackballs) and touchscreens.
    These produce different kinds of events.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有两种广泛使用的指向屏幕上事物的方式：鼠标（包括像触控板和轨迹球等起到鼠标作用的设备）和触摸屏。这些设备会产生不同类型的事件。
- en: '*Mouse Clicks*'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*鼠标点击*'
- en: Pressing a mouse button causes a number of events to fire. The “mousedown” and
    “mouseup” events are similar to “keydown” and “keyup” and fire when the button
    is pressed and released. These happen on the DOM nodes that are immediately below
    the mouse pointer when the event occurs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 按下鼠标按钮会触发多个事件。“mousedown”和“mouseup”事件类似于“keydown”和“keyup”，分别在按钮按下和释放时触发。这些事件发生在事件发生时位于鼠标指针正下方的DOM节点上。
- en: After the “mouseup” event, a “click” event fires on the most specific node that
    contained both the press and the release of the button. For example, if I press
    down the mouse button on one paragraph and then move the pointer to another paragraph
    and release the button, the “click” event will happen on the element that contains
    both those paragraphs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在“mouseup”事件之后，会在包含按钮按下和释放的最具体节点上触发一个“click”事件。例如，如果我在一个段落上按下鼠标按钮，然后将指针移动到另一个段落并释放按钮，“click”事件将发生在包含这两个段落的元素上。
- en: If two clicks happen close together, a “dblclick” (double-click) event also
    fires, after the second click event.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个点击发生得很接近，会触发一个“dblclick”（双击）事件，发生在第二次点击事件之后。
- en: To get precise information about the place where a mouse event happened, you
    can look at its clientX and clientY properties, which contain the event’s coordinates
    (in pixels) relative to the upper-left corner of the window, or pageX and pageY,
    which are relative to the upper-left corner of the whole document (which may be
    different when the window has been scrolled).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关于鼠标事件发生位置的精确信息，可以查看其clientX和clientY属性，这些属性包含事件相对于窗口左上角的坐标（以像素为单位），或者pageX和pageY，这些是相对于整个文档左上角的坐标（当窗口滚动时可能不同）。
- en: The following program implements a primitive drawing application. Every time
    you click the document, it adds a dot under your mouse pointer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序实现了一个原始的绘图应用程序。每次你点击文档时，它会在你的鼠标指针下添加一个点。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ll create a less primitive drawing application in [Chapter 19](ch19.xhtml#ch19).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第19章](ch19.xhtml#ch19)中创建一个不那么原始的绘图应用程序。
- en: '*Mouse Motion*'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*鼠标运动*'
- en: Every time the mouse pointer moves, a “mousemove” event fires. This event can
    be used to track the position of the mouse. A common situation in which this is
    useful is when implementing some form of mouse-dragging functionality.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每当鼠标指针移动时，都会触发“mousemove”事件。此事件可以用于跟踪鼠标的位置。这在实现某种形式的鼠标拖动功能时特别有用。
- en: 'As an example, the following program displays a bar and sets up event handlers
    so that dragging to the left or right on this bar makes it narrower or wider:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，以下程序显示了一个条，并设置了事件处理程序，以便在该条上向左或向右拖动时使其变窄或变宽：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The resulting page looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最终页面看起来是这样的：
- en: '![Image](../images/f0242-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0242-01.jpg)'
- en: Note that the “mousemove” handler is registered on the whole window. Even if
    the mouse goes outside of the bar during resizing, as long as the button is held,
    we still want to update its size.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“mousemove”处理程序注册在整个窗口上。即使在调整大小时鼠标移出条的范围，只要按钮被按住，我们仍然希望更新其大小。
- en: We must stop resizing the bar when the mouse button is released. For that, we
    can use the buttons property (note the plural), which tells us about the buttons
    that are currently held down. When it is 0, no buttons are down. When buttons
    are held, the value of the buttons property is the sum of the codes for those
    buttons—the left button has code 1, the right button 2, and the middle one 4\.
    With the left and right buttons held, for example, the value of buttons will be
    3.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在鼠标按钮释放时停止调整条的大小。为此，我们可以使用 buttons 属性（注意复数形式），它告诉我们当前被按下的按钮。当值为 0 时，表示没有按钮被按下。当按钮被按下时，buttons
    属性的值是这些按钮代码的总和——左键的代码是 1，右键是 2，中间键是 4。例如，当左键和右键同时按下时，buttons 的值将为 3。
- en: Note that the order of these codes is different from the one used by button,
    where the middle button came before the right one. As mentioned, consistency isn’t
    a strong point of the browser’s programming interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些代码的顺序与 button 使用的顺序不同，在那里中间按钮在右边按钮之前。如前所述，一致性并不是浏览器编程接口的强项。
- en: '*Touch Events*'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*触摸事件*'
- en: The style of graphical browser that we use was designed with mouse interfaces
    in mind, at a time where touchscreens were rare. To make the web “work” on early
    touchscreen phones, browsers for those devices pretended, to a certain extent,
    that touch events were mouse events. If you tap your screen, you’ll get “mousedown”,
    “mouseup”, and “click” events.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的图形浏览器样式是在触摸屏较为稀少的时代，以鼠标接口为设计理念的。为了使早期触摸屏手机上的网页“工作”，这些设备的浏览器在一定程度上假装触摸事件是鼠标事件。如果你轻触屏幕，会触发“mousedown”、“mouseup”和“click”事件。
- en: 'But this illusion isn’t very robust. A touchscreen doesn’t work like a mouse:
    it doesn’t have multiple buttons, you can’t track the finger when it isn’t on
    the screen (to simulate “mousemove”), and it allows multiple fingers to be on
    the screen at the same time.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种错觉并不是很稳健。触摸屏的工作方式与鼠标不同：它没有多个按钮，当手指不在屏幕上时，你无法追踪手指（以模拟“mousemove”），而且允许多个手指同时在屏幕上。
- en: Mouse events cover touch interaction only in straightforward cases—if you add
    a “click” handler to a button, touch users will still be able to use it. But something
    like the resizeable bar in the previous example does not work on a touchscreen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件仅在简单情况下覆盖触摸交互——如果你为按钮添加“点击”处理程序，触摸用户仍然可以使用它。但像前面示例中的可调整大小条在触摸屏上则无法工作。
- en: There are specific event types fired by touch interaction. When a finger starts
    touching the screen, you get a “touchstart” event. When it is moved while touching,
    “touchmove” events fire. Finally, when it stops touching the screen, you’ll see
    a “touchend” event.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 触摸交互会触发特定的事件类型。当手指开始接触屏幕时，你会收到一个“touchstart”事件。当手指在触摸时移动时，会触发“touchmove”事件。最后，当手指停止接触屏幕时，你会看到一个“touchend”事件。
- en: Because many touchscreens can detect multiple fingers at the same time, these
    events don’t have a single set of coordinates associated with them. Rather, their
    event objects have a touches property, which holds an array-like object of points,
    each of which has its own clientX, clientY, pageX, and pageY properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多触摸屏可以同时检测多个手指，因此这些事件没有与之相关联的单一坐标集。相反，它们的事件对象具有一个 touches 属性，该属性包含一个类似数组的点对象，每个点都有自己的
    clientX、clientY、pageX 和 pageY 属性。
- en: 'You could do something like this to show red circles around every touching
    finger:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做这样的事情，在每个触摸的手指周围显示红色圆圈：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll often want to call preventDefault in touch event handlers to override
    the browser’s default behavior (which may include scrolling the page on swiping)
    and to prevent the mouse events from being fired, for which you may *also* have
    a handler.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会希望在触摸事件处理程序中调用 preventDefault，以覆盖浏览器的默认行为（可能包括在滑动时滚动页面），并防止触发鼠标事件，对于这些事件你也可能有一个处理程序。
- en: Scroll Events
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动事件
- en: Whenever an element is scrolled, a “scroll” event is fired on it. This has various
    uses, such as knowing what the user is currently looking at (for disabling off-screen
    animations or sending spy reports to your evil headquarters) or showing some indication
    of progress (by highlighting part of a table of contents or showing a page number).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个元素滚动时，都会在其上触发“scroll”事件。这有多种用途，例如了解用户当前正在查看的内容（用于禁用屏幕外动画或向你邪恶的总部发送间谍报告）或显示某种进度指示（通过突出显示部分目录或显示页码）。
- en: 'The following example draws a progress bar above the document and updates it
    to fill up as you scroll down:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在文档上方绘制一个进度条，并在你向下滚动时更新它以填满：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Giving an element a position of fixed acts much like an absolute position but
    also prevents it from scrolling along with the rest of the document. The effect
    is to make our progress bar stay at the top. Its width is changed to indicate
    the current progress. We use %, rather than px, as a unit when setting the width
    so that the element is sized relative to the page width.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个元素的定位设置为固定的位置与绝对位置的效果类似，但也防止其与文档的其他部分一起滚动。其效果是使我们的进度条停留在顶部。其宽度会根据当前进度进行调整。我们在设置宽度时使用
    % 而不是 px 作为单位，这样元素的大小相对于页面宽度。
- en: The global innerHeight binding gives us the height of the window, which we must
    subtract from the total scrollable height—you can’t keep scrolling when you hit
    the bottom of the document. There’s also an innerWidth for the window width. By
    dividing pageYOffset, the current scroll position, by the maximum scroll position
    and multiplying by 100, we get the percentage for the progress bar.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 全局的 `innerHeight` 绑定给出了窗口的高度，我们必须从总可滚动高度中减去这一数值——当你到达文档底部时，无法继续滚动。窗口宽度还有 `innerWidth`。通过将当前滚动位置
    `pageYOffset` 除以最大滚动位置并乘以 100，我们得到进度条的百分比。
- en: Calling preventDefault on a scroll event does not prevent the scrolling from
    happening. In fact, the event handler is called only *after* the scrolling takes
    place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在滚动事件上调用 `preventDefault` 并不会阻止滚动的发生。事实上，事件处理程序仅在滚动发生后被调用。
- en: Focus Events
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚焦事件
- en: When an element gains focus, the browser fires a “focus” event on it. When it
    loses focus, the element gets a “blur” event.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素获得焦点时，浏览器会在其上触发“focus”事件。当它失去焦点时，该元素会收到“blur”事件。
- en: Unlike the events discussed earlier, these two events do not propagate. A handler
    on a parent element is not notified when a child element gains or loses focus.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前讨论的事件不同，这两个事件不会传播。父元素上的处理程序不会在子元素获得或失去焦点时被通知。
- en: 'The following example displays help text for the text field that currently
    has focus:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例为当前具有焦点的文本字段显示帮助文本：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This screenshot shows the help text for the age field:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该截图显示了年龄字段的帮助文本：
- en: '![Image](../images/f0245-01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0245-01.jpg)'
- en: The window object will receive “focus” and “blur” events when the user moves
    from or to the browser tab or window in which the document is shown.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在显示文档的浏览器标签或窗口之间切换时，窗口对象会接收“focus”和“blur”事件。
- en: Load Event
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载事件
- en: When a page finishes loading, the “load” event fires on the window and the document
    body objects. This is often used to schedule initialization actions that require
    the whole document to have been built. Remember that the content of <script> tags
    is run immediately when the tag is encountered. This may be too soon—for example,
    when the script needs to do something with parts of the document that appear after
    the <script> tag.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载完成时，“load”事件会在窗口和文档主体对象上触发。这通常用于安排需要整个文档构建完成后才能执行的初始化操作。请记住，<script> 标签中的内容在遇到标签时会立即执行。这可能来得太早——例如，当脚本需要处理在
    <script> 标签之后出现的文档部分时。
- en: Elements such as images and script tags that load an external file also have
    a “load” event that indicates the files they reference were loaded. Like the focus-related
    events, loading events do not propagate.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 像图片和加载外部文件的脚本标签这样的元素也有一个“load”事件，表示它们所引用的文件已加载。与聚焦相关的事件一样，加载事件不会传播。
- en: When you close a page or navigate away from it (for example, by following a
    link), a “beforeunload” event fires. The main use of this event is to prevent
    the user from accidentally losing work by closing a document. If you prevent the
    default behavior on this event *and* set the returnValue property on the event
    object to a string, the browser will show the user a dialog asking if they really
    want to leave the page. That dialog might include your string, but because some
    malicious sites try to use these dialogs to confuse people into staying on their
    page to look at dodgy weight-loss ads, most browsers no longer display them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你关闭页面或离开它（例如，通过点击链接）时，会触发一个“beforeunload”事件。这个事件的主要用途是防止用户通过关闭文档意外丢失工作。如果你在这个事件上阻止默认行为*并*将事件对象的returnValue属性设置为一个字符串，浏览器将向用户显示一个对话框，询问他们是否真的想离开页面。该对话框可能包含你的字符串，但由于一些恶意网站试图利用这些对话框来混淆人们，以使他们留在页面上观看可疑的减肥广告，大多数浏览器不再显示这些对话框。
- en: Events and the Event Loop
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件与事件循环
- en: In the context of the event loop, as discussed in [Chapter 11](ch11.xhtml#ch11),
    browser event handlers behave like other asynchronous notifications. They are
    scheduled when the event occurs but must wait for other scripts that are running
    to finish before they get a chance to run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](ch11.xhtml#ch11)讨论的事件循环的上下文中，浏览器事件处理程序的行为类似于其他异步通知。它们在事件发生时被调度，但必须等待正在运行的其他脚本完成后才能获得执行机会。
- en: The fact that events can be processed only when nothing else is running means
    that if the event loop is tied up with other work, any interaction with the page
    (which happens through events) will be delayed until there’s time to process it.
    So if you schedule too much work, either with long-running event handlers or with
    lots of short-running ones, the page will become slow and cumbersome to use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事件只能在没有其他操作运行时处理，这意味着如果事件循环被其他工作占用，与页面的任何交互（通过事件发生）将会延迟，直到有时间处理它。因此，如果你调度了过多的工作，无论是使用长时间运行的事件处理程序还是大量短时间运行的事件处理程序，页面将变得缓慢和笨重。
- en: For cases where you *really* do want to do some time-consuming thing in the
    background without freezing the page, browsers provide something called *web workers*.
    A worker is a JavaScript process that runs alongside the main script, on its own
    timeline.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果你*确实*想在后台执行一些耗时的操作而不冻结页面，浏览器提供了一种称为*网络工作者*的东西。工作者是一个JavaScript进程，它与主脚本并行运行，拥有自己的时间线。
- en: Imagine that squaring a number is a heavy, long-running computation that we
    want to perform in a separate thread. We could write a file called *code/squareworker.js*
    that responds to messages by computing a square and sending a message back.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，平方一个数字是一个耗时的长时间计算，我们希望在单独的线程中执行。我们可以编写一个名为 *code/squareworker.js* 的文件，它通过计算平方并发送消息返回来响应消息。
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To avoid the problems of having multiple threads touching the same data, workers
    do not share their global scope or any other data with the main script’s environment.
    Instead, you have to communicate with them by sending messages back and forth.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免多个线程同时访问相同数据的问题，工作线程不与主脚本的环境共享它们的全局作用域或其他任何数据。相反，你必须通过发送消息来进行通信。
- en: This code spawns a worker running that script, sends it a few messages, and
    outputs the responses.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成一个运行该脚本的工作者，发送几个消息，并输出响应。
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The postMessage function sends a message, which will cause a “message” event
    to fire in the receiver. The script that created the worker sends and receives
    messages through the Worker object, whereas the worker talks to the script that
    created it by sending and listening directly on its global scope. Only values
    that can be represented as JSON can be sent as messages—the other side will receive
    a *copy* of them, rather than the value itself.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: postMessage函数发送消息，这将导致接收方触发一个“message”事件。创建工作者的脚本通过Worker对象发送和接收消息，而工作者则通过直接在其全局作用域上发送和监听，与创建它的脚本进行通信。只有可以表示为JSON的值才能作为消息发送——另一方将接收到它们的*副本*，而不是值本身。
- en: Timers
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定时器
- en: The setTimeout function we saw in [Chapter 11](ch11.xhtml#ch11) schedules another
    function to be called after a given number of milliseconds. Sometimes you need
    to cancel a function you have scheduled. You can do this by storing the value
    returned by setTimeout and calling clearTimeout on it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第11章](ch11.xhtml#ch11)中看到的setTimeout函数会在给定的毫秒数后调度另一个函数被调用。有时你需要取消已经调度的函数。你可以通过存储setTimeout返回的值，并在其上调用clearTimeout来实现。
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The cancelAnimationFrame function works in the same way as clearTimeout. Calling
    it on a value returned by requestAnimationFrame will cancel that frame (assuming
    it hasn’t already been called).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: cancelAnimationFrame函数的工作方式与clearTimeout相同。对requestAnimationFrame返回的值调用它将取消该帧（假设它尚未被调用）。
- en: A similar set of functions, setInterval and clearInterval, are used to set timers
    that should repeat every *X* milliseconds.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一组类似的函数setInterval和clearInterval用于设置每*X*毫秒重复的计时器。
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Debouncing
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防抖
- en: Some types of events have the potential to fire rapidly many times in a row,
    such as the “mousemove” and “scroll” events. When handling such events, you must
    be careful not to do anything too time-consuming or your handler will take up
    so much time that interaction with the document starts to feel slow.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类型的事件可能会迅速连续触发多次，例如“mousemove”和“scroll”事件。在处理这些事件时，必须小心不要执行任何耗时的操作，否则你的处理程序会占用过多时间，从而使与文档的交互感觉缓慢。
- en: If you do need to do something nontrivial in such a handler, you can use setTimeout
    to make sure you are not doing it too often. This is usually called *debouncing*
    the event. There are several slightly different approaches to this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要在这样的处理程序中做一些复杂的事情，可以使用setTimeout来确保不会过于频繁地执行。这通常被称为*防抖*事件。对此有几种稍微不同的方法。
- en: For example, suppose we want to react when the user has typed something, but
    don’t want to do it immediately for every input event. When they are typing quickly,
    we just want to wait until a pause occurs. Instead of immediately performing an
    action in the event handler, we set a timeout. We also clear the previous timeout
    (if any) so that when events occur close together (closer than our timeout delay),
    the timeout from the previous event will be canceled.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想在用户输入时做出反应，但不想在每次输入事件中立即执行。用户快速输入时，我们只想等到出现暂停再处理。我们在事件处理程序中设置一个超时，而不是立即执行某个操作。我们还会清除之前的超时（如果有的话），这样当事件发生得很接近（比我们的超时延迟更近）时，前一个事件的超时将被取消。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Giving an undefined value to clearTimeout or calling it on a timeout that has
    already fired has no effect. Thus, we don’t have to be careful about when to call
    it, and we simply do so for every event.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将未定义的值传递给clearTimeout或在已经触发的超时上调用它不会产生任何效果。因此，我们不需要小心何时调用它，我们可以简单地对每个事件都调用它。
- en: We can use a slightly different pattern if we want to space responses so that
    they’re separated by at least a certain length of time but want to fire them *during*
    a series of events, not just afterward. For example, we might want to respond
    to “mousemove” events by showing the current coordinates of the mouse, but only
    every 250 milliseconds.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望响应之间的间隔至少有一定时间，但又想在一系列事件*发生期间*触发响应，我们可以使用稍微不同的模式。例如，我们可能希望通过显示当前鼠标坐标来响应“mousemove”事件，但每250毫秒才响应一次。
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Event handlers make it possible to detect and react to events happening in our
    web page. The addEventListener method is used to register such a handler.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序使我们能够检测和响应在网页上发生的事件。addEventListener方法用于注册这样的处理程序。
- en: Each event has a type (”keydown”, “focus”, and so on) that identifies it. Most
    events are called on a specific DOM element and then propagate to that element’s
    ancestors, allowing handlers associated with those elements to handle them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都有一个类型（“keydown”、“focus”等），用于标识它。大多数事件是在特定的DOM元素上调用，然后传播到该元素的祖先，从而允许与这些元素关联的处理程序进行处理。
- en: When an event handler is called, it’s passed an event object with additional
    information about the event. This object also has methods that allow us to stop
    further propagation (stopPropagation) and prevent the browser’s default handling
    of the event (preventDefault).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件处理程序被调用时，它会传递一个事件对象，包含有关事件的额外信息。该对象还有允许我们停止进一步传播（stopPropagation）和防止浏览器默认处理事件（preventDefault）的方法。
- en: Pressing a key fires “keydown” and “keyup” events. Pressing a mouse button fires
    “mousedown”, “mouseup”, and “click” events. Moving the mouse fires ”mousemove”
    events. Touchscreen interaction will result in “touchstart”, ”touchmove”, and
    “touchend” events.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 按下一个键会触发“keydown”和“keyup”事件。按下鼠标按钮会触发“mousedown”、“mouseup”和“click”事件。移动鼠标会触发“mousemove”事件。触摸屏交互会导致“touchstart”、“touchmove”和“touchend”事件。
- en: Scrolling can be detected with the “scroll” event, and focus changes can be
    detected with the “focus” and “blur” events. When the document finishes loading,
    a “load” event fires on the window.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过“scroll”事件检测滚动，焦点变化可以通过“focus”和“blur”事件检测。当文档加载完成时，窗口会触发一个“load”事件。
- en: Exercises
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*Balloon*'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*气球*'
- en: Write a page that displays a balloon (using the balloon emoji, ![Image](../images/f0249-01.jpg)).
    When you press the up arrow, it should inflate (grow) 10 percent. When you press
    the down arrow, it should deflate (shrink) 10 percent.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个页面，显示一个气球（使用气球表情符号， ![Image](../images/f0249-01.jpg)）。当你按上箭头时，它应膨胀（增长）10%。当你按下箭头时，它应缩小（收缩）10%。
- en: You can control the size of text (emoji are text) by setting the font-size CSS
    property (style.fontSize) on its parent element. Remember to include a unit in
    the value—for example, pixels (10px).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在其父元素上设置字体大小的 CSS 属性（style.fontSize）来控制文本（表情符号也是文本）的大小。记得在值中包含单位，例如像素（10px）。
- en: The key names of the arrow keys are “ArrowUp” and “ArrowDown”. Make sure the
    keys change only the balloon, without scrolling the page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头键的关键名称是“ArrowUp”和“ArrowDown”。确保这些键只改变气球，而不会滚动页面。
- en: Once you have that working, add a feature where if you blow up the balloon past
    a certain size, it “explodes.” In this case, exploding means that it is replaced
    with an ![Image](../images/f0249-02.jpg) emoji, and the event handler is removed
    (so that you can’t inflate or deflate the explosion).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这项工作，添加一个功能：如果你将气球膨胀到某个大小，它将“爆炸”。在这种情况下，爆炸意味着它被替换为一个 ![Image](../images/f0249-02.jpg)
    表情符号，并且事件处理程序被移除（这样你就无法再膨胀或缩小爆炸效果）。
- en: '*Mouse Trail*'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*鼠标拖尾*'
- en: In JavaScript’s early days, which was the high time of gaudy home pages with
    lots of animated images, people came up with some truly inspiring ways to use
    the language. One of these was the *mouse trail*—a series of elements that would
    follow the mouse pointer as you moved it across the page.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 的早期，正值华丽主页大量动画图像的高峰期，人们想出了许多真正鼓舞人心的使用该语言的方法。其中之一是 *鼠标拖尾*——一系列元素将在你移动鼠标时跟随鼠标指针。
- en: In this exercise, I want you to implement a mouse trail. Use absolutely positioned
    <div> elements with a fixed size and background color (refer to the code in the
    “Mouse Clicks” section on [page 241](ch15.xhtml#ch15lev2sec1) for an example).
    Create a bunch of these elements and, when the mouse moves, display them in the
    wake of the mouse pointer.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我希望你实现一个鼠标拖尾。使用绝对定位的 <div> 元素，固定大小和背景颜色（请参阅 [第 241 页](ch15.xhtml#ch15lev2sec1)
    “鼠标点击”部分的代码示例）。创建一堆这些元素，并在鼠标移动时，跟随鼠标指针显示它们。
- en: There are various possible approaches here. You can make your trail as simple
    or as complex as you want. A simple solution to start with is to keep a fixed
    number of trail elements and cycle through them, moving the next one to the mouse’s
    current position every time a “mousemove” event occurs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有多种可能的方法。你可以根据需要简化或复杂化你的拖尾。一个简单的起始解决方案是保持固定数量的拖尾元素，并在每次发生“mousemove”事件时，将下一个元素移动到鼠标的当前位置。
- en: '*Tabs*'
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*标签*'
- en: Tabbed panels are common in user interfaces. They allow you to select an interface
    panel by choosing from a number of tabs “sticking out” above an element.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 标签面板在用户界面中很常见。它们允许你通过选择在元素上方“突出的”多个标签中的一个来选择界面面板。
- en: Implement a simple tabbed interface. Write a function, asTabs, that takes a
    DOM node and creates a tabbed interface showing the child elements of that node.
    It should insert a list of <button> elements at the top of the node, one for each
    child element, containing text retrieved from the data-tabname attribute of the
    child. All but one of the original children should be hidden (given a display
    style of none). The currently visible node can be selected by clicking the buttons.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '实现一个简单的标签界面。编写一个函数 asTabs，该函数接受一个 DOM 节点，并创建一个标签界面，显示该节点的子元素。它应在节点顶部插入一个按钮元素列表，每个按钮对应一个子元素，文本来自子元素的
    data-tabname 属性。除一个外，所有原始子元素都应隐藏（设置为 display: none）。通过点击按钮可以选择当前可见的节点。'
- en: When that works, extend it to style the button for the currently selected tab
    differently so that it is obvious which tab is selected.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当这能正常工作时，扩展功能，使当前选中的标签的按钮样式不同，以便明显显示哪个标签被选中。
- en: '*All reality is a game.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有现实都是一场游戏。*'
- en: —Iain Banks, *The Player of Games*
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: —伊恩·班克斯，*游戏玩家*
- en: '![Image](../images/f0252-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0252-01.jpg)'
