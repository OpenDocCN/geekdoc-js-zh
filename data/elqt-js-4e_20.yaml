- en: '18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '18'
- en: HTTP AND FORMS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 与表单
- en: The HyperText Transfer Protocol, introduced in [Chapter 13](ch13.xhtml#ch13),
    is the mechanism through which data is requested and provided on the World Wide
    Web. This chapter describes the protocol in more detail and explains the way browser
    JavaScript has access to it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 超文本传输协议（HyperText Transfer Protocol），在[第 13 章](ch13.xhtml#ch13)中介绍，是在万维网上请求和提供数据的机制。本章更详细地描述了该协议，并解释了浏览器
    JavaScript 如何访问它。
- en: The Protocol
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议
- en: 'If you type *[eloquentjavascript.net/18_http.xhtml](http://eloquentjavascript.net/18_http.xhtml)*
    in your browser’s address bar, the browser first looks up the address of the server
    associated with *eloquent [javascript.net](http://javascript.net)* and tries to
    open a TCP connection to it on port 80, the default port for HTTP traffic. If
    the server exists and accepts the connection, the browser might send something
    like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器的地址栏中输入 *[eloquentjavascript.net/18_http.xhtml](http://eloquentjavascript.net/18_http.xhtml)*，浏览器首先查找与
    *eloquent [javascript.net](http://javascript.net)* 关联的服务器地址，并尝试在端口 80（HTTP 流量的默认端口）上打开一个
    TCP 连接。如果服务器存在并接受连接，浏览器可能会发送类似这样的内容：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then the server responds, through that same connection.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后服务器通过相同的连接进行响应。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The browser takes the part of the response after the blank line, its *body*
    (not to be confused with the HTML <body> tag), and displays it as an HTML document.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器获取空行后响应的部分，即它的 *主体*（不要与 HTML <body> 标签混淆），并将其显示为 HTML 文档。
- en: 'The information sent by the client is called the *request*. It starts with
    this line:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的信息称为 *请求*。它以这一行开始：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first word is the *method* of the request. GET means that we want to *get*
    the specified resource. Other common methods are DELETE to delete a resource,
    PUT to create or replace it, and POST to send information to it. Note that the
    server is not obliged to carry out every request it gets. If you walk up to a
    random website and tell it to DELETE its main page, it’ll probably refuse.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个词是请求的 *方法*。GET 意味着我们想要 *获取* 指定的资源。其他常见的方法有 DELETE 用于删除资源，PUT 用于创建或替换资源，POST
    用于向其发送信息。请注意，服务器并不一定有义务执行它收到的每一个请求。如果你走到一个随机网站并告诉它删除其主页，它可能会拒绝。
- en: The part after the method name is the path of the *resource* the request applies
    to. In the simplest case, a resource is simply a file on the server, but the protocol
    doesn’t require it to be. A resource may be anything that can be transferred *as
    if* it is a file. Many servers generate the responses they produce on the fly.
    For example, if you open *[https://github.com/marijnh](https://github.com/marijnh)*,
    the server looks in its database for a user named *marijnh*, and if it finds one,
    it will generate a profile page for that user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称之后的部分是请求应用于的 *资源* 的路径。在最简单的情况下，资源只是服务器上的一个文件，但协议并不要求它必须是。资源可以是任何可以被转移 *好像*
    它是一个文件的东西。许多服务器生成的响应是动态生成的。例如，如果你打开 *[https://github.com/marijnh](https://github.com/marijnh)*，服务器会在其数据库中查找名为
    *marijnh* 的用户，如果找到了，它会为该用户生成一个个人资料页面。
- en: After the resource path, the first line of the request mentions HTTP/1.1 to
    indicate the version of the HTTP protocol it is using.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源路径之后，请求的第一行提到 HTTP/1.1，以指示它使用的 HTTP 协议的版本。
- en: In practice, many sites use HTTP version 2, which supports the same concepts
    as version 1.1 but is a lot more complicated so that it can be faster. Browsers
    will automatically switch to the appropriate protocol version when talking to
    a given server, and the outcome of a request is the same regardless of which version
    is used. Because version 1.1 is more straightforward and easier to play around
    with, we’ll use that to illustrate the protocol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，许多网站使用 HTTP 版本 2，它支持与版本 1.1 相同的概念，但更加复杂，因此可以更快。浏览器在与特定服务器交互时会自动切换到适当的协议版本，无论使用哪个版本，请求的结果都是相同的。由于版本
    1.1 更加简单且更易于操作，我们将使用它来说明该协议。
- en: The server’s response will start with a version as well, followed by the status
    of the response, first as a three-digit status code and then as a human-readable
    string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的响应也会以一个版本开头，后面跟着响应的状态，首先是一个三位数的状态代码，然后是一个可读的字符串。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Status codes starting with a 2 indicate that the request succeeded. Codes starting
    with 4 mean there was something wrong with the request. The most famous HTTP status
    code is probably 404, which means that the resource could not be found. Codes
    that start with 5 mean an error happened on the server and the request is not
    to blame.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以2开头的状态码表示请求成功。以4开头的代码意味着请求存在问题。最著名的HTTP状态码可能是404，表示找不到该资源。以5开头的代码表示服务器发生了错误，请求没有错。
- en: 'The first line of a request or response may be followed by any number of *headers*.
    These are lines in the form name: value that specify extra information about the
    request or response. These headers were part of the example response:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '请求或响应的第一行后面可以跟随任意数量的*头部*。这些是形如name: value的行，指定有关请求或响应的额外信息。这些头部是示例响应的一部分：'
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This tells us the size and type of the response document. In this case, it is
    an HTML document of 87,320 bytes. It also tells us when that document was last
    modified.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们响应文档的大小和类型。在这种情况下，它是一个87,320字节的HTML文档。它还告诉我们该文档最后一次修改的时间。
- en: The client and server are free to decide what headers to include in their requests
    or responses. But some of them are necessary for things to work. For example,
    without a Content-Type header in the response, the browser won’t know how to display
    the document.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器可以自由决定在请求或响应中包含哪些头部。但其中一些对于正常工作是必要的。例如，如果响应中没有Content-Type头部，浏览器将不知道如何显示该文档。
- en: After the headers, both requests and responses may include a blank line followed
    by a body, which contains the actual document being sent. GET and DELETE requests
    don’t send along any data, but PUT and POST requests do. Some response types,
    such as error responses, also don’t require a body.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在头部之后，请求和响应都可能包含一个空行，后面跟着一个主体，其中包含实际发送的文档。GET和DELETE请求不发送任何数据，但PUT和POST请求会发送。一些响应类型，如错误响应，也不需要主体。
- en: Browsers and HTTP
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浏览器和HTTP
- en: As we saw, a browser will make a request when we enter a URL in its address
    bar. When the resulting HTML page references other files, such as images and JavaScript
    files, it will retrieve those as well.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，当我们在地址栏中输入URL时，浏览器会发起请求。当生成的HTML页面引用其他文件，例如图像和JavaScript文件时，它也会检索这些文件。
- en: A moderately complicated website can easily include anywhere from 10 to 200
    resources. To be able to fetch those quickly, browsers will make several GET requests
    simultaneously, rather than waiting for the responses one at a time.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中等复杂的网站可以轻松包含10到200个资源。为了能够快速获取这些资源，浏览器会同时发起多个GET请求，而不是一个个等待响应。
- en: 'HTML pages may include *forms*, which allow the user to fill out information
    and send it to the server. This is an example of a form:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面可以包含*表单*，允许用户填写信息并将其发送到服务器。这是一个表单的示例：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code describes a form with two fields: a small one asking for a name and
    a larger one to write a message in. When you click the Send button, the form is
    *submitted*, meaning that the content of its field is packed into an HTTP request
    and the browser navigates to the result of that request.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码描述了一个包含两个字段的表单：一个小字段用于输入名字，一个大字段用于写消息。当你点击发送按钮时，表单被*提交*，这意味着其字段的内容被打包成一个HTTP请求，浏览器会导航到该请求的结果。
- en: 'When the <form> element’s method attribute is GET (or is omitted), the information
    in the form is added to the end of the action URL as a *query string*. The browser
    might make a request to this URL:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当<form>元素的method属性为GET（或被省略）时，表单中的信息将作为*查询字符串*添加到动作URL的末尾。浏览器可能会向这个URL发起请求：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The question mark indicates the end of the path part of the URL and the start
    of the query. It is followed by pairs of names and values, corresponding to the
    name attribute on the form field elements and the content of those elements, respectively.
    An ampersand character (&) is used to separate the pairs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 问号表示URL路径部分的结束和查询的开始。它后面跟随名称和值的对，分别对应于表单字段元素的name属性和这些元素的内容。一个&符号用于分隔这些对。
- en: The actual message encoded in the URL is “Yes?” but the question mark is replaced
    by a strange code. Some characters in query strings must be escaped. The question
    mark, represented as %3F, is one of those. There seems to be an unwritten rule
    that every format needs its own way of escaping characters. This one, called *URL
    encoding*, uses a percent sign followed by two hexadecimal (base 16) digits that
    encode the character code. In this case, 3F, which is 63 in decimal notation,
    is the code of a question mark character. JavaScript provides the encodeURIComponent
    and decodeURIComponent functions to encode and decode this format.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: URL 中编码的实际消息是 “Yes?”，但问号被一个奇怪的代码替换。一些查询字符串中的字符必须被转义。问号（以 %3F 表示）就是其中之一。似乎有一种不成文的规则，即每种格式都需要自己的一种字符转义方式。这种称为
    *URL 编码* 的方式使用一个百分号，后跟两个十六进制（基数为 16）数字来编码字符代码。在这种情况下，3F 在十进制中是 63，是问号字符的代码。JavaScript
    提供了 encodeURIComponent 和 decodeURIComponent 函数来编码和解码这种格式。
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we change the method attribute of the HTML form in the example we saw earlier
    to POST, the HTTP request made to submit the form will use the POST method and
    put the query string in the body of the request rather than adding it to the URL.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前看到的 HTML 表单的 method 属性更改为 POST，提交表单时发出的 HTTP 请求将使用 POST 方法，并将查询字符串放入请求的主体中，而不是将其添加到
    URL 中。
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: GET requests should be used for requests that do not have side effects but simply
    ask for information. Requests that change something on the server, for example
    creating a new account or posting a message, should be expressed with other methods,
    such as POST. Client-side software such as a browser knows that it shouldn’t blindly
    make POST requests but will often implicitly make GET requests—to prefetch a resource
    it believes the user will soon need, for example.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: GET 请求应当用于没有副作用的请求，仅仅是请求信息。例如，创建新账户或发布消息等更改服务器内容的请求，应使用其他方法，例如 POST。客户端软件（例如浏览器）知道不应盲目发送
    POST 请求，但通常会隐式发送 GET 请求——例如，预取用户可能很快需要的资源。
- en: We’ll come back to forms and how to interact with them from JavaScript later
    in the chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在本章中回到表单以及如何通过 JavaScript 与它们进行交互。
- en: Fetch
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fetch
- en: The interface through which browser JavaScript can make HTTP requests is called
    fetch.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器 JavaScript 可以进行 HTTP 请求的接口称为 fetch。
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling fetch returns a promise that resolves to a Response object holding information
    about the server’s response, such as its status code and its headers. The headers
    are wrapped in a Map-like object that treats its keys (the header names) as case
    insensitive because header names are not supposed to be case sensitive. This means
    headers.get(“Content-Type”) and headers.get (“content-TYPE”) will return the same
    value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 fetch 返回一个 Promise，该 Promise 解析为一个 Response 对象，包含有关服务器响应的信息，例如其状态码和响应头。响应头被封装在一个类似
    Map 的对象中，该对象将其键（头部名称）视为不区分大小写，因为头部名称不应区分大小写。这意味着 headers.get(“Content-Type”) 和
    headers.get(“content-TYPE”) 将返回相同的值。
- en: Note that the promise returned by fetch resolves successfully even if the server
    responded with an error code. It can also be rejected if there is a network error
    or if the server to which the request is addressed can’t be found.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使服务器返回了错误代码，fetch 返回的 Promise 仍然会成功解决。如果发生网络错误或请求所针对的服务器无法找到，Promise 也可能被拒绝。
- en: The first argument to fetch is the URL that should be requested. When that URL
    doesn’t start with a protocol name (such as *http:*), it is treated as *relative*,
    which means it is interpreted relative to the current document. When it starts
    with a slash (/), it replaces the current path, which is the part after the server
    name. When it does not, the part of the current path up to and including its last
    slash character is put in front of the relative URL.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: fetch 的第一个参数是应该请求的 URL。当该 URL 不以协议名称（例如 *http:*）开头时，它被视为 *相对* 的，这意味着它相对于当前文档进行解释。当它以斜杠（/）开头时，它将替换当前路径，即服务器名称之后的部分。当它没有斜杠时，当前路径中直到最后一个斜杠的部分将放在相对
    URL 之前。
- en: To get at the actual content of a response, you can use its text method. Because
    the initial promise is resolved as soon as the response’s headers have been received
    and because reading the response body might take a while longer, this again returns
    a promise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取响应的实际内容，您可以使用其 text 方法。因为初始 Promise 一旦接收到响应的头部就会解决，而读取响应主体可能需要更长的时间，所以这再次返回一个
    Promise。
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A similar method, called json, returns a promise that resolves to the value
    you get when parsing the body as JSON or rejects if it’s not valid JSON.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一种类似的方法，称为json，返回一个解析为JSON时的值的promise，如果不是有效的JSON，则会拒绝。
- en: 'By default, fetch uses the GET method to make its request and does not include
    a request body. You can configure it differently by passing an object with extra
    options as a second argument. For example, this request tries to delete *example/data.txt*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，fetch使用GET方法发出请求，并且不包含请求主体。你可以通过将带有额外选项的对象作为第二个参数传递来配置它。例如，这个请求试图删除*example/data.txt*：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The 405 status code means “method not allowed,” an HTTP server’s way of saying
    “I’m afraid I can’t do that.”
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 405状态码表示“方法不被允许”，这是HTTP服务器表明“抱歉，我无法做到”的方式。
- en: To add a request body for a PUT or POST request, you can include a body option.
    To set headers, there’s the headers option. For example, this request includes
    a Range header, which instructs the server to return only part of a document.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要为PUT或POST请求添加请求主体，可以包含一个body选项。要设置头部，可以使用headers选项。例如，这个请求包含一个Range头部，指示服务器仅返回文档的一部分。
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The browser will automatically add some request headers, such as “Host” and
    those needed for the server to figure out the size of the body. But adding your
    own headers is often useful to include things such as authentication information
    or to tell the server which file format you’d like to receive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会自动添加一些请求头，例如“Host”和服务器确定主体大小所需的那些。但是，添加你自己的头部通常是有用的，以包含诸如身份验证信息或告诉服务器你希望接收的文件格式等内容。
- en: HTTP Sandboxing
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP沙箱
- en: Making HTTP requests in web page scripts once again raises concerns about security.
    The person who controls the script might not have the same interests as the person
    on whose computer it is running. More specifically, if I visit *themafia.org*,
    I do not want its scripts to be able to make a request to *mybank.com*, using
    identifying information from my browser, with instructions to transfer away all
    my money.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页脚本中发出HTTP请求再次引发了安全性方面的担忧。控制脚本的人可能与其运行的计算机上的人没有相同的利益。更具体地说，如果我访问*themafia.org*，我不希望它的脚本能够请求*mybank.com*，使用我浏览器中的识别信息，并指示转移我所有的钱。
- en: For this reason, browsers protect us by disallowing scripts to make HTTP requests
    to other domains (names such as *themafia.org* and *mybank.com*).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，浏览器通过禁止脚本向其他域（如*themafia.org*和*mybank.com*）发出HTTP请求来保护我们。
- en: 'This can be an annoying problem when building systems that want to access several
    domains for legitimate reasons. Fortunately, servers can include a header like
    this in their response to explicitly indicate to the browser that it is OK for
    the request to come from another domain:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建希望出于合法理由访问多个域的系统时，这可能是一个烦人的问题。幸运的是，服务器可以在其响应中包含这样的头部，以明确向浏览器指示请求可以来自另一个域：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Appreciating HTTP
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解HTTP
- en: When building a system that requires communication between a JavaScript program
    running in the browser (client-side) and a program on a server (server-side),
    there are several different ways to model this communication.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个需要在浏览器中运行的JavaScript程序（客户端）与服务器上的程序（服务器端）之间进行通信的系统时，有几种不同的方式来建模这种通信。
- en: A commonly used model is that of *remote procedure calls*. In this model, communication
    follows the patterns of normal function calls, except that the function is actually
    running on another machine. Calling it involves making a request to the server
    that includes the function’s name and arguments. The response to that request
    contains the returned value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的模型是*远程过程调用*。在这个模型中，通信遵循正常函数调用的模式，只不过函数实际上是在另一台机器上运行。调用它涉及向服务器发出请求，包括函数的名称和参数。对此请求的响应包含返回的值。
- en: When thinking in terms of remote procedure calls, HTTP is just a vehicle for
    communication, and you will most likely write an abstraction layer that hides
    it entirely.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑远程过程调用时，HTTP只是一个通信的载体，你很可能会编写一个完全隐藏它的抽象层。
- en: Another approach is to build your communication around the concept of resources
    and HTTP methods. Instead of a remote procedure called addUser, you use a PUT
    request to */users/larry*. Instead of encoding that user’s properties in function
    arguments, you define a JSON document format (or use an existing format) that
    represents a user. The body of the PUT request to create a new resource is then
    such a document. A resource is fetched by making a GET request to the resource’s
    URL (for example, */users/larry*), which again returns the document representing
    the resource.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是围绕资源和HTTP方法的概念构建你的通信。你使用PUT请求而不是远程过程addUser，针对*/users/larry*。你不再在函数参数中编码用户的属性，而是定义一个JSON文档格式（或使用现有格式）来表示用户。然后，用于创建新资源的PUT请求的主体就是这样的文档。通过向资源的URL（例如，*/users/larry*）发出GET请求来获取资源，这又会返回表示该资源的文档。
- en: This second approach makes it easier to use some of the features that HTTP provides,
    such as support for caching resources (keeping a copy of a resource on the client
    for fast access). The concepts used in HTTP, which are well designed, can provide
    a helpful set of principles to design your server interface around.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种第二种方法使得使用HTTP提供的一些特性变得更加容易，比如支持资源缓存（在客户端保留资源副本以便快速访问）。HTTP中的概念设计良好，可以为设计你的服务器接口提供一套有用的原则。
- en: Security and HTTPS
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全性和HTTPS
- en: Data traveling over the internet tends to follow a long, dangerous road. To
    get to its destination, it must hop through anything from coffee shop Wi-Fi hotspots
    to networks controlled by various companies and states. At any point along its
    route, it may be inspected or even modified.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上传输的数据往往要经历一条漫长而危险的道路。为了到达目的地，它必须穿越从咖啡店Wi-Fi热点到各种公司和国家控制的网络。在其路线的任何点，它都可能被检查甚至被修改。
- en: If it is important that something remain secret, such as the password to your
    email account, or that it arrive at its destination unmodified, such as the account
    number you transfer money to via your bank’s website, plain HTTP is not good enough.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某些东西保持秘密很重要，比如你的电子邮件账户密码，或者它需要在传输到目的地时不被修改，比如你通过银行网站转账的账户号码，那么普通HTTP就不够安全。
- en: The secure HTTP protocol, used for URLs starting with *https://*, wraps HTTP
    traffic in a way that makes it harder to read and tamper with. Before exchanging
    data, the client verifies that the server is who it claims to be by asking it
    to prove that it has a cryptographic certificate issued by a certificate authority
    that the browser recognizes. Next, all data going over the connection is encrypted
    in a way that should prevent eavesdropping and tampering.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 安全HTTP协议用于以*https://*开头的URL，以一种更难以阅读和篡改的方式封装HTTP流量。在交换数据之前，客户端通过要求服务器证明其拥有浏览器识别的证书颁发机构颁发的加密证书，来验证服务器的身份。接下来，通过连接传输的所有数据都以一种应该能防止窃听和篡改的方式进行加密。
- en: Thus, when it works right, HTTPS prevents other people from impersonating the
    website you are trying to talk to *and* from snooping on your communication. It’s
    not perfect, and there have been various incidents where HTTPS failed because
    of forged or stolen certificates and broken software, but it is a *lot* safer
    than plain HTTP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当它正常工作时，HTTPS可以防止其他人冒充你想要交流的网站*并且*监视你的通信。它并不完美，也发生过由于伪造或盗用证书和软件故障导致HTTPS失败的各种事件，但它比普通HTTP安全*得多*。
- en: Form Fields
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单字段
- en: Forms were originally designed for the pre-JavaScript web to allow websites
    to send user-submitted information in an HTTP request. This design assumes that
    interaction with the server always happens by navigating to a new page.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表单最初是为预JavaScript网页设计的，目的是允许网站通过HTTP请求发送用户提交的信息。这个设计假设与服务器的交互总是通过导航到新页面来进行。
- en: However, the form elements are part of the DOM, like the rest of the page, and
    the DOM elements that represent form fields support a number of properties and
    events that are not present on other elements. These make it possible to inspect
    and control such input fields with JavaScript programs and do things such as adding
    new functionality to a form or using forms and fields as building blocks in a
    JavaScript application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，表单元素是DOM的一部分，就像页面的其余部分一样，表示表单字段的DOM元素支持许多其他元素所不具备的属性和事件。这使得使用JavaScript程序检查和控制这些输入字段成为可能，并且可以进行诸如向表单添加新功能或在JavaScript应用程序中将表单和字段作为构建块等操作。
- en: A web form consists of any number of input fields grouped in a <form> tag. HTML
    allows several different styles of fields, ranging from simple on/off checkboxes
    to drop-down menus and fields for text input. This book won’t try to comprehensively
    discuss all field types, but we’ll start with a rough overview.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网页表单由任意数量的输入字段组成，这些字段被分组在一个 `<form>` 标签中。HTML 允许多种不同样式的字段，从简单的开关复选框到下拉菜单和文本输入字段。本书不会试图全面讨论所有字段类型，但我们将首先提供一个粗略的概述。
- en: 'A lot of field types use the <input> tag. This tag’s type attribute is used
    to select the field’s style. These are some commonly used <input> types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字段类型使用 `<input>` 标签。该标签的 type 属性用于选择字段的样式。以下是一些常用的 `<input>` 类型：
- en: '| text | A single-line text field |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| text | 单行文本字段 |'
- en: '| password | Same as text but hides the text that is typed |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| password | 与文本相同，但隐藏输入的文本 |'
- en: '| checkbox | An on/off switch |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| checkbox | 开/关切换开关 |'
- en: '| color | A color |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| color | 一种颜色 |'
- en: '| date | A calendar date |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| date | 日历日期 |'
- en: '| radio | (Part of) a multiple-choice field |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| radio | (部分) 多选字段 |'
- en: '| file | Allows the user to choose a file from their computer |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| file | 允许用户从他们的计算机中选择一个文件 |'
- en: Form fields do not necessarily have to appear in a <form> tag. You can put them
    anywhere in a page. Such form-less fields cannot be submitted (only a form as
    a whole can), but when responding to input with JavaScript, we often don’t want
    to submit our fields normally anyway.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段不一定要出现在 `<form>` 标签中。你可以将它们放置在页面的任何位置。这种无表单字段不能被提交（只有整个表单可以），但在使用 JavaScript
    响应输入时，我们通常不希望正常提交我们的字段。
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The fields created with this HTML code look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 HTML 代码创建的字段看起来是这样的：
- en: '![Image](../images/f0304-01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0304-01.jpg)'
- en: The JavaScript interface for such elements differs with the type of the element.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素的 JavaScript 接口根据元素的类型而有所不同。
- en: Multiline text fields have their own tag, <textarea>, mostly because using an
    attribute to specify a multiline starting value would be awkward. The <textarea>
    tag requires a matching </textarea> closing tag and uses the text between those
    two, instead of the value attribute, as starting text.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 多行文本字段有自己的标签 `<textarea>`，主要是因为使用属性指定多行起始值会显得尴尬。`<textarea>` 标签需要一个匹配的 `</textarea>`
    结束标签，并使用这两个标签之间的文本作为起始文本，而不是值属性。
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, the <select> tag is used to create a field that allows the user to
    select from a number of predefined options.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`<select>` 标签用于创建一个字段，允许用户从多个预定义选项中进行选择。
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Such a field looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的字段看起来是这样的：
- en: '![Image](../images/f0305-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0305-01.jpg)'
- en: Whenever the value of a form field changes, it will fire a “change” event.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每当表单字段的值发生变化时，它将触发一个“change”事件。
- en: Focus
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 焦点
- en: Unlike most elements in HTML documents, form fields can get *keyboard focus*.
    When clicked, moved to with TAB, or activated in some other way, they become the
    currently active element and the recipient of keyboard input.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与 HTML 文档中的大多数元素不同，表单字段可以获得 *键盘焦点*。当点击、通过 TAB 移动或以其他方式激活时，它们将成为当前活动元素并接收键盘输入。
- en: Thus, you can type into a text field only when it is focused. Other fields respond
    differently to keyboard events. For example, a <select> menu tries to move to
    the option that contains the text the user typed and responds to the arrow keys
    by moving its selection up and down.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你只能在文本字段获得焦点时输入内容。其他字段对键盘事件的响应方式不同。例如，`<select>` 菜单会尝试移动到包含用户输入文本的选项，并通过上下箭头键移动选择。
- en: We can control focus from JavaScript with the focus and blur methods. The first
    moves focus to the DOM element it is called on, and the second removes focus.
    The value in document.activeElement corresponds to the currently focused element.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 JavaScript 使用 focus 和 blur 方法控制焦点。第一个方法将焦点移动到调用的 DOM 元素，第二个方法则移除焦点。`document.activeElement`
    的值对应于当前获得焦点的元素。
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For some pages, the user is expected to want to interact with a form field immediately.
    JavaScript can be used to focus this field when the document is loaded, but HTML
    also provides the autofocus attribute, which produces the same effect while letting
    the browser know what we are trying to achieve. This gives the browser the option
    to disable the behavior when it is not appropriate, such as when the user has
    put the focus on something else.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些页面，用户期望立即与表单字段进行交互。JavaScript 可以在文档加载时聚焦该字段，但 HTML 也提供了 autofocus 属性，该属性在让浏览器知道我们想要实现什么的同时产生相同的效果。这让浏览器在不适当的情况下有机会禁用这一行为，比如当用户将焦点放在其他地方时。
- en: 'Browsers allow the user to move the focus through the document by pressing
    TAB to move to the next focusable element, and SHIFT-TAB to move back to the previous
    element. By default, elements are visited in the order in which they appear in
    the document. It is possible to use the tabindex attribute to change this order.
    The following example document will let the focus jump from the text input to
    the OK button, rather than going through the help link first:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器允许用户通过按 TAB 移动焦点到下一个可聚焦元素，按 SHIFT-TAB 返回到上一个元素。默认情况下，元素按照它们在文档中出现的顺序被访问。可以使用
    tabindex 属性来改变这个顺序。以下示例文档将允许焦点从文本输入跳转到 OK 按钮，而不是先经过帮助链接：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By default, most types of HTML elements cannot be focused. You can add a tabindex
    attribute to any element to make it focusable. A tabindex of 0 makes an element
    focusable without affecting the focus order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大多数类型的 HTML 元素不能被聚焦。你可以给任何元素添加 tabindex 属性使其可聚焦。tabindex 为 0 的元素可以被聚焦而不影响聚焦顺序。
- en: Disabled Fields
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用字段
- en: All form fields can be *disabled* through their disabled attribute. It is an
    attribute that can be specified without value—the fact that it is present at all
    disables the element.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有表单字段都可以通过其 disabled 属性被 *禁用*。这是一个可以不带值指定的属性——只要存在，元素就会被禁用。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Disabled fields cannot be focused or changed, and browsers make them look gray
    and faded.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 被禁用的字段无法聚焦或更改，浏览器会使其看起来呈灰色和褪色。
- en: '![Image](../images/f0306-01.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0306-01.jpg)'
- en: When a program is in the process of handling an action caused by some button
    or other control that might require communication with the server and thus take
    a while, it can be a good idea to disable the control until the action finishes.
    That way, when the user gets impatient and clicks it again, they don’t accidentally
    repeat their action.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个程序正在处理由某个按钮或其他控件引起的可能需要与服务器通信并因此耗时的操作时，禁用该控件直到操作完成是个好主意。这样，当用户不耐烦再次点击时，他们不会不小心重复他们的操作。
- en: The Form as a Whole
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整个表单
- en: When a field is contained in a <form> element, its DOM element will have a form
    property linking back to the form’s DOM element. The <form> element, in turn,
    has a property called elements that contains an array-like collection of the fields
    inside it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个字段包含在 `<form>` 元素中时，其 DOM 元素将有一个 form 属性链接回该表单的 DOM 元素。反过来，`<form>` 元素有一个名为
    elements 的属性，包含了内部字段的类似数组的集合。
- en: The name attribute of a form field determines the way its value will be identified
    when the form is submitted. It can also be used as a property name when accessing
    the form’s elements property, which acts both as an array-like object (accessible
    by number) and a map (accessible by name).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 表单字段的 name 属性决定了在提交表单时其值的识别方式。它也可以在访问表单的 elements 属性时用作属性名称，该属性既可以作为类似数组的对象（通过数字访问），也可以作为映射（通过名称访问）。
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A button with a type attribute of submit will, when pressed, cause the form
    to be submitted. Pressing ENTER when a form field is focused has the same effect.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个具有提交类型属性的按钮被按下时，会导致表单被提交。在表单字段聚焦时按下 ENTER 键也会产生相同的效果。
- en: Submitting a form normally means that the browser navigates to the page indicated
    by the form’s action attribute, using either a GET or a POST request. But before
    that happens, a “submit” event is fired. You can handle this event with JavaScript
    and prevent this default behavior by calling preventDefault on the event object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正常提交表单意味着浏览器导航到由表单的 action 属性指示的页面，使用 GET 或 POST 请求。但在这之前，会触发一个 “submit” 事件。你可以用
    JavaScript 处理这个事件，并通过在事件对象上调用 preventDefault 来阻止这种默认行为。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Intercepting “submit” events in JavaScript has various uses. We can write code
    to verify that the values the user entered make sense and immediately show an
    error message instead of submitting the form. Or we can disable the regular way
    of submitting the form entirely, as in the example, and have our program handle
    the input, possibly using fetch to send it to a server without reloading the page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中拦截 “submit” 事件有多种用途。我们可以编写代码来验证用户输入的值是否合理，并立即显示错误信息，而不是提交表单。或者，我们可以完全禁用常规的提交表单方式，如示例所示，让我们的程序处理输入，可能使用
    fetch 将其发送到服务器而无需重新加载页面。
- en: Text Fields
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本字段
- en: Fields created by <textarea> tags, or <input> tags with a type of text or password,
    share a common interface. Their DOM elements have a value property that holds
    their current content as a string value. Setting this property to another string
    changes the field’s content.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `<textarea>` 标签或类型为文本或密码的 `<input>` 标签创建的字段共享一个公共接口。它们的 DOM 元素具有一个 value 属性，该属性作为字符串值持有当前内容。将此属性设置为另一个字符串会更改字段的内容。
- en: The selectionStart and selectionEnd properties of text fields give us information
    about the cursor and selection in the text. When nothing is selected, these two
    properties hold the same number, indicating the position of the cursor. For example,
    0 indicates the start of the text, and 10 indicates the cursor is after the 10th
    character. When part of the field is selected, the two properties will differ,
    giving us the start and end of the selected text. Like value, these properties
    may also be written to.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段的 selectionStart 和 selectionEnd 属性提供了关于光标和文本选择的信息。当没有选中任何内容时，这两个属性的值相同，指示光标的位置。例如，0
    表示文本的开始，10 表示光标位于第 10 个字符之后。当字段的部分内容被选中时，这两个属性的值会不同，显示所选文本的起始和结束位置。与值一样，这些属性也可以被写入。
- en: Imagine you are writing an article about Khasekhemwy, last pharaoh of the Second
    Dynasty, but have some trouble spelling his name. The following code wires up
    a <textarea> tag with an event handler that, when you press F2, inserts the string
    “Khasekhemwy” for you.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在写一篇关于哈塞克赫姆维（Khasekhemwy），第二王朝的最后一位法老的文章，但在拼写他的名字时遇到了一些困难。以下代码连接了一个 `<textarea>`
    标签，并添加了一个事件处理程序，当你按下 F2 时，会为你插入字符串 “Khasekhemwy”。
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The replaceSelection function replaces the currently selected part of a text
    field’s content with the given word and then moves the cursor after that word
    so that the user can continue typing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: replaceSelection 函数将文本字段内容中当前选中的部分替换为给定的词，并将光标移动到该词后，以便用户可以继续输入。
- en: The “change” event for a text field does not fire every time something is typed.
    Rather, it fires when the field loses focus after its content was changed. To
    respond immediately to changes in a text field, you should register a handler
    for the “input” event instead, which fires every time the user types a character,
    deletes text, or otherwise manipulates the field’s content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字段的 “change” 事件并不会在每次输入时触发。而是在字段内容更改后失去焦点时触发。要立即响应文本字段中的更改，你应该注册 “input” 事件的处理程序，该事件在用户每次输入字符、删除文本或以其他方式操作字段内容时都会触发。
- en: 'The following example shows a text field and a counter displaying the current
    length of the text in the field:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个文本字段和一个计数器，显示该字段中文本的当前长度：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Checkboxes and Radio Buttons
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复选框和单选按钮
- en: A checkbox field is a binary toggle. Its value can be extracted or changed through
    its checked property, which holds a Boolean value.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框字段是一个二元切换。它的值可以通过其 checked 属性提取或更改，该属性持有布尔值。
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The <label> tag associates a piece of document with an input field. Clicking
    anywhere on the label will activate the field, which focuses it and toggles its
    value when it is a checkbox or radio button.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`<label>` 标签将文档中的一部分与输入字段关联。点击标签上的任何地方将激活该字段，使其获得焦点，并在其为复选框或单选按钮时切换其值。'
- en: A radio button is similar to a checkbox, but it’s implicitly linked to other
    radio buttons with the same name attribute so that only one of them can be active
    at any time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 单选按钮类似于复选框，但它隐式地与其他具有相同 name 属性的单选按钮关联，以确保在任何时候只有一个可以处于激活状态。
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The square brackets in the CSS query given to querySelectorAll are used to match
    attributes. It selects elements whose name attribute is “color”.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在传递给 querySelectorAll 的 CSS 查询中的方括号用于匹配属性。它选择 name 属性为 “color” 的元素。
- en: Select Fields
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择字段
- en: Select fields are conceptually similar to radio buttons—they also allow the
    user to choose from a set of options. But where a radio button puts the layout
    of the options under our control, the appearance of a <select> tag is determined
    by the browser.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 选择字段在概念上类似于单选按钮——它们也允许用户从一组选项中选择。但是，单选按钮的选项布局由我们控制，而 `<select>` 标签的外观则由浏览器决定。
- en: Select fields also have a variant more akin to a list of checkboxes rather than
    radio boxes. When given the multiple attribute, a <select> tag will allow the
    user to select any number of options, rather than just a single option. Whereas
    a regular select field is drawn as a *drop-down* control, which shows the inactive
    options only when you open it, a field with multiple enabled shows multiple options
    at the same time, allowing the user to enable or disable them individually.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 选择字段也有一个更像复选框而不是单选框的变体。当给定 multiple 属性时，<select> 标签将允许用户选择任意数量的选项，而不仅仅是单个选项。常规选择字段被绘制为
    *下拉* 控件，只有在打开时才会显示非活动选项，而启用 multiple 的字段则同时显示多个选项，允许用户单独启用或禁用它们。
- en: Each <option> tag has a value. This value can be defined with a value attribute.
    When that is not given, the text inside the option will count as its value. The
    value property of a <select> element reflects the currently selected option. For
    a multiple field, though, this property doesn’t mean much, since it will give
    the value of only *one* of the currently selected options.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 <option> 标签都有一个值。这个值可以通过 value 属性定义。当没有给出该属性时，选项内的文本将作为其值。<select> 元素的 value
    属性反映当前选定的选项。然而，对于多个字段来说，这个属性并不太有意义，因为它只会给出当前所选选项中的 *一个* 的值。
- en: The <option> tags for a <select> field can be accessed as an array-like object
    through the field’s options property. Each option has a property called selected,
    which indicates whether that option is currently selected. The property can also
    be written to select or deselect an option.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <select> 字段的 <option> 标签可以通过字段的 options 属性作为类数组对象访问。每个选项都有一个名为 selected 的属性，指示该选项当前是否被选中。该属性也可以被写入，以选择或取消选择一个选项。
- en: This example extracts the selected values from a multiple select field and uses
    them to compose a binary number from individual bits. Hold CTRL (or COMMAND on
    a Mac) to select multiple options.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例从多个选择字段中提取所选值，并利用这些值组成一个二进制数字。按住 CTRL（或在 Mac 上按 COMMAND）以选择多个选项。
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: File Fields
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件字段
- en: File fields were originally designed as a way to upload files from the user’s
    machine through a form. In modern browsers, they also provide a way to read such
    files from JavaScript programs. The field acts as a kind of gate-keeper. The script
    cannot simply start reading private files from the user’s computer, but if the
    user selects a file in such a field, the browser interprets that action to mean
    that the script may read the file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件字段最初被设计为一种通过表单从用户的计算机上传文件的方式。在现代浏览器中，它们还提供了一种从 JavaScript 程序读取此类文件的方法。该字段充当一种守门人。脚本不能简单地开始从用户的计算机读取私有文件，但如果用户在这样的字段中选择了一个文件，浏览器会将该操作解释为脚本可以读取该文件。
- en: A file field usually looks like a button labeled with something like “choose
    file” or “browse,” with information about the chosen file next to it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 文件字段通常看起来像一个带有“选择文件”或“浏览”之类标签的按钮，旁边有所选文件的信息。
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The files property of a file field element is an array-like object (once again,
    not a real array) containing the files chosen in the field. It is initially empty.
    The reason there isn’t simply a file property is that file fields also support
    a multiple attribute, which makes it possible to select multiple files at the
    same time.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 文件字段元素的 files 属性是一个类数组对象（再次强调，不是真正的数组），包含在字段中选择的文件。它最初是空的。没有简单的 file 属性的原因在于文件字段还支持
    multiple 属性，这使得可以同时选择多个文件。
- en: The objects in files have properties such as name (the filename), size (the
    file’s size in bytes, which are chunks of 8 bits), and type (the media type of
    the file, such as text/plain or image/jpeg).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的对象具有诸如 name（文件名）、size（文件的字节大小，8 位的块）和 type（文件的媒体类型，例如 text/plain 或 image/jpeg）等属性。
- en: What it does not have is a property that contains the content of the file. Getting
    at that is a little more involved. Since reading a file from disk can take time,
    the interface is asynchronous to avoid freezing the window.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有的属性是包含文件内容的属性。获取该内容的过程稍微复杂一些。由于从磁盘读取文件可能需要时间，因此接口是异步的，以避免冻结窗口。
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Reading a file is done by creating a FileReader object, registering a “load”
    event handler for it, and calling its readAsText method, giving it the file we
    want to read. Once loading finishes, the reader’s result property contains the
    file’s content.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件是通过创建一个 FileReader 对象，为其注册一个“加载”事件处理程序，并调用其 readAsText 方法，同时传入我们想要读取的文件。一旦加载完成，读取器的
    result 属性将包含文件的内容。
- en: 'FileReaders also fire an “error” event when reading the file fails for any
    reason. The error object itself will end up in the reader’s error property. This
    interface was designed before promises became part of the language. You could
    wrap it in a promise like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileReaders` 在读取文件失败的任何原因时也会触发“错误”事件。错误对象本身将最终出现在阅读器的错误属性中。这个接口在承诺成为语言的一部分之前设计。你可以像这样将其封装在一个承诺中：'
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Storing Data Client-Side
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端数据存储
- en: Simple HTML pages with a bit of JavaScript can be a great format for “mini applications”—small
    helper programs that automate basic tasks. By connecting a few form fields with
    event handlers, you can do anything from converting between centimeters and inches
    to computing passwords from a master password and a website name.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 带有一些 JavaScript 的简单 HTML 页面可以成为“迷你应用程序”的一种很好的格式——小型辅助程序，自动化基本任务。通过将几个表单字段与事件处理程序连接，你可以完成从厘米和英寸之间转换到根据主密码和网站名称计算密码的任何事情。
- en: When such an application needs to remember something between sessions, you cannot
    use JavaScript bindings—those are thrown away every time the page is closed. You
    could set up a server, connect it to the internet, and have your application store
    something there (we’ll see how to do that in [Chapter 20](ch20.xhtml#ch20)). But
    that’s a lot of extra work and complexity. Sometimes it’s enough to just keep
    the data in the browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样的应用程序需要在会话之间记住某些内容时，你不能使用 JavaScript 绑定——每次关闭页面时，这些绑定都会被丢弃。你可以设置一个服务器，将其连接到互联网，并让你的应用程序在那里存储某些内容（我们将在[第20章](ch20.xhtml#ch20)中看到如何做到这一点）。但那是很多额外的工作和复杂性。有时候，仅仅将数据保存在浏览器中就足够了。
- en: The localStorage object can be used to store data in a way that survives page
    reloads. This object allows you to file string values under names.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage` 对象可以用于以在页面重载后仍然存在的方式存储数据。该对象允许你根据名称存储字符串值。'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A value in localStorage sticks around until it is overwritten or is removed
    with removeItem, or the user clears their local data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage` 中的值会一直存在，直到被覆盖、使用 `removeItem` 移除，或用户清除他们的本地数据。'
- en: Sites from different domains get different storage compartments. That means
    data stored in localStorage by a given website can, in principle, be read (and
    overwritten) only by scripts on that same site.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 不同域名的网站获得不同的存储空间。这意味着由特定网站存储在 `localStorage` 中的数据，原则上只能被该网站上的脚本读取（和覆盖）。
- en: Browsers do enforce a limit on the size of the data a site can store in localStorage.
    That restriction, along with the fact that filling up people’s hard drives with
    junk is not really profitable, prevents the feature from eating up too much space.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器确实对网站可以在 `localStorage` 中存储的数据大小施加限制。这种限制，加上填满用户硬盘垃圾数据并不盈利的事实，防止了该功能占用过多空间。
- en: The following code implements a crude note-taking application. It keeps a set
    of named notes and allows the user to edit notes and create new ones.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了一个粗略的记事本应用程序。它保持一组命名的笔记，并允许用户编辑笔记和创建新笔记。
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The script gets its starting state from the “Notes” value stored in local Storage
    or, if that’s missing, creates an example state that has only a shopping list
    in it. Reading a field that does not exist from localStorage will yield null.
    Passing null to JSON.parse will make it parse the string “null” and return null.
    Thus, the ?? operator can be used to provide a default value in a situation like
    this.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本从本地存储中的“Notes”值获取其初始状态，或者如果缺少该值，则创建一个只有购物清单的示例状态。从 `localStorage` 读取不存在的字段将返回
    `null`。将 `null` 传递给 `JSON.parse` 将使其解析字符串 “null” 并返回 `null`。因此，?? 运算符可以用于在这种情况下提供默认值。
- en: The setState method makes sure the DOM is showing a given state and stores the
    new state to localStorage. Event handlers call this function to move to a new
    state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`setState` 方法确保 DOM 显示给定状态，并将新状态存储到 `localStorage`。事件处理程序调用此函数以移动到新状态。'
- en: The ... syntax in the example is used to create a new object that is a clone
    of the old state.notes, but with one property added or overwritten. It uses spread
    syntax to first add the properties from the old object and then set a new property.
    The square brackets notation in the object literal is used to create a property
    whose name is based on some dynamic value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的 `...` 语法用于创建一个新的对象，该对象是旧状态 `.notes` 的克隆，但添加或覆盖了一个属性。它首先使用扩展语法添加旧对象中的属性，然后设置一个新属性。对象字面量中的方括号语法用于创建一个属性，其名称基于某个动态值。
- en: There is another object, similar to localStorage, called sessionStorage. The
    difference between the two is that the content of sessionStorage is forgotten
    at the end of each *session*, which for most browsers means whenever the browser
    is closed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个对象，类似于 localStorage，称为 sessionStorage。两者之间的区别在于 sessionStorage 的内容在每个 *会话*
    结束时会被遗忘，对于大多数浏览器而言，这意味着每当浏览器关闭时。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, we discussed how the HTTP protocol works. A *client* sends
    a request, which contains a method (usually GET) and a path that identifies a
    resource. The *server* then decides what to do with the request and responds with
    a status code and a response body. Both requests and responses may contain headers
    that provide additional information.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了 HTTP 协议的工作原理。*客户端* 发送一个请求，该请求包含一个方法（通常是 GET）和一个标识资源的路径。然后 *服务器*
    决定如何处理该请求，并以状态码和响应体进行响应。请求和响应都可以包含提供附加信息的头。
- en: 'The interface through which browser JavaScript can make HTTP requests is called
    fetch. Making a request looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器 JavaScript 进行 HTTP 请求的接口称为 fetch。发起请求的方式如下：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Browsers make GET requests to fetch the resources needed to display a web page.
    A page may also contain forms, which allow information entered by the user to
    be sent as a request for a new page when the form is submitted.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器通过发起 GET 请求来获取显示网页所需的资源。页面还可以包含表单，当表单被提交时，用户输入的信息会作为新页面请求发送。
- en: HTML can represent various types of form fields, such as text fields, checkboxes,
    multiple-choice fields, and file pickers. Such fields can be inspected and manipulated
    with JavaScript. They fire the “change” event when changed, fire the “input” event
    when text is typed, and receive keyboard events when they have keyboard focus.
    Properties like value (for text and select fields) or checked (for checkboxes
    and radio buttons) are used to read or set the field’s content.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 可以表示多种类型的表单字段，如文本字段、复选框、多选字段和文件选择器。这些字段可以通过 JavaScript 进行检查和操作。字段变化时会触发“变化”事件，输入文本时会触发“输入”事件，并在具有键盘焦点时接收键盘事件。像
    value（对于文本和选择字段）或 checked（对于复选框和单选按钮）这样的属性用于读取或设置字段的内容。
- en: When a form is submitted, a “submit” event is fired on it. A JavaScript handler
    can call preventDefault on that event to disable the browser’s default behavior.
    Form field elements may also occur outside of a form tag.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单被提交时，会在其上触发“提交”事件。JavaScript 处理程序可以在该事件上调用 preventDefault 来禁用浏览器的默认行为。表单字段元素也可以出现在表单标签之外。
- en: When the user has selected a file from their local filesystem in a file picker
    field, the FileReader interface can be used to access the content of this file
    from a JavaScript program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在文件选择字段中从本地文件系统选择一个文件时，可以使用 FileReader 接口在 JavaScript 程序中访问该文件的内容。
- en: The localStorage and sessionStorage objects can be used to save information
    in a way that survives page reloads. The first object saves the data forever (or
    until the user decides to clear it), and the second saves it until the browser
    is closed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: localStorage 和 sessionStorage 对象可以用来以在页面重载时仍然保留信息的方式保存数据。第一个对象会永久保存数据（或者直到用户决定清除它），而第二个则在浏览器关闭之前保存数据。
- en: Exercises
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*Content Negotiation*'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*内容协商*'
- en: One of the things HTTP can do is called *content negotiation*. The Accept request
    header is used to tell the server what type of document the client would like
    to get. Many servers ignore this header, but when a server knows of various ways
    to encode a resource, it can look at this header and send the one that the client
    prefers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 的一项功能称为 *内容协商*。Accept 请求头用于告诉服务器客户端希望获得哪种类型的文档。许多服务器会忽略该头，但当服务器知道有多种方式对资源进行编码时，它可以查看该头并发送客户端所偏好的格式。
- en: The URL *[https://eloquentjavascript.net/author](https://eloquentjavascript.net/author)*
    is configured to respond with either plaintext, HTML, or JSON, depending on what
    the client asks for. These formats are identified by the standardized *media types*
    text/plain, text/html, and application/json.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: URL *[https://eloquentjavascript.net/author](https://eloquentjavascript.net/author)*
    被配置为根据客户端请求的内容返回纯文本、HTML 或 JSON。这些格式通过标准化的 *媒体类型* text/plain、text/html 和 application/json
    来识别。
- en: Send requests to fetch all three formats of this resource. Use the headers property
    in the options object passed to fetch to set the header named Accept to the desired
    media type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 发送请求以获取此资源的所有三种格式。使用传递给 fetch 的选项对象中的 headers 属性，将名为 Accept 的头设置为所需的媒体类型。
- en: Finally, try asking for the media type application/rainbows+unicorns and see
    which status code that produces.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，尝试请求媒体类型 application/rainbows+unicorns，看看会产生哪个状态码。
- en: '*A JavaScript Workbench*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一个 JavaScript 工作台*'
- en: Build an interface that allows users to type and run pieces of JavaScript code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个接口，允许用户输入和运行 JavaScript 代码片段。
- en: Put a button next to a <textarea> field that, when pressed, uses the Function
    constructor we saw in [Chapter 10](ch10.xhtml#ch10) to wrap the text in a function
    and call it. Convert the return value of the function, or any error it raises,
    to a string and display it below the text field.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<textarea>` 字段旁边放一个按钮，当按下时，使用我们在 [第 10 章](ch10.xhtml#ch10) 中看到的 Function
    构造函数将文本包装在一个函数中并调用它。将函数的返回值或它引发的任何错误转换为字符串并显示在文本字段下方。
- en: '*Conway’s Game of Life*'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*康威的生命游戏*'
- en: 'Conway’s Game of Life is a simple simulation that creates artificial “life”
    on a grid, each cell of which is either alive or not. In each generation (turn),
    the following rules are applied:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 康威的生命游戏是一个简单的模拟，它在一个网格上创建人工“生命”，每个单元格要么是活的，要么是死的。在每一代（轮次）中，应用以下规则：
- en: Any live cell with fewer than two or more than three live neighbors dies.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何活细胞如果邻居少于两个或多于三个活邻居则死亡。
- en: Any live cell with two or three live neighbors lives on to the next generation.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何活细胞如果有两个或三个活邻居，则可以存活到下一代。
- en: Any dead cell with exactly three live neighbors becomes a live cell.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有恰好三个活邻居的死细胞变为活细胞。
- en: A *neighbor* is defined as any adjacent cell, including diagonally adjacent
    ones.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*邻居*被定义为任何相邻的单元格，包括对角相邻的单元格。'
- en: Note that these rules are applied to the whole grid at once, not one square
    at a time. That means the counting of neighbors is based on the situation at the
    start of the generation, and changes happening to neighbor cells during this generation
    should not influence the new state of a given cell.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些规则是同时应用于整个网格，而不是逐个方格。这意味着邻居的计数是基于这一代开始时的情况，而在这一代中邻居单元格的变化不应影响给定单元格的新状态。
- en: Implement this game using whichever data structure you find appropriate. Use
    Math.random to populate the grid with a random pattern initially. Display it as
    a grid of checkbox fields, with a button next to it to advance to the next generation.
    When the user checks or unchecks the checkboxes, their changes should be included
    when computing the next generation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你认为合适的数据结构来实现这个游戏。使用 Math.random 最初以随机模式填充网格。将其显示为复选框字段的网格，并在旁边放置一个按钮以推进到下一代。当用户勾选或取消勾选复选框时，他们的更改应在计算下一代时考虑在内。
- en: '*I look at the many colors before me. I look at my blank canvas. Then, I try
    to apply colors like words that shape poems, like notes that shape music.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*我看着眼前的各种颜色。我看着我的空白画布。然后，我尝试像塑造诗句的词语一样应用颜色，像塑造音乐的音符一样。*'
- en: —Joan Miró
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: —胡安·米罗
- en: '![Image](../images/f0318-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0318-01.jpg)'
