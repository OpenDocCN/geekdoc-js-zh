- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: 'DATA STRUCTURES: OBJECTS AND ARRAYS'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构：对象和数组
- en: Numbers, Booleans, and strings are the atoms from which data structures are
    built. Many types of information require more than one atom, though. *Objects*
    allow us to group values—including other objects—to build more complex structures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数字、布尔值和字符串是构建数据结构的基本元素。然而，许多类型的信息需要多个元素。*对象*使我们能够将值（包括其他对象）分组，以构建更复杂的结构。
- en: The programs we have built so far have been limited by the fact that they were
    operating only on simple data types. After learning the basics of data structures
    in this chapter, you’ll know enough to start writing useful programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们构建的程序受到限制，因为它们只处理简单数据类型。在本章学习了数据结构的基础知识后，你将足够了解如何开始编写有用的程序。
- en: The chapter will work through a more or less realistic programming example,
    introducing concepts as they apply to the problem at hand. The example code will
    often build on functions and bindings introduced earlier in the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过一个或多或少现实的编程示例，逐步介绍相关概念。示例代码通常会基于本书前面介绍的函数和绑定进行构建。
- en: The online coding sandbox for the book (*[https://eloquentjavascript.net/code](https://eloquentjavascript.net/code)*)
    provides a way to run code in the context of a particular chapter. If you decide
    to work through the examples in another environment, be sure to first download
    the full code for this chapter from the sandbox page.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的在线编码沙箱（*[https://eloquentjavascript.net/code](https://eloquentjavascript.net/code)*)
    提供了一种在特定章节上下文中运行代码的方法。如果你决定在其他环境中进行示例练习，请务必首先从沙箱页面下载本章的完整代码。
- en: The Weresquirrel
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变成松鼠
- en: Every now and then, usually between 8 PM and 10 PM, Jacques finds himself transforming
    into a small furry rodent with a bushy tail.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不时，通常在晚上8点到10点之间，雅克发现自己变成了一只小毛茸茸的啮齿动物，长着蓬松的尾巴。
- en: On one hand, Jacques is quite glad that he doesn’t have classic lycanthropy.
    Turning into a squirrel does cause fewer problems than turning into a wolf. Instead
    of having to worry about accidentally eating the neighbor (*that* would be awkward),
    he worries about being eaten by the neighbor’s cat. After two occasions of waking
    up on a precariously thin branch in the crown of an oak, naked and disoriented,
    he has taken to locking the doors and windows of his room at night and putting
    a few walnuts on the floor to keep himself busy.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，雅克很高兴自己并没有经典的狼人症。变成松鼠比变成狼所造成的问题要少。他不必担心意外吃掉邻居（*那样就尴尬了*），而是担心被邻居的猫吃掉。经过两次醒来时发现自己光着身子、迷失方向，正好栖息在一根危险的细树枝上，他开始锁上房间的门窗，并在地板上放几个核桃以保持自己忙碌。
- en: But Jacques would prefer to get rid of his condition entirely. The irregular
    occurrences of the transformation make him suspect that they might be triggered
    by something. For a while, he believed that it happened only on days when he had
    been near oak trees. However, avoiding oak trees did not solve the problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但是雅克更希望完全摆脱这种状态。转变的不规则发生让他怀疑它们可能是由某种因素触发的。起初，他认为只有在靠近橡树的日子才会发生这种情况。然而，避开橡树并没有解决问题。
- en: Switching to a more scientific approach, Jacques has started keeping a daily
    log of everything he does on a given day and whether he changed form. With this
    data he hopes to narrow down the conditions that trigger the transformations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到更科学的方法，雅克开始记录他每天所做的事情以及是否发生了变化。凭借这些数据，他希望缩小触发转变的条件。
- en: The first thing he needs is a data structure to store this information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 他需要的第一件事是一个数据结构来存储这些信息。
- en: Datasets
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据集
- en: To work with a chunk of digital data, we first have to find a way to represent
    it in our machine’s memory. Say, for example, that we want to represent a collection
    of the numbers 2, 3, 5, 7, and 11.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理一块数字数据，我们首先需要找到一种在计算机内存中表示它的方法。假设我们想表示一组数字：2、3、5、7 和 11。
- en: We could get creative with strings—after all, strings can have any length, so
    we can put a lot of data into them—and use “2 3 5 7 11” as our representation.
    But this is awkward. We’d have to somehow extract the digits and convert them
    back to numbers to access them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用字符串来创造性地表示——毕竟，字符串可以有任意长度，因此我们可以将大量数据放入其中，并使用“2 3 5 7 11”作为我们的表示。但这样做很尴尬。我们必须以某种方式提取数字并将其转换回数字才能访问它们。
- en: Fortunately, JavaScript provides a data type specifically for storing sequences
    of values. It is called an *array* and is written as a list of values between
    square brackets, separated by commas.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，JavaScript 提供了一种特定的数据类型，用于存储值的序列。它被称为 *数组*，并以方括号中的值列表表示，值之间用逗号分隔。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The notation for getting at the elements inside an array also uses square brackets.
    A pair of square brackets immediately after an expression, with another expression
    inside of them, will look up the element in the left-hand expression that corresponds
    to the *index* given by the expression in the brackets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数组内部元素的表示法也使用方括号。紧随表达式之后的一对方括号，内部包含另一个表达式，将查找左侧表达式中与方括号中给出的 *索引* 对应的元素。
- en: The first index of an array is zero, not one, so the first element is retrieved
    with listOfNumbers[0]. Zero-based counting has a long tradition in technology
    and in certain ways makes a lot of sense, but it takes some getting used to. Think
    of the index as the number of items to skip, counting from the start of the array.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的第一个索引是零，而不是一，因此第一个元素可以通过 listOfNumbers[0] 来获取。零基计数在技术中有着悠久的传统，并在某些方面很有道理，但这需要一些适应。可以将索引视为从数组开始处跳过的项数。
- en: Properties
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: We’ve seen a few expressions like myString.length (to get the length of a string)
    and Math.max (the maximum function) in past chapters. These expressions access
    a *property* of some value. In the first case, we access the length property of
    the value in myString. In the second, we access the property named max in the
    Math object (which is a collection of mathematics-related constants and functions).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们见过一些表达式，比如 myString.length（获取字符串的长度）和 Math.max（最大函数）。这些表达式访问某个值的 *属性*。在第一个例子中，我们访问
    myString 中值的长度属性。在第二个例子中，我们访问 Math 对象中的名为 max 的属性（它是一个与数学相关的常量和函数的集合）。
- en: Almost all JavaScript values have properties. The exceptions are null and undefined.
    If you try to access a property on one of these nonvalues, you get an error.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有 JavaScript 值都有属性。例外的是 null 和 undefined。如果你试图访问这些非值之一的属性，你会得到一个错误。
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The two main ways to access properties in JavaScript are with a dot and with
    square brackets. Both value.x and value[x] access a property on value— but not
    necessarily the same property. The difference is in how x is interpreted. When
    using a dot, the word after the dot is the literal name of the property. When
    using square brackets, the expression between the brackets is *evaluated* to get
    the property name. Whereas value.x fetches the property of value named “x,” value[x]
    takes the value of the variable named x and uses that, converted to a string,
    as the property name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中访问属性的两种主要方式是使用点和方括号。value.x 和 value[x] 都访问 value 上的一个属性——但不一定是同一个属性。两者的区别在于
    x 的解释。当使用点时，点后的单词是属性的字面名称。当使用方括号时，括号内的表达式会被 *评估* 以获取属性名称。value.x 获取名为“x”的 value
    属性，而 value[x] 则获取名为 x 的变量的值，并将其转换为字符串作为属性名称。
- en: 'If you know that the property in which you are interested is called *color*,
    you say value.color. If you want to extract the property named by the value held
    in the binding i, you say value[i]. Property names are strings. They can be any
    string, but the dot notation works only with names that look like valid binding
    names—starting with a letter or underscore, and containing only letters, numbers,
    and underscores. If you want to access a property named *2* or *John Doe*, you
    must use square brackets: value[2] or value[“John Doe”].'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你感兴趣的属性名为 *color*，那么你可以使用 value.color。如果你想提取由绑定 i 中的值命名的属性，你可以使用 value[i]。属性名称是字符串。它们可以是任何字符串，但点表示法仅对看起来像有效绑定名称的名称有效——以字母或下划线开头，仅包含字母、数字和下划线。如果你想访问名为
    *2* 或 *John Doe* 的属性，你必须使用方括号：value[2] 或 value[“John Doe”]。
- en: The elements in an array are stored as the array’s properties, using numbers
    as property names. Because you can’t use the dot notation with numbers and usually
    want to use a binding that holds the index anyway, you have to use the bracket
    notation to get at them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的元素作为数组的属性存储，使用数字作为属性名。因为你不能用点符号与数字一起使用，并且通常想要使用一个绑定来持有索引，所以你必须使用括号表示法来访问它们。
- en: Just like strings, arrays have a length property that tells us how many elements
    the array has.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串一样，数组也有一个长度属性，用于告诉我们数组中有多少个元素。
- en: Methods
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: Both string and array values contain, in addition to the length property, a
    number of properties that hold function values.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数组值除了 length 属性外，还包含多个保存函数值的属性。
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every string has a toUpperCase property. When called, it will return a copy
    of the string in which all letters have been converted to uppercase. There is
    also toLowerCase, going the other way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符串都有一个 toUpperCase 属性。当调用时，它将返回一个副本，其中所有字母都被转换为大写。还有一个 toLowerCase，反向操作。
- en: Interestingly, even though the call to toUpperCase does not pass any arguments,
    the function somehow has access to the string “Doh”, the value whose property
    we called. You’ll find out how this works in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管对 toUpperCase 的调用没有传递任何参数，但这个函数以某种方式可以访问字符串 “Doh”，这是我们调用其属性的值。你将在 [第六章](ch06.xhtml#ch06)
    中了解这如何运作。
- en: Properties that contain functions are generally called *methods* of the value
    they belong to, as in “toUpperCase is a method of a string.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 包含函数的属性通常被称为它们所属值的 *方法*，比如“toUpperCase 是字符串的方法。”
- en: This example demonstrates two methods you can use to manipulate arrays.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例演示了两种可以用来操作数组的方法。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The push method adds values to the end of an array. The pop method does the
    opposite, removing the last value in the array and returning it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: push 方法将值添加到数组的末尾。pop 方法则相反，移除数组中的最后一个值并返回它。
- en: These somewhat silly names are the traditional terms for operations on a *stack*.
    A stack, in programming, is a data structure that allows you to push values into
    it and pop them out again in the opposite order so that the thing that was added
    last is removed first. Stacks are common in programming— you might remember the
    function call stack from the previous chapter, which is an instance of the same
    idea.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有点傻的名称是对 *栈* 操作的传统术语。在编程中，栈是一种数据结构，允许你将值推入其中并按相反顺序弹出它们，因此最后添加的东西最先被移除。栈在编程中很常见——你可能还记得上一章中的函数调用栈，它是同一思想的一个实例。
- en: Objects
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: Back to the weresquirrel. A set of daily log entries can be represented as an
    array, but the entries do not consist of just a number or a string—each entry
    needs to store a list of activities and a Boolean value that indicates whether
    Jacques turned into a squirrel or not. Ideally, we would like to group these together
    into a single value and then put those grouped values into an array of log entries.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回到人狼松鼠。每日日志条目可以表示为一个数组，但条目不仅仅由数字或字符串组成——每个条目需要存储一系列活动和一个布尔值，以指示雅克是否变成了松鼠。理想情况下，我们希望将这些信息组合成一个单一的值，然后将这些组合值放入日志条目的数组中。
- en: Values of the type *object* are arbitrary collections of properties. One way
    to create an object is by using braces as an expression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类型为 *object* 的值是任意属性的集合。创建对象的一种方法是将花括号作为表达式使用。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inside the braces, you write a list of properties separated by commas. Each
    property has a name followed by a colon and a value. When an object is written
    over multiple lines, indenting it as shown in this example helps with readability.
    Properties whose names aren’t valid binding names or valid numbers must be quoted.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号内，你写一个用逗号分隔的属性列表。每个属性都有一个名称，后面跟着一个冒号和一个值。当一个对象分多行书写时，像这个示例中那样缩进有助于可读性。名称不是有效绑定名称或有效数字的属性必须加上引号。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This means that braces have *two* meanings in JavaScript. At the start of a
    statement, they begin a block of statements. In any other position, they describe
    an object. Fortunately, it is rarely useful to start a statement with an object
    in braces, so the ambiguity between these two is not much of a problem. The one
    case where this does come up is when you want to return an object from a shorthand
    arrow function—you can’t write n => {prop: n}, since the braces will be interpreted
    as a function body. Instead, you have to put a set of parentheses around the object
    to make it clear that it is an expression.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '这意味着花括号在 JavaScript 中有 *两* 种含义。在语句的开始，它们开始一个语句块。在其他位置，它们描述一个对象。幸运的是，几乎没有必要在语句开头使用花括号中的对象，因此这两者之间的歧义并不是问题。唯一的例外是，当你想从简写箭头函数中返回一个对象时——你不能写
    n => {prop: n}，因为花括号会被解释为函数体。相反，你必须在对象周围加一组括号，以明确它是一个表达式。'
- en: Reading a property that doesn’t exist will give you the value undefined.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 读取一个不存在的属性将返回值 undefined。
- en: It is possible to assign a value to a property expression with the = operator.
    This will replace the property’s value if it already existed or create a new property
    on the object if it didn’t.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 = 运算符将值分配给属性表达式。如果属性已存在，这将替换该属性的值；如果不存在，则在对象上创建一个新属性。
- en: To briefly return to our tentacle model of bindings—property bindings are similar.
    They *grasp* values, but other bindings and properties might be holding onto those
    same values. You can think of objects as octopuses with any number of tentacles,
    each of which has a name written on it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简要回到我们的触手绑定模型——属性绑定是类似的。它们*抓取*值，但其他绑定和属性可能会握住那些相同的值。你可以将对象视为具有任意数量触手的章鱼，每个触手上都有一个名字。
- en: The delete operator cuts off a tentacle from such an octopus. It is a unary
    operator that, when applied to an object property, will remove the named property
    from the object. This is not a common thing to do, but it is possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: delete 运算符就像切断章鱼的触手。它是一个一元运算符，当应用于对象属性时，会从对象中移除指定属性。这并不是常见的操作，但它是可能的。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The binary in operator, when applied to a string and an object, tells you whether
    that object has a property with that name. The difference between setting a property
    to undefined and actually deleting it is that in the first case, the object still
    *has* the property (it just doesn’t have a very interesting value), whereas in
    the second case, the property is no longer present and in will return false.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 二元的 in 运算符，当应用于字符串和对象时，会告诉你该对象是否具有该名称的属性。将属性设置为 undefined 和实际删除它之间的区别在于，在第一种情况下，对象仍然*拥有*该属性（它只是不具有非常有趣的值），而在第二种情况下，该属性不再存在，因此返回
    false。
- en: To find out what properties an object has, you can use the Object.keys function.
    Give the function an object and it will return an array of strings— the object’s
    property names.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出一个对象有哪些属性，可以使用 Object.keys 函数。给这个函数一个对象，它将返回一个字符串数组——对象的属性名称。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There’s an Object.assign function that copies all properties from one object
    into another.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 Object.assign 函数，可以将一个对象的所有属性复制到另一个对象中。
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Arrays, then, are just a kind of object specialized for storing sequences of
    things. If you evaluate typeof [], it produces “object”. You can visualize arrays
    as long, flat octopuses with all their tentacles in a neat row, labeled with numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 数组本质上是一种专门用于存储事物序列的对象。如果你评估 typeof []，它会返回“object”。你可以将数组视为长长的、扁平的章鱼，所有的触手整齐排列，标记上数字。
- en: Jacques will represent the journal that he keeps as an array of objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 雅克将他保持的日记表示为对象数组。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Mutability
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变性
- en: We will get to actual programming soon, but first, there’s one more piece of
    theory to understand.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会进入实际编程，但首先，还有一个理论部分需要理解。
- en: We saw that object values can be modified. The types of values discussed in
    earlier chapters, such as numbers, strings, and Booleans, are all *immutable*—
    it is impossible to change values of those types. You can combine them and derive
    new values from them, but when you take a specific string value, that value will
    always remain the same. The text inside it cannot be changed. If you have a string
    that contains “cat”, it is not possible for other code to change a character in
    your string to make it spell “rat”.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到对象值是可以修改的。前几章讨论的值类型，如数字、字符串和布尔值，都是*不可变的*——无法更改这些类型的值。你可以将它们组合并推导出新值，但当你获得一个特定的字符串值时，该值将始终保持不变。它内部的文本无法更改。如果你有一个包含“cat”的字符串，其他代码无法更改你的字符串中的某个字符使其拼成“rat”。
- en: Objects work differently. You *can* change their properties, causing a single
    object value to have different content at different times.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的工作方式不同。你*可以*更改它们的属性，导致同一个对象值在不同时间具有不同的内容。
- en: 'When we have two numbers, 120 and 120, we can consider them precisely the same
    number, whether or not they refer to the same physical bits. With objects, there
    is a difference between having two references to the same object and having two
    different objects that contain the same properties. Consider the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有两个数字，120 和 120 时，我们可以将它们视为完全相同的数字，无论它们是否引用相同的物理位。对于对象来说，拥有对同一对象的两个引用与拥有两个不同的对象（它们包含相同的属性）之间是有区别的。考虑以下代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The object1 and object2 bindings grasp the *same* object, which is why changing
    object1 also changes the value of object2. They are said to have the same *identity*.
    The binding object3 points to a different object, which initially contains the
    same properties as object1 but lives a separate life.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: object1 和 object2 绑定指向 *同一个* 对象，这就是为什么更改 object1 也会更改 object2 的值。它们被称为具有相同的
    *身份*。绑定 object3 指向一个不同的对象，最初包含与 object1 相同的属性，但过着独立的生活。
- en: Bindings can also be changeable or constant, but this is separate from the way
    their values behave. Even though number values don’t change, you can use a let
    binding to keep track of a changing number by changing the value at which the
    binding points. Similarly, though a const binding to an object can itself not
    be changed and will continue to point at the same object, the *contents* of that
    object might change.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定可以是可变的或常量的，但这与它们的值的行为是分开的。尽管数字值不会改变，你可以使用 let 绑定来跟踪一个通过改变绑定指向的值而变化的数字。同样，尽管
    const 绑定的对象本身无法更改并将继续指向同一对象，但该对象的 *内容* 可能会发生变化。
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you compare objects with JavaScript’s == operator, it compares by identity:
    it will produce true only if both objects are precisely the same value. Comparing
    different objects will return false, even if they have identical properties. There
    is no “deep” comparison operation built into Java-Script that compares objects
    by contents, but it is possible to write it yourself (which is one of the exercises
    at the end of this chapter).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 JavaScript 的 == 运算符比较对象时，它按身份进行比较：只有当两个对象的值完全相同时，它才会返回 true。比较不同的对象将返回
    false，即使它们具有相同的属性。JavaScript 中没有内置的“深度”比较操作，可以按内容比较对象，但你可以自己编写这个操作（这也是本章末尾的一个练习）。
- en: The Lycanthrope’s Log
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 《狼人日志》
- en: Jacques starts up his JavaScript interpreter and sets up the environment he
    needs to keep his journal.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 雅克启动了他的 JavaScript 解释器，并设置了他记录日记所需的环境。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the object added to the journal looks a little odd. Instead of declaring
    properties like events: events, it just gives a property name: events. This is
    shorthand that means the same thing—if a property name in brace notation isn’t
    followed by a value, its value is taken from the binding with the same name.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，添加到日记中的对象看起来有点奇怪。它不是像 events: events 这样声明属性，而只是给出了一个属性名称：events。这是一种简写方式，意思是相同的——如果大括号表示法中的属性名称后面没有值，则它的值来自同名的绑定。'
- en: Every evening at 10 PM—or sometimes the next morning, after climbing down from
    the top shelf of his bookcase—Jacques records the day.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每天晚上 10 点——有时是第二天早晨，从书架的顶层下来的时候——雅克会记录当天的事情。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once he has enough data points, he intends to use statistics to find out which
    of these events may be related to the squirrelifications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他收集到足够的数据点，他打算利用统计学找出哪些事件可能与松鼠化相关。
- en: '*Correlation* is a measure of dependence between statistical variables. A statistical
    variable is not quite the same as a programming variable. In statistics you typically
    have a set of *measurements*, and each variable is measured for every measurement.
    Correlation between variables is usually expressed as a value that ranges from
    –1 to 1\. Zero correlation means the variables are not related. A correlation
    of 1 indicates that the two are perfectly related—if you know one, you also know
    the other. Negative 1 also means that the variables are perfectly related but
    are opposites—when one is true, the other is false.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*相关性* 是统计变量之间依赖关系的度量。统计变量与编程变量并不完全相同。在统计学中，通常有一组 *测量值*，每个变量针对每个测量值进行测量。变量之间的相关性通常以一个介于
    –1 和 1 之间的值表示。零相关性意味着变量之间没有关系。相关性为 1 表示两者完全相关——如果你知道一个，你也知道另一个。负 1 也意味着变量之间完全相关，但它们是相反的——当一个为真时，另一个为假。'
- en: To compute the measure of correlation between two Boolean variables, we can
    use the *phi coefficient* (*φ*). This is a formula whose input is a frequency
    table containing the number of times the different combinations of the variables
    were observed. The output of the formula is a number between –1 and 1 that describes
    the correlation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算两个布尔变量之间的相关性度量，我们可以使用 *phi 系数* (*φ*)。这是一个公式，其输入是一个频率表，包含不同变量组合被观察到的次数。公式的输出是一个介于
    –1 和 1 之间的数字，用于描述相关性。
- en: We could take the event of eating pizza and put that in a frequency table like
    this, where each number indicates the number of times that combination occurred
    in our measurements.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将吃披萨的事件放入一个频率表中，每个数字表示这种组合在我们的测量中出现的次数。
- en: '![Image](../images/f0065-01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0065-01.jpg)'
- en: 'If we call that table *n*, we can compute *φ* using the following formula:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们称该表为 *n*，我们可以使用以下公式计算 *φ*：
- en: '![Image](../images/f0065-02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0065-02.jpg)'
- en: (If at this point you’re putting the book down to focus on a terrible flash-back
    to 10th grade math class—hold on! I do not intend to torture you with endless
    pages of cryptic notation—it’s just this one formula for now. And even with this
    one, all we do is turn it into JavaScript.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: （如果在这一点上你放下书本，专注于对十年级数学课的可怕回忆——等等！我并不打算用无尽的神秘符号折磨你——现在就只有这个公式。即便如此，我们所做的只是把它转化为
    JavaScript。）
- en: The notation *n*[01] indicates the number of measurements where the first variable
    (squirrelness) is false (0) and the second variable (pizza) is true (1). In the
    pizza table, *n*[01] is 9.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表示法 *n*[01] 表示测量次数，其中第一个变量（松鼠性）为假（0），第二个变量（披萨）为真（1）。在披萨表中，*n*[01] 是 9。
- en: The value *n*[1*•*] refers to the sum of all measurements where the first variable
    is true, which is 5 in the example table. Likewise, *n*[•0] refers to the sum
    of the measurements where the second variable is false.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值 *n*[1*•*] 指的是第一个变量为真时所有测量的总和，在示例表中是 5。同样，*n*[•0] 指的是第二个变量为假时的测量总和。
- en: So for the pizza table, the part above the division line (the dividend) would
    be 1 *×* 76 − 4 *×* 9 = 40, and the part below it (the divisor) would be the square
    root of 5 *×* 85 *×* 10 *×* 80, or ![Image](../images/f0065-03.jpg). This comes
    out to *φ ≈* 0.069, which is tiny. Eating pizza does not appear to have influence
    on the transformations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所以对于披萨表，分割线以上的部分（被除数）是 1 *×* 76 − 4 *×* 9 = 40，而以下的部分（除数）是 5 *×* 85 *×* 10 *×*
    80 的平方根，或者 ![Image](../images/f0065-03.jpg)。结果是 *φ ≈* 0.069，这个值很小。吃披萨似乎对变换没有影响。
- en: Computing Correlation
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算相关性
- en: We can represent a two-by-two table in JavaScript with a four-element array
    ([76, 9, 4, 1]). We could also use other representations, such as an array containing
    two two-element arrays ([[76, 9], [4, 1]]) or an object with property names like
    “11” and “01”, but the flat array is simple and makes the expressions that access
    the table pleasantly short. We’ll interpret the indices to the array as two-bit
    binary numbers, where the leftmost (most significant) digit refers to the squirrel
    variable and the rightmost (least significant) digit refers to the event variable.
    For example, the binary number 10 refers to the case where Jacques did turn into
    a squirrel, but the event (say, “pizza”) didn’t occur. This happened four times.
    And since binary 10 is 2 in decimal notation, we will store this number at index
    2 of the array.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个四元素数组在 JavaScript 中表示一个二乘二表（[76, 9, 4, 1]）。我们也可以使用其他表示方式，例如包含两个二元素数组的数组
    ([[76, 9], [4, 1]])，或者属性名为 “11” 和 “01” 的对象，但平面数组简单且访问表的表达式简洁明了。我们将数组的索引解释为两位二进制数，其中最左边（最重要）的数字指的是松鼠变量，最右边（最不重要）的数字指的是事件变量。例如，二进制数
    10 指的是 Jacques 变成松鼠但事件（比如“披萨”）没有发生的情况。这种情况发生了四次。由于二进制 10 在十进制中是 2，因此我们将在数组的索引
    2 存储这个数字。
- en: 'This is the function that computes the *φ* coefficient from such an array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算此类数组中 *φ* 系数的函数：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a direct translation of the *φ* formula into JavaScript. Math.sqrt is
    the square root function, as provided by the Math object in a standard Java-Script
    environment. We have to add two fields from the table to get fields like *n*[1*•*]
    because the sums of rows or columns are not stored directly in our data structure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 *φ* 公式直接转化为 JavaScript 的形式。Math.sqrt 是平方根函数，由标准 JavaScript 环境中的 Math 对象提供。我们必须从表中添加两个字段以获取
    *n*[1*•*] 这样的字段，因为行或列的总和并没有直接存储在我们的数据结构中。
- en: Jacques keeps his journal for three months. The resulting dataset is available
    in the coding sandbox for this chapter (*[https://eloquentjavascript.net/code#4](https://eloquentjavascript.net/code#4)*),
    where it is stored in the JOURNAL binding, and in a downloadable file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Jacques 记录他的日记三个月。生成的数据集可以在本章的编码沙盒中找到 (*[https://eloquentjavascript.net/code#4](https://eloquentjavascript.net/code#4)*），存储在
    JOURNAL 绑定中，并且可以下载。
- en: To extract a two-by-two table for a specific event from the journal, we must
    loop over all the entries and tally how many times the event occurs in relation
    to squirrel transformations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要从日志中提取特定事件的二维表格，我们必须遍历所有条目，并统计该事件与松鼠变身相关的出现次数。
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Arrays have an includes method that checks whether a given value exists in the
    array. The function uses that to determine whether the event name it is interested
    in is part of the event list for a given day.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有一个 includes 方法，可以检查给定值是否存在于数组中。该函数利用这个方法来判断它感兴趣的事件名称是否属于某一天的事件列表。
- en: The body of the loop in tableFor figures out which box in the table each journal
    entry falls into by checking whether the entry contains the specific event it’s
    interested in and whether the event happens alongside a squirrel incident. The
    loop then adds one to the correct box in the table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: tableFor 循环的主体通过检查每个日志条目是否包含感兴趣的特定事件，以及该事件是否发生在与松鼠事件同时，来确定每个日志条目对应表格中的哪个框。然后，循环会将
    1 加到表格中的正确框内。
- en: We now have the tools we need to compute individual correlations. The only step
    remaining is to find a correlation for every type of event that was recorded and
    see whether anything stands out.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有计算个别相关性的工具。剩下的唯一一步是为记录的每种事件类型找到相关性，并查看是否有什么特别之处。
- en: Array Loops
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组循环
- en: 'In the tableFor function, there’s a loop like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 tableFor 函数中，有一个这样的循环：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This kind of loop is common in classical JavaScript—going over arrays one element
    at a time is something that comes up a lot, and to do that you’d run a counter
    over the length of the array and pick out each element in turn.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环在经典 JavaScript 中很常见——逐个遍历数组元素是一种常见操作，为此，你需要在数组的长度上运行一个计数器，并依次挑选出每个元素。
- en: There is a simpler way to write such loops in modern JavaScript.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 JavaScript 中，有一种更简单的方法来编写这样的循环。
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When a for loop uses the word of after its variable definition, it will loop
    over the elements of the value given after of. This works not only for arrays
    but also for strings and some other data structures. We’ll discuss *how* it works
    in [Chapter 6](ch06.xhtml#ch06).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 for 循环在变量定义后使用 of 这个词时，它将遍历在 of 后面给出的值中的元素。这不仅适用于数组，也适用于字符串和其他一些数据结构。我们将在[第六章](ch06.xhtml#ch06)中讨论*它是如何工作的*。
- en: The Final Analysis
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终分析
- en: We need to compute a correlation for every type of event that occurs in the
    dataset. To do that, we first need to *find* every type of event.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为数据集中发生的每种事件类型计算相关性。为此，我们首先需要*找到*每种事件类型。
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By adding any event names that aren’t already in it to the events array, the
    function collects every type of event.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将任何不在其中的事件名称添加到事件数组中，该函数收集每种类型的事件。
- en: Using that function, we can see all the correlations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用那个函数，我们可以看到所有的相关性。
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Most correlations seem to lie close to zero. Eating carrots, bread, or pudding
    apparently does not trigger squirrel-lycanthropy. The transformations *do* seem
    to occur somewhat more often on weekends. Let’s filter the results to show only
    correlations greater than 0.1 or less than –0.1.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数相关性似乎接近零。吃胡萝卜、面包或布丁显然不会引发松鼠变身。变身*似乎*在周末更常发生。让我们过滤结果，只显示相关性大于 0.1 或小于 -0.1
    的情况。
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Aha! There are two factors with a correlation clearly stronger than the others.
    Eating peanuts has a strong positive effect on the chance of turning into a squirrel,
    whereas brushing teeth has a significant negative effect.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！有两个因素的相关性明显强于其他因素。吃花生对变成松鼠的几率有很强的正面影响，而刷牙则有显著的负面影响。
- en: 'Interesting. Let’s try something:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣。让我们试试：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s a strong result. The phenomenon occurs precisely when Jacques eats peanuts
    and fails to brush his teeth. If only he weren’t such a slob about dental hygiene,
    he’d never even have noticed his affliction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强烈的结果。这种现象恰恰发生在雅克吃花生而没刷牙的时候。如果他在牙齿卫生方面不是如此邋遢，他甚至可能不会注意到自己的病症。
- en: Knowing this, Jacques stops eating peanuts altogether and finds that his transformations
    stop.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点后，雅克完全不再吃花生，发现他的变身停止了。
- en: But it takes only a few months for him to notice that something is missing from
    this entirely human way of living. Without his feral adventures, Jacques hardly
    feels alive at all. He decides he’d rather be a full-time wild animal. After building
    a beautiful little tree house in the forest and equipping it with a peanut butter
    dispenser and a ten-year supply of peanut butter, he changes form one last time
    and lives the short and energetic life of a squirrel.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 但他只花了几个月就注意到，这种完全人类的生活方式缺少了一些东西。没有他的野外冒险，雅克几乎感觉不到生命的存在。他决定宁愿成为一只全职的野生动物。在森林中建造一个漂亮的小树屋，并配备一个花生酱分配器和十年的花生酱供应后，他最后一次改变形态，过上了短暂而充满活力的松鼠生活。
- en: Further Arrayology
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入数组学
- en: Before finishing the chapter, I want to introduce you to a few more object-related
    concepts. I’ll start with some generally useful array methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，我想向你介绍几个与对象相关的概念。我将从一些普遍有用的数组方法开始。
- en: We saw push and pop, which add and remove elements at the end of an array, earlier
    in this chapter. The corresponding methods for adding and removing things at the
    start of an array are called unshift and shift.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章早些时候看到了`push`和`pop`，它们分别在数组的末尾添加和移除元素。对应于在数组开头添加和移除元素的方法称为`unshift`和`shift`。
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This program manages a queue of tasks. You add tasks to the end of the queue
    by calling remember(“groceries”), and when you’re ready to do something, you call
    getTask() to get (and remove) the front item from the queue. The rememberUrgently
    function also adds a task but adds it to the front instead of the back of the
    queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序管理一个任务队列。你通过调用`remember("groceries")`将任务添加到队列的末尾，当你准备好执行某个任务时，你可以调用`getTask()`从队列中获取（并移除）最前面的项目。`rememberUrgently`函数也添加一个任务，但它将任务添加到队列的前面，而不是后面。
- en: To search for a specific value, arrays provide an indexOf method. The method
    searches through the array from the start to the end and returns the index at
    which the requested value was found—or –1 if it wasn’t found. To search from the
    end instead of the start, there’s a similar method called lastIndexOf.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要搜索特定值，数组提供了`indexOf`方法。该方法从数组的开始到结束进行搜索，并返回请求值找到时的索引——如果未找到则返回-1。要从末尾而不是从开头进行搜索，还有一个类似的方法叫做`lastIndexOf`。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both indexOf and lastIndexOf take an optional second argument that indicates
    where to start searching.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`和`lastIndexOf`都接受一个可选的第二个参数，用于指示从哪里开始搜索。'
- en: Another fundamental array method is slice, which takes start and end indices
    and returns an array that has only the elements between them. The start index
    is inclusive and the end index is exclusive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个基本的数组方法是`slice`，它接受起始和结束索引，并返回一个只包含它们之间元素的数组。起始索引是包含的，结束索引是不包含的。
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the end index is not given, slice will take all of the elements after the
    start index. You can also omit the start index to copy the entire array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有提供结束索引时，切片将获取起始索引之后的所有元素。你也可以省略起始索引，以复制整个数组。
- en: The concat method can be used to append arrays together to create a new array,
    similar to what the + operator does for strings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat`方法可用于将数组连接在一起，以创建一个新的数组，这与`+`运算符对字符串的作用类似。'
- en: The following example shows both concat and slice in action. It takes an array
    and an index and returns a new array that is a copy of the original array with
    the element at the given index removed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了`concat`和`slice`的实际应用。它接受一个数组和一个索引，并返回一个新的数组，该数组是原始数组的副本，给定索引处的元素被移除。
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you pass concat an argument that is not an array, that value will be added
    to the new array as if it were a one-element array.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向`concat`传递一个不是数组的参数，该值将被当作一个单元素数组添加到新数组中。
- en: Strings and Their Properties
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串及其属性
- en: We can read properties like length and toUpperCase from string values. But if
    we try to add a new property, it doesn’t stick.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从字符串值中读取像`length`和`toUpperCase`这样的属性。但是如果我们尝试添加一个新属性，它不会生效。
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Values of type string, number, and Boolean are not objects, and though the language
    doesn’t complain if you try to set new properties on them, it doesn’t actually
    store those properties. As mentioned earlier, such values are immutable and cannot
    be changed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串、数字和布尔值的值不是对象，尽管语言不会抱怨你尝试在它们上设置新属性，但实际上并不会存储这些属性。如前所述，这些值是不可变的，无法更改。
- en: But these types do have built-in properties. Every string value has a number
    of methods. Some very useful ones are slice and indexOf, which resemble the array
    methods of the same name.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些类型确实有内置属性。每个字符串值都有许多方法。一些非常有用的方法是`slice`和`indexOf`，它们与数组的同名方法类似。
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One difference is that a string’s indexOf can search for a string containing
    more than one character, whereas the corresponding array method looks only for
    a single element.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不同之处在于字符串的indexOf可以搜索包含多个字符的字符串，而对应的数组方法仅查找单个元素。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The trim method removes whitespace (spaces, newlines, tabs, and similar characters)
    from the start and end of a string.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: trim方法从字符串的开始和结束移除空白字符（空格、换行符、制表符及类似字符）。
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The zeroPad function from the previous chapter also exists as a method. It is
    called padStart and takes the desired length and padding character as arguments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的zeroPad函数也作为一个方法存在。它被称为padStart，并接受所需的长度和填充字符作为参数。
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can split a string on every occurrence of another string with split and
    join it again with join.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`split`在每个出现的另一个字符串上拆分一个字符串，然后用`join`再次连接它。
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A string can be repeated with the repeat method, which creates a new string
    containing multiple copies of the original string, glued together.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可以通过repeat方法重复，它创建一个包含多个原始字符串副本的新字符串，将它们粘合在一起。
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have already seen the string type’s length property. Accessing the individual
    characters in a string looks like accessing array elements (with a complication
    that we’ll discuss in [Chapter 5](ch05.xhtml#ch05)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到字符串类型的长度属性。访问字符串中的单个字符看起来就像访问数组元素（有一个复杂性，我们将在[第5章](ch05.xhtml#ch05)中讨论）。
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Rest Parameters
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩余参数
- en: 'It can be useful for a function to accept any number of arguments. For example,
    Math.max computes the maximum of *all* the arguments it is given. To write such
    a function, you put three dots before the function’s last parameter, like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数接受任意数量的参数是非常有用的。例如，Math.max计算它所给的*所有*参数中的最大值。要编写这样的函数，你在函数最后一个参数前加上三个点，如下所示：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When such a function is called, the *rest parameter* is bound to an array containing
    all further arguments. If there are other parameters before it, their values aren’t
    part of that array. When, as in max, it is the only parameter, it will hold all
    arguments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用这样的函数时，*剩余参数*被绑定到一个包含所有后续参数的数组。如果它之前有其他参数，它们的值不属于那个数组。当它像max一样是唯一的参数时，它将包含所有参数。
- en: You can use a similar three-dot notation to *call* a function with an array
    of arguments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的三个点符号来*调用*一个带有参数数组的函数。
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This “spreads” out the array into the function call, passing its elements as
    separate arguments. It is possible to include an array like that along with other
    arguments, as in max(9, ...numbers, 2).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将数组“展开”到函数调用中，将其元素作为单独的参数传递。可以将这样的数组与其他参数一起包含，例如max(9, ...numbers, 2)。
- en: Square bracket array notation similarly allows the triple-dot operator to spread
    another array into the new array.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号数组符号同样允许三点操作符将另一个数组展开到新数组中。
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This works even in curly brace objects, where it adds all properties from another
    object. If a property is added multiple times, the last value to be added wins.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这在花括号对象中也有效，它将另一个对象的所有属性添加进来。如果一个属性被多次添加，最后添加的值将胜出。
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Math Object
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Math对象
- en: As we’ve seen, Math is a grab bag of number-related utility functions such as
    Math.max (maximum), Math.min (minimum), and Math.sqrt (square root).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Math是一个包含数字相关实用函数的集合，例如Math.max（最大值）、Math.min（最小值）和Math.sqrt（平方根）。
- en: The Math object is used as a container to group a bunch of related functionality.
    There is only one Math object, and it is almost never useful as a value. Rather,
    it provides a *namespace* so that all these functions and values do not have to
    be global bindings.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Math对象被用作一个容器，以分组一堆相关的功能。只有一个Math对象，它几乎从来没有作为一个值有用。相反，它提供了一个*命名空间*，使所有这些函数和值不必是全局绑定。
- en: Having too many global bindings “pollutes” the namespace. The more names have
    been taken, the more likely you are to accidentally overwrite the value of some
    existing binding. For example, it’s not unlikely you’ll want to name something
    max in one of your programs. Since JavaScript’s built-in max function is tucked
    safely inside the Math object, you don’t have to worry about overwriting it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 过多的全局绑定会“污染”命名空间。被占用的名称越多，你越可能意外覆盖某些现有绑定的值。例如，在你的某个程序中，你可能会想将某个东西命名为max。由于JavaScript内置的max函数安全地嵌套在Math对象中，你不必担心覆盖它。
- en: Many languages will stop you, or at least warn you, when you are defining a
    binding with a name that is already taken. JavaScript does this for bindings you
    declared with let or const but—perversely—not for standard bindings nor for bindings
    declared with var or function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言会阻止你，或者至少会警告你，当你定义一个已经被占用的名称的绑定时。JavaScript 对使用 let 或 const 声明的绑定这样做，但——反而——对标准绑定或使用
    var 或 function 声明的绑定不这样做。
- en: Back to the Math object. If you need to do trigonometry, Math can help. It contains
    cos (cosine), sin (sine), and tan (tangent), as well as their inverse functions,
    acos, asin, and atan, respectively. The number *π* (pi)—or at least the closest
    approximation that fits in a JavaScript number—is available as Math.PI. There
    is an old programming tradition of writing the names of constant values in all
    caps.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Math 对象。如果你需要进行三角函数运算，Math 可以提供帮助。它包含 cos（余弦）、sin（正弦）和 tan（正切），以及它们的反函数 acos、asin
    和 atan。数字 *π*（圆周率）—或者至少是适合 JavaScript 数字的最接近的近似值—可以通过 Math.PI 获取。旧有的编程传统是将常量的名称全部用大写字母书写。
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you’re not familiar with sines and cosines, don’t worry. I’ll explain them
    when they are used in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对正弦和余弦不熟悉，别担心。我会在[第14章](ch14.xhtml#ch14)中解释它们的用法。
- en: The previous example used Math.random. This is a function that returns a new
    pseudorandom number between 0 (inclusive) and 1 (exclusive) every time you call
    it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个例子使用了 Math.random。这是一个每次调用都会返回一个在 0（包含）和 1（不包含）之间的新伪随机数的函数。
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Though computers are deterministic machines—they always react the same way if
    given the same input—it is possible to have them produce numbers that appear random.
    To do that, the machine keeps some hidden value, and whenever you ask for a new
    random number, it performs complicated computations on this hidden value to create
    a new value. It stores a new value and returns some number derived from it. That
    way, it can produce ever new, hard-to-predict numbers in a way that *seems* random.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管计算机是确定性的机器——如果给定相同的输入，它们总是以相同的方式反应——但它们可以生成看似随机的数字。为此，计算机保持一些隐藏值，每当你请求一个新的随机数时，它会对这个隐藏值进行复杂的计算以生成新值。它存储一个新值并返回从中派生出的某个数字。这样，它就可以以*看似*随机的方式生成不断新的、难以预测的数字。
- en: If we want a whole random number instead of a fractional one, we can use Math.floor
    (which rounds down to the nearest whole number) on the result of Math.random.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个整数随机数而不是小数，我们可以对 Math.random 的结果使用 Math.floor（向下舍入到最接近的整数）。
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Multiplying the random number by 10 gives us a number greater than or equal
    to 0 and below 10\. Since Math.floor rounds down, this expression will produce,
    with equal chance, any number from 0 through 9.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将随机数乘以 10 会得到一个大于或等于 0 并且小于 10 的数字。由于 Math.floor 向下舍入，这个表达式将以相等的概率生成 0 到 9 之间的任何数字。
- en: There are also the functions Math.ceil (for “ceiling,” which rounds up to a
    whole number), Math.round (to the nearest whole number), and Math.abs, which takes
    the absolute value of a number, meaning it negates negative values but leaves
    positive ones as they are.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些函数，如 Math.ceil（“向上取整”，将数字向上舍入到最接近的整数）、Math.round（舍入到最接近的整数）和 Math.abs，它返回一个数的绝对值，这意味着它将负值取反，但保持正值不变。
- en: Destructuring
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解构
- en: Let’s return to the phi function for a moment.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回到 phi 函数。
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: One reason this function is awkward to read is that we have a binding pointing
    at our array, but we’d much prefer to have bindings for the *elements* of the
    array—that is, let n00 = table[0] and so on. Fortunately, there is a succinct
    way to do this in JavaScript.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数难以阅读的一个原因是我们有一个指向数组的绑定，但我们更希望有指向数组*元素*的绑定——也就是说， let n00 = table[0] 等等。幸运的是，JavaScript
    中有一种简洁的方法可以做到这一点。
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This also works for bindings created with let, var, or const. If you know that
    the value you are binding is an array, you can use square brackets to “look inside”
    of the value, binding its contents.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于使用 let、var 或 const 创建的绑定同样有效。如果你知道你正在绑定的值是一个数组，你可以使用方括号“查看”该值的内部，绑定其内容。
- en: A similar trick works for objects, using braces instead of square brackets.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象，可以使用花括号而不是方括号进行类似的操作。
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that if you try to destructure null or undefined, you get an error, much
    as you would if you directly try to access a property of those values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你尝试解构 null 或 undefined，你会得到一个错误，就像你直接尝试访问这些值的属性时一样。
- en: Optional Property Access
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选属性访问
- en: 'When you aren’t sure whether a given value produces an object, but still want
    to read a property from it when it does, you can use a variant of the dot notation:
    object?.property.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不确定某个值是否会生成对象，但仍然希望在它确实生成对象时读取其属性时，可以使用一种点表示法的变体：object?.property。
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The expression a?.b means the same as a.b when a isn’t null or undefined. When
    it is, it evaluates to undefined. This can be convenient when, as in the example,
    you aren’t sure that a given property exists or when a variable might hold an
    undefined value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式a?.b与a.b的意思相同，前提是a不为null或undefined。当它为null或undefined时，则评估为undefined。这在像示例中不确定某个属性是否存在或某个变量可能持有undefined值时是非常方便的。
- en: A similar notation can be used with square bracket access, and even with function
    calls, by putting ?. in front of the parentheses or brackets.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的表示法可以与方括号访问结合使用，甚至可以通过在括号或方括号前放置?.来使用函数调用。
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: JSON
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON
- en: Because properties grasp their value rather than contain it, objects and arrays
    are stored in the computer’s memory as sequences of bits holding the *addresses*—the
    place in memory—of their contents. An array with another array inside of it consists
    of (at least) one memory region for the inner array and another for the outer
    array, containing (among other things) a number that represents the address of
    the inner array.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于属性抓取其值而不是包含它，因此对象和数组在计算机内存中以持有*地址*（内存中的位置）的比特序列存储。一个包含另一个数组的数组至少由一个内存区域用于内部数组，另一个内存区域用于外部数组，后者包含（除了其他内容）表示内部数组地址的数字。
- en: If you want to save data in a file for later or send it to another computer
    over the network, you have to somehow convert these tangles of memory addresses
    to a description that can be stored or sent. You *could* send over your entire
    computer memory along with the address of the value you’re interested in, I suppose,
    but that doesn’t seem like the best approach.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将数据保存到文件中以备后用或通过网络发送到另一台计算机，你必须以某种方式将这些内存地址的纠结转换为可以存储或发送的描述。我想你*可以*连同你感兴趣的值的地址一起发送整个计算机内存，但这似乎不是最佳方法。
- en: What we can do is *serialize* the data. That means it is converted into a flat
    description. A popular serialization format is called *JSON* (pronounced “Jason”),
    which stands for JavaScript Object Notation. It is widely used as a data storage
    and communication format on the web, even with languages other than JavaScript.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的是*序列化*数据。这意味着它被转换为一种扁平描述。一种流行的序列化格式称为*JSON*（发音为“杰森”），代表JavaScript对象表示法。它在网络上广泛用作数据存储和通信格式，甚至在JavaScript以外的语言中也使用。
- en: JSON looks similar to JavaScript’s way of writing arrays and objects, with a
    few restrictions. All property names have to be surrounded by double quotes, and
    only simple data expressions are allowed—no function calls, bindings, or anything
    that involves actual computation. Comments are not allowed in JSON.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的书写方式与JavaScript的数组和对象相似，但有一些限制。所有属性名称必须用双引号括起来，且仅允许简单的数据表达式——不允许函数调用、绑定或涉及实际计算的内容。JSON中不允许注释。
- en: 'A journal entry might look like this when represented as JSON data:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 日志条目在作为JSON数据表示时可能看起来像这样：
- en: '[PRE46]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: JavaScript gives us the functions JSON.stringify and JSON.parse to convert data
    to and from this format. The first takes a JavaScript value and returns a JSON-encoded
    string. The second takes such a string and converts it to the value it encodes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了JSON.stringify和JSON.parse函数，用于在这种格式之间转换数据。第一个函数接受一个JavaScript值并返回一个JSON编码的字符串。第二个函数接受这样的字符串并将其转换为它编码的值。
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Objects and arrays provide ways to group several values into a single value.
    This allows us to put a bunch of related things in a bag and run around with the
    bag instead of wrapping our arms around all of the individual things and trying
    to hold on to them separately.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对象和数组提供了将多个值组合为单个值的方法。这允许我们将一堆相关的事物放入一个袋子中，然后拿着袋子四处走，而不是试图单独抱住所有个别事物。
- en: Most values in JavaScript have properties, with the exceptions being null and
    undefined. Properties are accessed using value.prop or value[“prop”]. Objects
    tend to use names for their properties and store more or less a fixed set of them.
    Arrays, on the other hand, usually contain varying amounts of conceptually identical
    values and use numbers (starting from 0) as the names of their properties.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JavaScript值都有属性，唯一的例外是null和undefined。属性通过value.prop或value[“prop”]来访问。对象通常使用名称作为其属性，并存储一组或多组固定的属性。而数组则通常包含数量不等的概念上相同的值，并使用数字（从0开始）作为其属性的名称。
- en: There *are* some named properties in arrays, such as length and a number of
    methods. Methods are functions that live in properties and (usually) act on the
    value of which they are a property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中*确实*有一些命名属性，例如length和一些方法。方法是存在于属性中的函数，并且（通常）对其属性的值进行操作。
- en: 'You can iterate over arrays using a special kind of for loop: for (let *element*
    of *array*).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一种特殊的for循环遍历数组：for (let *element* of *array*)。
- en: Exercises
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*The Sum of a Range*'
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*范围的总和*'
- en: 'The introduction of this book alluded to the following as a nice way to compute
    the sum of a range of numbers:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的引言提到以下内容作为计算一系列数字总和的好方法：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Write a range function that takes two arguments, start and end, and returns
    an array containing all the numbers from start up to and including end.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个范围函数，该函数接受两个参数，start和end，并返回一个包含从start到包括end的所有数字的数组。
- en: Next, write a sum function that takes an array of numbers and returns the sum
    of these numbers. Run the example program and see whether it does indeed return
    55.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一个sum函数，接受一个数字数组并返回这些数字的总和。运行示例程序，查看它是否确实返回55。
- en: As a bonus assignment, modify your range function to take an optional third
    argument that indicates the “step” value used when building the array. If no step
    is given, the elements should go up by increments of one, corresponding to the
    old behavior. The function call range(1, 10, 2) should return [1, 3, 5, 7, 9].
    Make sure this also works with negative step values so that range(5, 2, -1) produces
    [5, 4, 3, 2].
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外作业，修改你的范围函数，使其接受一个可选的第三个参数，指示构建数组时使用的“步长”值。如果未给出步长，元素应该以1的增量增加，对应于旧行为。函数调用range(1,
    10, 2)应该返回[1, 3, 5, 7, 9]。确保这也适用于负步长值，以便range(5, 2, -1)生成[5, 4, 3, 2]。
- en: '*Reversing an Array*'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*反转数组*'
- en: 'Arrays have a reverse method that changes the array by inverting the order
    in which its elements appear. For this exercise, write two functions, reverseArray
    and reverseArrayInPlace. The first, reverseArray, should take an array as its
    argument and produce a *new* array that has the same elements in the inverse order.
    The second, reverseArrayInPlace, should do what the reverse method does: *modify*
    the array given as its argument by reversing its elements. Neither may use the
    standard reverse method.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有一个反转方法，通过反转元素出现的顺序来改变数组。对于这个练习，请编写两个函数：reverseArray和reverseArrayInPlace。第一个reverseArray应该以数组作为参数，并生成一个*新的*数组，包含相同元素但顺序相反。第二个reverseArrayInPlace应该执行反转方法所做的事情：*修改*作为参数传入的数组，反转其元素。两者均不得使用标准反转方法。
- en: Thinking back to the notes about side effects and pure functions in the previous
    chapter, which variant do you expect to be useful in more situations? Which one
    runs faster?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下前一章关于副作用和纯函数的笔记，你认为哪种变体在更多情况下会有用？哪一个运行得更快？
- en: '*A List*'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*一个列表*'
- en: As generic blobs of values, objects can be used to build all sorts of data structures.
    A common data structure is the *list* (not to be confused with arrays). A list
    is a nested set of objects with the first object holding a reference to the second,
    the second to the third, and so on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为通用的值块，对象可以用来构建各种数据结构。一种常见的数据结构是*列表*（不要与数组混淆）。列表是一个嵌套的对象集合，第一个对象持有对第二个对象的引用，第二个对象持有对第三个对象的引用，依此类推。
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The resulting objects form a chain, as shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 结果对象形成一条链，如下图所示：
- en: '![Image](../images/f0078-01.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0078-01.jpg)'
- en: 'A nice thing about lists is that they can share parts of their structure. For
    example, if I create two new values {value: 0, rest: list} and {value: -1, rest:
    list} (with list referring to the binding defined earlier), they are both independent
    lists, but they share the structure that makes up their last three elements. The
    original list is also still a valid three-element list.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '列表的一个优点是它们可以共享部分结构。例如，如果我创建两个新值 {value: 0, rest: list} 和 {value: -1, rest:
    list}（其中list指的是之前定义的绑定），它们都是独立的列表，但共享组成其最后三个元素的结构。原始列表仍然是一个有效的三元素列表。'
- en: Write a function arrayToList that builds up a list structure like the one shown
    when given [1, 2, 3] as its argument. Also write a listToArray function that produces
    an array from a list. Add the helper functions prepend, which takes an element
    and a list and creates a new list that adds the element to the front of the input
    list, and nth, which takes a list and a number and returns the element at the
    given position in the list (with zero referring to the first element) or undefined
    when there is no such element.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数 arrayToList，当给定 `[1, 2, 3]` 作为参数时，构建出如所示的列表结构。还要编写一个 listToArray 函数，它可以从列表中生成一个数组。添加辅助函数
    prepend，该函数接收一个元素和一个列表，并创建一个新的列表，将元素添加到输入列表的前面；以及 nth，该函数接收一个列表和一个数字，并返回列表中给定位置的元素（零表示第一个元素），如果没有这样的元素则返回
    undefined。
- en: If you haven’t already, also write a recursive version of nth.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，也要编写 nth 的递归版本。
- en: '*Deep Comparison*'
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*深度比较*'
- en: The == operator compares objects by identity, but sometimes you’d prefer to
    compare the values of their actual properties.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: == 操作符通过身份比较对象，但有时你可能更希望比较它们实际属性的值。
- en: Write a function deepEqual that takes two values and returns true only if they
    are the same value or are objects with the same properties, where the values of
    the properties are equal when compared with a recursive call to deepEqual.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数 deepEqual，它接收两个值，仅当它们是相同的值或是具有相同属性的对象时返回 true，其中属性的值在使用 deepEqual 的递归调用时比较相等。
- en: 'To find out whether values should be compared directly (using the === operator)
    or have their properties compared, you can use the typeof operator. If it produces
    “object” for both values, you should do a deep comparison. But you have to take
    one silly exception into account: because of a historical accident, typeof null
    also produces “object”.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定值是否应该直接比较（使用 === 操作符）或比较其属性，你可以使用 typeof 操作符。如果它对两个值都返回“object”，那么你应该进行深度比较。但你必须考虑一个愚蠢的例外：由于历史原因，typeof
    null 也会返回“object”。
- en: The Object.keys function will be useful when you need to go over the properties
    of objects to compare them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要遍历对象的属性进行比较时，Object.keys 函数会很有用。
- en: '*There are two ways of constructing a software design: One way is to make it
    so simple that there are obviously no deficiencies, and the other way is to make
    it so complicated that there are no obvious deficiencies.*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*构建软件设计有两种方式：一种是将其简化到明显没有缺陷，另一种是将其复杂化到没有明显缺陷。*'
- en: —C.A.R. Hoare, *1980 ACM Turing Award Lecture*
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: —C.A.R. Hoare，*1980 ACM 图灵奖演讲*
- en: '![Image](../images/f0080-01.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0080-01.jpg)'
