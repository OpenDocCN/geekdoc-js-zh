- en: Chapter 15\. JavaScript in Web Browsers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章 JavaScript在Web浏览器中
- en: The JavaScript language was created in 1994 with the express purpose of enabling
    dynamic behavior in the documents displayed by web browsers. The language has
    evolved significantly since then, and at the same time, the scope and capabilities
    of the web platform have grown explosively. Today, JavaScript programmers can
    think of the web as a full-featured platform for application development. Web
    browsers specialize in the display of formatted text and images, but, like native
    operating systems, browsers also provide other services, including graphics, video,
    audio, networking, storage, and threading. JavaScript is the language that enables
    web applications to use the services provided by the web platform, and this chapter
    demonstrates how you can use the most important of these services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言是在1994年创建的，旨在使Web浏览器显示的文档具有动态行为。自那时以来，该语言已经发生了显著的演变，与此同时，Web平台的范围和功能也迅速增长。今天，JavaScript程序员可以将Web视为一个功能齐全的应用程序开发平台。Web浏览器专门用于显示格式化文本和图像，但是，像本机操作系统一样，浏览器还提供其他服务，包括图形、视频、音频、网络、存储和线程。JavaScript是一种使Web应用程序能够使用Web平台提供的服务的语言，本章演示了您如何使用这些最重要的服务。
- en: 'The chapter begins with the web platform’s programming model, explaining how
    scripts are embedded within HTML pages ([§15.1](#webbasics)) and how JavaScript
    code is triggered asynchronously by events ([§15.2](#events)). The sections that
    follow this introductory material document the core JavaScript APIs that enable
    your web applications to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从网络平台的编程模型开始，解释了脚本如何嵌入在HTML页面中（[§15.1](#webbasics)），以及JavaScript代码如何通过事件异步触发（[§15.2](#events)）。接下来的部分将记录启发性材料之后的核心JavaScript
    API，使您的Web应用程序能够：
- en: Control document content ([§15.3](#dom)) and style ([§15.4](#css))
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制文档内容（[§15.3](#dom)）和样式（[§15.4](#css)）
- en: Determine the on-screen position of document elements ([§15.5](#geometry))
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定文档元素的屏幕位置（[§15.5](#geometry)）
- en: Create reusable user interface components ([§15.6](#webcomponents))
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的用户界面组件（[§15.6](#webcomponents)）
- en: Draw graphics ([§15.7](#svg) and [§15.8](#canvas))
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制图形（[§15.7](#svg)和[§15.8](#canvas)）
- en: Play and generate sounds ([§15.9](#audioapis))
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放和生成声音（[§15.9](#audioapis)）
- en: Manage browser navigation and history ([§15.10](#navigationandhistory))
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理浏览器导航和历史记录（[§15.10](#navigationandhistory)）
- en: Exchange data over the network ([§15.11](#networking))
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络上交换数据（[§15.11](#networking)）
- en: Store data on the user’s computer ([§15.12](#storage))
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户计算机上存储数据（[§15.12](#storage)）
- en: Perform concurrent computation with threads ([§15.13](#webworkers))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程执行并发计算（[§15.13](#webworkers)）
- en: Previous editions of this book attempted to comprehensively cover all JavaScript
    APIs defined by web browsers, and as a result, this book was too long a decade
    ago. The number and complexity of web APIs has continued to grow, and I no longer
    think it makes sense to attempt to cover them all in one book. As of the seventh
    edition, my goal is to cover the JavaScript language definitively and to provide
    an in-depth introduction to using the language with Node and with web browsers.
    This chapter cannot cover all the web APIs, but it introduces the most important
    ones in enough detail that you can start using them right away. And, having learned
    about the core APIs covered here, you should be able to pick up new APIs (like
    those summarized in [§15.15](#furtherreading)) when and if you need them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的早期版本试图全面涵盖Web浏览器定义的所有JavaScript API，结果，十年前这本书太长了。Web API的数量和复杂性继续增长，我不再认为尝试在一本书中涵盖它们所有是有意义的。截至第七版，我的目标是全面覆盖JavaScript语言，并提供深入介绍如何在Node和Web浏览器中使用该语言。本章无法涵盖所有Web
    API，但它以足够的细节介绍了最重要的API，以便您可以立即开始使用它们。并且，学习了这里介绍的核心API后，您应该能够在需要时学习新的API（比如[§15.15](#furtherreading)中总结的那些）。
- en: Node has a single implementation and a single authoritative source for documentation.
    Web APIs, by contrast, are defined by consensus among the major web browser vendors,
    and the authoritative documentation takes the form of a specification intended
    for the C++ programmers who implement the API, not for the JavaScript programmers
    who will use it. Fortunately, [Mozilla’s “MDN web docs” project](https://developer.mozilla.org)
    is a reliable and comprehensive source^([1](ch15.xhtml#idm46198510985832)) for
    web API documentation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Node有一个单一的实现和一个单一的权威文档来源。相比之下，Web API是由主要的Web浏览器供应商之间的共识定义的，权威文档采用了面向实现API的C++程序员的规范形式，而不是面向将使用它的JavaScript程序员。幸运的是，[Mozilla的“MDN
    web docs”项目](https://developer.mozilla.org)是Web API文档的一个可靠和全面的来源^([1](ch15.xhtml#idm46198510985832))。
- en: 15.1 Web Programming Basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1 Web编程基础
- en: This section explains how JavaScript programs for the web are structured, how
    they are loaded into a web browser, how they obtain input, how they produce output,
    and how they run asynchronously by responding to events.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了Web上的JavaScript程序的结构，它们如何加载到Web浏览器中，如何获取输入，如何产生输出，以及如何通过响应事件异步运行。
- en: 15.1.1 JavaScript in HTML <script> Tags
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.1 HTML中的JavaScript `<script>`标签
- en: Web browsers display HTML documents. If you want a web browser to execute JavaScript
    code, you must include (or reference) that code from an HTML document, and this
    is what the HTML `<script>` tag does.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器显示HTML文档。如果您希望Web浏览器执行JavaScript代码，您必须在HTML文档中包含（或引用）该代码，这就是HTML `<script>`标签的作用。
- en: 'JavaScript code can appear inline within an HTML file between `<script>` and
    `</script>` tags. Here, for example, is an HTML file that includes a script tag
    with JavaScript code that dynamically updates one element of the document to make
    it behave like a digital clock:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码可以内联出现在HTML文件中的`<script>`和`</script>`标签之间。例如，这是一个包含JavaScript代码的脚本标签的HTML文件，动态更新文档的一个元素，使其表现得像一个数字时钟：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Although JavaScript code can be embedded directly within a `<script>` tag,
    it is more common to instead use the `src` attribute of the `<script>` tag to
    specify the URL (an absolute URL or a URL relative to the URL of the HTML file
    being displayed) of a file containing JavaScript code. If we took the JavaScript
    code out of this HTML file and stored it in its own *scripts/digital_clock.js*
    file, then the `<script>` tag might reference that file of code like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 JavaScript 代码可以直接嵌入在`<script>`标签中，但更常见的做法是使用`<script>`标签的`src`属性来指定包含 JavaScript
    代码的文件的 URL（绝对 URL 或相对于显示的 HTML 文件的 URL）。如果我们将这个 HTML 文件中的 JavaScript 代码提取出来并存储在自己的*scripts/digital_clock.js*文件中，那么`<script>`标签可能会引用该代码文件，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A JavaScript file contains pure JavaScript, without `<script>` tags or any other
    HTML. By convention, files of JavaScript code have names that end with *.js*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 JavaScript 文件包含纯 JavaScript，没有`<script>`标签或任何其他 HTML。按照惯例，JavaScript 代码文件的名称以*.js*结尾。
- en: 'A `<script>` tag with the a `src` attribute behaves exactly as if the contents
    of the specified JavaScript file appeared directly between the `<script>` and
    `</script>` tags. Note that the closing `</script>` tag is required in HTML documents
    even when the `src` attribute is specified: HTML does not support a `<script/>`
    tag.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`src`属性的`<script>`标签的行为与指定的 JavaScript 文件的内容直接出现在`<script>`和`</script>`标签之间完全相同。请注意，即使指定了`src`属性，HTML
    文档中也需要关闭`</script>`标签：HTML 不支持`<script/>`标签。
- en: 'There are a number of advantages to using the `src` attribute:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`src`属性有许多优点：
- en: It simplifies your HTML files by allowing you to remove large blocks of JavaScript
    code from them—that is, it helps keep content and behavior separate.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过允许您从 HTML 文件中删除大块 JavaScript 代码，简化了您的 HTML 文件 - 也就是说，它有助于保持内��和行为分离。
- en: When multiple web pages share the same JavaScript code, using the `src` attribute
    allows you to maintain only a single copy of that code, rather than having to
    edit each HTML file when the code changes.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个网页共享相同的 JavaScript 代码时，使用`src`属性可以让您仅维护该代码的单个副本，而无需在代码更改时编辑每个 HTML 文件。
- en: If a file of JavaScript code is shared by more than one page, it only needs
    to be downloaded once, by the first page that uses it—subsequent pages can retrieve
    it from the browser cache.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个 JavaScript 代码文件被多个页面共享，只需要被第一个使用它的页面下载一次，随后的页面可以从浏览器缓存中检索它。
- en: Because the `src` attribute takes an arbitrary URL as its value, a JavaScript
    program or web page from one web server can employ code exported by other web
    servers. Much internet advertising relies on this fact.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`src`属性以任意 URL 作为其值，所以来自一个 web 服务器的 JavaScript 程序或网页可以使用其他 web 服务器导出的代码。许多互联网广告都依赖于这一点。
- en: Modules
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: '[§10.3](ch10.xhtml#es6modules) documents JavaScript modules and covers their
    `import` and `export` directives. If you have written your JavaScript program
    using modules (and have not used a code-bundling tool to combine all your modules
    into a single nonmodular file of JavaScript), then you must load the top-level
    module of your program with a `<script>` tag that has a `type="module"` attribute.
    If you do this, then the module you specify will be loaded, and all of the modules
    it imports will be loaded, and (recursively) all of the modules they import will
    be loaded. See [§10.3.5](ch10.xhtml#es6modules-script) for complete details.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[§10.3](ch10.xhtml#es6modules) 文档了 JavaScript 模块，并涵盖它们的`import`和`export`指令。如果您使用模块编写了
    JavaScript 程序（并且没有使用代码捆绑工具将所有模块组合成单个非模块化的 JavaScript 文件），那么您必须使用带有`type="module"`属性的`<script>`标签加载程序的顶层模块。如果这样做，那么您指定的模块将被加载，它导入的所有模块也将被加载，以及（递归地）导入的所有模块也将被加载。详细信息请参见[§10.3.5](ch10.xhtml#es6modules-script)。'
- en: Specifying script type
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定脚本类型
- en: 'In the early days of the web, it was thought that browsers might some day implement
    languages other than JavaScript, and programmers added attributes like `language="javascript"`
    and `type="application/javascript"` to their `<script>` tags. This is completely
    unnecessary. JavaScript is the default (and only) language of the web. The `language`
    attribute is deprecated, and there are only two reasons to use a `type` attribute
    on a `<script>` tag:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 web 的早期，人们认为浏览器可能会实现除 JavaScript 外的其他语言，程序员们在他们的`<script>`标签中添加了`language="javascript"`和`type="application/javascript"`等属性。这是完全不必要的。JavaScript
    是 web 的默认（也是唯一）语言。`language`属性已被弃用，只有两个原因可以在`<script>`标签上使用`type`属性：
- en: To specify that the script is a module
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定脚本为模块
- en: To embed data into a web page without displaying it (see [§15.3.4](#elementcontent))
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据嵌入网页而不显示它（参见[§15.3.4](#elementcontent)）
- en: 'When scripts run: async and deferred'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本何时运行：异步和延迟
- en: When JavaScript was first added to web browsers, there was no API for traversing
    and manipulating the structure and content of an already rendered document. The
    only way that JavaScript code could affect the content of a document was to generate
    that content on the fly while the document was in the process of loading. It did
    this by using the `document.write()` method to inject HTML text into the document
    at the location of the script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 首次添加到 web 浏览器时，没有 API 可以遍历和操作已经呈现的文档的结构和内容。JavaScript 代码影响文档内容的唯一方法是在文档加载过程中动态生成内容。它通过使用`document.write()`方法将
    HTML 文本注入到脚本位置来实现这一点。
- en: The use of `document.write()` is no longer considered good style, but the fact
    that it is possible means that when the HTML parser encounters a `<script>` element,
    it must, by default, run the script just to be sure that it doesn’t output any
    HTML before it can resume parsing and rendering the document. This can dramatically
    slow down parsing and rendering of the web page.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`document.write()`不再被认为是良好的风格，但它是可能的事实意味着当 HTML 解析器遇到`<script>`元素时，默认情况下必须运行脚本，以确保它在恢复解析和呈现文档之前不输出任何
    HTML。这可能会显著减慢网页的解析和呈现速度。
- en: 'Fortunately, this default *synchronous* or *blocking* script execution mode
    is not the only option. The `<script>` tag can have `defer` and `async` attributes,
    which cause scripts to be executed differently. These are boolean attributes—they
    don’t have a value; they just need to be present on the `<script>` tag. Note that
    these attributes are only meaningful when used in conjunction with the `src` attribute:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，默认的*同步*或*阻塞*脚本执行模式并不是唯一的选择。`<script>`标签可以具有`defer`和`async`属性，这会导致脚本以不同的方式执行。这些是布尔属性——它们没有值；它们只需要出现在`<script>`标签上。请注意，这些属性仅在与`src`属性一起使用时才有意义：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both the `defer` and `async` attributes are ways of telling the browser that
    the linked script does not use `document.write()` to generate HTML output, and
    that the browser, therefore, can continue to parse and render the document while
    downloading the script. The `defer` attribute causes the browser to defer execution
    of the script until after the document has been fully loaded and parsed and is
    ready to be manipulated. The `async` attribute causes the browser to run the script
    as soon as possible but does not block document parsing while the script is being
    downloaded. If a `<script>` tag has both attributes, the `async` attribute takes
    precedence.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`和`async`属性都是告诉浏览器链接的脚本不使用`document.write()`来生成HTML输出的方式，因此浏览器可以在下载脚本的同时继续解析和渲染文档。`defer`属性会导致浏览器推迟执行脚本，直到文档完全加载和解析完成，并且准备好被操作。`async`属性会导致浏览器尽快运行脚本，但不会在下载脚本时阻止文档解析。如果一个`<script>`标签同时具有这两个属性，`async`属性优先。'
- en: Note that deferred scripts run in the order in which they appear in the document.
    Async scripts run as they load, which means that they may execute out of order.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，延迟脚本按照它们在文档中出现的顺序运行。异步脚本在加载时运行，这意味着它们可能无序执行。
- en: Scripts with the `type="module"` attribute are, by default, executed after the
    document has loaded, as if they had a `defer` attribute. You can override this
    default with the `async` attribute, which will cause the code to be executed as
    soon as the module and all of its dependencies have loaded.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`type="module"`属性的脚本默认在文档加载后执行，就像它们有一个`defer`属性一样。您可以使用`async`属性覆盖此默认行为，这将导致代码在模块及其所有依赖项加载后立即执行。
- en: A simple alternative to the `async` and `defer` attributes—especially for code
    that is included directly in the HTML—is to simply put your scripts at the end
    of the HTML file. That way, the script can run knowing that the document content
    before it has been parsed and is ready to be manipulated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的替代方案是`async`和`defer`属性——特别是对于直接包含在HTML中的代码——只需将脚本放在HTML文件的末尾。这样，脚本可以运行，知道它前面的文档内容已被解析并准备好被操作。
- en: Loading scripts on demand
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按需加载脚本
- en: Sometimes, you may have JavaScript code that is not used when a document first
    loads and is only needed if the user takes some action like clicking on a button
    or opening a menu. If you are developing your code using modules, you can load
    a module on demand with `import()`, as described in [§10.3.6](ch10.xhtml#dynamicimports).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能有一些JavaScript代码在文档首次加载时不被使用，只有在用户执行某些操作，如点击按钮或打开菜单时才需要。如果您正在使用模块开发代码，可以使用`import()`按需加载模块，如[§10.3.6](ch10.xhtml#dynamicimports)中所述。
- en: 'If you are not using modules, you can load a file of JavaScript on demand simply
    by adding a `<script>` tag to your document when you want the script to load:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用模块，可以在希望脚本加载时向文档添加一个`<script>`标签来按需加载JavaScript文件：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This `importScript()` function uses DOM APIs ([§15.3](#dom)) to create a new
    `<script>` tag and add it to the document `<head>`. And it uses event handlers
    ([§15.2](#events)) to determine when the script has loaded successfully or when
    loading has failed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`importScript()`函数使用DOM API（[§15.3](#dom)）来创建一个新的`<script>`标签，并将其添加到文档的`<head>`中。它使用事件处理程序（[§15.2](#events)）来确定脚本何时成功加载或加载失败。
- en: 15.1.2 The Document Object Model
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.2 文档对象模型
- en: One of the most important objects in client-side JavaScript programming is the
    Document object—which represents the HTML document that is displayed in a browser
    window or tab. The API for working with HTML documents is known as the Document
    Object Model, or DOM, and it is covered in detail in [§15.3](#dom). But the DOM
    is so central to client-side JavaScript programming that it deserves to be introduced
    here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端JavaScript编程中最重要的对象之一是文档对象，它代表在浏览器窗口或标签中显示的HTML文档。用于处理HTML文档的API称为文档对象模型，或DOM，在[§15.3](#dom)中有详细介绍。但是DOM在客户端JavaScript编程中如此重要，以至于应该在这里介绍。
- en: 'HTML documents contain HTML elements nested within one another, forming a tree.
    Consider the following simple HTML document:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档包含嵌套在一起的HTML元素，形成一棵树。考虑以下简单的HTML文档：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The top-level `<html>` tag contains `<head>` and `<body>` tags. The `<head>`
    tag contains a `<title>` tag. And the `<body>` tag contains `<h1>` and `<p>` tags.
    The `<title>` and `<h1>` tags contain strings of text, and the `<p>` tag contains
    two strings of text with an `<i>` tag between them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层的`<html>`标签包含`<head>`和`<body>`标签。`<head>`标签包含一个`<title>`标签。`<body>`标签包含`<h1>`和`<p>`标签。`<title>`和`<h1>`标签包含文本字符串，`<p>`标签包含两个文本字符串，中间有一个`<i>`标签。
- en: The DOM API mirrors the tree structure of an HTML document. For each HTML tag
    in the document, there is a corresponding JavaScript Element object, and for each
    run of text in the document, there is a corresponding Text object. The Element
    and Text classes, as well as the Document class itself, are all subclasses of
    the more general Node class, and Node objects are organized into a tree structure
    that JavaScript can query and traverse using the DOM API. The DOM representation
    of this document is the tree pictured in [Figure 15-1](#documenttree).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DOM API 反映了 HTML 文档的树结构。对于文档中的每个 HTML 标签，都有一个对应的 JavaScript Element 对象，对于文档中的每个文本运行，都有一个对应的
    Text 对象。Element 和 Text 类，以及 Document 类本身，都是更一般的 Node 类的子类，Node 对象组织成 JavaScript
    可以使用 DOM API 查询和遍历的树结构。此文档的 DOM 表示是 [图 15-1](#documenttree) 中描绘的树。
- en: '![js7e 1501](Images/js7e_1501.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1501](Images/js7e_1501.png)'
- en: Figure 15-1\. The tree representation of an HTML document
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-1。HTML 文档的树形表示
- en: If you are not already familiar with tree structures in computer programming,
    it is helpful to know that they borrow terminology from family trees. The node
    directly above a node is the *parent* of that node. The nodes one level directly
    below another node are the *children* of that node. Nodes at the same level, and
    with the same parent, are *siblings*. The set of nodes any number of levels below
    another node are the *descendants* of that node. And the parent, grandparent,
    and all other nodes above a node are the *ancestors* of that node.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对计算机编程中的树结构不熟悉，了解它们从家谱中借来的术语会有所帮助。直接在节点上方的节点是该节点的*父节点*。直接在另一个节点下一级的节点是该节点的*子节点*。在同一级别且具有相同父节点的节点是*兄弟节点*。在另一个节点下的任意级别的节点是该节点的*后代节点*。父节点、祖父节点和其他所有在节点上方的节点都是该节点的*祖先节点*。
- en: The DOM API includes methods for creating new Element and Text nodes, and for
    inserting them into the document as children of other Element objects. There are
    also methods for moving elements within the document and for removing them entirely.
    While a server-side application might produce plain-text output by writing strings
    with `console.log()`, a client-side JavaScript application can produce formatted
    HTML output by building or manipulating the document tree document using the DOM
    API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: DOM API 包括用于创建新的 Element 和 Text 节点，并将它们作为其他 Element 对象的子节点插入文档的方法。还有用于在文档中移动元素和完全删除它们的方法。虽然服务器端应用程序可能通过使用
    `console.log()` 写入字符串来生成纯文本输出，但客户端 JavaScript 应用程序可以通过使用 DOM API 构建或操作文档树来生成格式化的
    HTML 输出。
- en: There is a JavaScript class corresponding to each HTML tag type, and each occurrence
    of the tag in a document is represented by an instance of the class. The `<body>`
    tag, for example, is represented by an instance of HTMLBodyElement, and a `<table>`
    tag is represented by an instance of HTMLTableElement. The JavaScript element
    objects have properties that correspond to the HTML attributes of the tags. For
    example, instances of HTMLImageElement, which represent `<img>` tags, have a `src`
    property that corresponds to the `src` attribute of the tag. The initial value
    of the `src` property is the attribute value that appears in the HTML tag, and
    setting this property with JavaScript changes the value of the HTML attribute
    (and causes the browser to load and display a new image). Most of the JavaScript
    element classes just mirror the attributes of an HTML tag, but some define additional
    methods. The HTMLAudioElement and HTMLVideoElement classes, for example, define
    methods like `play()` and `pause()` for controlling playback of audio and video
    files.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HTML 标签类型都对应一个 JavaScript 类，文档中每个标签的出现都由该类的一个实例表示。例如，`<body>` 标签由 HTMLBodyElement
    的一个实例表示，`<table>` 标签由 HTMLTableElement 的一个实例表示。JavaScript 元素对象具有与标签的 HTML 属性对应的属性。例如，代表
    `<img>` 标签的 HTMLImageElement 实例具有一个与标签的 `src` 属性对应的 `src` 属性。`src` 属性的初始值是出现在
    HTML 标签中的属性值，使用 JavaScript 设置此属性会改变 HTML 属性的值（并导致浏览器加载和显示新图像）。大多数 JavaScript 元素类只是反映
    HTML 标签的属性，但有些定义了额外的方法。例如，HTMLAudioElement 和 HTMLVideoElement 类定义了像 `play()` 和
    `pause()` 这样的方法，用于控制音频和视频文件的播放。
- en: 15.1.3 The Global Object in Web Browsers
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.3 Web 浏览器中的全局对象
- en: 'There is one global object per browser window or tab ([§3.7](ch03.xhtml#global)).
    All of the JavaScript code (except code running in worker threads; see [§15.13](#webworkers))
    running in that window shares this single global object. This is true regardless
    of how many scripts or modules are in the document: all the scripts and modules
    of a document share a single global object; if one script defines a property on
    that object, that property is visible to all the other scripts as well.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器窗口或标签页都有一个全局对象（[§3.7](ch03.xhtml#global)）。在该窗口中运行的所有 JavaScript 代码（除了在工作线程中运行的代码；参见[§15.13](#webworkers)）共享这个单一全局对象。无论文档中有多少脚本或模块，这一点都是真实的：文档中的所有脚本和模块共享一个全局对象；如果一个脚本在该对象上定义了一个属性，那么其他所有脚本也能看到这个属性。
- en: The global object is where JavaScript’s standard library is defined—the `parseInt()`
    function, the Math object, the Set class, and so on. In web browsers, the global
    object also contains the main entry points of various web APIs. For example, the
    `document` property represents the currently displayed document, the `fetch()`
    method makes HTTP network requests, and the `Audio()` constructor allows JavaScript
    programs to play sounds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象是 JavaScript 标准库的定义位置——`parseInt()` 函数、Math 对象、Set 类等等。在 Web 浏览器中，全局对象还包含各种
    Web API 的主要入口点。例如，`document` 属性代表当前显示的文档，`fetch()` 方法发起 HTTP 网络请求，`Audio()` 构造函数允许
    JavaScript 程序播放声音。
- en: 'In web browsers, the global object does double duty: in addition to defining
    built-in types and functions, it also represents the current web browser window
    and defines properties like `history` ([§15.10.2](#history)), which represent
    the window’s browsing history, and `innerWidth`, which holds the window’s width
    in pixels. One of the properties of this global object is named `window`, and
    its value is the global object itself. This means that you can simply type `window`
    to refer to the global object in your client-side code. When using window-specific
    features, it is often a good idea to include a `window.` prefix: `window.innerWidth`
    is clearer than `innerWidth`, for example.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 浏览器中，全局对象承担双重职责：除了定义内置类型和函数之外，它还表示当前 Web 浏览器窗口，并定义诸如 `history`（[§15.10.2](#history)）这样的属性，表示窗口的浏览历史，以及
    `innerWidth`，保存窗口的宽度（以像素为单位）。这个全局对象的一个属性名为 `window`，其值是全局对象本身。这意味着您可以简单地在客户端代码中输入
    `window` 来引用全局对象。在使用特定于窗口的功能时，通常最好包含一个 `window.` 前缀：例如，`window.innerWidth` 比 `innerWidth`
    更清晰。
- en: 15.1.4 Scripts Share a Namespace
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.4 脚本共享命名空间
- en: With modules, the constants, variables, functions, and classes defined at the
    top level (i.e., outside of any function or class definition) of the module are
    private to the module unless they are explicitly exported, in which case, they
    can be selectively imported by other modules. (Note that this property of modules
    is honored by code-bundling tools as well.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块时，在模块顶层（即在任何函数或类定义之外）定义的常量、变量、函数和类对于模块是私有的，除非它们被明确导出，这样，其他模块可以有选择地导入它们。（请注意，模块的这个属性也受到代码捆绑工具的尊重。）
- en: With non-module scripts, however, the situation is completely different. If
    the top-level code in a script defines a constant, variable, function, or class,
    that declaration will be visible to all other scripts in the same document. If
    one script defines a function `f()` and another script defines a class `c`, then
    a third script can invoke the function and instantiate the class without having
    to take any action to import them. So if you are not using modules, the independent
    scripts in your document share a single namespace and behave as if they are all
    part of a single larger script. This can be convenient for small programs, but
    the need to avoid naming conflicts can become problematic for larger programs,
    especially when some of the scripts are third-party libraries.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于非模块脚本，情况完全不同。如果脚本中的顶层代码定义了常量、变量、函数或类，那个声明将对同一文档中的所有其他脚本可见。如果一个脚本定义了一个函数
    `f()`，另一个脚本定义了一个类 `c`，那么第三个脚本可以调用该函数并实例化该类，而无需采取任何导入操作。因此，如果您不使用模块，在您的文档中的独立脚本共享一个单一命名空间，并且表现得好像它们都是单个更大脚本的一部分。这对于小型程序可能很方便，但在更大的程序中，特别是当一些脚本是第三方库时，需要避免命名冲突可能会成为问题。
- en: 'There are some historical quirks with how this shared namespace works. `var`
    and `function` declarations at the top level create properties in the shared global
    object. If one script defines a top-level function `f()`, then another script
    in the same document can invoke that function as `f()` or as `window.f()`. On
    the other hand, the ES6 declarations `const`, `let`, and `class`, when used at
    the top level, do not create properties in the global object. They are still defined
    in a shared namespace, however: if one script defines a class `C`, other scripts
    will be able to create instances of that class with `new C()`, but not with `new
    window.C()`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个共享命名空间的工作方式有一些历史上的怪癖。在顶层使用 `var` 和 `function` 声明会在共享的全局对象中创建属性。如果一个脚本定义了一个顶层函数
    `f()`，那么同一文档中的另一个脚本可以将该函数调用为 `f()` 或 `window.f()`。另一方面，ES6 声明 `const`、`let` 和
    `class` 在顶层使用时不会在全局对象中创建属性。然而，它们仍然在共享的命名空间中定义：如果一个脚本定义了一个类 `C`，其他脚本将能够使用 `new
    C()` 创建该类的实例，但不能使用 `new window.C()`。
- en: 'To summarize: in modules, top-level declarations are scoped to the module and
    can be explicitly exported. In nonmodule scripts, however, top-level declarations
    are scoped to the containing document, and the declarations are shared by all
    scripts in the document. Older `var` and `function` declarations are shared via
    properties of the global object. Newer `const`, `let`, and `class` declarations
    are also shared and have the same document scope, but they do not exist as properties
    of any object that JavaScript code has access to.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：在模块中，顶层声明的作用域是模块，并且可以被明确导出。然��，在非模块脚本中，顶层声明的作用域是包含文档，并且这些声明被文档中的所有脚本共享。旧的
    `var` 和 `function` 声明通过全局对象的属性共享。新的 `const`、`let` 和 `class` 声明也是共享的，并具有相同的文档作用域，但它们不作为
    JavaScript 代码可以访问的任何对象的属性存在。
- en: 15.1.5 Execution of JavaScript Programs
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.5 JavaScript 程序的执行
- en: There is no formal definition of a *program* in client-side JavaScript, but
    we can say that a JavaScript program consists of all the JavaScript code in, or
    referenced from, a document. These separate bits of code share a single global
    Window object, which gives them access to the same underlying Document object
    representing the HTML document. Scripts that are not modules additionally share
    a top-level namespace.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端 JavaScript 中，*程序* 没有正式的定义，但我们可以说 JavaScript 程序包括文档中的所有 JavaScript 代码或引用的代码。这些独立的代码片段共享一个全局
    Window 对象，使它们可以访问表示 HTML 文档的相同底层 Document 对象。不是模块的脚本还共享一个顶层命名空间。
- en: If a web page includes an embedded frame (using the `<iframe>` element), the
    JavaScript code in the embedded document has a different global object and Document
    object than the code in the embedding document, and it can be considered a separate
    JavaScript program. Remember, though, that there is no formal definition of what
    the boundaries of a JavaScript program are. If the container document and the
    contained document are both loaded from the same server, the code in one document
    can interact with the code in the other, and you can treat them as two interacting
    parts of a single program, if you wish. [§15.13.6](#crossoriginmessaging) explains
    how a JavaScript program can send and receive messages to and from JavaScript
    code running in an `<iframe>`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网页包含嵌入的框架（使用 `<iframe>` 元素），嵌入文档中的 JavaScript 代码具有不同的全局对象和文档对象，与包含文档中的代码不同，并且可以被视为一个单独的
    JavaScript 程序。但请记住，JavaScript 程序的边界没有正式的定义。如果容器文档和包含文档都是从同一服务器加载的，那么一个文档中的代码可以与另一个文档中的代码互动，并且您可以将它们视为单个程序的两个互动部分，如果您愿意的话。[§15.13.6](#crossoriginmessaging)
    解释了一个 JavaScript 程序如何与在 `<iframe>` 中运行的 JavaScript 代码发送和接收消息。
- en: You can think of JavaScript program execution as occurring in two phases. In
    the first phase, the document content is loaded, and the code from `<script>`
    elements (both inline scripts and external scripts) is run. Scripts generally
    run in the order in which they appear in the document, though this default order
    can be modified by the `async` and `defer` attributes we’ve described. The JavaScript
    code within any single script is run from top to bottom, subject, of course, to
    JavaScript’s conditionals, loops, and other control statements. Some scripts don’t
    really *do* anything during this first phase and instead just define functions
    and classes for use in the second phase. Other scripts might do significant work
    during the first phase and then do nothing in the second. Imagine a script at
    the very end of a document that finds all `<h1>` and `<h2>` tags in the document
    and modifies the document by generating and inserting a table of contents at the
    beginning of the document. This could be done entirely in the first phase. (See
    [§15.3.6](#tocsection) for an example that does exactly this.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 JavaScript 程序执行看作是分为两个阶段进行的。在第一阶段中，文档内容被加载，`<script>` 元素中的代码（包括内联脚本和外部脚本）被运行。脚本通常按照它们在文档中出现的顺序运行，尽管这种默认顺序可以通过我们描述的
    `async` 和 `defer` 属性进行修改。单个脚本中的 JavaScript 代码从上到下运行，当然，受 JavaScript 的条件语句、循环和其他控制语句的影响。在第一阶段中，一些脚本实际上并没有*执行*任何操作，而是仅仅定义函数和类供第二阶段使用。其他脚本可能在第一阶段做了大量工作，然后在第二阶段不做任何事情。想象一下一个位于文档末尾的脚本，它会查找文档中的所有
    `<h1>` 和 `<h2>` 标签，并通过在文档开头生成并插入目录来修改文档。这完全可以在第一阶段完成。（参见 [§15.3.6](#tocsection)
    中的一个实现此功能的示例。）
- en: Once the document is loaded and all scripts have run, JavaScript execution enters
    its second phase. This phase is asynchronous and event-driven. If a script is
    going to participate in this second phase, then one of the things it must have
    done during the first phase is to register at least one event handler or other
    callback function that will be invoked asynchronously. During this event-driven
    second phase, the web browser invokes event handler functions and other callbacks
    in response to events that occur asynchronously. Event handlers are most commonly
    invoked in response to user input (mouse clicks, keystrokes, etc.) but may also
    be triggered by network activity, document and resource loading, elapsed time,
    or errors in JavaScript code. Events and event handlers are described in detail
    in [§15.2](#events).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文档加载完成并且所有脚本都运行完毕，JavaScript 执行进入第二阶段。这个阶段是异步和事件驱动的。如果一个脚本要参与这个第二阶段，那么���在第一阶段必须至少注册一个事件处理程序或其他回调函数，这些函数将被异步调用。在这个事件驱动的第二阶段，Web
    浏览器根据异步发生的事件调用事件处理程序函数和其他回调。事件处理程序通常是响应用户输入（鼠标点击、按键等）而被调用，但也可能是由网络活动、文档和资源加载、经过的时间或
    JavaScript 代码中的错误触发。事件和事件处理程序在 [§15.2](#events) 中有详细描述。
- en: Some of the first events to occur during the event-driven phase are the “DOMContentLoaded”
    and “load” events. “DOMContentLoaded” is triggered when the HTML document has
    been completely loaded and parsed. The “load” event is triggered when all of the
    document’s external resources—such as images—are also fully loaded. JavaScript
    programs often use one of these events as a trigger or starting signal. It is
    common to see programs whose scripts define functions but take no action other
    than registering an event handler function to be triggered by the “load” event
    at the beginning of the event-driven phase of execution. It is this “load” event
    handler that then manipulates the document and does whatever it is that the program
    is supposed to do. Note that it is common in JavaScript programming for an event
    handler function such as the “load” event handler described here to register other
    event handlers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动阶段最先发生的一些事件是“DOMContentLoaded”和“load”事件。“DOMContentLoaded”在 HTML 文档完全加载和解析后触发。“load”事件在文档的所有外部资源（如图像）也完全加载后触发。JavaScript
    程序通常使用其中一个事件作为触发器或启动信号。通常可以看到这样的程序，其脚本定义函数但除了注册一个事件处理程序函数以在执行的事件驱动阶段开始时由“load”事件触发外不执行任何操作。然后，这个“load”事件处理程序会操作文档并执行程序应该执行的任何操作。请注意，在
    JavaScript 编程中，像这里描述的“load”事件处理程序这样的事件处理程序函数通常会注册其他事件处理程序。
- en: 'The loading phase of a JavaScript program is relatively short: ideally less
    than a second. Once the document is loaded, the event-driven phase lasts for as
    long as the document is displayed by the web browser. Because this phase is asynchronous
    and event-driven, there may be long periods of inactivity where no JavaScript
    is executed, punctuated by bursts of activity triggered by user or network events.
    We’ll cover these two phases in more detail next.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 程序的加载阶段相对较短：理想情况下不超过一秒。一旦文档加载完成，基于事件驱动的阶段将持续到网页被浏览器显示的整个时间。由于这个阶段是异步和事件驱动的，可能会出现长时间的不活动期，期间不执行任何
    JavaScript，然后会因用户或网络事件触发而出现活动突发。接下来我们将更详细地介绍这两个阶段。
- en: Client-side JavaScript threading model
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端 JavaScript 线程模型
- en: 'JavaScript is a single-threaded language, and single-threaded execution makes
    for much simpler programming: you can write code with the assurance that two event
    handlers will never run at the same time. You can manipulate document content
    knowing that no other thread is attempting to modify it at the same time, and
    you never need to worry about locks, deadlock, or race conditions when writing
    JavaScript code.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种单线程语言，单线程执行使编程变得简单得多：您可以编写代码，确保两个事件处理程序永远不会同时运行。您可以操作文档内容，知道没有其他线程同时尝试修改它，而在编写
    JavaScript 代码时永远不需要担心锁、死锁或竞争条件。
- en: 'Single-threaded execution means that web browsers stop responding to user input
    while scripts and event handlers are executing. This places a burden on JavaScript
    programmers: it means that JavaScript scripts and event handlers must not run
    for too long. If a script performs a computationally intensive task, it will introduce
    a delay into document loading, and the user will not see the document content
    until the script completes. If an event handler performs a computationally intensive
    task, the browser may become nonresponsive, possibly causing the user to think
    that it has crashed.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程执行意味着在脚本和事件处理程序执行时，Web 浏览器停止响应用户输入。这给 JavaScript 程序员带来了负担：这意味着 JavaScript
    脚本和事件处理程序不能运行太长时间。如果脚本执行了计算密集型任务，它将延迟文档加载，用户将在脚本完成之前看不到文档内容。如果事件处理程序执行了计算密集型任务，浏览器可能会变得无响应，可能导致用户认为它已崩溃。
- en: The web platform defines a controlled form of concurrency called a “web worker.”
    A web worker is a background thread for performing computationally intensive tasks
    without freezing the user interface. The code that runs in a web worker thread
    does not have access to document content, does not share any state with the main
    thread or with other workers, and can only communicate with the main thread and
    other workers through asynchronous message events, so the concurrency is not detectable
    to the main thread, and web workers do not alter the basic single-threaded execution
    model of JavaScript programs. See [§15.13](#webworkers) for full details on the
    web’s safe threading mechanism.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Web 平台定义了一种受控并发形式，称为“Web Worker”。Web Worker 是用于执行计算密集型任务的后台线程，而不会冻结用户界面。在 Web
    Worker 线程中运行的代码无法访问文档内容，也不与主线程或其他 Worker 共享任何状态，并且只能通过异步消息事件与主线程和其他 Worker 进行通信，因此主线程无法检测到并发，Web
    Worker 不会改变 JavaScript 程序的基本单线程执行模型。有关 Web 安全线程机制的完整详细信息，请参见[§15.13](#webworkers)。
- en: Client-side JavaScript timeline
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端 JavaScript 时间轴
- en: 'We’ve already seen that JavaScript programs begin in a script-execution phase
    and then transition to an event-handling phase. These two phases can be further
    broken down into the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 JavaScript 程序开始于脚本执行阶段，然后过渡到事件处理阶段。这两个阶段可以进一步分解为以下步骤：
- en: The web browser creates a Document object and begins parsing the web page, adding
    Element objects and Text nodes to the document as it parses HTML elements and
    their textual content. The `document.readyState` property has the value “loading”
    at this stage.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Web 浏览器创建一个 Document 对象并开始解析网页，随着解析 HTML 元素及其文本内容，将 Element 对象和 Text 节点添加到文档中。此时`document.readyState`属性的值为“loading”。
- en: When the HTML parser encounters a `<script>` tag that does not have any of the
    `async`, `defer`, or `type="module"` attributes, it adds that script tag to the
    document and then executes the script. The script is executed synchronously, and
    the HTML parser pauses while the script downloads (if necessary) and runs. A script
    like this can use `document.write()` to insert text into the input stream, and
    that text will become part of the document when the parser resumes. A script like
    this often simply defines functions and registers event handlers for later use,
    but it can traverse and manipulate the document tree as it exists at that time.
    That is, non-module scripts that do not have an `async` or `defer` attribute can
    see their own `<script>` tag and document content that comes before it.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 HTML 解析器遇到一个没有任何`async`、`defer`或`type="module"`属性的`<script>`标签时，它将该脚本标签添加到文档中，然后执行该脚本。脚本是同步执行的，而
    HTML 解析器在脚本下载（如果需要）和运行时暂停。这样的脚本可以使用`document.write()`将文本插入输入流，当解析器恢复时，该文本将成为文档的一部分。这样的脚本通常只是定义函数并注册事件处理程序以供以后使用，但它可以遍历和操作文档树，就像它在那个时候存在的那样。也就是说，没有`async`或`defer`属性的非模块脚本可以看到自己的`<script>`标签和在它之前出现的文档内容。
- en: When the parser encounters a `<script>` element that has the `async` attribute
    set, it begins downloading the script text (and if the script is a module, it
    also recursively downloads all of the script’s dependencies) and continues parsing
    the document. The script will be executed as soon as possible after it has downloaded,
    but the parser does not stop and wait for it to download. Asynchronous scripts
    must not use the `document.write()` method. They can see their own `<script>`
    tag and all document content that comes before it, and may or may not have access
    to additional document content.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当解析器遇到设置了`async`属性的`<script>`元素时，它开始下载脚本文本（如果脚本是一个模块，它还会递归下载所有脚本的依赖项），并继续解析文档。脚本将在下载后尽快执行，但解析器不会停止等待它下载。异步脚本不能使用`document.write()`方法。它们可以看到自己的`<script>`标签和在它之前出现的所有文档内容，并且可能或可能不具有对额外文档内容的访问权限。
- en: When the document is completely parsed, the `document.readyState` property changes
    to “interactive.”
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当文档完全解析时，`document.readyState`属性更改为“interactive”。
- en: Any scripts that had the `defer` attribute set (along with any module scripts
    that do not have an `async` attribute) are executed in the order in which they
    appeared in the document. Async scripts may also be executed at this time. Deferred
    scripts have access to the complete document and they must not use the `document.write()`
    method.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何设置了`defer`属性的脚本（以及没有设置`async`属性的任何模块脚本）按照它们在文档中出现的顺序执行。异步脚本也可能在此时执行。���迟脚本可以访问完整的文档，它们不能使用`document.write()`方法。
- en: The browser fires a “DOMContentLoaded” event on the Document object. This marks
    the transition from synchronous script-execution phase to the asynchronous, event-driven
    phase of program execution. Note, however, that there may still be `async` scripts
    that have not yet executed at this point.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器在 Document 对象上触发“DOMContentLoaded”事件。这标志着从同步脚本执行阶段到程序执行的异步、事件驱动阶段的转变。但请注意，此时可能仍有尚未执行的`async`脚本。
- en: The document is completely parsed at this point, but the browser may still be
    waiting for additional content, such as images, to load. When all such content
    finishes loading, and when all `async` scripts have loaded and executed, the `document.readyState`
    property changes to “complete” and the web browser fires a “load” event on the
    Window object.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时文档已完全解析，但浏览器可能仍在等待其他内容（如图像）加载。当所有这些内容加载完成，并且所有`async`脚本已加载和执行时，`document.readyState`属性将更改为“complete”，并且网络浏览器在
    Window 对象上触发“load”事件。
- en: From this point on, event handlers are invoked asynchronously in response to
    user input events, network events, timer expirations, and so on.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这一点开始，事件处理程序将异步调用以响应用户输入事件、网络事件、定时器到期等。
- en: 15.1.6 Program Input and Output
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.6 程序输入和输出
- en: 'Like any program, client-side JavaScript programs process input data to produce
    output data. There are a variety of inputs available:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何程序一样，客户端 JavaScript 程序处理输入数据以生成输出数据。有各种可用的输入：
- en: The content of the document itself, which JavaScript code can access with the
    DOM API ([§15.3](#dom)).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档本身的内容，JavaScript 代码可以使用 DOM API（[§15.3](#dom)）访问。
- en: User input, in the form of events, such as mouse clicks (or touch-screen taps)
    on HTML `<button>` elements, or text entered into HTML `<textarea>` elements,
    for example. [§15.2](#events) demonstrates how JavaScript programs can respond
    to user events like these.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入，以事件的形式，例如鼠标点击（或触摸屏点击）HTML `<button>` 元素，或输入到 HTML `<textarea>` 元素中的文本，例如。[§15.2](#events)演示了
    JavaScript 程序如何响应这些用户事件。
- en: The URL of the document being displayed is available to client-side JavaScript
    as `document.URL`. If you pass this string to the `URL()` constructor ([§11.9](ch11.xhtml#urlapi)),
    you can easily access the path, query, and fragment sections of the URL.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在显示的文档的 URL 可以作为`document.URL`在客户端 JavaScript 中使用。如果将此字符串传递给`URL()`构造函数（[§11.9](ch11.xhtml#urlapi)），您可以轻松访问
    URL 的路径、查询和片段部分。
- en: The content of the HTTP “Cookie” request header is available to client-side
    code as `document.cookie`. Cookies are usually used by server-side code for maintaining
    user sessions, but client-side code can also read (and write) them if necessary.
    See [§15.12.2](#cookies) for further details.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP“Cookie”请求头的内容可以作为`document.cookie`在客户端代码中使用。Cookie通常由服务器端代码用于维护用户会话，但如果必要，客户端代码也可以读取（和写入）它们。有关详细信息，请参见[§15.12.2](#cookies)。
- en: The global `navigator` property provides access to information about the web
    browser, the OS it’s running on top of, and the capabilities of each. For example,
    `navigator.userAgent` is a string that identifies the web browser, `navigator.language`
    is the user’s preferred language, and `navigator.hardwareConcurrency` returns
    the number of logical CPUs available to the web browser. Similarly, the global
    `screen` property provides access to the user’s display size via the `screen.width`
    and `screen.height` properties. In a sense, these `navigator` and `screen` objects
    are to web browsers what environment variables are to Node programs.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局的`navigator`属性提供了关于网络浏览器、其运行的操作系统以及每个操作系统的功能的信息。例如，`navigator.userAgent`是一个标识网络浏览器的字符串，`navigator.language`是用户首选语言，`navigator.hardwareConcurrency`返回可用于网络浏览器的逻辑
    CPU 数量。类似地，全局的`screen`属性通过`screen.width`和`screen.height`属性提供了用户的显示尺寸访问。在某种意义上，这些`navigator`和`screen`对象对于网络浏览器来说就像环境变量对于
    Node 程序一样。
- en: Client-side JavaScript typically produces output, when it needs to, by manipulating
    the HTML document with the DOM API ([§15.3](#dom)) or by using a higher-level
    framework such as React or Angular to manipulate the document. Client-side code
    can also use `console.log()` and related methods ([§11.8](ch11.xhtml#consoleapi))
    to produce output. But this output is only visible in the web developer console,
    so it is useful when debugging, but not for user-visible output.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 JavaScript 通常通过使用 DOM API（[§15.3](#dom)）操纵 HTML 文档或使用更高级的框架如 React 或 Angular
    来操纵文档来生成输出。客户端代码还可以使用 `console.log()` 和相关方法（[§11.8](ch11.xhtml#consoleapi)）生成输出。但这些输出只在
    Web 开发者控制台中可见，因此在调试时很有用，但不适用于用户可见的输出。
- en: 15.1.7 Program Errors
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.7 程序错误
- en: Unlike applications (such as Node applications) that run directly on top of
    the OS, JavaScript programs in a web browser can’t really “crash.” If an exception
    occurs while your JavaScript program is running, and if you do not have a `catch`
    statement to handle it, an error message will be displayed in the developer console,
    but any event handlers that have been registered keep running and responding to
    events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接运行在操作系统之上的应用程序（如 Node 应用程序）不同，Web 浏览器中的 JavaScript 程序实际上不能真正“崩溃”。如果在运行 JavaScript
    程序时发生异常，并且没有 `catch` 语句来处理它，将在开发者控制台中显示错误消息，但已注册的任何事件处理程序仍在运行并响应事件。
- en: If you would like to define an error handler of last resort to be invoked when
    this kind of uncaught exception occurs, set the `onerror` property of the Window
    object to an error handler function. When an uncaught exception propagates all
    the way up the call stack and an error message is about to be displayed in the
    developer console, the `window.onerror` function will be invoked with three string
    arguments. The first argument to `window.onerror` is a message describing the
    error. The second argument is a string that contains the URL of the JavaScript
    code that caused the error. The third argument is the line number within the document
    where the error occurred. If the `onerror` handler returns `true`, it tells the
    browser that the handler has handled the error and that no further action is necessary—in
    other words, the browser should not display its own error message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想定义一个最后一道防线的错误处理程序，在发生此类未捕获异常时调用，将 Window 对象的 `onerror` 属性设置为一个错误处理程序函数。当未捕获的异常传播到调用堆栈的最顶层并且即将在开发者控制台中显示错误消息时，`window.onerror`
    函数将被调用，带有三个字符串参数。`window.onerror` 的第一个参数是描述错误的消息。第二个参数是一个包含导致错误的 JavaScript 代码的
    URL 的字符串。第三个参数是错误发生的文档中的行号。如果 `onerror` 处理程序返回 `true`，它告诉浏览器处理程序已处理了错误，不需要进一步操作——换句话说，浏览器不应显示自己的错误消息。
- en: 'When a Promise is rejected and there is no `.catch()` function to handle it,
    that is a situation much like an unhandled exception: an unanticipated error or
    a logic error in your program. You can detect this by defining a `window.onunhandledrejection`
    function or by using `window.addEventListener()` to register a handler for “unhandledrejection”
    events. The event object passed to this handler will have a `promise` property
    whose value is the Promise object that rejected and a `reason` property whose
    value is what would have been passed to a `.catch()` function. As with the error
    handlers described earlier, if you call `preventDefault()` on the unhandled rejection
    event object, it will be considered handled and won’t cause an error message in
    the developer console.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Promise 被拒绝且没有 `.catch()` 函数来处理它时，这就像未处理的异常：您的程序中出现了意外错误或逻辑错误。您可以通过定义 `window.onunhandledrejection`
    函数或使用 `window.addEventListener()` 注册一个“unhandledrejection”事件处理程序来检��这种情况。传递给此处理程序的事件对象将具有一个
    `promise` 属性，其值是被拒绝的 Promise 对象，以及一个 `reason` 属性，其值是将传递给 `.catch()` 函数的内容。与前面描述的错误处理程序一样，如果在未处理的拒绝事件对象上调用
    `preventDefault()`，它将被视为已处理，并且不会在开发者控制台中引发错误消息。
- en: It is not often necessary to define `onerror` or `onunhandledrejection` handlers,
    but it can be quite useful as a telemetry mechanism if you want to report client-side
    errors to the server (using the `fetch()` function to make an HTTP POST request,
    for example) so that you can get information about unexpected errors that happen
    in your users’ browsers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `onerror` 或 `onunhandledrejection` 处理程序通常不是必需的，但如果您想要将客户端错误报告给服务器（例如使用 `fetch()`
    函数进行 HTTP POST 请求），以便获取有关用户浏览器中发生的意外错误的信息，这可能非常有用。
- en: 15.1.8 The Web Security Model
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.8 Web 安全模型
- en: 'The fact that web pages can execute arbitrary JavaScript code on your personal
    device has clear security implications, and browser vendors have worked hard to
    balance two competing goals:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Web 页面可以在您的个人设备上执行任意 JavaScript 代码这一事实具有明显的安全影响，浏览器供应商努力平衡两个竞争目标：
- en: Defining powerful client-side APIs to enable useful web applications
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义强大的客户端 API 以实现有用的 Web 应用程序
- en: Preventing malicious code from reading or altering your data, compromising your
    privacy, scamming you, or wasting your time
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止恶意代码读取或更改您的数据，危害您的隐私，欺诈您，或浪费您的时间
- en: The subsections that follow give a quick overview of the security restrictions
    and issues that you, as a JavaScript programmer, should to be aware of.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节快速概述了您作为 JavaScript 程序员应该了解的安全限制和问题。
- en: What JavaScript can’t do
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript 不能做什么
- en: Web browsers’ first line of defense against malicious code is that they simply
    do not support certain capabilities. For example, client-side JavaScript does
    not provide any way to write or delete arbitrary files or list arbitrary directories
    on the client computer. This means a JavaScript program cannot delete data or
    plant viruses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Web 浏览器对抗恶意代码的第一道防线是它们根本不支持某些功能。例如，客户端 JavaScript 不提供任何方法来写入或删除客户端计算机上的任意文件或列出任意目录。这意味着
    JavaScript 程序无法删除数据或植入病毒。
- en: Similarly, client-side JavaScript does not have general-purpose networking capabilities.
    A client-side JavaScript program can make HTTP requests ([§15.11.1](#fetch)).
    And another standard, known as WebSockets ([§15.11.3](#websockets)), defines a
    socket-like API for communicating with specialized servers. But neither of these
    APIs allows unmediated access to the wider network. General-purpose internet clients
    and servers cannot be written in client-side JavaScript.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，客户端JavaScript没有通用的网络功能。客户端JavaScript程序可以发出HTTP请求（[§15.11.1](#fetch)）。另一个名为WebSockets的标准（[§15.11.3](#websockets)）定义了一个类似套接字的API，用于与专用服务器通信。但是这些API都不允许直接访问更广泛的网络。通用的互联网客户端和服务器不能使用客户端JavaScript编写。
- en: The same-origin policy
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同源策略
- en: The *same-origin policy* is a sweeping security restriction on what web content
    JavaScript code can interact with. It typically comes into play when a web page
    includes `<iframe>` elements. In this case, the same-origin policy governs the
    interactions of JavaScript code in one frame with the content of other frames.
    Specifically, a script can read only the properties of windows and documents that
    have the same origin as the document that contains the script.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*同源策略*是对JavaScript代码可以与之交互的Web内容的广泛安全限制。当一个网页包含`<iframe>`元素时，通常会出现这种情况。在这种情况下，同源策略规定了一个框架中的JavaScript代码与其他框架内容的交互。具体来说，脚本只能读取与包含脚本的文档具有相同源的窗口和文档的属性。'
- en: The origin of a document is defined as the protocol, host, and port of the URL
    from which the document was loaded. Documents loaded from different web servers
    have different origins. Documents loaded through different ports of the same host
    have different origins. And a document loaded with the `http:` protocol has a
    different origin than one loaded with the `https:` protocol, even if they come
    from the same web server. Browsers typically treat every `file:` URL as a separate
    origin, which means that if you’re working on a program that displays more than
    one document from the same server, you may not be able to test it locally using
    `file:` URLs and will have to run a static web server during development.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的源被定义为文档加载的URL的协议、主机和端口。从不同web服务器加载的文档具有不同的源。通过同一主机的不同端口加载的文档具有不同的源。使用`http:`协议加载的文档与使用`https:`协议加载的文档具有不同的源，即使它们来自同一web服务器。浏览器通常将每个`file:`
    URL视为单独的源，这意味着如果您正在开发一个显示来自同一服务器的多个文档的程序，您可能无法使用`file:` URL在本地进行测试，而必须在开发过程中运行一个静态web服务器。
- en: 'It is important to understand that the origin of the script itself is not relevant
    to the same-origin policy: what matters is the origin of the document in which
    the script is embedded. Suppose, for example, that a script hosted by host A is
    included (using the `src` property of a `<script>` element) in a web page served
    by host B. The origin of that script is host B, and the script has full access
    to the content of the document that contains it. If the document contains an `<iframe>`
    that contains a second document from host B, then the script also has full access
    to the content of that second document. But if the top-level document contains
    another `<iframe>` that displays a document from host C (or even one from host
    A), then the same-origin policy comes into effect and prevents the script from
    accessing this nested document.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解脚本本身的源对同源策略不重要：重要的是脚本嵌入的文档的源。例如，假设由主机A托管的脚本被包含在由主机B提供的网页中（使用`<script>`元素的`src`属性）。该脚本的源是主机B，并且脚本可以完全访问包含它的文档的内容。如果文档包含一个来自主机B的第二个文档的`<iframe>`，那么脚本也可以完全访问该第二个文档的内容。但是，如果顶级文档包含另一个显示来自主机C（甚至来自主机A）的文档的`<iframe>`，那么同源策略就会生效，并阻止脚本访问这个嵌套文档。
- en: The same-origin policy also applies to scripted HTTP requests (see [§15.11.1](#fetch)).
    JavaScript code can make arbitrary HTTP requests to the web server from which
    the containing document was loaded, but it does not allow scripts to communicate
    with other web servers (unless those web servers opt in with CORS, as we describe
    next).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略也适用于脚本化的HTTP请求（参见[§15.11.1](#fetch)）。JavaScript代码可以向包含文档所在的web服务器发出任意HTTP请求，但它不允许脚本与其他web服务器通信（除非这些web服务器通过CORS选择加入，我们将在下文描述）。
- en: The same-origin policy poses problems for large websites that use multiple subdomains.
    For example, scripts with origin *orders.example.com* might need to read properties
    from documents on *example.com*. To support multidomain websites of this sort,
    scripts can alter their origin by setting `document.domain` to a domain suffix.
    So a script with origin *[*https://orders.example.com*](https://orders.example.com)*
    can change its origin to *[*https://example.com*](https://example.com)* by setting
    `document.domain` to “example.com.” But that script cannot set `document.domain`
    to “orders.example”, “ample.com”, or “com”.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同源策略对使用多个子域的大型网站造成问题。例如，源自*orders.example.com*的脚本可能需要从*example.com*的文档中读取属性。为了支持这种多域网站，脚本可以通过将`document.domain`设置为域后缀来更改其源。因此，源自[*https://orders.example.com*](https://orders.example.com)的脚本可以通过将`document.domain`设置为“example.com”来将其源更改为[*https://example.com*](https://example.com)。但是该脚本不能将`document.domain`设置为“orders.example”、“ample.com”或“com”。
- en: The second technique for relaxing the same-origin policy is Cross-Origin Resource
    Sharing, or CORS, which allows servers to decide which origins they are willing
    to serve. CORS extends HTTP with a new `Origin:` request header and a new `Access-Control-Allow-Origin`
    response header. It allows servers to use a header to explicitly list origins
    that may request a file or to use a wildcard and allow a file to be requested
    by any site. Browsers honor these CORS headers and do not relax same-origin restrictions
    unless they are present.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 放宽同源策略的第二种技术是跨域资源共享（CORS），它允许服务器决定愿意提供哪些来源。CORS 使用一个新的 `Origin:` 请求头和一个新的 `Access-Control-Allow-Origin`
    响应头来扩展 HTTP。它允许服务器使用一个头来明确列出可以请求文件的来源，或者使用通配符允许任何站点请求文件。浏览器遵守这些 CORS 头，并且除非它们存在，否则不放宽同源限制。
- en: Cross-site scripting
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站脚本
- en: '*Cross-site scripting*, or XSS, is a term for a category of security issues
    in which an attacker injects HTML tags or scripts into a target website. Client-side
    JavaScript programmers must be aware of, and defend against, cross-site scripting.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站脚本*，或 XSS，是一种安全问题类别，攻击者向目标网站注入 HTML 标记或脚本。客户端 JavaScript 程序员必须意识到并防范跨站脚本。'
- en: 'A web page is vulnerable to cross-site scripting if it dynamically generates
    document content and bases that content on user-submitted data without first “sanitizing”
    that data by removing any embedded HTML tags from it. As a trivial example, consider
    the following web page that uses JavaScript to greet the user by name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网页动态生成文档内容并且基于用户提交的数据而不先通过“消毒”该数据来删除其中嵌入的 HTML 标记，则该网页容易受到跨站脚本攻击。作为一个简单的例子，考虑以下使用
    JavaScript 通过名称向用户问候的网页：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This two-line script extracts input from the “name” query parameter of the
    document URL. It then uses the DOM API to inject an HTML string into the first
    `<h1>` tag in the document. This page is intended to be invoked with a URL like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个两行脚本从文档 URL 的“name”查询参数中提取输入。然后使用 DOM API 将 HTML 字符串注入到文档中的第一个 `<h1>` 标签中。此页面旨在通过以下
    URL 调用：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When used like this, it displays the text “Hello David.” But consider what
    happens when it is invoked with this query parameter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当像这样使用时，它会显示文本“Hello David。”但考虑一下当它被调用时会发生什么：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When the URL-escaped parameters are decoded, this URL causes the following
    HTML to be injected into the document:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当 URL 转义参数被解码时，此 URL 导致以下 HTML 被注入到文档中：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After the image loads, the string of JavaScript in the `onload` attribute is
    executed. The global `alert()` function displays a modal dialogue box. A single
    dialogue box is relatively benign but demonstrates that arbitrary code execution
    is possible on this site because it displays unsanitized HTML.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图像加载完成后，`onload` 属性中的 JavaScript 字符串将被执行。全局 `alert()` 函数会显示一个模态对话框。单个对话框相对无害，但表明在该网站上可能存在任意代码执行，因为它显示了未经过滤的
    HTML。
- en: Cross-site scripting attacks are so called because more than one site is involved.
    Site B includes a specially crafted link (like the one in the previous example)
    to site A. If site B can convince users to click the link, they will be taken
    to site A, but that site will now be running code from site B. That code might
    deface the page or cause it to malfunction. More dangerously, the malicious code
    could read cookies stored by site A (perhaps account numbers or other personally
    identifying information) and send that data back to site B. The injected code
    could even track the user’s keystrokes and send that data back to site B.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击之所以被称为如此，是因为涉及到多个站点。站点 B 包含一个特制链接（就像前面示例中的那个）到站点 A。如果站点 B 能说服用户点击该链接，他们将被带到站点
    A，但该站点现在将运行来自站点 B 的代码。该代码可能破坏页面或导致其功能失效。更危险的是，恶意代码可能读取站点 A 存储的 cookie（也许是账号号码或其他个人身份信息）并将数据发送回站点
    B。注入的代码甚至可以跟踪用户的按键操作并将数据发送回站点 B。
- en: 'In general, the way to prevent XSS attacks is to remove HTML tags from any
    untrusted data before using it to create dynamic document content. You can fix
    the *greet.html* file shown earlier by replacing special HTML characters in the
    untrusted input string with their equivalent HTML entities:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，防止 XSS 攻击的方法是在使用未受信任的数据创建动态文档内容之前，从中删除 HTML 标记。你可以通过用等效的 HTML 实体替换未受信任输入字符串中的特殊
    HTML 字符来修复之前显示的 *greet.html* 文件：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another approach to the problem of XSS is to structure your web applications
    so that untrusted content is always displayed in an `<iframe>` with the `sandbox`
    attribute set to disable scripting and other capabilities.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 XSS 问题的另一种方法是构建您的 Web 应用程序，使得不受信任的内容始终显示在具有设置为禁用脚本和其他功能的 `sandbox` 属性的 `<iframe>`
    中。
- en: Cross-site scripting is a pernicious vulnerability whose roots go deep into
    the architecture of the web. It is worth understanding this vulnerability in-depth,
    but further discussion is beyond the scope of this book. There are many online
    resources to help you defend against cross-site scripting.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本是一种根深蒂固的漏洞，其根源深入到网络架构中。值得深入了解这种漏洞，但进一步讨论超出了本书的范围。有许多在线资源可帮助您防范跨站脚本。
- en: 15.2 Events
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2 事件
- en: 'Client-side JavaScript programs use an asynchronous event-driven programming
    model. In this style of programming, the web browser generates an *event* whenever
    something interesting happens to the document or browser or to some element or
    object associated with it. For example, the web browser generates an event when
    it finishes loading a document, when the user moves the mouse over a hyperlink,
    or when the user strikes a key on the keyboard. If a JavaScript application cares
    about a particular type of event, it can register one or more functions to be
    invoked when events of that type occur. Note that this is not unique to web programming:
    all applications with graphical user interfaces are designed this way—they sit
    around waiting to be interacted with (i.e., they wait for events to occur), and
    then they respond.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端JavaScript程序使用异步事件驱动的编程模型。在这种编程风格中，当文档或浏览器或与之关联的某个元素或对象发生有趣的事情时，Web浏览器会生成一个*事件*。例如，当Web浏览器完成加载文档时，当用户将鼠标移动到超链接上时，或者当用户在键盘上按下键时，Web浏览器会生成一个事件。如果JavaScript应用程序关心特定类型的事件，它可以注册一个或多个函数，在发生该类型的事件时调用这些函数。请注意，这并不是Web编程的独有特性：所有具有图形用户界面的应用程序都是这样设计的——它们等待与之交互（即，它们等待事件发生），然后做出响应。
- en: 'In client-side JavaScript, events can occur on any element within an HTML document,
    and this fact makes the event model of web browsers significantly more complex
    than Node’s event model. We begin this section with some important definitions
    that help to explain that event model:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端JavaScript中，事件可以发生在HTML文档中的任何元素上，这一事实使得Web浏览器的事件模型比Node的事件模型复杂得多。我们从一些重要的定义开始，这些定义有助于解释事件模型：
- en: event type
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 事件类型
- en: This string specifies what kind of event occurred. The type “mousemove,” for
    example, means that the user moved the mouse. The type “keydown” means that the
    user pressed a key on the keyboard down. And the type “load” means that a document
    (or some other resource) has finished loading from the network. Because the type
    of an event is just a string, it’s sometimes called an *event name*, and indeed,
    we use this name to identify the kind of event we’re talking about.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此字符串指定发生的事件类型。例如，“mousemove”类型表示用户移动了鼠标。“keydown”类型表示用户按下键盘上的键。而“load”类型表示文档（或其他资源）已经从网络加载完成。由于事件类型只是一个字符串，有时被称为*事件名称*，确实，我们使用这个名称来识别我们所讨论的事件类型。
- en: event target
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件目标
- en: This is the object on which the event occurred or with which the event is associated.
    When we speak of an event, we must specify both the type and the target. A load
    event on a Window, for example, or a click event on a `<button>` Element. Window,
    Document, and Element objects are the most common event targets in client-side
    JavaScript applications, but some events are triggered on other kinds of objects.
    For example, a Worker object (a kind of thread, covered [§15.13](#webworkers))
    is a target for “message” events that occur when the worker thread sends a message
    to the main thread.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事件发生的对象或与之相关联的对象。当我们谈论事件时，必须同时指定类型和目标。例如，窗口上的加载事件，或`<button>`元素上的点击事件。窗口、文档和元素对象是客户端JavaScript应用程序中最常见的事件目标，但有些事件会在其他类型的对象上触发。例如，Worker对象（一种线程，在[§15.13](#webworkers)中介绍）是“message”事件的目标，当工作线程向主线程发送消息时会触发该事件。
- en: event handler, or event listener
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序，或事件监听器
- en: This function handles or responds to an event.^([2](ch15.xhtml#idm46198510122904))
    Applications register their event handler functions with the web browser, specifying
    an event type and an event target. When an event of the specified type occurs
    on the specified target, the browser invokes the handler function. When event
    handlers are invoked for an object, we say that the browser has “fired,” “triggered,”
    or “dispatched” the event. There are a number of ways to register event handlers,
    and the details of handler registration and invocation are explained in [§15.2.2](#handlerregistration)
    and [§15.2.3](#handlerinvocation).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数处理或响应事件。^([2](ch15.xhtml#idm46198510122904)) 应用程序通过指定事件类型和事件目标向Web浏览器注册其事件处理程序函数。当指定类型的事件发生在指定目标上时，浏览器会调用处理程序函数。当为对象调用事件处理程序时，我们说浏览器已经“触发”、“触发”或“分发”了事件。有多种注册事件处理程序的方法，处理程序注册和调用的详细信息在[§15.2.2](#handlerregistration)和[§15.2.3](#handlerinvocation)中有解释。
- en: event object
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象
- en: This object is associated with a particular event and contains details about
    that event. Event objects are passed as an argument to the event handler function.
    All event objects have a `type` property that specifies the event type and a `target`
    property that specifies the event target. Each event type defines a set of properties
    for its associated event object. The object associated with a mouse event includes
    the coordinates of the mouse pointer, for example, and the object associated with
    a keyboard event contains details about the key that was pressed and the modifier
    keys that were held down. Many event types define only a few standard properties—such
    as `type` and `target`—and do not carry much other useful information. For those
    events, it is the simple occurrence of the event, not the event details, that
    matter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象与特定事件相关联，并包含有关该事件的详细信息。事件对象作为参数传递给事件处理程序函数。所有事件对象都有一个`type`属性，指定事件类型，以及一个`target`属性，指定事件目标。每种事件类型为其关联的事件对象定义了一组属性。与鼠标事件相关联的对象包括鼠标指针的坐标，例如，与键盘事件相关联的对象包含有关按下的键和按下的修改键的详细信息。许多事件类型仅定义了一些标准属性，如`type`和`target`，并不包含其他有用信息。对于这些事件，事件的简单发生才是重要的，而不是事件的详细信息。
- en: event propagation
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件传播
- en: 'This is the process by which the browser decides which objects to trigger event
    handlers on. For events that are specific to a single object—such as the “load”
    event on the Window object or a “message” event on a Worker object—no propagation
    is required. But when certain kinds of events occur on elements within the HTML
    document, however, they propagate or “bubble” up the document tree. If the user
    moves the mouse over a hyperlink, the mousemove event is first fired on the `<a>`
    element that defines that link. Then it is fired on the containing elements: perhaps
    a `<p>` element, a `<section>` element, and the Document object itself. It is
    sometimes more convenient to register a single event handler on a Document or
    other container element than to register handlers on each individual element you’re
    interested in. An event handler can stop the propagation of an event so that it
    will not continue to bubble and will not trigger handlers on containing elements.
    Handlers do this by invoking a method of the event object. In another form of
    event propagation, known as *event capturing*, handlers specially registered on
    container elements have the opportunity to intercept (or “capture”) events before
    they are delivered to their actual target. Event bubbling and capturing are covered
    in detail in [§15.2.4](#eventpropagation).'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器决定触发事件处理程序的对象的过程。对于特定于单个对象的事件（例如Window对象上的“load”事件或Worker对象上的“message”事件），不需要传播。但是，对于发生在HTML文档中的元素上的某些类型的事件，它们会传播或“冒泡”到文档树上。如果用户将鼠标移动到超链接上，那么mousemove事件首先在定义该链接的`<a>`元素上触发。然后在包含元素上触发：可能是一个`<p>`元素，一个`<section>`元素，以及文档对象本身。有时，在文档或其他容器元素上注册一个事件处理程序比在每个感兴趣的单个元素上注册处理程序更方便。事件处理程序可以阻止事件的传播，使其不会继续冒泡并且不会触发包含元素上的处理程序。处理程序通过调用事件对象的方法来执行此操作。在另一种事件传播形式中，称为*事件捕获*，在容器元素上特别注册的处理程序有机会在事件传递到其实际目标之前拦截（或“捕获”）事件。事件冒泡和捕获在[§15.2.4](#eventpropagation)中有详细介绍。
- en: Some events have *default actions* associated with them. When a click event
    occurs on a hyperlink, for example, the default action is for the browser to follow
    the link and load a new page. Event handlers can prevent this default action by
    invoking a method of the event object. This is sometimes called “canceling” the
    event and is covered in [§15.2.5](#eventcancellation).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一些��件与*默认操作*相关联。例如，当单击超链接时，浏览器的默认操作是跟随链接并加载新页面。事件处理程序可以通过调用事件对象的方法来阻止此默认操作。这有时被称为“取消”事件，并在[§15.2.5](#eventcancellation)中有介绍。
- en: 15.2.1 Event Categories
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.1 事件类别
- en: 'Client-side JavaScript supports such a large number of event types that there
    is no way this chapter can cover them all. It can be useful, though, to group
    events into some general categories, to illustrate the scope and wide variety
    of supported events:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端JavaScript支持如此多的事件类型，以至于本章无法涵盖所有事件。然而，将事件分组到一些一般类别中可能是有用的，以说明支持的事件范围和各种各样的事件：
- en: Device-dependent input events
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与设备相关的输入事件
- en: These events are directly tied to a specific input device, such as the mouse
    or keyboard. They include event types such as “mousedown,” “mousemove,” “mouseup,”
    “touchstart,” “touchmove,” “touchend,” “keydown,” and “keyup.”
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件与特定的输入设备直接相关，例如鼠标或键盘。它们包括“mousedown”，“mousemove”，“mouseup”，“touchstart”，“touchmove”，“touchend”，“keydown”和“keyup”等事件类型。
- en: Device-independent input events
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与设备无关的输入事件
- en: These input events are not directly tied to a specific input device. The “click”
    event, for example, indicates that a link or button (or other document element)
    has been activated. This is often done via a mouse click, but it could also be
    done by keyboard or (on touch-sensitive devices) with a tap. The “input” event
    is a device-independent alternative to the “keydown” event and supports keyboard
    input as well as alternatives such as cut-and-paste and input methods used for
    ideographic scripts. The “pointerdown,” “pointermove,” and “pointerup” event types
    are device-independent alternatives to mouse and touch events. They work for mouse-type
    pointers, for touch screens, and for pen- or stylus-style input as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这些输入事件与特定的输入设备没有直接关联。例如，“click”事件表示链接或按钮（或其他文档元素）已被激活。通常是通过鼠标点击完成，但也可以通过键盘或（在触摸设备上）通过轻触完成。
    “input”事件是“keydown”事件的与设备无关的替代品，并支持键盘输入以及剪切和粘贴以及用于表意文字的输入方法等替代方法。 “pointerdown”，“pointermove”和“pointerup”事件类型是鼠标和触摸事件的与设备无关的替代品。它们适用于鼠标类型指针，触摸屏幕以及笔或笔式输入。
- en: User interface events
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面事件
- en: UI events are higher-level events, often on HTML form elements that define a
    user interface for a web application. They include the “focus” event (when a text
    input field gains keyboard focus), the “change” event (when the user changes the
    value displayed by a form element), and the “submit” event (when the user clicks
    a Submit button in a form).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: UI事件是更高级别的事件，通常在HTML表单元素上定义Web应用程序的用户界面。它们包括“focus”事件（当文本输入字段获得键盘焦点时），“change”事件（当用户更改表单元素显示的值时）和“submit”事件（当用户单击表单中的提交按钮时）。
- en: State-change events
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更改事件
- en: Some events are not triggered directly by user activity, but by network or browser
    activity, and indicate some kind of life-cycle or state-related change. The “load”
    and “DOMContentLoaded” events—fired on the Window and Document objects, respectively,
    at the end of document loading—are probably the most commonly used of these events
    (see [“Client-side JavaScript timeline”](#timeline)). Browsers fire “online” and
    “offline” events on the Window object when network connectivity changes. The browser’s
    history management mechanism ([§15.10.4](#pushstate)) fires the “popstate” event
    in response to the browser’s Back button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一些事件不是直接由用户活动触发的，而是由网络或浏览器活动触发的，并指示某种生命周期或状态相关的变化。“load”和“DOMContentLoaded”事件分别在文档加载结束时在
    Window 和 Document 对象上触发，可能是最常用的这些事件（参见[“客户端 JavaScript 时间线”](#timeline)）。浏览器在网络连接状态发生变化时在
    Window 对象上触发“online”和“offline”事件。浏览器的历史管理机制（[§15.10.4](#pushstate)）在响应浏览器的后退按钮时触发“popstate”事件。
- en: API-specific events
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于 API 的事件
- en: A number of web APIs defined by HTML and related specifications include their
    own event types. The HTML `<video>` and `<audio>` elements define a long list
    of associated event types such as “waiting,” “playing,” “seeking,” “volumechange,”
    and so on, and you can use them to customize media playback. Generally speaking,
    web platform APIs that are asynchronous and were developed before Promises were
    added to JavaScript are event-based and define API-specific events. The IndexedDB
    API, for example ([§15.12.3](#indexeddb)), fires “success” and “error” events
    when database requests succeed or fail. And although the new `fetch()` API ([§15.11.1](#fetch))
    for making HTTP requests is Promise-based, the XMLHttpRequest API that it replaces
    defines a number of API-specific event types.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 和相关规范定义的许多 Web API 包括它们自己的事件类型。HTML `<video>` 和 `<audio>` 元素定义了一长串相关事件类型，如“waiting”、“playing”、“seeking”、“volumechange”等，您可以使用它们来自定义媒体播放。一般来说，异步的
    Web 平台 API 在 JavaScript 添加 Promise 之前是基于事件的，并定义了特定于 API 的事件。例如，IndexedDB API（[§15.12.3](#indexeddb)）在数据库请求成功或失败时触发“success”和“error”事件。虽然用于发出
    HTTP 请求的新 `fetch()` API（[§15.11.1](#fetch)）是基于 Promise 的，但它替代的 XMLHttpRequest
    API 定义了许多特定于 API 的事件类型。
- en: 15.2.2 Registering Event Handlers
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册事件处理程序
- en: There are two basic ways to register event handlers. The first, from the early
    days of the web, is to set a property on the object or document element that is
    the event target. The second (newer and more general) technique is to pass the
    handler to the `addEventListener()` method of the object or element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注册事件处理程序有两种基本方法。第一种是来自 Web 早期的，在事件目标上设置对象或文档元素的属性。第二种（更新且更通用）技术是将处理程序传递给对象或元素的
    `addEventListener()` 方法。
- en: Setting event handler properties
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置事件处理程序属性
- en: 'The simplest way to register an event handler is by setting a property of the
    event target to the desired event handler function. By convention, event handler
    properties have names that consist of the word “on” followed by the event name:
    `onclick`, `onchange`, `onload`, `onmouseover`, and so on. Note that these property
    names are case sensitive and are written in all lowercase,^([3](ch15.xhtml#idm46198510064168))
    even when the event type (such as “mousedown”) consists of multiple words. The
    following code includes two event handler registrations of this kind:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注册事件处理程序的最简单方法是将事件目标的属性设置为所需的事件处理程序函数。按照惯例，事件处理程序属性的名称由单词“on”后跟事件名称组成：`onclick`、`onchange`、`onload`、`onmouseover`等。请注意，这些属性名称区分大小写，并且全部小写书写，即使事件类型（如“mousedown”）由多个单词组成。以下代码包括两种此类事件处理程序的注册：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The shortcoming of event handler properties is that they are designed around
    the assumption that event targets will have at most one handler for each type
    of event. It is often better to register event handlers using `addEventListener()`
    because that technique does not overwrite any previously registered handlers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序属性的缺点在于，它们设计时假设事件目标最多只有一个每种事件类型的处理程序。通常最好使用 `addEventListener()` 注册事件处理程序，因为该技术不会覆盖任何先前注册的处理程序。
- en: Setting event handler attributes
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置事件处理程序属性
- en: The event handler properties of document elements can also be defined directly
    in the HTML file as attributes on the corresponding HTML tag. (Handlers that would
    be registered on the Window element with JavaScript can be defined with attributes
    on the `<body>` tag in HTML.) This technique is generally frowned upon in modern
    web development, but it is possible, and it’s documented here because you may
    still see it in existing code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 文档元素的���件处理程序属性也可以直接在 HTML 文件中作为相应 HTML 标记的属性定义。在 HTML 中，可以使用在 `<body>` 标记上的属性定义应该在
    JavaScript 中注册在 Window 元素上的处理程序。尽管这种技术在现代 Web 开发中通常不受欢迎，但它是可能的，并且在此处记录，因为您可能仍然在现有代码中看到它。
- en: 'When defining an event handler as an HTML attribute, the attribute value should
    be a string of JavaScript code. That code should be the *body* of the event handler
    function, not a complete function declaration. That is, your HTML event handler
    code should not be surrounded by curly braces and prefixed with the `function`
    keyword. For example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当将事件处理程序定义为 HTML 属性时，属性值应为 JavaScript 代码的字符串。该代码应为事件处理程序函数的*主体*，而不是完整的函数声明。换句话说，您的
    HTML 事件处理程序代码不应被大括号包围并以 `function` 关键字为前缀。例如：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If an HTML event handler attribute contains multiple JavaScript statements,
    you must remember to separate those statements with semicolons or break the attribute
    value across multiple lines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTML 事件处理程序属性包含多个 JavaScript 语句，则必须记住使用分号分隔这些语句或将属性值跨多行断开。
- en: 'When you specify a string of JavaScript code as the value of an HTML event
    handler attribute, the browser converts your string into a function that works
    something like this one:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将 JavaScript 代码的字符串指定为 HTML 事件处理程序属性的值时，浏览器会将您的字符串转换为一个类似于这个函数的函数：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `event` argument means that your handler code can refer to the current event
    object as `event`. The `with` statements mean that the code of your handler can
    refer to the properties of the target object, the containing `<form>` (if any),
    and the containing Document object directly, as if they were variables in scope.
    The `with` statement is forbidden in strict mode ([§5.6.3](ch05.xhtml#strictmode)),
    but JavaScript code in HTML attributes is never strict. Event handlers defined
    in this way are executed in an environment in which unexpected variables are defined.
    This can be a source of confusing bugs and is a good reason to avoid writing event
    handlers in HTML.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`参数意味着您的处理程序代码可以将当前事件对象称为`event`。`with`语句意味着您的处理程序代码可以直接引用目标对象、包含的`<form>`（如果有）和包含的文档对象的属性，就像它们是作用域中的变量一样。`with`语句在严格模式下是禁止的（[§5.6.3](ch05.xhtml#strictmode)），但是HTML属性中的JavaScript代码永远不会是严格模式。以这种方式定义的事件处理程序在定义了意外变量的环境中执行。这可能是令人困惑的错误源，是避免在HTML中编写事件处理程序的一个很好的理由。'
- en: addEventListener()
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: addEventListener()
- en: Any object that can be an event target—this includes the Window and Document
    objects and all document Elements—defines a method named `addEventListener()`
    that you can use to register an event handler for that target. `addEventListener()`
    takes three arguments. The first is the event type for which the handler is being
    registered. The event type (or name) is a string that does not include the “on”
    prefix used when setting event handler properties. The second argument to `addEventListener()`
    is the function that should be invoked when the specified type of event occurs.
    The third argument is optional and is explained below.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以成为事件目标的对象——包括Window和Document对象以及所有文档元素——都定义了一个名为`addEventListener()`的方法，您可以使用该方法为该目标注册事件处理程序。`addEventListener()`接受三个参数。第一个是要注册处理程序的事件类型。事件类型（或名称）是一个字符串，不包括在设置事件处理程序属性时使用的“on”前缀。`addEventListener()`的第二个参数是应在发生指定类型事件时调用的函数。第三个参数是可选的，下面会解释。
- en: 'The following code registers two handlers for the “click” event on a `<button>`
    element. Note the differences between the two techniques used:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码为`<button>`元素注册了两个“click”事件处理程序。请注意两种技术之间的区别：
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Calling `addEventListener()` with “click” as its first argument does not affect
    the value of the `onclick` property. In this code, a button click will log two
    messages to the developer console. And if we called `addEventListener()` first
    and then set `onclick`, we would still log two messages, just in the opposite
    order. More importantly, you can call `addEventListener()` multiple times to register
    more than one handler function for the same event type on the same object. When
    an event occurs on an object, all of the handlers registered for that type of
    event are invoked in the order in which they were registered. Invoking `addEventListener()`
    more than once on the same object with the same arguments has no effect—the handler
    function remains registered only once, and the repeated invocation does not alter
    the order in which handlers are invoked.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`addEventListener()`时，第一个参数为“click”不会影响`onclick`属性的值。在此代码中，单击按钮将向开发者控制台记录两条消息。如果我们先调用`addEventListener()`然后设置`onclick`，我们仍然会记录两条消息，只是顺序相反。更重要的是，您可以多次调用`addEventListener()`为同一对象的同一事件类型注册多个处理程序函数。当对象上发生事件时，为该类型事件注册的所有处理程序按照注册顺序被调用。在同一对象上多次调用具有相同参数的`addEventListener()`不会产生任何效果——处理程序函数仅注册一次，并且重复调用不会改变调用处理程序的顺序。
- en: '`addEventListener()` is paired with a `removeEventListener()` method that expects
    the same two arguments (plus an optional third) but removes an event handler function
    from an object rather than adding it. It is often useful to temporarily register
    an event handler and then remove it soon afterward. For example, when you get
    a “mousedown” event, you might register temporary event handlers for “mousemove”
    and “mouseup” events so that you can see if the user drags the mouse. You’d then
    deregister these handlers when the “mouseup” event arrives. In such a situation,
    your event handler removal code might look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener()`与`removeEventListener()`方法配对使用，它期望相同的两个参数（加上可选的第三个参数），但是从对象中删除事件处理程序函数而不是添加它。通常有用的是暂时注册事件处理程序，然后不久之后将其删除。例如，当您获得“mousedown”事件时，您可能��为“mousemove”和“mouseup”事件注册临时事件处理程序，以便查看用户是否拖动鼠标。然后，当“mouseup”事件到达时，您将取消注册这些处理程序。在这种情况下，您的事件处理程序移除代码可能如下所示：'
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The optional third argument to `addEventListener()` is a boolean value or object.
    If you pass `true`, then your handler function is registered as a *capturing*
    event handler and is invoked at a different phase of event dispatch. We’ll cover
    event capturing in [§15.2.4](#eventpropagation). If you pass a third argument
    of `true` when you register an event listener, then you must also pass `true`
    as the third argument to `removeEventListener()` if you want to remove the handler.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener()`的可选第三个参数是布尔值或对象。如果传递`true`，则您的处理程序函数将被注册为*捕获*事件处理程序，并在事件分发的不同阶段被调用。我们将在[§15.2.4](#eventpropagation)中介绍事件捕获。如果在注册事件监听器时传递第三个参数为`true`，那么如果要删除处理程序，则必须在`removeEventListener()`的第三个参数中也传递`true`。'
- en: 'Registering a capturing event handler is only one of the three options that
    `addEventListener()` supports, and instead of passing a single boolean value,
    you can also pass an object that explicitly specifies the options you want:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注册捕获事件处理程序只是`addEventListener()`支持的三个选项之一，而不是传递单个布尔值，您还可以传递一个明确指定所需选项的对象：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the Options object has a `capture` property set to `true`, then the event
    handler will be registered as a capturing handler. If that property is `false`
    or is omitted, then the handler will be non-capturing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Options对象的`capture`属性设置为`true`，那么事件处理程序将被注册为捕获处理程序。如果该属性为`false`或被省略，则处理程序将为非捕获。
- en: If the Options object has a `once` property set to `true`, then the event listener
    will be automatically removed after it is triggered once. If this property is
    `false` or is omitted, then the handler is never automatically removed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Options对象的`once`属性设置为`true`，则事件侦听器将在触发一次后自动删除。如果此属性为`false`或省略，则处理程序永远不会自动删除。
- en: If the Options object has a `passive` property set to `true`, it indicates that
    the event handler will never call `preventDefault()` to cancel the default action
    (see [§15.2.5](#eventcancellation)). This is particularly important for touch
    events on mobile devices—if event handlers for “touchmove” events can prevent
    the browser’s default scrolling action, then the browser cannot implement smooth
    scrolling. This `passive` property provides a way to register a potentially disruptive
    event handler of this sort but lets the web browser know that it can safely begin
    its default behavior—such as scrolling—while the event handler is running. Smooth
    scrolling is so important for a good user experience that Firefox and Chrome make
    “touchmove” and “mousewheel” events passive by default. So if you actually want
    to register a handler that calls `preventDefault()` for one of these events, you
    should explicitly set the `passive` property to `false`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Options对象的`passive`属性设置为`true`，则表示事件处理程序永远不会调用`preventDefault()`来取消默认操作（参见[§15.2.5](#eventcancellation)）。这对于移动设备上的触摸事件尤为重要
    - 如果“touchmove”事件的事件处理程序可以阻止浏览器的默认滚动操作，那么浏览器无法实现平滑滚动。这个`passive`属性提供了一种注册这种潜在干扰性事件处理程序的方法，但让Web浏览器知道它可以安全地开始其默认行为
    - 例如滚动 - 而事件处理程序正在运行。平滑滚动对于良好的用户体验非常重要，因此Firefox和Chrome默认将“touchmove”和“mousewheel”事件设置为被动。因此，如果您确实想要注册一个调用`preventDefault()`的处理程序来处理这些事件中的一个，那么应明确将`passive`属性设置为`false`。
- en: You can also pass an Options object to `removeEventListener()`, but the `capture`
    property is the only one that is relevant. There is no need to specify `once`
    or `passive` when removing a listener, and these properties are ignored.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以向`removeEventListener()`传递一个Options对象，但`capture`属性是唯一相关的属性。在移除侦听器时，无需指定`once`或`passive`，这些属性将被忽略。
- en: 15.2.3 Event Handler Invocation
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.3事件处理程序调用
- en: Once you’ve registered an event handler, the web browser will invoke it automatically
    when an event of the specified type occurs on the specified object. This section
    describes event handler invocation in detail, explaining event handler arguments,
    the invocation context (the `this` value), and the meaning of the return value
    of an event handler.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注册了事件处理程序，当指定类型的事件发生在指定对象上时，Web浏览器将自动调用它。本节详细描述了事件处理程序的调用，解释了事件处理程序参数、调用上下文（`this`值）以及事件处理程序的返回值的含义。
- en: Event handler argument
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理程序参数
- en: 'Event handlers are invoked with an Event object as their single argument. The
    properties of the Event object provide details about the event:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理程序以一个Event对象作为它们的唯一参数调用。Event对象的属性提供有关事件的详细信息：
- en: '`type`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`'
- en: The type of the event that occurred.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事件类型。
- en: '`target`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`'
- en: The object on which the event occurred.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发生的对象。
- en: '`currentTarget`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentTarget`'
- en: For events that propagate, this property is the object on which the current
    event handler was registered.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 事件传播时，此属性是当前事件处理程序注册的对象。
- en: '`timeStamp`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeStamp`'
- en: A timestamp (in milliseconds) that represents when the event occurred but that
    does not represent an absolute time. You can determine the elapsed time between
    two events by subtracting the timestamp of the first event from the timestamp
    of the second.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 代表事件发生时间的时间戳（以毫秒为单位），但不代表绝对时间。您可以通过从第一个事件的时间戳中减去第二个事件的时间戳来确定两个事件之间的经过时间。
- en: '`isTrusted`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`isTrusted`'
- en: This property will be `true` if the event was dispatched by the web browser
    itself and `false` if the event was dispatched by JavaScript code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件是由Web浏览器本身分派的，则此属性将为`true`，如果事件是由JavaScript代码分派的，则此属性将为`false`。
- en: Specific kinds of events have additional properties. Mouse and pointer events,
    for example, have `clientX` and `clientY` properties that specify the window coordinates
    at which the event occurred.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类型的事件具有额外的属性。例如，鼠标和指针事件具有`clientX`和`clientY`属性，指定事件发生时的窗口坐标。
- en: Event handler context
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件处理程序上下文
- en: 'When you register an event handler by setting a property, it looks as if you
    are defining a new method on the target object:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过设置属性注册事件处理程序时，看起来就像您正在为目标对象定义一个新方法：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It isn’t surprising, therefore, that event handlers are invoked as methods of
    the object on which they are defined. That is, within the body of an event handler,
    the `this` keyword refers to the object on which the event handler was registered.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不足为奇，事件处理程序作为定义它们的对象的方法调用。也就是说，在事件处理程序的主体内，`this`关键字指的是注册事件处理程序的对象。
- en: 'Handlers are invoked with the target as their `this` value, even when registered
    using `addEventListener()`. This does not work for handlers defined as arrow functions,
    however: arrow functions always have the same `this` value as the scope in which
    they are defined.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序以目标作为它们的`this`值调用，即使使用`addEventListener()`注册。但是对于定义为箭头函数的处理程序，这种方式不起作用：箭头函数始终具有与其定义的作用域相同的`this`值。
- en: Handler return value
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理程序返回值
- en: In modern JavaScript, event handlers should not return anything. You may see
    event handlers that return values in older code, and the return value is typically
    a signal to the browser that it should not perform the default action associated
    with the event. If the `onclick` handler of a Submit button in a form returns
    `false`, for example, then the web browser will not submit the form (usually because
    the event handler determined that the user’s input fails client-side validation).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代JavaScript中，事件处理程序不应返回任何内容。您可能会在旧代码中看到返回值的事件处理程序，返回值通常是向浏览器发出信号，告诉它不要执行与事件关联的默认操作。例如，如果表单中的提交按钮的`onclick`处理程序返回`false`，那么Web浏览器将不会提交表单（通常是因为事件处理程序确定用户的输入未通过客户端验证）。
- en: The standard and preferred way to prevent the browser from performing a default
    action is to call the `preventDefault()` method ([§15.2.5](#eventcancellation))
    on the Event object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止浏览器执行默认操作的标准和首选方法是在事件对象上调用`preventDefault()`方法（[§15.2.5](#eventcancellation)）。
- en: Invocation order
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用顺序
- en: An event target may have more than one event handler registered for a particular
    type of event. When an event of that type occurs, the browser invokes all of the
    handlers in the order in which they were registered. Interestingly, this is true
    even if you mix event handlers registered with `addEventListener()` with an event
    handler registered on an object property like `onclick`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 事件目标可能对特定类型的事件注册了多个事件处理程序。当发生该类型的事件时，浏览器按照注册的顺序调用所有处理程序。有趣的是，即使您混合使用`addEventListener()`注册的事件处理程序和在对象属性上注册的事件处理程序（如`onclick`），这也是正确的。
- en: 15.2.4 Event Propagation
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.4 事件传播
- en: When the target of an event is the Window object or some other standalone object,
    the browser responds to an event simply by invoking the appropriate handlers on
    that one object. When the event target is a Document or document Element, however,
    the situation is more complicated.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件的目标是 Window 对象或其他独立对象时，浏览器只需调用该对象上的适当处理程序来响应事件。但是，当事件目标是 Document 或文档元素时，情况就更加复杂。
- en: 'After the event handlers registered on the target element are invoked, most
    events “bubble” up the DOM tree. The event handlers of the target’s parent are
    invoked. Then the handlers registered on the target’s grandparent are invoked.
    This continues up to the Document object, and then beyond to the Window object.
    Event bubbling provides an alternative to registering handlers on lots of individual
    document elements: instead, you can register a single handler on a common ancestor
    element and handle events there. You might register a “change” handler on a `<form>`
    element, for example, instead of registering a “change” handler for every element
    in the form.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用目标元素上注册的事件处理程序后，大多数事件会在 DOM 树中“冒泡”。将调用目标父级的事件处理程序。然后调用目标祖父级上注册的处理程序。这将一直持续到
    Document 对象，然后继续到 Window 对象。事件冒泡提供了一种替代方法，可以在共同祖先元素上注册单个处理程序，并在那里处理事件，而不是在许多单独的文档元素上注册处理程序。例如，您可以在`<form>`元素上注册一个“change”处理程序，而不是为表单中的每个元素注册“change”处理程序。
- en: Most events that occur on document elements bubble. Notable exceptions are the
    “focus,” “blur,” and “scroll” events. The “load” event on document elements bubbles,
    but it stops bubbling at the Document object and does not propagate on to the
    Window object. (The “load” event handlers of the Window object are triggered only
    when the entire document has loaded.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发生在文档元素上的事件都会冒泡。值得注意的例外是“focus”、“blur”和“scroll”事件。文档元素上的“load”事件会冒泡，但在 Document
    对象处停止冒泡，不会传播到 Window 对象上。（仅当整个文档加载完成时，Window 对象的“load”事件处理程序才会被触发。）
- en: Event bubbling is the third “phase” of event propagation. The invocation of
    the event handlers of the target object itself is the second phase. The first
    phase, which occurs even before the target handlers are invoked, is called the
    “capturing” phase. Recall that `addEventListener()` takes an optional third argument.
    If that argument is `true`, or `{capture:true}`, then the event handler is registered
    as a capturing event handler for invocation during this first phase of event propagation.
    The capturing phase of event propagation is like the bubbling phase in reverse.
    The capturing handlers of the Window object are invoked first, then the capturing
    handlers of the Document object, then of the body object, and so on down the DOM
    tree until the capturing event handlers of the parent of the event target are
    invoked. Capturing event handlers registered on the event target itself are not
    invoked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 事件冒泡是事件传播的第三个“阶段”。目标对象本身的事件处理程序的调用是第二阶段。第一阶段，甚至在调用目标处理程序之前发生，称为“捕获”阶段。请记住，`addEventListener()`接受一个可选的第三个参数。如果该参数为`true`或`{capture:true}`，则事件处理程序将被注册为捕获事件处理程序，在事件传播的第一阶段调用。事件传播的捕获阶段类似于反向的冒泡阶段。首先调用
    Window 对象的捕获处理程序，然后调用 Document 对象的捕获处理程序，然后是 body 对象，依此类推，直到调用事件目标的父级的捕获事件处理程序。在事件目标本身上注册的捕获事件处理程序不会被调用。
- en: Event capturing provides an opportunity to peek at events before they are delivered
    to their target. A capturing event handler can be used for debugging, or it can
    be used along with the event cancellation technique described in the next section
    to filter events so that the target event handlers are never actually invoked.
    One common use for event capturing is handling mouse drags, where mouse motion
    events need to be handled by the object being dragged, not the document elements
    over which it is dragged.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 事件捕获提供了一个机会，在事件传递到目标之前查看事件。捕获事件处理程序可用于调试，或者可以与下一���描述的事件取消技术一起使用，以过滤事件，从而永远不会实际调用目标事件处理程序。事件捕获的一个常见用途是处理鼠标拖动，其中需要由被拖动的对象处理鼠标移动事件，而不是文档元素。
- en: 15.2.5 Event Cancellation
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.5 事件取消
- en: 'Browsers respond to many user events, even if your code does not: when the
    user clicks the mouse on a hyperlink, the browser follows the link. If an HTML
    text input element has the keyboard focus and the user types a key, the browser
    will enter the user’s input. If the user moves their finger across a touch-screen
    device, the browser scrolls. If you register an event handler for events like
    these, you can prevent the browser from performing its default action by invoking
    the `preventDefault()` method of the event object. (Unless you registered the
    handler with the `passive` option, which makes `preventDefault()` ineffective.)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器会响应许多用户事件，即使您的代码没有：当用户在超链接上单击鼠标时，浏览器会跟随链接。如果 HTML 文本输入元素具有键盘焦点并且用户键入键，则浏览器将输入用户的输入。如果用户在触摸屏设备上移动手指，则浏览器会滚动。如果您为此类事件注册了事件处理程序，可以通过调用事件对象的`preventDefault()`方法来阻止浏览器执行其默认操作。（除非您使用`passive`选项注册了处理程序，这会使`preventDefault()`无效。）
- en: Canceling the default action associated with an event is only one kind of event
    cancellation. We can also cancel the propagation of events by calling the `stopPropagation()`
    method of the event object. If there are other handlers defined on the same object,
    the rest of those handlers will still be invoked, but no event handlers on any
    other object will be invoked after `stopPropagation()` is called. `stopPropagation()`
    works during the capturing phase, at the event target itself, and during the bubbling
    phase. `stopImmediatePropagation()` works like `stopPropagation()`, but it also
    prevents the invocation of any subsequent event handlers registered on the same
    object.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 取消与事件关联的默认操作只是一种事件取消的方式。我们还可以通过调用事件对象的`stopPropagation()`方法来取消事件的传播。如果在同一对象上定义了其他处理程序，则其余处理程序仍将被调用，但在调用`stopPropagation()`后不会调用任何其他对象上的事件处理程序。`stopPropagation()`在捕获阶段、事件目标本身以及冒泡阶段起作用。`stopImmediatePropagation()`的工作方式类似于`stopPropagation()`，但它还阻止调用在同一对象上注册的任何后续事件处理程序。
- en: 15.2.6 Dispatching Custom Events
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.6 分派自定义事件
- en: Client-side JavaScript’s event API is a relatively powerful one, and you can
    use it to define and dispatch your own events. Suppose, for example, that your
    program periodically needs to perform a long calculation or make a network request
    and that, while this operation is pending, other operations are not possible.
    You want to let the user know about this by displaying “spinners” to indicate
    that the application is busy. But the module that is busy should not need to know
    where the spinners should be displayed. Instead, that module might just dispatch
    an event to announce that it is busy and then dispatch another event when it is
    no longer busy. Then, the UI module can register event handlers for those events
    and take whatever UI actions are appropriate to notify the user.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端JavaScript的事件API是一个相对强大的API，您可以使用它来定义和分派自己的事件。例如，假设您的程序需要定期执行长时间计算或进行网络请求，并且在此操作挂起期间，其他操作是不可能的。您希望通过显示“旋转器”来告知用户应用程序正在忙碌。但是忙碌的模块不需要知道旋转器应该显示在哪里。相反，该模块可能只需分派一个事件来宣布它正在忙碌，然后在不再忙碌时再分派另一个事件。然后，UI模块可以为这些事件注册事件处理程序，并采取适当的UI操作来通知用户。
- en: 'If a JavaScript object has an `addEventListener()` method, then it is an “event
    target,” and this means it also has a `dispatchEvent()` method. You can create
    your own event object with the `CustomEvent()` constructor and pass it to `dispatchEvent()`.
    The first argument to `CustomEvent()` is a string that specifies the type of your
    event, and the second argument is an object that specifies the properties of the
    event object. Set the `detail` property of this object to a string, object, or
    other value that represents the content of your event. If you plan to dispatch
    your event on a document element and want it to bubble up the document tree, add
    `bubbles:true` to the second argument:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个JavaScript对象有一个`addEventListener()`方法，那么它是一个“事件目标”，这意味着它也有一个`dispatchEvent()`方法。您可以使用`CustomEvent()`构造函数创建自己的事件对象，并将其传递给`dispatchEvent()`。`CustomEvent()`的第一个参数是一个字符串，指定您的事件类型，第二个参数是一个指定事件对象属性的对象。将此对象的`detail`属性设置为表示事件内容的字符串、对象或其他值。如果计划在文档元素上分派事件并希望它冒泡到文档树，将`bubbles:true`添加到第二个参数中：
- en: '[PRE17]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 15.3 Scripting Documents
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.3 脚本化文档
- en: Client-side JavaScript exists to turn static HTML documents into interactive
    web applications. So scripting the content of web pages is really the central
    purpose of JavaScript.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端JavaScript存在的目的是将静态HTML文档转换为交互式Web应用程序。因此，脚本化Web页面的内容确实是JavaScript的核心目的。
- en: Every Window object has a `document` property that refers to a Document object.
    The Document object represents the content of the window, and it is the subject
    of this section. The Document object does not stand alone, however. It is the
    central object in the DOM for representing and manipulating document content.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Window对象都有一个指向Document对象的`document`属性。Document对象代表窗口的内容，本节的主题就是它。然而，Document对象并不是独立存在的。它是DOM中用于表示和操作文档内容的中心对象。
- en: 'The DOM was introduced in [§15.1.2](#domintro). This section explains the API
    in detail. It covers:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: DOM是在[§15.1.2](#domintro)中介绍的。本节详细解释了API。它涵盖了：
- en: How to query or *select* individual elements from a document.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从文档中查询或*选择*单个元素。
- en: How to *traverse* a document, and how to find the ancestors, siblings, and descendants
    of any document element.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何*遍历*文档，以及如何找到任何文档元素的祖先、同级和后代。
- en: How to query and set the attributes of document elements.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询和设置文档元素的属性。
- en: How to query, set, and modify the content of a document.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何查询、设置和修改文档的内容。
- en: How to modify the structure of a document by creating, inserting, and deleting
    nodes.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过创建、插入和删除节点来修改文档的结构。
- en: 15.3.1 Selecting Document Elements
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.1 选择文档元素
- en: Client-side JavaScript programs often need to manipulate one or more elements
    within the document. The global `document` property refers to the Document object,
    and the Document object has `head` and `body` properties that refer to the Element
    objects for the `<head>` and `<body>` tags, respectively. But a program that wants
    to manipulate an element embedded more deeply in the document must somehow obtain
    or *select* the Element objects that refer to those document elements.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端JavaScript程序经常需要操作文档中的一个或多个元素。全局的`document`属性指向Document对象，而Document对象有`head`和`body`属性，分别指向`<head>`和`<body>`标签的Element对象。但是，想要操作文档中嵌套更深的元素的程序必须以某种方式获取或*选择*指向这些文档元素的Element对象。
- en: Selecting elements with CSS selectors
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CSS选择器选择元素
- en: CSS stylesheets have a very powerful syntax, known as *selectors*, for describing
    elements or sets of elements within a document. The DOM methods `querySelector()`
    and `querySelectorAll()` allow us to find the element or elements within a document
    that match a specified CSS selector. Before we cover the methods, we’ll start
    with a quick tutorial on CSS selector syntax.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 样式表具有非常强大的语法，称为*选择器*，用于描述文档中的元素或元素集。DOM 方法`querySelector()`和`querySelectorAll()`允许我们查找与指定
    CSS 选择器匹配的文档中的元素或元素。在介绍这些方法之前，我们将从快速教程开始，介绍 CSS 选择器语法。
- en: 'CSS selectors can describe elements by tag name, the value of their `id` attribute,
    or the words in their `class` attribute:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 选择器可以根据标签名、它们的`id`属性的值或它们的`class`属性中的单词描述元素：
- en: '[PRE18]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `#` character is used to match based on the `id` attribute, and the `.`
    character is used to match based on the `class` attribute. Elements can also be
    selected based on more general attribute values:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`#`字符用于基于`id`属性匹配，`.`字符用于基于`class`属性匹配。也可以根据更一般的属性值选择元素：'
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that these examples combine a tag name selector (or the `*` tag name wildcard)
    with an attribute selector. More complex combinations are also possible:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些示例将标签名选择器（或`*`标签名通配符）与属性选择器结合使用。还可以使用更复杂的组合：
- en: '[PRE20]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Selectors can also specify document structure:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器还可以指定文档结构：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If two selectors are separated by a comma, it means that we’ve selected elements
    that match either one of the selectors:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个选择器用逗号分隔，这意味着我们选择了匹配任一选择器的元素：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, CSS selectors allow us to refer to elements within a document
    by type, ID, class, attributes, and position within the document. The `querySelector()`
    method takes a CSS selector string as its argument and returns the first matching
    element in the document that it finds, or returns `null` if none match:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，CSS 选择器允许我们通过类型、ID、类、属性和文档中的位置引用文档中的元素。`querySelector()`方法将 CSS 选择器字符串作为其参数，并返回在文档中找到的第一个匹配元素，如果没有匹配项，则返回`null`：
- en: '[PRE23]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`querySelectorAll()` is similar, but it returns all matching elements in the
    document rather than just returning the first:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelectorAll()`类似，但它返回文档中所有匹配的元素，而不仅仅返回第一个：'
- en: '[PRE24]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The return value of `querySelectorAll()` is not an array of Element objects.
    Instead, it is an array-like object known as a NodeList. NodeList objects have
    a `length` property and can be indexed like arrays, so you can loop over them
    with a traditional `for` loop. NodeLists are also iterable, so you can use them
    with `for/of` loops as well. If you want to convert a NodeList into a true array,
    simply pass it to `Array.from()`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelectorAll()`的返回值不是 Element 对象的数组。相反，它是一种称为 NodeList 的类似数组的对象。NodeList
    对象具有`length`属性，并且可以像数组一样进行索引，因此您可以使用传统的`for`循环对它们进行循环。NodeLists 也是可迭代的，因此您也可以将它们与`for/of`循环一起使用。如果要将
    NodeList 转换为真正的数组，只需将其传递给`Array.from()`。'
- en: The NodeList returned by `querySelectorAll()` will have a `length` property
    set to 0 if there are not any elements in the document that match the specified
    selector.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelectorAll()`返回的 NodeList 如果文档中没有任何匹配的元素，则`length`属性将设置为 0。'
- en: '`querySelector()` and `querySelectorAll()` are implemented by the Element class
    as well as by the Document class. When invoked on an element, these methods will
    only return elements that are descendants of that element.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelector()`和`querySelectorAll()`也由 Element 类和 Document 类实现。当在元素上调用这些方法时，它们只会返回该元素的后代元素。'
- en: Note that CSS defines `::first-line` and `::first-letter` pseudoelements. In
    CSS, these match portions of text nodes rather than actual elements. They will
    not match if used with `querySelectorAll()` or `querySelector()`. Also, many browsers
    will refuse to return matches for the `:link` and `:visited` pseudoclasses, as
    this could expose information about the user’s browsing history.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，CSS 定义了`::first-line`和`::first-letter`伪元素。在 CSS 中，这些匹配文本节点的部分而不是实际元素。如果与`querySelectorAll()`或`querySelector()`一起使用，它们将不匹配。此外，许多浏览器将拒绝返回`：link`和`：visited`伪类的匹配项，因为这可能会暴露用户的浏览历史信息。
- en: 'Another CSS-based element selection method is `closest()`. This method is defined
    by the Element class and takes a selector as its only argument. If the selector
    matches the element it is invoked on, it returns that element. Otherwise, it returns
    the closest ancestor element that the selector matches, or returns `null` if none
    matched. In a sense, `closest()` is the opposite of `querySelector()`: `closest()`
    starts at an element and looks for a match above it in the tree, while `querySelector()`
    starts with an element and looks for a match below it in the tree. `closest()`
    can be useful when you have registered an event handler at a high level in the
    document tree. If you are handling a “click” event, for example, you might want
    to know whether it is a click a hyperlink. The event object will tell you what
    the target was, but that target might be the text inside a link rather than the
    hyperlink’s `<a>` tag itself. Your event handler could look for the nearest containing
    hyperlink like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种基于 CSS 的元素选择方法是`closest()`。该方法由 Element 类定义，以选择器作为其唯一参数。如果选择器与调用它的元素匹配，则返回该元素。否则，返回选择器匹配的最近祖先元素，如果没有匹配项，则返回`null`。在某种意义上，`closest()`是`querySelector()`的相反：`closest()`从一个元素开始，并在树中查找匹配项，而`querySelector()`从一个元素开始，并在树中查找匹配项。当您在文档树的高级别注册事件处理程序时，`closest()`可能很有用。例如，如果您处理“click”事件，您可能想知道它是否是单击超链接。事件对象将告诉您目标是什么，但该目标可能是链接内部的文本而不是超链接的`<a>`标签本身。您的事件处理程序可以这样查找最近的包含超链接：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is another way you might use `closest()`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可能使用`closest()`的另一种方式：
- en: '[PRE26]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The related method `matches()` does not return ancestors or descendants: it
    simply tests whether an element is matched by a CSS selector and returns `true`
    if so and `false` otherwise:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 相关方法`matches()`不返回祖先或后代：它只是测试一个元素是否被 CSS 选择器匹配，并在是这样时返回`true`，否则返回`false`：
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Other element selection methods
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他元素选择方法
- en: 'In addition to `querySelector()` and `querySelectorAll()`, the DOM also defines
    a number of older element selection methods that are more or less obsolete now.
    You may still see some of these methods (especially `getElementById()`) in use,
    however:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`querySelector()`和`querySelectorAll()`，DOM 还定义了一些更或多或少已经过时的元素选择方法。你可能仍然会看到一些这些方法（尤其是`getElementById()`）在使用中，然而：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Like `querySelectorAll()`, the methods in this code return a NodeList (except
    for `getElementById()`, which returns a single Element object). Unlike `querySelectorAll()`,
    however, the NodeLists returned by these older selection methods are “live,” which
    means that the length and content of the list can change if the document content
    or structure changes.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 像`querySelectorAll()`一样，这段代码中的方法返回一个 NodeList（除了`getElementById()`，它返回一个单个的
    Element 对象）。然而，与`querySelectorAll()`不同，这些旧的选择方法返回的 NodeList 是“活动的”，这意味着如果文档内容或结构发生变化，列表的长度和内容也会发生变化。
- en: Preselected elements
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预选元素
- en: 'For historical reasons, the Document class defines shortcut properties to access
    certain kinds of nodes. The `images`, `forms`, and `links` properties, for example,
    provide easy access to the `<img>`, `<form>`, and `<a>` elements (but only `<a>`
    tags that have an `href` attribute) of a document. These properties refer to HTMLCollection
    objects, which are much like NodeList objects, but they can additionally be indexed
    by element ID or name. With the `document.forms` property, for example, you can
    access the `<form id="address">` tag as:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史原因，Document 类定义了一些快捷属性来访问某些类型的节点。例如，`images`、`forms`和`links`属性提供了对文档中`<img>`、`<form>`和`<a>`元素（但只有具有`href`属性的`<a>`标签）的简单访问。这些属性指的是
    HTMLCollection 对象，它们很像 NodeList 对象，但可以通过元素 ID 或名称进行索引。例如，通过`document.forms`属性，你可以访问`<form
    id="address">`标签：
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: An even more outdated API for selecting elements is the `document.all` property,
    which is like an HTMLCollection for all elements in the document. `document.all`
    is deprecated, and you should no longer use it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更过时的用于选择元素的 API 是`document.all`属性，它类似于文档中所有元素的 HTMLCollection。`document.all`已被弃用，你不应该再使用它。
- en: 15.3.2 Document Structure and Traversal
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.2 文档结构和遍历
- en: 'Once you have selected an Element from a Document, you sometimes need to find
    structurally related portions (parent, siblings, children) of the document. When
    we are primarily interested in the Elements of a document instead of the text
    within them (and the whitespace between them, which is also text), there is a
    traversal API that allows us to treat a document as a tree of Element objects,
    ignoring Text nodes that are also part of the document. This traversal API does
    not involve any methods; it is simply a set of properties on Element objects that
    allow us to refer to the parent, children, and siblings of a given element:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从文档中选择了一个元素，有时候你需要找到文档的结构相关部分（父元素、兄弟元素、子元素）。当我们主要关注文档中的元素而不是其中的文本（以及文本之间的空白，这也是文本），有一个遍历
    API 允许我们将文档视为元素对象树，忽略文档中也包含的文本节点。这个遍历 API 不涉及任何方法；它只是一组元素对象上的属性，允许我们引用给定元素的父元素、子元素和兄弟元素：
- en: '`parentNode`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`parentNode`'
- en: This property of an element refers to the parent of the element, which will
    be another Element or a Document object.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个元素的属性指的是元素的父元素，它将是另一个元素或一个文档对象。
- en: '`children`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`children`'
- en: This NodeList contains the Element children of an element, but excludes non-Element
    children like Text nodes (and Comment nodes).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 NodeList 包含一个元素的元素子节点，但不包括非元素子节点，比如文本节点（和注释节点）。
- en: '`childElementCount`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`childElementCount`'
- en: The number of Element children. Returns the same value as `children.length`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 元素子节点的数量。返回与`children.length`相同的值。
- en: '`firstElementChild`, `lastElementChild`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstElementChild`, `lastElementChild`'
- en: These properties refer to the first and last Element children of an Element.
    They are `null` if the Element has no Element children.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性指的是一个元素的第一个和最后一个元素子节点。如果元素没有元素子节点，则它们为`null`。
- en: '`nextElementSibling`, `previousElementSibling`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextElementSibling`, `previousElementSibling`'
- en: These properties refer to the sibling Elements immediately before or immediately
    after an Element, or `null` if there is no such sibling.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性指的是元素的前一个或后一个兄弟元素，如果没有这样的兄弟元素则为`null`。
- en: 'Using these Element properties, the second child Element of the first child
    Element of the Document can be referred to with either of these expressions:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些元素属性，文档的第一个子元素的第二个子元素可以用以下任一表达式引用：
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: (In a standard HTML document, both of those expressions refer to the `<body>`
    tag of the document.)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: (在标准的 HTML 文档中，这两个表达式都指的是文档的`<body>`标签。)
- en: 'Here are two functions that demonstrate how you can use these properties to
    recursively do a depth-first traversal of a document invoking a specified function
    for every element in the document:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个函数，演示了如何使用这些属性递归地对文档进行深度优先遍历，对文档中的每个元素调用指定的函数：
- en: '[PRE31]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Documents as trees of nodes
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以节点树的形式的文档
- en: If you want to traverse a document or some portion of a document and do not
    want to ignore the Text nodes, you can use a different set of properties defined
    on all Node objects. This will allow you to see Elements, Text nodes, and even
    Comment nodes (which represent HTML comments in the document).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想遍历文档或文档的某个部分，并且不想忽略文本节点，你可以使用所有 Node 对象上��义的另一组属性。这将允许你看到元素、文本节点，甚至注释节点（代表文档中的
    HTML 注释）。
- en: 'All Node objects define the following properties:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Node 对象定义以下属性：
- en: '`parentNode`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`parentNode`'
- en: The node that is the parent of this one, or `null` for nodes like the Document
    object that have no parent.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点的父节点，对于没有父节点的节点来说为`null`。
- en: '`childNodes`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`childNodes`'
- en: A read-only NodeList that that contains all children (not just Element children)
    of the node.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只读的 NodeList，包含节点的所有子节点（不仅仅是元素子节点）。
- en: '`firstChild`, `lastChild`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstChild`, `lastChild`'
- en: The first and last child nodes of a node, or `null` if the node has no children.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点的第一个和最后一个子节点，或者如果节点没有子节点则为`null`。
- en: '`nextSibling`, `previousSibling`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextSibling`, `previousSibling`'
- en: The next and previous sibling nodes of a node. These properties connect nodes
    in a doubly linked list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的下一个和上一个兄弟节点。这些属性将节点连接成一个双向链表。
- en: '`nodeType`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeType`'
- en: A number that specifies what kind of node this is. Document nodes have value
    9. Element nodes have value 1. Text nodes have value 3. Comment nodes have value
    8.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个指定节点类型的数字。文档节点的值为9。元素节点的值为1。文本节点的值为3。注释节点的值为8。
- en: '`nodeValue`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeValue`'
- en: The textual content of a Text or Comment node.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Text或Comment节点的文本内容。
- en: '`nodeName`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeName`'
- en: The HTML tag name of an Element, converted to uppercase.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Element的HTML标签名，转换为大写。
- en: 'Using these Node properties, the second child node of the first child of the
    Document can be referred to with expressions like these:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些Node属性，可以使用以下表达式引用文档的第一个子节点的第二个子节点：
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Suppose the document in question is the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所讨论的文档如下：
- en: '[PRE33]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Then the second child of the first child is the `<body>` element. It has a `nodeType`
    of 1 and a `nodeName` of “BODY”.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第一个子节点的第二个子节点是`<body>`元素。它的`nodeType`为1，`nodeName`为“BODY”。
- en: Note, however, that this API is extremely sensitive to variations in the document
    text. If the document is modified by inserting a single newline between the `<html>`
    and the `<head>` tag, for example, the Text node that represents that newline
    becomes the first child of the first child, and the second child is the `<head>`
    element instead of the `<body>` element.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，此API对文档文本的变化非常敏感。例如，如果在`<html>`和`<head>`标签之间插入一个换行符修改了文档，那么表示该换行符的Text节点将成为第一个子节点的第一个子节点，第二个子节点将是`<head>`元素，而不是`<body>`元素。
- en: 'To demonstrate this Node-based traversal API, here is a function that returns
    all of the text within an element or document:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示基于Node的遍历API，这里是一个返回元素或文档中所有文本的函数：
- en: '[PRE34]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function is a demonstration only—in practice, you would simply write `e.textContent`
    to obtain the textual content of the element `e`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅用于演示—在实践中，您只需编写`e.textContent`即可获取元素`e`的文本内容。
- en: 15.3.3 Attributes
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.3 属性
- en: HTML elements consist of a tag name and a set of name/value pairs known as *attributes*.
    The `<a>` element that defines a hyperlink, for example, uses the value of its
    `href` attribute as the destination of the link.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素由标签名和一组称为*属性*的名称/值对组成。例如，定义超链接的`<a>`元素使用其`href`属性的值作为链接的目的地。
- en: The Element class defines general `getAttribute()`, `setAttribute()`, `hasAttribute()`,
    and `removeAttribute()` methods for querying, setting, testing, and removing the
    attributes of an element. But the attribute values of HTML elements (for all standard
    attributes of standard HTML elements) are available as properties of the HTMLElement
    objects that represent those elements, and it is usually much easier to work with
    them as JavaScript properties than it is to call `getAttribute()` and related
    methods.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Element类定义了用于查询、设置、测试和删除元素属性的通用`getAttribute()`、`setAttribute()`、`hasAttribute()`和`removeAttribute()`方法。但是HTML元素的属性值（对于所有标准HTML元素的标准属性）作为表示这些元素的HTMLElement对象的属性可用，并且通常更容易作为JavaScript属性处理，而不是调用`getAttribute()`和相关方法。
- en: HTML attributes as element properties
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTML属性作为元素属性
- en: 'The Element objects that represent the elements of an HTML document usually
    define read/write properties that mirror the HTML attributes of the elements.
    Element defines properties for the universal HTML attributes such as `id`, `title`,
    `lang`, and `dir` and event handler properties like `onclick`. Element-specific
    subtypes define attributes specific to those elements. To query the URL of an
    image, for example, you can use the `src` property of the HTMLElement that represents
    the `<img>` element:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表示HTML文档元素的Element对象通常定义了反映元素HTML属性的读/写属性。Element定义了通用HTML属性的属性，如`id`、`title`、`lang`和`dir`，以及像`onclick`这样的事件处理程序属性。特定于元素的子类型定义了特定于这些元素的属性。例如，要查询图像的URL，可以使用表示`<img>`元素的HTMLElement的`src`属性：
- en: '[PRE35]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Similarly, you might set the form-submission attributes of a `<form>` element
    with code like this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，你可以使用以下代码设置`<form>`元素的表单提交属性：
- en: '[PRE36]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For some elements, such as the `<input>` element, some HTML attribute names
    map to differently named properties. The HTML `value` attribute of an `<input>`,
    for example, is mirrored by the JavaScript `defaultValue` property. The JavaScript
    `value` property of the `<input>` element contains the user’s current input, but
    changes to the `value` property do not affect the `defaultValue` property nor
    the `value` attribute.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些元素，例如`<input>`元素，一些HTML属性名称映射到不同命名的属性。例如，`<input>`的HTML `value`属性在JavaScript中由`defaultValue`属性镜像。`<input>`元素的JavaScript
    `value`属性包含用户当前的输入，但对`value`属性的更改不会影响`defaultValue`属性或`value`属性。
- en: 'HTML attributes are not case sensitive, but JavaScript property names are.
    To convert an attribute name to the JavaScript property, write it in lowercase.
    If the attribute is more than one word long, however, put the first letter of
    each word after the first in uppercase: `defaultChecked` and `tabIndex`, for example.
    Event handler properties like `onclick` are an exception, however, and are written
    in lowercase.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: HTML属性不区分大小写，但JavaScript属性名称区分大小写。要将属性名称转换为JavaScript属性，将其写成小写。但是，如果属性超过一个单词，将第一个单词后的每个单词的第一个字母大写：例如，`defaultChecked`和`tabIndex`。但是，事件处理程序属性如`onclick`是一个例外，它们以小写形式编写。
- en: 'Some HTML attribute names are reserved words in JavaScript. For these, the
    general rule is to prefix the property name with “html”. The HTML `for` attribute
    (of the `<label>` element), for example, becomes the JavaScript `htmlFor` property.
    “class” is a reserved word in JavaScript, and the very important HTML `class`
    attribute is an exception to the rule: it becomes `className` in JavaScript code.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一些HTML属性名称在JavaScript中是保留字。对于这些属性，一般规则是在属性名称前加上“html”。例如，HTML `<label>`元素的`for`属性变为JavaScript的`htmlFor`属性。“class”是JavaScript中的保留字，而非常重要的HTML
    `class`属性是规则的例外：在JavaScript代码中变为`className`。
- en: The properties that represent HTML attributes usually have string values. But
    when the attribute is a boolean or numeric value (the `defaultChecked` and `maxLength`
    attributes of an `<input>` element, for example), the properties are booleans
    or numbers instead of strings. Event handler attributes always have functions
    (or `null`) as their values.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 代表 HTML 属性的属性通常具有字符串值。但是，当属性是布尔值或数字值（例如 `<input>` 元素的 `defaultChecked` 和 `maxLength`
    属性）时，属性是布尔值或数字，而不是字符串。事件处理程序属性始终具有函数（或 `null`）作为它们的值。
- en: Note that this property-based API for getting and setting attribute values does
    not define any way to remove an attribute from an element. In particular, the
    `delete` operator cannot be used for this purpose. If you need to delete an attribute,
    use the `removeAttribute()` method.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用于获取和设置属性值的基于属性的 API 不定义任何删除元素属性的方法。特别是，`delete` 运算符不能用于此目的。如果需要删除属性，请使用
    `removeAttribute()` 方法。
- en: The class attribute
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: class 属性
- en: 'The `class` attribute of an HTML element is a particularly important one. Its
    value is a space-separated list of CSS classes that apply to the element and affect
    how it is styled with CSS. Because `class` is a reserved word in JavaScript, the
    value of this attribute is available through the `className` property on Element
    objects. The `className` property can set and return the value of the `class`
    attribute as a string. But the `class` attribute is poorly named: its value is
    a list of CSS classes, not a single class, and it is common in client-side JavaScript
    programming to want to add and remove individual class names from this list rather
    than work with the list as a single string.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 元素的 `class` 属性是一个特别重要的属性。它的值是一个空格分隔的 CSS 类列表，适用于元素并影响其在 CSS 中的样式。由于 `class`
    在 JavaScript 中是一个保留字，因此此属性的值可以通过 Element 对象上的 `className` 属性获得。`className` 属性可以设置和返回
    `class` 属性的值作为字符串。但是 `class` 属性的命名不太合适：它的值是 CSS 类的列表，而不是单个类，通常在客户端 JavaScript
    编程中，希望从此列表中添加和删除单个类名，而不是将列表作为单个字符串处理。
- en: 'For this reason, Element objects define a `classList` property that allows
    you to treat the `class` attribute as a list. The value of the `classList` property
    is an iterable Array-like object. Although the name of the property is `classList`,
    it behaves more like a set of classes, and defines `add()`, `remove()`, `contains()`,
    and `toggle()` methods:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Element 对象定义了一个 `classList` 属性，允许您将 `class` 属性视为列表。`classList` 属性的值是一个可迭代的类似数组的对象。尽管属性的名称是
    `classList`，但它更像是一组类，并定义了 `add()`、`remove()`、`contains()` 和 `toggle()` 方法：
- en: '[PRE37]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Dataset attributes
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据集属性
- en: It is sometimes useful to attach additional information to HTML elements, typically
    when JavaScript code will be selecting those elements and manipulating them in
    some way. In HTML, any attribute whose name is lowercase and begins with the prefix
    “data-” is considered valid, and you can use them for any purpose. These “dataset
    attributes” will not affect the presentation of the elements on which they appear,
    and they define a standard way to attach additional data without compromising
    document validity.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在 HTML 元素上附加额外信息是有用的，通常是当 JavaScript 代码将选择这些元素并以某种方式操作它们时。在 HTML 中，任何名称为小写并以前缀“data-”开头的属性都被视为有效，您可以将它们用于任何目的。这些“数据集属性”不会影响它们所在元素的呈现，并且它们定义了一种标准的方法来附加额外数据，而不会影响文档的有效性。
- en: 'In the DOM, Element objects have a `dataset` property that refers to an object
    that has properties that correspond to the `data-` attributes with their prefix
    removed. Thus, `dataset.x` would hold the value of the `data-x` attribute. Hyphenated
    attributes map to camelCase property names: the attribute `data-section-number`
    becomes the property `dataset.sectionNumber`.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DOM 中，Element 对象具有一个 `dataset` 属性，指向一个对象，该对象具有与其前缀去除的 `data-` 属性对应的属性。因此，`dataset.x`
    将保存 `data-x` 属性的值。连字符属性映射到驼峰命名属性名称：属性 `data-section-number` 变为属性 `dataset.sectionNumber`。
- en: 'Suppose an HTML document contains this text:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个 HTML 文档包含以下文本：
- en: '[PRE38]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then you could write JavaScript like this to access that section number:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以编写如下 JavaScript 代码来访问该部分编号：
- en: '[PRE39]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 15.3.4 Element Content
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.4 元素内容
- en: 'Look again at the document tree pictured in [Figure 15-1](#documenttree), and
    ask yourself what the “content” of the `<p>` element is. There are two ways we
    might answer this question:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 [图 15-1](#documenttree) 中显示的文档树，并问问自己 `<p>` 元素的“内容”是什么。我们可能以两种方式回答这个问题：
- en: The content is the HTML string “This is a <i>simple</i> document”.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容是 HTML 字符串“This is a <i>simple</i> document”。
- en: The content is the plain-text string “This is a simple document”.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容是纯文本字符串“This is a simple document”。
- en: Both of these are valid answers, and each answer is useful in its own way. The
    sections that follow explain how to work with the HTML representation and the
    plain-text representation of an element’s content.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种答案都是有效的，每个答案在其自身的方式上都是有用的。接下来的部分将解释如何处理元素内容的 HTML 表示和��文本表示。
- en: Element content as HTML
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素内容作为 HTML
- en: 'Reading the `innerHTML` property of an Element returns the content of that
    element as a string of markup. Setting this property on an element invokes the
    web browser’s parser and replaces the element’s current content with a parsed
    representation of the new string. You can test this out by opening the developer
    console and typing:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 Element 的 `innerHTML` 属性会返回该元素的内容作为标记字符串。在元素上设置此属性会调用 Web 浏览器的解析器，并用新字符串的解析表示替换元素的当前内容。您可以通过打开开发者控制台并输入以下内容来测试：
- en: '[PRE40]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You will see that the entire web page disappears and is replaced with the single
    heading, “Oops”. Web browsers are very good at parsing HTML, and setting `innerHTML`
    is usually fairly efficient. Note, however, that appending text to the `innerHTML`
    property with the `+=` operator is not efficient because it requires both a serialization
    step to convert element content to a string and then a parsing step to convert
    the new string back into element content.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到整个网页消失，并被单个标题“Oops”替换。Web浏览器非常擅长解析HTML，并且设置`innerHTML`通常相当高效。但请注意，使用`+=`运算符将文本附加到`innerHTML`属性不高效，因为它需要序列化步骤将元素内容转换为字符串，然后需要解析步骤将新字符���转换回元素内容。
- en: Warning
  id: totrans-347
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: When using these HTML APIs, it is very important that you never insert user
    input into the document. If you do this, you allow malicious users to inject their
    own scripts into your application. See [“Cross-site scripting”](#xss) for details.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些HTML API时，非常重要的一点是绝对不要将用户输入插入文档中。如果这样做，您将允许恶意用户将自己的脚本注入到您的应用程序中。有关详细信息，请参见[“跨站脚本”](#xss)。
- en: The `outerHTML` property of an Element is like `innerHTML` except that its value
    includes the element itself. When you query `outerHTML`, the value includes the
    opening and closing tags of the element. And when you set `outerHTML` on an element,
    the new content replaces the element itself.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的`outerHTML`属性类似于`innerHTML`，只是它的值包括元素本身。当您查询`outerHTML`时，该值包括元素的开头和结尾标记。当您在元素上设置`outerHTML`时，新内容将替换元素本身。
- en: A related Element method is `insertAdjacentHTML()`, which allows you to insert
    a string of arbitrary HTML markup “adjacent” to the specified element. The markup
    is passed as the second argument to this method, and the precise meaning of “adjacent”
    depends on the value of the first argument. This first argument should be a string
    with one of the values “beforebegin,” “afterbegin,” “beforeend,” or “afterend.”
    These values correspond to insertion points that are illustrated in [Figure 15-2](#insertionpoints).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的元素方法是`insertAdjacentHTML()`，它允许您在指定元素的“相邻”位置插入任意HTML标记的字符串。标记作为第二个参数传递给此方法，而“相邻”的确切含义取决于第一个参数的值。第一个参数应该是一个带有“beforebegin”、“afterbegin”、“beforeend”或“afterend”值之一的字符串。这些值对应于[图15-2](#insertionpoints)中说明的插入点。
- en: '![js7e 1502](Images/js7e_1502.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1502](Images/js7e_1502.png)'
- en: Figure 15-2\. Insertion points for insertAdjacentHTML()
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-2\. insertAdjacentHTML()的插入点
- en: Element content as plain text
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素内容作为纯文本
- en: 'Sometimes you want to query the content of an element as plain text or to insert
    plain text into a document (without having to escape the angle brackets and ampersands
    used in HTML markup). The standard way to do this is with the `textContent` property:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望将元素的内容查询为纯文本，或者将纯文本插入文档中（而无需转义HTML标记中使用的尖括号和和号）。标准的做法是使用`textContent`属性：
- en: '[PRE41]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `textContent` property is defined by the Node class, so it works for Text
    nodes as well as Element nodes. For Element nodes, it finds and returns all text
    in all descendants of the element.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`textContent`属性由Node类定义，因此适用于文本节点和元素节点。对于元素节点，它会查找并返回元素所有后代中的所有文本。'
- en: The Element class defines an `innerText` property that is similar to `textContent`.
    `innerText` has some unusual and complex behaviors, such as attempting to preserve
    table formatting. It is not well specified nor implemented compatibly between
    browsers, however, and should no longer be used.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Element类定义了类似于`textContent`的`innerText`属性。`innerText`具有一些不寻常和复杂的行为，例如尝试保留表格格式。然而，它在各个浏览器之间的规范和实现并不一致，因此不应再使用。
- en: 15.3.5 Creating, Inserting, and Deleting Nodes
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.5 创建、插入和删除节点
- en: We’ve seen how to query and alter document content using strings of HTML and
    of plain text. And we’ve also seen that we can traverse a Document to examine
    the individual Element and Text nodes that it is made of. It is also possible
    to alter a document at the level of individual nodes. The Document class defines
    methods for creating Element objects, and Element and Text objects have methods
    for inserting, deleting, and replacing nodes in the tree.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用HTML字符串和纯文本查询和更改文档内容。我们还看到我们可以遍历文档以检查它由哪些单独的元素和文本节点组成。还可以在单个节点级别更改文档。Document类定义了用于创建元素对象的方法，而Element和Text对象具有在树中插入、删除和替换节点的方法。
- en: 'Create a new element with the `createElement()` method of the Document class
    and append strings of text or other elements to it with its `append()` and `prepend()`
    methods:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Document类的`createElement()`方法创建一个新元素，并使用其`append()`和`prepend()`方法将文本字符串或其他元素附加到其中：
- en: '[PRE42]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`append()` and `prepend()` take any number of arguments, which can be Node
    objects or strings. String arguments are automatically converted to Text nodes.
    (You can create Text nodes explicitly with `document.createTextNode()`, but there
    is rarely any reason to do so.) `append()` adds the arguments to the element at
    the end of the child list. `prepend()` adds the arguments at the start of the
    child list.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`和`prepend()`接受任意数量的参数，可以是节点对象或字符串。字符串参数会自动转换为文本节点。（您可以使用`document.createTextNode()`显式创建文本节点，但很少有理由这样做。）`append()`将参数添加到子节点列表的末尾。`prepend()`将参数添加到子节点列表的开头。'
- en: 'If you want to insert an Element or Text node into the middle of the containing
    element’s child list, then neither `append()` or `prepend()` will work for you.
    In this case, you should obtain a reference to a sibling node and call `before()`
    to insert the new content before that sibling or `after()` to insert it after
    that sibling. For example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要将元素或文本节点插入包含元素的子节点列表的中间位置，则`append()`或`prepend()`都不适用。在这种情况下，您应该获取一个兄弟节点的引用，并调用`before()`在该兄弟节点之前插入新内容，或者调用`after()`在该兄弟节点之后插入新内容。例如：
- en: '[PRE43]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Like `append()` and `prepend()`, `after()` and `before()` take any number of
    string and element arguments and insert them all into the document after converting
    strings to Text nodes. `append()` and `prepend()` are only defined on Element
    objects, but `after()` and `before()` work on both Element and Text nodes: you
    can use them to insert content relative to a Text node.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 像`append()`和`prepend()`一样，`after()`和`before()`接受任意数量的字符串和元素参数，并在将字符串转换为文本节点后将它们全部插入文档中。`append()`和`prepend()`仅在Element对象上定义，但`after()`和`before()`适用于Element和Text节点：您可以使用它们相对于Text节点插入内容。
- en: 'Note that elements can only be inserted at one spot in the document. If an
    element is already in the document and you insert it somewhere else, it will be
    moved to the new location, not copied:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，元素只能插入文档中的一个位置。如果元素已经在文档中并且您将其插入到其他位置，它将被移动到新位置，而不是复制：
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you do want to make a copy of an element, use the `cloneNode()` method,
    passing `true` to copy all of its content:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实想要复制一个元素，请使用`cloneNode()`方法，传递`true`以复制其所有内容：
- en: '[PRE45]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can remove an Element or Text node from the document by calling its `remove()`
    method, or you can replace it by calling `replaceWith()` instead. `remove()` takes
    no arguments, and `replaceWith()` takes any number of strings and elements just
    like `before()` and `after()` do:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用其`remove()`方法从文档中删除Element或Text节点，或者您可以通过调用`replaceWith()`来替换它。`remove()`不接受任何参数，`replaceWith()`接受任意数量的字符串和元素，就像`before()`和`after()`一样：
- en: '[PRE46]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The DOM API also defines an older generation of methods for inserting and removing
    content. `appendChild()`, `insertBefore()`, `replaceChild()`, and `removeChild()`
    are harder to use than the methods shown here and should never be needed.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: DOM API还定义了一组用于插入和删除内容的较旧一代方法。`appendChild()`、`insertBefore()`、`replaceChild()`和`removeChild()`比这里显示的方法更难使用，而且永远不应该需要。
- en: '15.3.6 Example: Generating a Table of Contents'
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.6 示例：生成目录
- en: '[Example 15-1](#TOC.js) shows how to dynamically create a table of contents
    for a document. It demonstrates many of the document scripting techniques described
    in the previous sections. The example is well commented, and you should have no
    trouble following the code.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例15-1](#TOC.js)展示了如何为文档动态创建目录。它演示了前几节描述的许多文档脚本化技术。示例有很好的注释，您应该没有问题跟踪代码。'
- en: Example 15-1\. Generating a table of contents with the DOM API
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-1。使用DOM API生成目录
- en: '[PRE47]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 15.4 Scripting CSS
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.4 脚本化CSS
- en: We’ve seen that JavaScript can control the logical structure and content of
    HTML documents. It can also control the visual appearance and layout of those
    documents by scripting CSS. The following subsections explain a few different
    techniques that JavaScript code can use to work with CSS.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到JavaScript可以控制HTML文档的逻辑结构和内容。它还可以通过脚本化CSS来控制这些文档的视觉外观和布局。以下各小节解释了JavaScript代码可以使用的几种不同技术来处理CSS。
- en: 'This is a book about JavaScript, not about CSS, and this section assumes that
    you already have a working knowledge of how CSS is used to style HTML content.
    But it’s worth mentioning some of the CSS styles that are commonly scripted from
    JavaScript:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于JavaScript的书，不是关于CSS的书，本节假设您已经掌握了如何使用CSS来为HTML内容设置样式的工作知识。但值得一提的是，一些常常从JavaScript中脚本化的CSS样式：
- en: Setting the `display` style to “none” hides an element. You can later show the
    element by setting `display` to some other value.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`display`样式设置为“none”可以隐藏一个元素。稍后可以通过将`display`设置为其他值来显示元素。
- en: You can dynamically position elements by setting the `position` style to “absolute,”
    “relative,” or “fixed” and then setting the `top` and `left` styles to the desired
    coordinates. This is important when using JavaScript to display dynamic content
    like modal dialogues and tooltips.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过将`position`样式设置为“absolute”、“relative”或“fixed”，然后将`top`和`left`样式设置为所需的坐标来动态定位元素。在使用JavaScript显示动态内容（如模态对话框和工具提示）时，这一点很重要。
- en: You can shift, scale, and rotate elements with the `transform` style.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`transform`样式来移动、缩放和旋转元素。
- en: You can animate changes to other CSS styles with the `transition` style. These
    animations are handled automatically by the web browser and do not require JavaScript,
    but you can use JavaScript to initiate the animations.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`transition`样式对其他CSS样式的更改进行动画处理。这些动画由Web浏览器自动处理，不需要JavaScript，但您可以使用JavaScript来启动动画。
- en: 15.4.1 CSS Classes
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.1 CSS类
- en: The simplest way to use JavaScript to affect the styling of document content
    is to add and remove CSS class names from the `class` attribute of HTML tags.
    This is easy to do with the `classList` property of Element objects, as explained
    in [“The class attribute”](#classattributes).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript影响文档内容的样式的最简单方法是从HTML标签的`class`属性中添加和删除CSS类名。这很容易通过Element对象的`classList`属性来实现，如[“class属性”](#classattributes)中所述。
- en: 'Suppose, for example, that your document’s stylesheet includes a definition
    for a “hidden” class:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您的文档样式表包含一个“hidden”类的定义：
- en: '[PRE48]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this style defined, you can hide (and then show) an element with code
    like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种定义的样式，您可以通过以下代码隐藏（��后显示）一个元素：
- en: '[PRE49]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 15.4.2 Inline Styles
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.2 内联样式
- en: To continue with the preceding tooltip example, suppose that the document is
    structured with only a single tooltip element, and we want to dynamically position
    it before displaying it. In general, we can’t create a different stylesheet class
    for each possible position of the tooltip, so the `classList` property won’t help
    us with positioning.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个工具提示示例，假设文档结构中只有一个工具提示元素，并且我们希望在显示之前动态定位它。一般来说，我们无法为工具提示的每种可能位置创建不同的样式表类，因此`classList`属性无法帮助我们定位。
- en: 'In this case, we need to script the `style` attribute of the tooltip element
    to set inline styles that are specific to that one element. The DOM defines a
    `style` property on all Element objects that correspond to the `style` attribute.
    Unlike most such properties, however, the `style` property is not a string. Instead,
    it is a CSSStyleDeclaration object: a parsed representation of the CSS styles
    that appear in textual form in the `style` attribute. To display and set the position
    of our hypothetical tooltip with JavaScript, we might use code like this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要脚本化工具提示元素的`style`属性，以设置特定于该元素的内联样式。DOM为所有Element对象定义了一个与`style`属性对应的`style`属性。然而，与大多数这样的属性不同，`style`属性不是一个字符串。相反，它是一个CSSStyleDeclaration对象：CSS样式的解析表示形式，它以文本形式出现在`style`属性中。为了使用JavaScript显示和设置我们假设的工具提示的位置，我们可能会使用类似于以下代码：
- en: '[PRE50]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When working with the style properties of the CSSStyleDeclaration object, remember
    that all values must be specified as strings. In a stylesheet or `style` attribute,
    you can write:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CSSStyleDeclaration对象的样式属性时，请记住所有值必须指定为字符串。在样式表或`style`属性中，您可以这样写：
- en: '[PRE51]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To accomplish the same thing for an element `e` with JavaScript, you have to
    quote all of the values:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript中为具有相同效果的元素`e`执行相同的操作，您必须引用所有值：
- en: '[PRE52]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the semicolons go outside the strings. These are just normal JavaScript
    semicolons; the semicolons you use in CSS stylesheets are not required as part
    of the string values you set with JavaScript.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，分号放在字符串外部。这些只是普通的JavaScript分号；您在CSS样式表中使用的分号不是JavaScript中设置的字符串值的一部分。
- en: 'Furthermore, remember that many CSS properties require units such as “px” for
    pixels or “pt” for points. Thus, it is not correct to set the `marginLeft` property
    like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，许多CSS属性需要像“px”表示像素或“pt”表示点这样的单位。因此，像这样设置`marginLeft`属性是不正确的：
- en: '[PRE53]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Units are required when setting style properties in JavaScript, just as they
    are when setting style properties in stylesheets. The correct way to set the value
    of the `marginLeft` property of an element `e` to 300 pixels is:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中设置样式属性时需要单位，就像在样式表中设置样式属性时一样。将元素`e`的`marginLeft`属性值设置为300像素的正确方法是：
- en: '[PRE54]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you want to set a CSS property to a computed value, be sure to append the
    units at the end of the computation:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将CSS属性设置为计算值，请确保在计算结束时附加单位：
- en: '[PRE55]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Recall that some CSS properties, such as `margin`, are shortcuts for other
    properties, such as `margin-top`, `margin-right`, `margin-bottom`, and `margin-left`.
    The CSSStyleDeclaration object has properties that correspond to these shortcut
    properties. For example, you might set the `margin` property like this:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一些CSS属性，例如`margin`，是其他属性的快捷方式，例如`margin-top`，`margin-right`，`margin-bottom`和`margin-left`。CSSStyleDeclaration对象具有与这些快捷属性对应的属性。例如，您可以这样设置`margin`属性：
- en: '[PRE56]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Sometimes, you may find it easier to set or query the inline style of an element
    as a single string value rather than as a CSSStyleDeclaration object. To do that,
    you can use the Element `getAttribute()` and `setAttribute()` methods, or you
    can use the `cssText` property of the CSSStyleDeclaration object:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会发现将元素的内联样式设置或查询为单个字符串值比作为CSSStyleDeclaration对象更容易。为此，您可以使用Element的`getAttribute()`和`setAttribute()`方法，或者您可以使用CSSStyleDeclaration对象的`cssText`属性：
- en: '[PRE57]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When querying the `style` property of an element, keep in mind that it represents
    only the inline styles of an element and that most styles for most elements are
    specified in stylesheets rather than inline. Furthermore, the values you obtain
    when querying the `style` property will use whatever units and whatever shortcut
    property format is actually used on the HTML attribute, and your code may have
    to do some sophisticated parsing to interpret them. In general, if you want to
    query the styles of an element, you probably want the *computed style*, which
    is discussed next.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询元素的`style`属性时，请记住它仅表示元素的内联样式，大多数元素的大多数样式是在样式表中指定而不是内联的。此外，当查询`style`属性时获得的值将使用实际在HTML属性上使用的任何单位和任何快捷属性格式，并且您的代码可能需要进行一些复杂的解析来解释它们。一般来说，如果您想查询元素的样式，您可能需要*计算样式*，下面将讨论。
- en: 15.4.3 Computed Styles
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.3 计算样式
- en: 'The computed style for an element is the set of property values that the browser
    derives (or computes) from the element’s inline style plus all applicable style
    rules in all stylesheets: it is the set of properties actually used to display
    the element. Like inline styles, computed styles are represented with a CSSStyleDeclaration
    object. Unlike inline styles, however, computed styles are read-only. You can’t
    set these styles, but the computed CSSStyleDeclaration object for an element lets
    you determine what style property values the browser used when rendering that
    element.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的计算样式是浏览器从元素的内联样式加上所有样式表中的所有适用样式规则推导（或计算）出的属性值集合：它是实际用于显示元素的属性集合。与内联样式一样，计算样式用CSSStyleDeclaration对象表示。然而，与内联样式不同，计算样式是只读的。您不能设置这些样式，但是元素的计算CSSStyleDeclaration对象可以让您确定浏览器在呈现该元素时使用了哪些样式属性值。
- en: 'Obtain the computed style for an element with the `getComputedStyle()` method
    of the Window object. The first argument to this method is the element whose computed
    style is desired. The optional second argument is used to specify a CSS pseudoelement,
    such as “::before” or “::after”:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Window对象的`getComputedStyle()`方法获取元素的计算样式。此方法的第一个参数是所需的计算样式的元素。可选的第二个参数用于指定CSS伪元素，例如“::before”或“::after”：
- en: '[PRE58]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The return value of `getComputedStyle()` is a CSSStyleDeclaration object that
    represents all the styles that apply to the specified element (or pseudoelement).
    There are a number of important differences between a CSSStyleDeclaration object
    that represents inline styles and one that represents computed styles:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`getComputedStyle()`的返回值是一个表示应用于指定元素（或伪元素）的所有样式的CSSStyleDeclaration对象。表示内联样式的CSSStyleDeclaration对象和表示计算样式的CSSStyleDeclaration对象之间有一些重要的区别：'
- en: Computed style properties are read-only.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算样式属性是只读的。
- en: 'Computed style properties are *absolute*: relative units like percentages and
    points are converted to absolute values. Any property that specifies a size (such
    as a margin size or a font size) will have a value measured in pixels. This value
    will be a string with a “px” suffix, so you’ll still need to parse it, but you
    won’t have to worry about parsing or converting other units. Properties whose
    values are colors will be returned in “rgb()” or “rgba()” format.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算样式属性是*绝对的*：相对单位如百分比和点会被转换为绝对值。任何指定大小的属性（如边距大小或字体大小）将具有以像素为单位的值。这个值将是一个带有“px”后缀的字符串，因此你仍然需要解析它，但你不必担心解析或转换其他单位。值为颜色的属性将以“rgb()”或“rgba()”格式返回。
- en: Shortcut properties are not computed—only the fundamental properties that they
    are based on are. Don’t query the `margin` property, for example, but use `marginLeft`,
    `marginTop`, and so on. Similarly, don’t query `border` or even `borderWidth`.
    Instead, use `borderLeftWidth`, `borderTopWidth`, and so on.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快捷属性不会被计算，只有它们所基于的基本属性会被计算。例如，不要查询`margin`属性，而是使用`marginLeft`、`marginTop`等。同样，不要查询`border`甚至`borderWidth`，而是使用`borderLeftWidth`、`borderTopWidth`等。
- en: The `cssText` property of the computed style is undefined.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算样式的`cssText`属性是未定义的。
- en: 'A CSSStyleDeclaration object returned by `getComputedStyle()` generally contains
    much more information about an element than the CSSStyleDeclaration obtained from
    the inline `style` property of that element. But computed styles can be tricky,
    and querying them does not always provide the information you might expect. Consider
    the `font-family` attribute: it accepts a comma-separated list of desired font
    families for cross-platform portability. When you query the `fontFamily` property
    of a computed style, you’re simply getting the value of the most specific `font-family`
    style that applies to the element. This may return a value such as “arial,helvetica,sans-serif,”
    which does not tell you which typeface is actually in use. Similarly, if an element
    is not absolutely positioned, attempting to query its position and size through
    the `top` and `left` properties of its computed style often returns the value
    `auto`. This is a perfectly legal CSS value, but it is probably not what you were
    looking for.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`getComputedStyle()`返回的 CSSStyleDeclaration 对象通常包含有关元素的更多信息，而不是从该元素的内联`style`属性获取的
    CSSStyleDeclaration。但计算样式可能会有些棘手，查询它们并不总是提供你期望的信息。考虑`font-family`属性：它接受一个逗号分隔的所需字体系列列表，以实现跨平台可移植性。当你查询计算样式的`fontFamily`属性时，你只是获取适用于元素的最具体`font-family`样式的值。这可能返回一个值，如“arial,helvetica,sans-serif”，这并不告诉你实际使用的字体。同样，如果一个元素没有绝对定位，尝试通过计算样式的`top`和`left`属性查询其位置和大小通常会返回值`auto`。这是一个完全合法的
    CSS 值，但这可能不是你要找的。
- en: Although CSS can be used to precisely specify the position and size of document
    elements, querying the computed style of an element is not the preferred way to
    determine the element’s size and position. See [§15.5.2](#getBoundingClientRect)
    for a simpler, portable alternative.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CSS 可以精确指定文档元素的位置和大小，但查询元素的计算样式并不是确定元素大小和位置的首选方法。查看[§15.5.2](#getBoundingClientRect)以获取更简单、可移植的替代方法。
- en: 15.4.4 Scripting Stylesheets
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.4 脚本样式表
- en: In addition to scripting class attributes and inline styles, JavaScript can
    also manipulate stylesheets themselves. Stylesheets are associated with an HTML
    document with a `<style>` tag or with a `<link rel="stylesheet">` tag. Both of
    these are regular HTML tags, so you can give them both `id` attributes and then
    look them up with `document.querySelector()`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作类属性和内联样式，JavaScript 还可以操作样式表本身。样式表与 HTML 文档关联，可以通过`<style>`标签或`<link rel="stylesheet">`标签进行关联。这两者都是常规的
    HTML 标签，因此你可以给它们都添加`id`属性，然后使用`document.querySelector()`查找它们。
- en: 'The Element objects for both `<style>` and `<link>` tags have a `disabled`
    property that you can use to disable the entire stylesheet. You might use it with
    code like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`<style>`和`<link>`标签的 Element 对象都有一个`disabled`属性，你可以使用它来禁用整个样式表。你可以使用如下代码：'
- en: '[PRE59]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Another simple way to script stylesheets is to insert new ones into the document
    using DOM manipulation techniques we’ve already seen. For example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种简单的脚本样式表的方法是使用我们已经看过的 DOM 操作技术将新样式表插入文档中。例如：
- en: '[PRE60]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Less subtly, you can also just insert a string of HTML containing a `<style>`
    tag into your document. This is a fun trick, for example:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 更直接地，你也可以将一个包含`<style>`标签的 HTML 字符串插入到你的文档中。例如：
- en: '[PRE61]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Browsers define an API that allows JavaScript to look inside stylesheets to
    query, modify, insert, and delete style rules in that stylesheet. This API is
    so specialized that it is not documented here. You can read about it on MDN by
    searching for “CSSStyleSheet” and “CSS Object Model.”
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器定义了一个 API，允许 JavaScript 查看样式表内部，查询、修改、插入和删除该样式表中的样式规则。这个 API 是如此专门化，以至于这里没有记录。你可以在
    MDN 上搜索“CSSStyleSheet”和“CSS Object Model”来了解它。
- en: 15.4.5 CSS Animations and Events
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.5 CSS 动画和事件
- en: 'Suppose you have the following two CSS classes defined in a stylesheet:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在样式表中定义了以下两个 CSS 类：
- en: '[PRE62]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you apply the first style to an element, it will be fully transparent and
    therefore invisible. But if you apply the second style that tells the browser
    that when the opacity of the element changes, that change should be animated over
    a period of 0.5 seconds, “ease-in” specifies that the opacity change animation
    should start off slow and then accelerate.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将第一个样式应用于一个元素，它将完全透明，因此看不见。但如果你应用第二个样式，告诉浏览器当元素的不透明度发生变化时，该变化应该在 0.5 秒内进行动画处理，“ease-in”指定不透明度变化动画应该从缓慢开始然后加速。
- en: 'Now suppose that your HTML document contains an element with the “fadeable”
    class:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你的 HTML 文档包含一个带有“fadeable”类的元素：
- en: '[PRE63]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In JavaScript, you can add the “transparent” class:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，你可以添加“transparent”类：
- en: '[PRE64]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This element is configured to animate opacity changes. Adding the “transparent”
    class changes the opacity and triggers an animate: the browser “fades out” the
    element so that it becomes fully transparent over the period of half a second.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素已配置为动画不透明度变化。添加“transparent”类会改变不透明度并触发动画：浏览器会使元素“淡出”，使其在半秒钟内完全透明。
- en: 'This works in reverse as well: if you remove the “transparent” class of a “fadeable”
    element, that is also an opacity change, and the element fades back in and becomes
    visible again.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于相反的情况：如果您删除“fadeable”元素的“transparent”类，那也是一个不透明度变化，元素会重新淡入并再次变得可见。
- en: 'JavaScript does not have to do any work to make these animations happen: they
    are a pure CSS effect. But JavaScript can be used to trigger them.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不需要做任何工作来实现这些动画：它们是纯CSS效果。但是JavaScript可以用来触发它们。
- en: JavaScript can also be used to monitor the progress of a CSS transition because
    the web browser fires events at the start and end of a transition. The “transitionrun”
    event is dispatched when the transition is first triggered. This may happen before
    any visual changes begin, when the `transition-delay` style has been specified.
    Once the visual changes begin a “transitionstart” event is dispatched, and when
    the animation is complete, a “transitionend” event is dispatched. The target of
    all these events is the element being animated, of course. The event object passed
    to handlers for these events is a TransitionEvent object. It has a `propertyName`
    property that specifies the CSS property being animated and an `elapsedTime` property
    that for “transitionend” events specifies how many seconds have passed since the
    “transitionstart” event.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript也可以用于监视CSS过渡的进度，因为Web浏览器在过渡开始和结束时会触发事件。当过渡首次触发时，会分发“transitionrun”事件。这可能发生在任何视觉变化开始之前，当指定了`transition-delay`样式时。一旦视觉变化开始，就会分发“transitionstart”事件，当动画完成时，就会分发“transitionend”事件。当然，所有这些事件的目标都是正在进行动画的元素。传递给这些事件处理程序的事件对象是一个TransitionEvent对象。它有一个`propertyName`属性，指定正在进行动画的CSS属性，以及一个`elapsedTime`属性，对于“transitionend”事件，它指定自“transitionstart”事件以来经过了多少秒。
- en: In addition to transitions, CSS also supports a more complex form of animation
    known simply as “CSS Animations.” These use CSS properties such as `animation-name`
    and `animation-duration` and a special `@keyframes` rule to define animation details.
    Details of how CSS animations work are beyond the scope of this book, but once
    again, if you define all of the animation properties on a CSS class, then you
    can use JavaScript to trigger the animation simply by adding the class to the
    element that is to be animated.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 除了过渡效果，CSS还支持一种更复杂的动画形式，简称为“CSS动画”。这些使用CSS属性，如`animation-name`和`animation-duration`，以及特殊的`@keyframes`规则来定义动画细节。CSS动画的工作原理超出了本书的范围，但再次，如果您在CSS类上定义了所有动画属性，那么您可以通过将该类添加到要进行动画处理的元素来使用JavaScript触发动画。
- en: And like CSS transitions, CSS animations also trigger events that your JavaScript
    code can listen form. “animationstart” is dispatched when the animation starts,
    and “animationend” is dispatched when it is complete. If the animation repeats
    more than once, then an “animationiteration” event is dispatched after each repetition
    except the last. The event target is the animated element, and the event object
    passed to handler functions is an AnimationEvent object. These events include
    an `animationName` property that specifies the `animation-name` property that
    defines the animation and an `elapsedTime` property that specifies how many seconds
    have passed since the animation started.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 与CSS过渡类似��CSS动画也会触发事件，您的JavaScript代码可以监听这些事件。“animationstart”在动画开始时分发，“animationend”在动画完成时分发。如果动画重复多次，则在每次重复之后（除最后一次）都会分发“animationiteration”事件。事件目标是被动画化的元素，传递给处理程序函数的事件对象是一个AnimationEvent对象。这些事件包括一个`animationName`属性，指定定义动画的`animation-name`属性，以及一个`elapsedTime`属性，指定自动画开始以来经过了多少秒。
- en: 15.5 Document Geometry and Scrolling
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.5 文档几何和滚动
- en: In this chapter so far, we have thought about documents as abstract trees of
    elements and text nodes. But when a browser renders a document within a window,
    it creates a visual representation of the document in which each element has a
    position and a size. Often, web applications can treat documents as trees of elements
    and never have to think about how those elements are rendered on screen. Sometimes,
    however, it is necessary to determine the precise geometry of an element. If,
    for example, you want to use CSS to dynamically position an element (such as a
    tooltip) next to some ordinary browser-positioned element, you need to be able
    to determine the location of that element.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经将文档视为元素和文本节点的抽象树。但是当浏览器在窗口中呈现文档时，它会创建文档的视觉表示，其中每个元素都有位置和大小。通常，Web应用程序可以将文档视为元素树，而无需考虑这些元素如何在屏幕上呈现。然而，有时需要确定元素的精确几何形状。例如，如果您想使用CSS动态定位一个元素（如工具提示）在一些普通的浏览器定位元素旁边，您需要能够确定该元素的位置。
- en: The following subsections explain how you can go back and forth between the
    abstract, tree-based *model* of a document and the geometrical, coordinate-based
    *view* of the document as it is laid out in a browser window.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节解释了如何在文档的抽象、基于树的*模型*和在浏览器窗口中布局的几何、基于坐标的*视图*之间来回切换。
- en: 15.5.1 Document Coordinates and Viewport Coordinates
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.1 文档坐标和视口坐标
- en: 'The position of a document element is measured in CSS pixels, with the *x*
    coordinate increasing to the right and the *y* coordinate increasing as we go
    down. There are two different points we can use as the coordinate system origin,
    however: the *x* and *y* coordinates of an element can be relative to the top-left
    corner of the document or relative to the top-left corner of the *viewport* in
    which the document is displayed. In top-level windows and tabs, the “viewport”
    is the portion of the browser that actually displays document content: it excludes
    browser “chrome” such as menus, toolbars, and tabs. For documents displayed in
    `<iframe>` tags, it is the iframe element in the DOM that defines the viewport
    for the nested document. In either case, when we talk about the position of an
    element, we must be clear whether we are using document coordinates or viewport
    coordinates. (Note that viewport coordinates are sometimes called “window coordinates.”)'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 文档元素的位置以 CSS 像素为单位，*x* 坐标向右增加，*y* 坐标向下增加。然而，我们可以使用两个不同的点作为坐标系原点：元素的 *x* 和 *y*
    坐标可以相对于文档的左上角或相对于显示文档的*视口*的左上角。在顶级窗口和标签中，“视口”是实际显示文档内容的浏览器部分：它不包括浏览器的“chrome”（如菜单、工具栏和标签）。对于在
    `<iframe>` 标签中显示的文档，DOM 中定义嵌套文档的视口的是 iframe 元素。无论哪种情况，当我们谈论元素的位置时，必须清楚我们是使用文档坐标还是视口坐标。（请注意，有时视口坐标被称为“窗口坐标”。）
- en: If the document is smaller than the viewport, or if it has not been scrolled,
    the upper-left corner of the document is in the upper-left corner of the viewport
    and the document and viewport coordinate systems are the same. In general, however,
    to convert between the two coordinate systems, we must add or subtract the *scroll
    offsets*. If an element has a *y* coordinate of 200 pixels in document coordinates,
    for example, and if the user has scrolled down by 75 pixels, then that element
    has a *y* coordinate of 125 pixels in viewport coordinates. Similarly, if an element
    has an *x* coordinate of 400 in viewport coordinates after the user has scrolled
    the viewport 200 pixels horizontally, then the element’s *x* coordinate in document
    coordinates is 600.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档比视口小，或者没有滚动，文档的左上角在视口的左上角，文档和视口坐标系是相同的。然而，一般来说，要在两个坐标系之间转换，必须添加或减去*滚动偏移量*。例如，如果一个元素在文档坐标中有
    200 像素的 *y* 坐标，而用户向下滚动了 75 像素，那么该元素在视口坐标中的 *y* 坐标为 125 像素。同样，如果一个元素在用户水平滚动视口 200
    像素后在视口坐标中有 400 的 *x* 坐标，那么元素在文档坐标中的 *x* 坐标为 600。
- en: If we use the mental model of printed paper documents, it is logical to assume
    that every element in a document must have a unique position in document coordinates,
    regardless of how much the user has scrolled the document. That is an appealing
    property of paper documents, and it applies for simple web documents, but in general,
    document coordinates don’t really work on the web. The problem is that the CSS
    `overflow` property allows elements within a document to contain more content
    than it can display. Elements can have their own scrollbars and serve as viewports
    for the content they contain. The fact that the web allows scrolling elements
    within a scrolling document means that it is simply not possible to describe the
    position of an element within the document using a single (x,y) point.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用印刷纸质文档的思维模型，逻辑上可以假设文档中的每个元素在文档坐标中必须有一个唯一的位置，无论用户滚动了多少。这是纸质文档的一个吸引人的特性，对于简单的网页文档也适用，但总的来说，在网页上文档坐标实际上并不起作用。问题在于
    CSS `overflow` 属性允许文档中的元素包含比其能显示的更多内容。元素可以有自己的滚动条，并作为包含的内容的视口。网页允许在滚动文档中滚动元素意味着不可能使用单个
    (x,y) 点描述文档中元素的位置。
- en: Because document coordinates don’t really work, client-side JavaScript tends
    to use viewport coordinates. The `getBoundingClientRect()` and `elementFromPoint()`
    methods described next use viewport coordinates, for example, and the `clientX`
    and `clientY` properties of mouse and pointer event objects also use this coordinate
    system.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因为文档坐标实际上不起作用，客户端 JavaScript 倾向于使用视口坐标。例如，下面描述的 `getBoundingClientRect()` 和
    `elementFromPoint()` 方法使用视口坐标，而鼠标和指针事件对象的 `clientX` 和 `clientY` 属性也使用这个坐标系。
- en: When you explicitly position an element using CSS `position:fixed`, the `top`
    and `left` properties are interpreted in viewport coordinates. If you use `position:relative`,
    the element is positioned relative to where it would have been if it didn’t have
    the `position` property set. If you use `position:absolute`, then `top` and `left`
    are relative to the document or to the nearest containing positioned element.
    This means, for example, that an absolutely positioned element inside a relatively
    positioned element is positioned relative to the container element, not relative
    to the overall document. It is sometimes very useful to create a relatively positioned
    container with `top` and `left` set to 0 (so the container is laid out normally)
    in order to establish a new coordinate system origin for the absolutely positioned
    elements it contains. We might refer to this new coordinate system as “container
    coordinates” to distinguish it from document coordinates and viewport coordinates.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 CSS `position:fixed` 明确定位元素时，`top` 和 `left` 属性是以视口坐标解释的。如果使用 `position:relative`，元素的定位是相对于如果没有设置
    `position` 属性时的位置。如果使用 `position:absolute`，那么 `top` 和 `left` 是相对于文档或最近的包含定位元素的。这意味着，例如，相对定位元素位于相对定位元素内部，是相对于容器元素而不是相对于整个文档的。有时候，创建一个相对定位的容器并将
    `top` 和 `left` 设置为 0（使容器正常布局）非常有用，以便为其中包含的绝对定位元素建立一个新的坐标系原点。我们可能将这个新的坐标系称为“容器坐标”，以区别于文档坐标和视口坐标。
- en: 15.5.2 Querying the Geometry of an Element
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.2 查询元素的几何信息
- en: You can determine the size (including CSS border and padding, but not the margin)
    and position (in viewport coordinates) of an element by calling its `getBoundingClientRect()`
    method. It takes no arguments and returns an object with properties `left`, `right`,
    `top`, `bottom`, `width`, and `height`. The `left` and `top` properties give the
    *x* and *y* coordinates of the upper-left corner of the element, and the `right`
    and `bottom` properties give the coordinates of the lower-right corner. The differences
    between these values are the `width` and `height` properties.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用其`getBoundingClientRect()`方法来确定元素的大小（包括CSS边框和填充，但不包括边距）和位置（在视口坐标中）。它不带参数并返回一个具有属性`left`、`right`、`top`、`bottom`、`width`和`height`的对象。`left`和`top`属性给出元素左上角的*x*和*y*坐标，`right`和`bottom`属性给出右下角的坐标。这些值之间的差异是`width`和`height`属性。
- en: Block elements, such as images, paragraphs, and `<div>` elements are always
    rectangular when laid out by the browser. Inline elements, such as `<span>`, `<code>`,
    and `<b>` elements, however, may span multiple lines and may therefore consist
    of multiple rectangles. Imagine, for example, some text within `<em>` and `</em>`
    tags that happens to be displayed so that it wraps across two lines. Its rectangles
    consist of the end of the first line and beginning of the second line. If you
    call `getBoundingClientRect()` on this element, the bounding rectangle would include
    the entire width of both lines. If you want to query the individual rectangles
    of inline elements, call the `getClientRects()` method to obtain a read-only,
    array-like object whose elements are rectangle objects like those returned by
    `getBoundingClientRect()`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 块元素，如图像、段落和`<div>`元素在浏览器布局时始终是矩形的。然而，内联元素，如`<span>`、`<code>`和`<b>`元素，可能跨越多行，因此可能由多个矩形组成。例如，想象一下，某些文本在`<em>`和`</em>`标签中显示，跨越两行。其矩形包括第一行的末尾和第二行的开头。如果您在此元素上调用`getBoundingClientRect()`，边界矩形将包括两行的整个宽度。如果要查询内联元素的各个矩形，请调用`getClientRects()`方法以获取一个只读的类似数组的对象，其元素是类似于`getBoundingClientRect()`返回的矩形对象。
- en: 15.5.3 Determining the Element at a Point
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.3 确定点处的元素
- en: 'The `getBoundingClientRect()` method allows us to determine the current position
    of an element in a viewport. Sometimes we want to go in the other direction and
    determine which element is at a given location in the viewport. You can determine
    this with the `elementFromPoint()` method of the Document object. Call this method
    with the *x* and *y* coordinates of a point (using viewport coordinates, not document
    coordinates: the `clientX` and `clientY` coordinates of a mouse event work, for
    example). `elementFromPoint()` returns an Element object that is at the specified
    position. The *hit detection* algorithm for selecting the element is not precisely
    specified, but the intent of this method is that it returns the innermost (most
    deeply nested) and uppermost (highest CSS `z-index` attribute) element at that
    point.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBoundingClientRect()`方法允许我们确定元素在视口中的当前位置。有时我们想要反向操作，并确定视口中给定位置的元素是哪个。您可以使用文档对象的`elementFromPoint()`方法来确定这一点。使用点的*x*和*y*坐标调用此方法（使用视口坐标，而不是文档坐标：例如，鼠标事件的`clientX`和`clientY`坐标）。`elementFromPoint()`返回一个在指定位置的元素对象。用于选择元素的*命中检测*算法没有明确定义，但此方法的意图是返回该点处最内部（最深度嵌套）和最上层（最高CSS
    `z-index`属性）的元素。'
- en: 15.5.4 Scrolling
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.4 滚动
- en: 'The `scrollTo()` method of the Window object takes the *x* and *y* coordinates
    of a point (in document coordinates) and sets these as the scrollbar offsets.
    That is, it scrolls the window so that the specified point is in the upper-left
    corner of the viewport. If you specify a point that is too close to the bottom
    or too close to the right edge of the document, the browser will move it as close
    as possible to the upper-left corner but won’t be able to get it all the way there.
    The following code scrolls the browser so that the bottom-most page of the document
    is visible:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Window对象的`scrollTo()`方法接受点的*x*和*y*坐标（在文档坐标中）并将其设置为滚动条偏移量。也就是说，它滚动窗口，使指定点位于视口的左上角。如果指定的点太靠近文档的底部或右边缘，浏览器会尽可能将其移动到左上角，但无法完全到达那里。以下代码将浏览器滚动，以便看到文档的最底部页面：
- en: '[PRE65]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `scrollBy()` method of the Window is similar to `scrollTo()`, but its arguments
    are relative and are added to the current scroll position:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Window的`scrollBy()`方法类似于`scrollTo()`，但其参数是相对的，并添加到当前滚动位置：
- en: '[PRE66]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you want to scroll smoothly with `scrollTo()` or `scrollBy()`, pass a single
    object argument instead of two numbers, like this:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用`scrollTo()`或`scrollBy()`平滑滚动，请传递一个对象参数，而不是两个数字，就像这样：
- en: '[PRE67]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Often, instead of scrolling to a numeric location in a document, we just want
    to scroll so that a certain element in the document is visible. You can do this
    with the `scrollIntoView()` method on the desired HTML element. This method ensures
    that the element on which it is invoked is visible in the viewport. By default,
    it tries to put the top edge of the element at or near the top of the viewport.
    If `false` is passed as the only argument, it tries to put the bottom edge of
    the element at the bottom of the viewport. The browser will also scroll the viewport
    horizontally as needed to make the element visible.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不是要在文档中滚动到数值位置，而是要滚动以使文档中的某个特定元素可见。您可以使用所需HTML元素上的`scrollIntoView()`方法来实现这一点。此方法确保调用它的元素在视口中可见。默认情况下，它尝试将元素的顶部边缘放在视口的顶部或附近。如果将`false`作为唯一参数传递，它将尝试将元素的底部边缘放在视口的底部。浏览器还将根据需要水平滚动视口以使元素可见。
- en: You can also pass an object to `scrollIntoView()`, setting the `behavior:"smooth"`
    property for smooth scrolling. You can set the `block` property to specify where
    the element should be positioned vertically and the `inline` property to specify
    how it should be positioned horizontally if horizontal scrolling is needed. Legal
    values for both of these properties are `start`, `end`, `nearest`, and `center`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将对象传递给`scrollIntoView()`，设置`behavior:"smooth"`属性以实现平滑滚动。您可以设置`block`属性以指定元素在垂直方向上的位置，并设置`inline`属性以指定水平滚动时元素的位置。这些属性的合法值为`start`、`end`、`nearest`和`center`。
- en: 15.5.5 Viewport Size, Content Size, and Scroll Position
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视口大小、内容大小和滚动位置
- en: As we’ve discussed, browser windows and other HTML elements can display scrolling
    content. When this is the case, we sometimes need to know the size of the viewport,
    the size of the content, and the scroll offsets of the content within the viewport.
    This section covers these details.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，浏览器窗口和其他HTML元素可以显示滚动内容。在这种情况下，我们有时需要知道视口的大小、内容的大小以及内容在视口内的滚动偏移量。本节涵盖了这些细节。
- en: 'For browser windows, the viewport size is given by the `window.innerWidth`
    and `window.innerHeight` properties. (Web pages optimized for mobile devices often
    use a `<meta name="viewport">` tag in their `<head>` to set the desired viewport
    width for the page.) The total size of the document is the same as the size of
    the `<html>` element, `document.documentElement`. You can call `getBoundingClientRect()`
    on `document.documentElement` to get the width and height of the document, or
    you can use the `offsetWidth` and `offsetHeight` properties of `document.documentElement`.
    The scroll offsets of the document within its viewport are available as `window.scrollX`
    and `window.scrollY`. These are read-only properties, so you can’t set them to
    scroll the document: use `window.scrollTo()` instead.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浏览器窗口，视口大小由`window.innerWidth`和`window.innerHeight`属性给出。（为移动设备优化的网页通常在`<head>`中使用`<meta
    name="viewport">`标签来设置页面所需的视口宽度。）文档的总大小与`<html>`元素的大小相同，即`document.documentElement`。您可以在`document.documentElement`上调用`getBoundingClientRect()`来获取文档的宽度和高度，或者您可以使用`document.documentElement`的`offsetWidth`和`offsetHeight`属性。文档在其视口内的滚动偏移量可通过`window.scrollX`和`window.scrollY`获得。这些是只读属性，因此您无法设置它们来滚动文档：请改用`window.scrollTo()`。
- en: 'Things are a little more complicated for elements. Every Element object defines
    the following three groups of properties:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元素来说情况会有些复杂。每个Element对象定义以下三组属性：
- en: '[PRE68]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `offsetWidth` and `offsetHeight` properties of an element return its on-screen
    size in CSS pixels. The returned sizes include the element border and padding
    but not margins. The `offsetLeft` and `offsetTop` properties return the *x* and
    *y* coordinates of the element. For many elements, these values are document coordinates.
    But for descendants of positioned elements and for some other elements, such as
    table cells, these properties return coordinates that are relative to an ancestor
    element rather than the document itself. The `offsetParent` property specifies
    which element the properties are relative to. These offset properties are all
    read-only.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的`offsetWidth`和`offsetHeight`属性返回其在屏幕上的大小（以CSS像素为单位）。返回的大小包括元素的边框和填充，但不包括边距。`offsetLeft`和`offsetTop`属性返回元素的*x*和*y*坐标。对于许多元素，这些值是文档坐标。但对于定位元素的后代和一些其他元素（如表格单元格），这些属性返回相对于祖先元素而不是文档本身的坐标。`offsetParent`属性指定这些属性相对于哪个元素。这些偏移属性都是只读的。
- en: '`clientWidth` and `clientHeight` are like `offsetWidth` and `offsetHeight`
    except that they do not include the border size—only the content area and its
    padding. The `clientLeft` and `clientTop` properties are not very useful: they
    return the horizontal and vertical distance between the outside of an element’s
    padding and the outside of its border. Usually, these values are just the width
    of the left and top borders. These client properties are all read-only. For inline
    elements like `<i>`, `<code>`, and `<span>`, they all return 0.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientWidth`和`clientHeight`类似于`offsetWidth`和`offsetHeight`，只是它们不包括边框大小，只包括内容区域及其填充。`clientLeft`和`clientTop`属性并不是很有用：它们返回元素的填充外部与边框外部之间的水平和垂直距离。通常，这些值只是左边框和上边框的宽度。这些客户端属性都是只读的。对于像`<i>`、`<code>`和`<span>`这样的内联元素，它们都返回0。'
- en: '`scrollWidth` and `scrollHeight` return the size of an element’s content area
    plus its padding plus any overflowing content. When the content fits within the
    content area without overflow, these properties are the same as `clientWidth`
    and `clientHeight`. But when there is overflow, they include the overflowing content
    and return values larger than `clientWidth` and `clientHeight`. `scrollLeft` and
    `scrollTop` give the scroll offset of the element content within the element’s
    viewport. Unlike all the other properties described here, `scrollLeft` and `scrollTop`
    are writable properties, and you can set them to scroll the content within an
    element. (In most browsers, Element objects also have `scrollTo()` and `scrollBy()`
    methods like the Window object does, but these are not yet universally supported.)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollWidth`和`scrollHeight`返回元素内容区域的大小加上其填充加上任何溢出内容。当内容适合内容区域而不溢出时，这些属性与`clientWidth`和`clientHeight`相同。但当存在溢出时，它们包括溢出的内容并返回大于`clientWidth`和`clientHeight`的值。`scrollLeft`和`scrollTop`给出元素内容在元素视口内的滚动偏移量。与这里描述的所有其他属性不同，`scrollLeft`和`scrollTop`是可写属性，您可以设置它们来滚动元素内的内容。（在大多数浏览器中，Element对象也像Window对象一样具有`scrollTo()`和`scrollBy()`方法，但这些方法尚未得到普遍支持。）'
- en: 15.6 Web Components
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web组件
- en: HTML is a language for document markup and defines a rich set of tags for that
    purpose. Over the last three decades, it has become a language that is used to
    describe the user interfaces of web applications, but basic HTML tags such as
    `<input>` and `<button>` are inadequate for modern UI designs. Web developers
    are able to make it work, but only by using CSS and JavaScript to augment the
    appearance and behavior of basic HTML tags. Consider a typical user interface
    component, such as the search box shown in [Figure 15-3](#searchboxfig).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是一种用于文档标记的语言，为此定义了一套丰富的标签。在过去的三十年里，它已经成为描述Web应用程序用户界面的语言，但基本的HTML标签如`<input>`和`<button>`对于现代UI设计来说是不足够的。Web开发人员可以让其工作，但只能通过使用CSS和JavaScript来增强基本HTML标签的外观和行为。考虑一个典型的用户界面组件，比如在[图15-3](#searchboxfig)中显示的搜索框。
- en: '![js7e 1503](Images/js7e_1503.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1503](Images/js7e_1503.png)'
- en: Figure 15-3\. A search box user interface component
  id: totrans-478
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-3。一个搜索框用户界面组件
- en: 'The HTML `<input>` element can be used to accept a single line of input from
    the user, but it doesn’t have any way to display icons like the magnifying glass
    on the left and the cancel X on the right. In order to implement a modern user
    interface element like this for the web, we need to use at least four HTML elements:
    an `<input>` element to accept and display the user’s input, two `<img>` elements
    (or in this case, two `<span>` elements displaying Unicode glyphs), and a container
    `<div>` element to hold those three children. Furthermore, we have to use CSS
    to hide the default border of the `<input>` element and define a border for the
    container. And we need to use JavaScript to make all the HTML elements work together.
    When the user clicks on the X icon, we need an event handler to clear the input
    from the `<input>` element, for example.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `<input>`元素可用于接受用户的单行输入，但它没有任何显示图标的方法，比如左侧的放大镜和右侧的取消X。为了在Web上实现这样一个现代用户界面元素，我们���少需要使用四个HTML元素：一个`<input>`元素用于接受和显示用户的输入，两个`<img>`元素（或在这种情况下，两个显示Unicode图标的`<span>`元素），以及一个容器`<div>`元素来容纳这三个子元素。此外，我们必须使用CSS来隐藏`<input>`元素的默认边框，并为容器定义一个边框。我们还需要使用JavaScript使所有HTML元素协同工作。当用户点击X图标时，我们需要一个事件处理程序来清除`<input>`元素中的输入，例如。
- en: That is a lot of work to do every time you want to display a search box in a
    web application, and most web applications today are not written using “raw” HTML.
    Instead, many web developers use frameworks like React and Angular that support
    the creation of reusable user interface components like the search box shown here.
    Web components is a browser-native alternative to those frameworks based on three
    relatively recent additions to web standards that allow JavaScript to extend HTML
    with new tags that work as self-contained, reusable UI components.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 每次想在Web应用程序中显示一个搜索框都需要做很多工作，而今天大多数Web应用程序并不是使用“原始”HTML编写的。相反，许多Web开发人员使用像React和Angular这样的框架，支持创建可重用的用户界面组件，比如这里显示的搜索框。Web组件是一个基于Web标准的浏览器原生替代方案，它基于三个相对较新的Web标准添加，允许JavaScript使用新的标签扩展HTML，这些标签可以作为独立的、可重用的UI组件。
- en: The subsections that follow explain how to use web components defined by other
    developers in your own web pages, then explain each of the three technologies
    that web components are based on, and finally tie all three together in an example
    that implements the search box element pictured in [Figure 15-3](#searchboxfig).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节将解释如何在自己的Web页面中使用其他开发人员定义的Web组件，然后解释Web组件基于的三种技术，并最终在一个示例中将这三种技术结合起来，实现[图15-3](#searchboxfig)中显示的搜索框元素。
- en: 15.6.1 Using Web Components
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.1 使用Web组件
- en: 'Web components are defined in JavaScript, so in order to use a web component
    in your HTML file, you need to include the JavaScript file that defines the component.
    Because web components are a relatively new technology, they are often written
    as JavaScript modules, so you might include one in your HTML like this:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件是用JavaScript定义的，因此为了在HTML文件中使用Web组件，你需要包含定义组件的JavaScript文件。由于Web组件是一种相对较新的技术，它们通常被编写为JavaScript模块，因此你可以像这样在HTML中包含一个：
- en: '[PRE69]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Web components define their own HTML tag names, with the important restriction
    that those tag names must include a hyphen. (This means that future versions of
    HTML can introduce new tags without hyphens, and there is no chance that the tags
    will conflict with anyone’s web component.) To use a web component, just use its
    tag in your HTML file:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件定义自己的HTML标签名称，重要的限制是这些标签名称必须包含连字符。这意味着未来版本的HTML可以引入不带连字符的新标签，而且不会与任何人的Web组件冲突。要使用Web组件，只需在HTML文件中使用其标签：
- en: '[PRE70]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Web components can have attributes just like regular HTML tags can; the documentation
    for the component you are using should tell you which attributes are supported.
    Web components cannot be defined with self-closing tags. You cannot write `<search-box/>`,
    for example. Your HTML file must include both the opening tag and the closing
    tag.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件可以像常规HTML标签一样具有属性；你使用的组件的文档应告诉你支持哪些属性。Web组件不能用自闭合标签来定义。例如，你不能写`<search-box/>`。你的HTML文件必须包含开放标签和闭合标签。
- en: 'Like regular HTML elements, some web components are written to expect children
    and others are written in such a way that they do not expect (and will not display)
    children. Some web components are written so that they can optionally accept specially
    labeled children that will appear in named “slots.” The `<search-box>` component
    pictured in [Figure 15-3](#searchboxfig) and implemented in [Example 15-3](#search-box.js)
    uses “slots” for the two icons it displays. If you want to to use a `<search-box>`
    with different icons, you can use HTML like this:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 像常规HTML元素一样，一些Web组件被编写为期望有子元素，而另一些则被编写为不期望（也不会显示）子元素。一些Web组件被编写为可以选择接受特殊标记的子元素，这些子元素将出现在命名的“插槽”中。[图15-3](#searchboxfig)中显示的`<search-box>`组件，并在[示例15-3](#search-box.js)中实现，使用“插槽”来显示两个图标。如果你想使用带有不同图标的`<search-box>`，可以使用如下HTML：
- en: '[PRE71]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `slot` attribute is an extension to HTML that it is used to specify which
    children should go where. The slot names—“left” and “right” in this example—are
    defined by the web component. If the component you are using supports slots, that
    fact should be included in its documentation.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`slot` 属性是 HTML 的扩展，用于指定哪些子元素应该放在哪里。在这个示例中定义的插槽名称“left”和“right”由 Web 组件定义。如果您使用的组件支持插槽，那么这一点应该包含在其文档中。'
- en: I previously noted that web components are often implemented as JavaScript modules
    and can be loaded into HTML files with a `<script type="module">` tag. You may
    remember from the beginning of this chapter that modules are loaded after document
    content is parsed, as if they had a `deferred` tag. So this means that a web browser
    will typically parse and render tags like `<search-box>` before it has run the
    code that will tell it what a `<search-box>` is. This is normal when using web
    components. HTML parsers in web browsers are flexible and very forgiving about
    input that they do not understand. When they encounter a web component tag before
    that component has been defined, they add a generic HTMLElement to the DOM tree
    even though they do not know what to do with it. Later, when the custom element
    is defined, the generic element is “upgraded” so that it looks and behaves as
    desired.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，Web 组件通常作为 JavaScript 模块实现，并且可以通过`<script type="module">`标签加载到 HTML 文件中。您可能还记得本章开头提到的模块在文档内容解析后加载，就像它们有一个`deferred`标签一样。这意味着
    Web 浏览器通常会在运行告诉它`<search-box>`是什么的代码之前解析和呈现`<search-box>`等标签。这在使用 Web 组件时是正常的。Web
    浏览器中的 HTML 解析器对于它们不理解的输入非常灵活和宽容。当它们在组件被定义之前遇到一个 Web 组件标签时，它们会向 DOM 树添加一个通用的 HTMLElement，即使它们不知道如何处理它。稍后，当自定义元素被定义时，通用元素会被“升级”，以便看起来和行为符合预期。
- en: 'If a web component has children, then those children will probably be displayed
    incorrectly before the component is defined. You can use this CSS to keep web
    components hidden until they are defined:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 Web 组件有子元素，在组件定义之前这些子元素可能会显示不正确。您可以使用以下 CSS 来保持 Web 组件隐藏，直到它们被定义：
- en: '[PRE72]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Like regular HTML elements, web components can be used in JavaScript. If you
    include a `<search-box>` tag in your web page, then you can obtain a reference
    to it with `querySelector()` and an appropriate CSS selector, just as you would
    for any other HTML tag. Generally, it only makes sense to do this after the module
    that defines the component has run, so be careful when querying web components
    that you do not do so too early. Web component implementations typically (but
    this is not a requirement) define a JavaScript property for each HTML attribute
    they support. And, like HTML elements, they may also define useful methods. Once
    again, the documentation for the web component you are using should specify what
    properties and methods are available to your JavaScript code.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 像常规 HTML 元素一样，Web 组件可以在 JavaScript 中使用。如果在 Web 页面中包含了`<search-box>`标签，那么您可以使用`querySelector()`和适当的
    CSS 选择器获取对它的引用，就像对任何其他 HTML 标签一样。通常，只有在定义组件的模块运行后才有意义这样做，因此在查询 Web 组件时要小心不要太早。Web
    组件实现通常（但这不是必需的）为它们支持的每个 HTML 属性定义一个 JavaScript 属性。而且，像 HTML 元素一样，它们也可以定义有用的方法。再次强调，您使用的
    Web 组件的文档应该指定哪些属性和方法对您的 JavaScript 代码是可用的。
- en: Now that you know how to use web components, the next three sections cover the
    three web browser features that allow us to implement them.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解如何使用 Web 组件，接下来的三节将介绍允许我们实现它们的三个 Web 浏览器功能。
- en: 15.6.2 HTML Templates
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.2 HTML 模板
- en: The HTML `<template>` tag is only loosely related to web components, but it
    does enable a useful optimization for components that appear frequently in web
    pages. `<template>` tags and their children are never rendered by a web browser
    and are only useful on web pages that use JavaScript. The idea behind this tag
    is that when a web page contains multiple repetitions of the same basic HTML structure
    (such as rows in a table or the internal implementation of a web component), then
    we can use a `<template>` to define that element structure once, then use JavaScript
    to duplicate the structure as many times as needed.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `<template>` 标签与 Web 组件只有松散的关系，但它确实为在 Web 页面中频繁出现的组件提供了一个有用的优化。`<template>`
    标签及其子元素从不被 Web 浏览器呈现，仅在使用 JavaScript 的 Web 页面上才有用。这个标签的理念是，当一个 Web 页面包含多个相同基本
    HTML 结构的重复（例如表中的行或 Web 组件的内部实现）时，我们可以使用 `<template>` 一次定义该元素结构，然后使用 JavaScript
    根据需要复制该结构多次。
- en: 'In JavaScript, a `<template>` tag is represented by an HTMLTemplateElement
    object. This object defines a single `content` property, and the value of this
    property is a DocumentFragment of all the child nodes of the `<template>`. You
    can clone this DocumentFragment and then insert the cloned copy into your document
    as needed. The fragment itself will not be inserted, but its children will be.
    Suppose you’re working with a document that includes a `<table>` and `<template
    id="row">` tag and that the template defines the structure of rows for that table.
    You might use the template like this:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`<template>` 标签由 HTMLTemplateElement 对象表示。这个对象定义了一个`content`属性，这个属性的值是`<template>`的所有子节点的
    DocumentFragment。您可以克隆这个 DocumentFragment，然后根据需要将克隆的副本插入到您的文档中。片段本身不会被插入，但它的子节点会被插入。假设您正在处理一个包含`<table>`和`<template
    id="row">`标签的文档，模板定义了该表的行结构。您可以像这样使用模板：
- en: '[PRE73]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Template elements do not have to appear literally in an HTML document in order
    to be useful. You can create a template in your JavaScript code, create its children
    with `innerHTML`, and then make as many clones as needed without the parsing overhead
    of `innerHTML`. This is how HTML templates are typically used in web components,
    and [Example 15-3](#search-box.js) demonstrates this technique.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 模板元素不必在 HTML 文档中直接出现才能发挥作用。您可以在 JavaScript 代码中创建模板，使用`innerHTML`创建其子元素，然后根据需要制作尽可能多的克隆而无需解析`innerHTML`的开销。这就是
    HTML 模板在 Web 组件中通常的用法，[示例 15-3](#search-box.js)演示了这种技术。
- en: 15.6.3 Custom Elements
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.3 自定义元素
- en: 'The second web browser feature that enables web components is “custom elements”:
    the ability to associate a JavaScript class with an HTML tag name so that any
    such tags in the document are automatically turned into instances of the class
    in the DOM tree. The `customElements.define()` method takes a web component tag
    name as its first argument (remember that the tag name must include a hyphen)
    and a subclass of HTMLElement as its second argument. Any existing elements in
    the document with that tag name are “upgraded” to newly created instances of the
    class. And if the browser parses any HTML in the future, it will automatically
    create an instance of the class for each of the tags it encounters.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 使 Web 组件能够实现的第二个 Web 浏览器功能是“自定义元素”：将 JavaScript 类与 HTML 标签名称关联起来，以便文档中的任何此类标签自动转换为
    DOM 树中的类实例。`customElements.define()` 方法以 Web 组件标签名称作为第一个参数（请记住标签名称必须包含连字符），以 HTMLElement
    的子类作为第二个参数。文档中具有该标签名称的任何现有元素都会“升级”为新创建的类实例。如果浏览器将来解析任何 HTML，它将自动为遇到的每个标签创建一个类的实例。
- en: The class passed to `customElements.define()` should extend HTMLElement and
    not a more specific type like HTMLButtonElement.^([4](ch15.xhtml#idm46198505802920))
    Recall from [Chapter 9](ch09.xhtml#classes) that when a JavaScript class extends
    another class, the constructor function must call `super()` before it uses the
    `this` keyword, so if the custom element class has a constructor, it should call
    `super()` (with no arguments) before doing anything else.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `customElements.define()` 的类应该扩展 HTMLElement，而不是更具体的类型，如 HTMLButtonElement。回想一下[第
    9 章](ch09.xhtml#classes)中提到的，当 JavaScript 类扩展另一个类时，构造函数必须在使用 `this` 关键字之前调用 `super()`，因此如果自定义元素类有构造函数，它应该在执行任何其他操作之前调用
    `super()`（不带参数）。
- en: The browser will automatically invoke certain “lifecycle methods” of a custom
    element class. The `connectedCallback()` method is invoked when an instance of
    the custom element is inserted into the document, and many elements use this method
    to perform initialization. There is also a `disconnectedCallback()` method invoked
    when (and if) the element is removed from the document, though this is less often
    used.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将自动调用自定义元素类的某些“生命周期方法”。当自定义元素的实例插入文档中时，将调用 `connectedCallback()` 方法，许多元素使用此方法执行初始化。还有一个
    `disconnectedCallback()` 方法在元素从文档中移除时（如果有的话）被调用，尽管这不太常用。
- en: If a custom element class defines a static `observedAttributes` property whose
    value is an array of attribute names, and if any of the named attributes are set
    (or changed) on an instance of the custom element, the browser will invoke the
    `attributeChangedCallback()` method, passing the attribute name, its old value,
    and its new value. This callback can take whatever steps are necessary to update
    the component based on its attribute values.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自定义元素类定义了一个静态的 `observedAttributes` 属性，其值是属性名称数组，并且如果在自定义元素的实例上设置（或更改）了任何命名属性，则浏览器将调用
    `attributeChangedCallback()` 方法，传递属性名称、其旧值和新值。此回调可以采取任何必要步骤来根据其属性值更新组件。
- en: Custom element classes can also define whatever other properties and methods
    they want to. Commonly, they will define getter and setter methods that make the
    element’s attributes available as JavaScript properties.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元素类也可以定义任何其他属性和方法。通常，它们会定义获取器和设置器方法，使元素的属性可以作为 JavaScript 属性使用。
- en: 'As an example of a custom element, suppose we want to be able to display circles
    within paragraphs of regular text. We’d like to be able to write HTML like this
    in order to render mathematical story problems like the one shown in [Figure 15-4](#inlinecircle):'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 作为自定义元素的一个示例，假设我们希望能够在常规文本段落中显示圆形。我们希望能够编写类似于以下 HTML 以渲染像[图 15-4](#inlinecircle)中显示的数学问题：
- en: '[PRE74]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![js7e 15in01](Images/js7e_15in01.png)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 15in01](Images/js7e_15in01.png)'
- en: Figure 15-4\. An inline circle custom element
  id: totrans-510
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-4\. 内联圆形自定义元素
- en: 'We can implement this `<inline-circle>` custom element with the code shown
    in [Example 15-2](#inline-circle-js):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 [示例 15-2](#inline-circle-js) 中显示的代码来实现这个 `<inline-circle>` 自定义元素：
- en: Example 15-2\. The <inline-circle> custom element
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-2\. `<inline-circle>` 自定义元素
- en: '[PRE75]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 15.6.4 Shadow DOM
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.4 影子 DOM
- en: The custom element demonstrated in [Example 15-2](#inline-circle-js) is not
    well encapsulated. When you set its `diameter` or `color` attributes, it responds
    by altering its own `style` attribute, which is not behavior we would ever expect
    from a real HTML element. To turn a custom element into a true web component,
    it should use the powerful encapsulation mechanism known as *shadow DOM*.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 15-2](#inline-circle-js)中展示的自定义元素没有很好地封装。当设置其 `diameter` 或 `color` 属性时，它会通过更改自己的
    `style` 属性来响应，这不是我们从真正的 HTML 元素中期望的行为。要将自定义元素转变为真正的 Web 组件，它应该使用强大的封装机制，即*影子 DOM*。
- en: Shadow DOM allows a “shadow root” to be attached to a custom element (and also
    to a `<div>`, `<span>`, `<body>`, `<article>`, `<main>`, `<nav>`, `<header>`,
    `<footer>`, `<section>`, `<p>`, `<blockquote>`, `<aside>`, or `<h1>` through `<h6>`
    element) known as a “shadow host.” Shadow host elements, like all HTML elements,
    are already the root of a normal DOM tree of descendant elements and text nodes.
    A shadow root is the root of another, more private, tree of descendant elements
    that sprouts from the shadow host and can be thought of as a distinct minidocument.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow DOM 允许将“影子根”附加到自定义元素（以及 `<div>`、`<span>`、`<body>`、`<article>`、`<main>`、`<nav>`、`<header>`、`<footer>`、`<section>`、`<p>`、`<blockquote>`、`<aside>`
    或 `<h1>` 到 `<h6>` 元素）上，称为“影子主机”。影子主机元素，像所有 HTML 元素一样，已经是后代元素和文本节点的普通 DOM 树的根。影子根是另一个更私密的后代元素树的根，从影子主机发芽，可以被视为一个独立的小型文档。
- en: 'The word “shadow” in “shadow DOM” refers to the fact that elements that descend
    from a shadow root are “hiding in the shadows”: they are not part of the normal
    DOM tree, do not appear in the `children` array of their host element, and are
    not visited by normal DOM traversal methods such as `querySelector()`. For contrast,
    the normal, regular DOM children of a shadow host are sometimes referred to as
    the “light DOM.”'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: “shadow DOM” 中的 “shadow” 一词指的是从影子根源的元素“隐藏在阴影中”：它们不是正常 DOM 树的一部分，不出现在其宿主元素的 `children`
    数组中，并且不会被正常的 DOM 遍历方法（如 `querySelector()`）访问。相比之下，影子宿主的正常、常规 DOM 子元素有时被称为 “light
    DOM”。
- en: 'To understand the purpose of the shadow DOM, picture the HTML `<audio>` and
    `<video>` elements: they display a nontrivial user interface for controlling media
    playback, but the play and pause buttons and other UI elements are not part of
    the DOM tree and cannot be manipulated by JavaScript. Given that web browsers
    are designed to display HTML, it is only natural that browser vendors would want
    to display internal UIs like these using HTML. In fact, most browsers have been
    doing something like that for a long time, and the shadow DOM makes it a standard
    part of the web platform.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解影子 DOM 的目的，想象一下 HTML `<audio>` 和 `<video>` 元素：它们显示了一个用于控制媒体播放的非平凡用户界面，但播放和暂停按钮以及其他
    UI 元素不是 DOM 树的一部分，也不能被 JavaScript 操纵。鉴于 Web 浏览器设计用于显示 HTML，浏览器供应商自然希望使用 HTML 显示这些内部
    UI。事实上，大多数浏览器长期以来一直在做类似的事情，而影子 DOM 使其成为 Web 平台的标准部分。
- en: Shadow DOM encapsulation
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影子 DOM 封装
- en: 'The key feature of shadow DOM is the encapsulation it provides. The descendants
    of a shadow root are hidden from—and independent from—the regular DOM tree, almost
    as if they were in an independent document. There are three very important kinds
    of encapsulation provided by the shadow DOM:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 影子 DOM 的关键特征是提供的封装。影子根的后代元素对于常规 DOM 树是隐藏的，并且独立的，几乎就像它们在一个独立的文档中一样。影子 DOM 提供了三种非常重要的封装类型：
- en: As already mentioned, elements in the shadow DOM are hidden from regular DOM
    methods like `querySelectorAll()`. When a shadow root is created and attached
    to its shadow host, it can be created in “open” or “closed” mode. A closed shadow
    root is completely sealed away and inaccessible. More commonly, though, shadow
    roots are created in “open” mode, which means that the shadow host has a `shadowRoot`
    property that JavaScript can use to gain access to the elements of the shadow
    root, if it has some reason to do so.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，影子 DOM 中的元素对于像 `querySelectorAll()` 这样的常规 DOM 方法是隐藏的。当创建一个影子根并将其附加到其影子宿主时，它可以以
    “open” 或 “closed” 模式创建。尽管更常见的是，影子根以 “open” 模式创建，这意味着影子宿主具有一个 `shadowRoot` 属性，JavaScript
    可以使用它来访问影子根的元素，如果有某种原因需要这样做。
- en: 'Styles defined beneath a shadow root are private to that tree and will never
    affect the light DOM elements on the outside. (A shadow root can define default
    styles for its host element, but these will be overridden by light DOM styles.)
    Similarly, the light DOM styles that apply to the shadow host element have no
    effect on the descendants of the shadow root. Elements in the shadow DOM will
    inherit things like font size and background color from the light DOM, and styles
    in the shadow DOM can choose to use CSS variables defined in the light DOM. For
    the most part, however, the styles of the light DOM and the styles of the shadow
    DOM are completely independent: the author of a web component and the user of
    a web component do not have to worry about collisions or conflicts between their
    stylesheets. Being able to “scope” CSS in this way is perhaps the most important
    feature of the shadow DOM.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在影子根下定义的样式是私有的，并且永远不会影响外部的 light DOM 元素。（影子根可以为其宿主元素定义默认样式，但这些样式将被 light DOM
    样式覆盖。）同样，适用于影子宿主元素的 light DOM 样式对影子根的后代元素没有影响。影子 DOM 中的元素将从 light DOM 继承诸如字体大小和背景颜色之类的属性，并且影子
    DOM 中的样式可以选择使用在 light DOM 中定义的 CSS 变量。然而，在大多数情况下，light DOM 的样式和影子 DOM 的样式是完全独立的：Web
    组件的作者和 Web 组件的用户不必担心样式表之间的冲突或冲突。以这种方式“范围” CSS 可能是影子 DOM 最重要的特性。
- en: Some events (like “load”) that occur within the shadow DOM are confined to the
    shadow DOM. Others, including focus, mouse, and keyboard events bubble up and
    out. When an event that originates in the shadow DOM crosses the boundary and
    begins to propagate in the light DOM, its `target` property is changed to the
    shadow host element, so it appears to have originated directly on that element.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在影子 DOM 中发生的一些事件（如 “load”）被限制在影子 DOM 中。其他事件，包括焦点、鼠标和键盘事件会冒泡并传播出去。当起源于影子 DOM
    的事件越过边界并开始在 light DOM 中传播时，其 `target` 属性会更改为影子宿主元素，因此看起来好像是直接在该元素上发生的。
- en: Shadow DOM slots and light DOM children
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影子 DOM 插槽和 light DOM 子元素
- en: 'An HTML element that is a shadow host has two trees of descendants. One is
    the `children[]` array—the regular light DOM descendants of the host element—and
    the other is the shadow root and all of its descendants, and you may be wondering
    how two distinct content trees can be displayed within the same host element.
    Here’s how it works:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 作为影子宿主的 HTML 元素有两个后代树。一个是 `children[]` 数组—宿主元素的常规 light DOM 后代—另一个是影子根及其所有后代，您可能想知道如何在同一宿主元素内显示两个不同的内容树。工作原理如下：
- en: The descendants of the shadow root are always displayed within the shadow host.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影子根的后��元素始终显示在影子宿主内。
- en: If those descendants include a `<slot>` element, then the regular light DOM
    children of the host element are displayed as if they were children of that `<slot>`,
    replacing any shadow DOM content in the slot. If the shadow DOM does not include
    a `<slot>`, then any light DOM content of the host is never displayed. If the
    shadow DOM has a `<slot>`, but the shadow host has no light DOM children, then
    the shadow DOM content of the slot is displayed as a default.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这些后代包括一个 `<slot>` 元素，则主机元素的常规 light DOM 子元素将显示为该 `<slot>` 的子元素，替换插槽中的任何 shadow
    DOM 内容。如果 shadow DOM 不包含 `<slot>`，则主机的任何 light DOM 内容都不会显示。如果 shadow DOM 有一个 `<slot>`，但
    shadow host 没有 light DOM ���元素，则插槽的 shadow DOM 内容将作为默认显示。
- en: When light DOM content is displayed within a shadow DOM slot, we say that those
    elements have been “distributed,” but it is important to understand that the elements
    do not actually become part of the shadow DOM. They can still be queried with
    `querySelector()`, and they still appear in the light DOM as children or descendants
    of the host element.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 light DOM 内容显示在 shadow DOM 插槽中时，我们说这些元素已被“分发”，但重要的是要理解这些元素实际上并未成为 shadow DOM
    的一部分。它们仍然可以使用 `querySelector()` 进行查询，并且它们仍然显示在 light DOM 中，作为主机元素的子元素或后代。
- en: If the shadow DOM defines more than one `<slot>` and names those slots with
    a `name` attribute, then children of the shadow host can specify which slot they
    would like to appear in by specifying a `slot="slotname"` attribute. We saw an
    example of this usage in [§15.6.1](#usingwebcomponents) when we demonstrated how
    to customize the icons displayed by the `<search-box>` component.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 shadow DOM 定义了多个带有 `name` 属性命名的 `<slot>`，那么 shadow host 的子元素可以通过指定 `slot="slotname"`
    属性来指定它们想要出现在哪个插槽中。我们在 [§15.6.1](#usingwebcomponents) 中演示了这种用法的示例，当我们演示如何自定义 `<search-box>`
    组件显示的图标时。
- en: Shadow DOM API
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shadow DOM API
- en: For all of its power, the Shadow DOM doesn’t have much of a JavaScript API.
    To turn a light DOM element into a shadow host, just call its `attachShadow()`
    method, passing `{mode:"open"}` as the only argument. This method returns a shadow
    root object and also sets that object as the value of the host’s `shadowRoot`
    property. The shadow root object is a DocumentFragment, and you can use DOM methods
    to add content to it or just set its `innerHTML` property to a string of HTML.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Shadow DOM 功能强大，但它的 JavaScript API 并不多。要将 light DOM 元素转换为 shadow host，只需调用其
    `attachShadow()` 方法，将 `{mode:"open"}` 作为唯一参数传递。此方法返回一个 shadow root 对象，并将该对象设置为主机的
    `shadowRoot` 属性的值。shadow root 对象是一个 DocumentFragment，您可以使用 DOM 方法向其添加内容，或者只需将其
    `innerHTML` 属性设置为 HTML 字符串。
- en: If your web component needs to know when the light DOM content of a shadow DOM
    `<slot>` has changed, it can register a listener for “slotchanged” events directly
    on the `<slot>` element.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的 Web 组件需要知道 shadow DOM `<slot>` 的 light DOM 内容何时更改，它可以直接在 `<slot>` 元素上注册“slotchanged”事件的监听器。
- en: '15.6.5 Example: a <search-box> Web Component'
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.5 示例：一个 <search-box> Web 组件
- en: '[Figure 15-3](#searchboxfig) illustrated a `<search-box>` web component. [Example 15-3](#search-box.js)
    demonstrates the three enabling technologies that define web components: it implements
    the `<search-box>` component as a custom element that uses a `<template>` tag
    for efficiency and a shadow root for encapsulation.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-3](#searchboxfig) 展示了一个 `<search-box>` Web 组件。[示例 15-3](#search-box.js)
    演示了定义 Web 组件的三种启用技术：它将 `<search-box>` 组件实现为使用 `<template>` 标签提高效率和使用 shadow root
    封装的自定义元素。'
- en: This example shows how to use the low-level web component APIs directly. In
    practice, many web components developed today create them using higher-level libraries
    such as “lit-element.” One of the reasons to use a library is that creating reusable
    and customizable components is actually quite hard to do well, and there are many
    details to get right. [Example 15-3](#search-box.js) demonstrates web components
    and does some basic keyboard focus handling, but otherwise ignores accessibility
    and makes no attempt to use proper ARIA attributes to make the component work
    with screen readers and other assistive technology.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何直接使用低级 Web 组件 API。实际上，今天开发的许多 Web 组件都是使用诸如 “lit-element” 等更高级别库创建的。使用库的原因之一是创建可重用和可定制组件实际上是非常困难的，并且有许多细节需要正确处理。[示例
    15-3](#search-box.js) 演示了 Web 组件并进行了一些基本的键盘焦点处理，但忽略了可访问性，并且没有尝试使用正确的 ARIA 属性使组件与屏幕阅读器和其他辅助技术配合使用。
- en: Example 15-3\. Implementing a web component
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-3。实现一个 Web 组件
- en: '[PRE76]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '15.7 SVG: Scalable Vector Graphics'
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.7 SVG：可缩放矢量图形
- en: '*SVG* (scalable vector graphics) is an image format. The word “vector” in its
    name indicates that it is fundamentally different from raster image formats, such
    as GIF, JPEG, and PNG, that specify a matrix of pixel values. Instead, an SVG
    “image” is a precise, resolution-independent (hence “scalable”) description of
    the steps necessary to draw the desired graphic. SVG images are described by text
    files using the XML markup language, which is quite similar to HTML.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '*SVG*（可缩放矢量图形）是一种图像格式。其名称中的“矢量”一词表明它与像 GIF、JPEG 和 PNG 这样指定像素值矩阵的位图图像格式 fundamentally
    fundamentally 不同。相反，SVG “图像”是绘制所需图形的步骤的精确、与分辨率无关（因此“可缩放”）描述。SVG 图像由使用 XML 标记语言的文本文件描述，这与
    HTML 非常相似。'
- en: 'There are three ways you can use SVG in web browsers:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 浏览器中有三种使用 SVG 的方式：
- en: You can use *.svg* image files with regular HTML `<img>` tags, just as you would
    use a *.png* or *.jpeg* image.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以像使用 *.png* 或 *.jpeg* 图像一样使用 *.svg* 图像文件与常规 HTML `<img>` 标签。
- en: Because the XML-based SVG format is so similar to HTML, you can actually embed
    SVG tags directly into your HTML documents. If you do this, the browser’s HTML
    parser allows you to omit XML namespaces and treat SVG tags as if they were HTML
    tags.
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于基于 XML 的 SVG 格式与 HTML 如此相似，您实际上可以直接将 SVG 标记嵌入到 HTML 文档中。如果这样做，浏览器的 HTML 解析器允许您省略
    XML 命名空间，并将 SVG 标记视为 HTML 标记。
- en: You can use the DOM API to dynamically create SVG elements to generate images
    on demand.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 DOM API 动态创建 SVG 元素以根据需要生成图像。
- en: The subsections that follow demonstrate the second and third uses of SVG. Note,
    however, that SVG has a large and moderately complex grammar. In addition to simple
    shape-drawing primitives, it includes support for arbitrary curves, text, and
    animation. SVG graphics can even incorporate JavaScript scripts and CSS stylesheets
    to add behavior and presentation information. A full description of SVG is well
    beyond the scope of this book. The goal of this section is just to show you how
    you can use SVG in your HTML documents and script it with JavaScript.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节演示了SVG的第二和第三种用法。但请注意，SVG具有庞大且稍微复杂的语法。除了简单的形状绘制原语外，它还包括对任意曲线、文本和动画的支持。SVG图形甚至可以包含JavaScript脚本和CSS样式表，以添加行为和呈现信息。SVG的完整描述远远超出了本书的范围。本节的目标只是向您展示如何在HTML文档中使用SVG并使用JavaScript进行脚本化。
- en: 15.7.1 SVG in HTML
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.1 HTML中的SVG
- en: 'SVG images can, of course, be displayed using HTML `<img>` tags. But you can
    also embed SVG directly in HTML. And if you do this, you can even use CSS stylesheets
    to specify things like fonts, colors, and line widths. Here, for example, is an
    HTML file that uses SVG to display an analog clock face:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SVG图像可以使用HTML `<img>`标签显示。但您也可以直接在HTML中嵌入SVG。如果这样做，甚至可以使用CSS样式表来指定字体、颜色和线宽等内容。例如，这里是一个使用SVG显示模拟时钟表盘的HTML文件：
- en: '[PRE77]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You’ll notice that the descendants of the `<svg>` tag are not normal HTML tags.
    `<circle>`, `<line>`, and `<text>` tags have obvious purposes, though, and it
    should be clear how this SVG graphic works. There are many other SVG tags, however,
    and you’ll need to consult an SVG reference to learn more. You may also notice
    that the stylesheet is odd. Styles like `fill`, `stroke-width`, and `text-anchor`
    are not normal CSS style properties. In this case, CSS is essentially being used
    to set attributes of SVG tags that appear in the document. Note also that the
    CSS `font` shorthand property does not work for SVG tags, and you must explicitly
    set `font-family`, `font-size`, and `font-weight` as separate style properties.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到`<svg>`标签的后代不是普通的HTML标签。`<circle>`、`<line>`和`<text>`标签具有明显的目的，因此这个SVG图形的工作原理应该很清楚。然而，还有许多其他SVG标签，您需要查阅SVG参考资料以了解更多信息。您可能还会注意到样式表很奇怪。像`fill`���`stroke-width`和`text-anchor`这样的样式不是正常的CSS样式属性。在这种情况下，CSS基本上用于设置文档中出现的SVG标签的属性。还要注意，CSS的`font`简写属性不适用于SVG标签，您必须显式设置`font-family`、`font-size`和`font-weight`等单独的样式属性。
- en: 15.7.2 Scripting SVG
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.2 脚本化SVG
- en: One reason to embed SVG directly into your HTML files (instead of just using
    static `<img>` tags) is that if you do this, then you can use the DOM API to manipulate
    the SVG image. Suppose you use SVG to display icons in your web application. You
    could embed SVG within a `<template>` tag ([§15.6.2](#templatetag)) and then clone
    the template content whenever you need to insert a copy of that icon into your
    UI. And if you want the icon to respond to user activity—by changing color when
    the user hovers the pointer over it, for example—you can often achieve this with
    CSS.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 将SVG直接嵌入HTML文件中（而不仅仅使用静态的`<img>`标签）的一个原因是，这样做可以使用DOM API来操纵SVG图像。假设您在Web应用程序中使用SVG显示图标。您可以在`<template>`标签中嵌入SVG（[§15.6.2](#templatetag)），然后在需要将该图标的副本插入UI时克隆模板内容。如果您希望图标对用户活动做出响应——例如，当用户将指针悬停在其上时更改颜色——通常可以使用CSS实现。
- en: It is also possible to dynamically manipulate SVG graphics that are directly
    embedded in HTML. The clock face example in the previous section displays a static
    clock with hour and minute hands facing straight up displaying the time noon or
    midnight. But you may have noticed that the HTML file includes a `<script>` tag.
    That script runs a function periodically to check the time and transform the hour
    and minute hands by rotating them the appropriate number of degrees so that the
    clock actually displays the current time, as shown in [Figure 15-5](#clockfig).
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以动态操作直接嵌入HTML中的SVG图形。前一节中的时钟示例显示了一个静态时钟，时针和分针指向正上方，显示中午或午夜时间。但您可能已经注意到HTML文件包含了一个`<script>`标签。该脚本定期运行一个函数来检查时间，并根据需要旋转时针和分针的适当角度，使时钟实际显示当前时间，如[图 15-5](#clockfig)所示。
- en: '![js7e 1504](Images/js7e_1504.png)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1504](Images/js7e_1504.png)'
- en: Figure 15-5\. A scripted SVG analog clock
  id: totrans-553
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-5\. 一个脚本化的SVG模拟时钟
- en: 'The code to manipulate the clock is straightforward. It determines the proper
    angle of the hour and minute hands based on the current time, then uses `querySelector()`
    to look up the SVG elements that display those hands, then sets a `transform`
    attribute on them to rotate them around the center of the clock face. The function
    uses `setTimeout()` to ensure that it runs once a minute:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵时钟的代码很简单。它根据当前时间确定时针和分针的正确角度，然后使用`querySelector()`查找显示这些指针的SVG元素，然后在它们上设置`transform`属性以围绕时钟表盘的中心旋转它们。该函数使用`setTimeout()`确保它每分钟运行一次：
- en: '[PRE78]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 15.7.3 Creating SVG Images with JavaScript
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.3 使用JavaScript创建SVG图像
- en: In addition to simply scripting SVG images embedded in your HTML documents,
    you can also build SVG images from scratch, which can be useful to create visualizations
    of dynamically loaded data, for example. [Example 15-4](#pieChart.js) demonstrates
    how you can use JavaScript to create SVG pie charts, like the one shown in [Figure 15-6](#piechartfig).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单地在HTML文档中嵌入脚本化的SVG图像外，您还可以从头开始构建SVG图像，这对于创建动态加载数据的可视化效果非常有用。[示例 15-4](#pieChart.js)演示了如何使用JavaScript创建SVG饼图，就像在[图 15-6](#piechartfig)中显示的那样。
- en: Even though SVG tags can be included within HTML documents, they are technically
    XML tags, not HTML tags, and if you want to create SVG elements with the JavaScript
    DOM API, you can’t use the normal `createElement()` function that was introduced
    in [§15.3.5](#creating-inserting-deleting). Instead you must use `createElementNS()`,
    which takes an XML namespace string as its first argument. For SVG, that namespace
    is the literal string “http://www.w3.org/2000/svg.”
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SVG标记可以包含在HTML文档中，但它们在技术上是XML标记，而不是HTML标记，如果要使用JavaScript DOM API创建SVG元素，就不能使用在[§15.3.5](#creating-inserting-deleting)中介绍的普通`createElement()`函数。相反，必须使用`createElementNS()`，它的第一个参数是XML命名空间字符串。对于SVG，该命名空间是字面字符串“http://www.w3.org/2000/svg”。
- en: '![js7e 1505](Images/js7e_1505.png)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1505](Images/js7e_1505.png)'
- en: Figure 15-6\. An SVG pie chart built with JavaScript (data from Stack Overflow’s
    2018 Developer Survey of Most Popular Technologies)
  id: totrans-560
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-6\. 使用JavaScript构建的SVG饼图（数据来自Stack Overflow的2018年开发者调查最受欢迎技术）
- en: Other than the use of `createElementNS()`, the pie chart–drawing code in [Example 15-4](#pieChart.js)
    is relatively straightforward. There is a little math to convert the data being
    charted into pie-slice angles. The bulk of the example, however, is DOM code that
    creates SVG elements and sets attributes on those elements.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`createElementNS()`之外，[示例15-4](#pieChart.js)中的饼图绘制代码相对简单。有一点数学计算将被绘制的数据转换为饼图角度。然而，示例的大部分是创建SVG元素并在这些元素上设置属性的DOM代码。
- en: The most opaque part of this example is the code that draws the actual pie slices.
    The element used to display each slice is `<path>`. This SVG element describes
    arbitrary shapes comprised of lines and curves. The shape description is specified
    by the `d` attribute of the `<path>` element. The value of this attribute uses
    a compact grammar of letter codes and numbers that specify coordinates, angles,
    and other values. The letter M, for example, means “move to” and is followed by
    *x* and *y* coordinates. The letter L means “line to” and draws a line from the
    current point to the coordinates that follow it. This example also uses the letter
    A to draw an arc. This letter is followed by seven numbers describing the arc,
    and you can look up the syntax online if you want to know more.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中最不透明的部分是绘制实际饼图片段的代码。用于显示每个片段的元素是`<path>`。这个SVG元素描述由线条和曲线组成的任意形状。形状描述由`<path>`元素的`d`属性指定。该属性的值使用字母代码和数字的紧凑语法，指定坐标、角度和其他值。例如，字母M表示“移动到”，后面跟着*x*和*y*坐标。字母L表示“线到”，从当前点画一条线到其后面的坐标。这个示例还使用字母A来绘制弧线。这个字母后面跟着描述弧线的七个数字，如果想了解更多，可以在线查找语法。
- en: Example 15-4\. Drawing a pie chart with JavaScript and SVG
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-4\. 使用JavaScript和SVG绘制饼图
- en: '[PRE79]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The pie chart in [Figure 15-6](#piechartfig) was created using the `pieChart()`
    function from [Example 15-4](#pieChart.js), like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-6](#piechartfig)中的饼图是使用[示例15-4](#pieChart.js)中的`pieChart()`函数创建的，如下所示：'
- en: '[PRE80]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 15.8 Graphics in a <canvas>
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.8 <canvas>中的图形
- en: 'The `<canvas>` element has no appearance of its own but creates a drawing surface
    within the document and exposes a powerful drawing API to client-side JavaScript.
    The main difference between the `<canvas>` API and SVG is that with the canvas
    you create drawings by calling methods, and with SVG you create drawings by building
    a tree of XML elements. These two approaches are equivalently powerful: either
    one can be simulated with the other. On the surface, they are quite different,
    however, and each has its strengths and weaknesses. An SVG drawing, for example,
    is easily edited by removing elements from its description. To remove an element
    from the same graphic in a `<canvas>`, it is often necessary to erase the drawing
    and redraw it from scratch. Since the Canvas drawing API is JavaScript-based and
    relatively compact (unlike the SVG grammar), it is documented in more detail in
    this book.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`<canvas>`元素本身没有自己的外观，但在文档中创建了一个绘图表面，并向客户端JavaScript公开了强大的绘图API。`<canvas>`
    API与SVG之间的主要区别在于，使用canvas时通过调用方法创建绘图，而使用SVG时通过构建XML元素树创建绘图。这两种方法具有同等的强大功能：任何一种都可以模拟另一种。然而，在表面上，它们是非常不同的，每种方法都有其优势和劣势。例如，SVG图形很容易通过从描述中删除元素来编辑。要从`<canvas>`中的相同图形中删除元素，通常需要擦除绘图并从头开始重绘。由于Canvas绘图API基于JavaScript且相对紧凑（不像SVG语法），因此在本书中对其进行了更详细的文档记录。'
- en: Most of the Canvas drawing API is defined not on the `<canvas>` element itself,
    but instead on a “drawing context” object obtained with the `getContext()` method
    of the canvas. Call `getContext()` with the argument “2d” to obtain a CanvasRenderingContext2D
    object that you can use to draw two-dimensional graphics into the canvas.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分Canvas绘图API并不是在`<canvas>`元素本身上定义的，而是在通过canvas的`getContext()`方法获得的“绘图上下文”对象上定义的。使用参数“2d”调用`getContext()`以获得一个CanvasRenderingContext2D对象，您可以使用它将二维图形绘制到画布上。
- en: 'As a simple example of the Canvas API, the following HTML document uses `<canvas>`
    elements and some JavaScript to display two simple shapes:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Canvas API的一个简单示例，以下HTML文档使用`<canvas>`元素和一些JavaScript来显示两个简单的形状：
- en: '[PRE81]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We’ve seen that SVG describes complex shapes as a “path” of lines and curves
    that can be drawn or filled. The Canvas API also uses the notion of a path. Instead
    of describing a path as a string of letters and numbers, a path is defined by
    a series of method calls, such as the `beginPath()` and `arc()` invocations in
    the preceding code. Once a path is defined, other methods, such as `fill()`, operate
    on that path. Various properties of the context object, such as `fillStyle`, specify
    how these operations are performed.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到SVG将复杂形状描述为由线条和曲线组成的“路径”。Canvas API也使用路径的概念。路径不是通过字母和数字的字符串描述，而是通过一系列方法调用来定义，例如前面代码中的`beginPath()`和`arc()`调用。一旦定义了路径，其他方法，如`fill()`，就会对该路径进行操作。上下文对象的各种属性，如`fillStyle`，指定了这些操作是如何执行的。
- en: 'The subsections that follow demonstrate the methods and properties of the 2D
    Canvas API. Much of the example code that follows operates on a variable `c`.
    This variable holds the CanvasRenderingContext2D object of the canvas, but the
    code to initialize that variable is sometimes not shown. In order to make these
    examples run, you would need to add HTML markup to define a canvas with appropriate
    `width` and `height` attributes, and then add code like this to initialize the
    variable `c`:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节演示了2D Canvas API的方法和属性。后面的示例代码大部分操作一个名为`c`的变量。这个变量保存了画布的CanvasRenderingContext2D对象，但有时初始化该变量的代码并没有显示。为了使这些示例运行，你需要添加HTML标记来定义一个带有适当`width`和`height`属性的画布，然后添加像这样的代码来初始化变量`c`：
- en: '[PRE82]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 15.8.1 Paths and Polygons
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.1 路径和多边形
- en: 'To draw lines on a canvas and to fill the areas enclosed by those lines, you
    begin by defining a *path*. A path is a sequence of one or more subpaths. A subpath
    is a sequence of two or more points connected by line segments (or, as we’ll see
    later, by curve segments). Begin a new path with the `beginPath()` method. Begin
    a new subpath with the `moveTo()` method. Once you have established the starting
    point of a subpath with `moveTo()`, you can connect that point to a new point
    with a straight line by calling `lineTo()`. The following code defines a path
    that includes two line segments:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制线条并填充由这些线条围起来的区域时，首先需要定义一个*路径*。路径是一个或多个子路径的序列。子路径是由线段（或者后面我们将看到的曲线段）连接的两个或多个点的序列。使用`beginPath()`方法开始一个新路径。使用`moveTo()`方法开始一个新的子路径。一旦用`moveTo()`确定了子路径的起始点，你可以通过调用`lineTo()`将该点连接到一个新点形成一条直线。以下代码定义了包含两条线段的路径：
- en: '[PRE83]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This code simply defines a path; it does not draw anything on the canvas. To
    draw (or “stroke”) the two line segments in the path, call the `stroke()` method,
    and to fill the area defined by those line segments, call `fill()`:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仅仅定义了一个路径；它并没有在画布上绘制任何东西。要绘制（或“描边”）路径中的两条线段，调用`stroke()`方法；要填充由这些线段定义的区域，调用`fill()`：
- en: '[PRE84]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This code (along with some additional code to set line widths and fill colors)
    produced the drawing shown in [Figure 15-7](Images/#simplepath_png).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码（以及一些额外的用于设置线宽和填充颜色的代码）生成了[图 15-7](Images/#simplepath_png)中显示的图形。
- en: '![js7e 1506](Images/js7e_1506.png)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1506](Images/js7e_1506.png)'
- en: Figure 15-7\. A simple path, filled and stroked
  id: totrans-582
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-7\. 一个简单的路径，填充和描边
- en: Notice that the subpath defined in [Figure 15-7](Images/#simplepath_png) is
    “open.” It consists of just two line segments, and the end point is not connected
    back to the starting point. This means that it does not enclose a region. The
    `fill()` method fills open subpaths by acting as if a straight line connected
    the last point in the subpath to the first point in the subpath. That is why this
    code fills a triangle, but strokes only two sides of the triangle.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图 15-7](Images/#simplepath_png)中定义的子路径是“开放”的。它只包含两条线段，结束点没有连接回起始点。这意味着它没有围起一个区域。`fill()`方法通过假设一条直线连接子路径中的最后一个点和第一个点来填充开放的子路径。这就是为什么这段代码填充了一个三角形，但只描绘了三角形的两条边。
- en: If you wanted to stroke all three sides of the triangle just shown, you would
    call the `closePath()` method to connect the end point of the subpath to the start
    point. (You could also call `lineTo(100,100)`, but then you end up with three
    line segments that share a start and end point but are not truly closed. When
    drawing with wide lines, the visual results are better if you use `closePath()`.)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要描绘刚才显示的三角形的所有三条边，你可以调用`closePath()`方法将子路径的结束点连接到起始点。（你也可以调用`lineTo(100,100)`，但那样你会得到三条共享起始点和结束点但并非真正闭合的线段。当使用宽线条绘制时，如果使用`closePath()`效果更好。）
- en: 'There are two other important points to notice about `stroke()` and `fill()`.
    First, both methods operate on all subpaths in the current path. Suppose we had
    added another subpath in the preceding code:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两点关于`stroke()`和`fill()`需要注意。首先，这两个方法都作用于当前路径中的所有子路径。假设我们在前面的代码中添加了另一个子路径：
- en: '[PRE85]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If we then called `stroke()`, we would draw two connected edges of a triangle
    and a disconnected vertical line.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们随后调用了`stroke()`，我们将绘制一个三角形的两条相连边和一条不相连的垂直线。
- en: 'The second point to note about `stroke()` and `fill()` is that neither one
    alters the current path: you can call `fill()` and the path will still be there
    when you call `stroke()`. When you are done with a path and want to begin another,
    you must remember to call `beginPath()`. If you don’t, you’ll end up adding new
    subpaths to the existing path, and you may end up drawing those old subpaths over
    and over again.'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`stroke()`和`fill()`的第二点是，它们都不会改变当前路径：你可以调用`fill()`，而当你调用`stroke()`时，路径仍然存在。当你完成一个路径并想要开始另一个路径时，你必须记得调用`beginPath()`。如果不这样做，你将不断向现有路径添加新的子路径，并且可能会一遍又一遍地绘制那些旧的子路径。
- en: '[Example 15-5](#polygons.js) defines a function for drawing regular polygons
    and demonstrates the use of `moveTo()`, `lineTo()`, and `closePath()` for defining
    subpaths and of `fill()` and `stroke()` for drawing those paths. It produces the
    drawing shown in [Figure 15-8](Images/#polygons.png).'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-5](#polygons.js)定义了一个用于绘制正多边形的函数，并演示了使用`moveTo()`、`lineTo()`和`closePath()`定义子路径以及使用`fill()`和`stroke()`绘制这些路径。它生成了[图 15-8](Images/#polygons.png)中显示的图形。'
- en: '![js7e 1507](Images/js7e_1507.png)'
  id: totrans-590
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1507](Images/js7e_1507.png)'
- en: Figure 15-8\. Regular polygons
  id: totrans-591
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-8\. 正多边形
- en: Example 15-5\. Regular polygons with moveTo(), lineTo(), and closePath()
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-5\. 使用moveTo()、lineTo()和closePath()绘制正多边形
- en: '[PRE86]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Notice that this example draws a hexagon with a square inside it. The square
    and the hexagon are separate subpaths, but they overlap. When this happens (or
    when a single subpath intersects itself), the canvas needs to be able to determine
    which regions are inside the path and which are outside. The canvas uses a test
    known as the “nonzero winding rule” to achieve this. In this case, the interior
    of the square is not filled because the square and the hexagon were drawn in the
    opposite directions: the vertices of the hexagon were connected with line segments
    moving clockwise around the circle. The vertices of the square were connected
    counterclockwise. Had the square been drawn clockwise as well, the call to `fill()`
    would have filled the interior of the square as well.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此示例绘制了一个六边形，内部有一个正方形。正方形和六边形是分开的子路径，但它们重叠。当发生这种情况（或者当单个子路径相交时），画布需要能够确定哪些区域在路径内部，哪些在外部。画布使用称为“非零环绕规则”的测试来实现这一点。在这种情况下，正方形的内部没有填充，因为正方形和六边形是以相反的方向绘制的：六边形的顶点是沿着圆周顺时针连接的线段。正方形的顶点是逆时针连接的。如果正方形也是顺时针绘制的，那么调用`fill()`将填充正方形的内部。
- en: 15.8.2 Canvas Dimensions and Coordinates
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.2 画布尺寸和坐标
- en: The `width` and `height` attributes of the `<canvas>` element and the corresponding
    `width` and `height` properties of the Canvas object specify the dimensions of
    the canvas. The default canvas coordinate system places the origin (0,0) at the
    upper-left corner of the canvas. The *x* coordinates increase to the right and
    the *y* coordinates increase as you go down the screen. Points on the canvas can
    be specified using floating-point values.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`<canvas>`元素的`width`和`height`属性以及Canvas对象的对应`width`和`height`属性指定了画布的尺寸。默认的画布坐标系统将原点（0,0）放在画布的左上角。*x*坐标向右增加，*y*坐标向下增加。可以使用浮点值指定画布上的点。'
- en: The dimensions of a canvas cannot be altered without completely resetting the
    canvas. Setting either the `width` or `height` properties of a Canvas (even setting
    them to their current value) clears the canvas, erases the current path, and resets
    all graphics attributes (including current transformation and clipping region)
    to their original state.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的尺寸不能在不完全重置画布的情况下进行更改。设置Canvas的`width`或`height`属性（即使将它们设置为当前值）都会清除画布，擦除当前路径，并将所有图形属性（包括当前变换和裁剪区域）重置为其原始状态。
- en: The `width` and `height` attributes of a canvas specify the actual number of
    pixels that the canvas can draw into. Four bytes of memory are allocated for each
    pixel, so if `width` and `height` are both set to 100, the canvas allocates 40,000
    bytes to represent 10,000 pixels.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的`width`和`height`属性指定了画布可以绘制的实际像素数。每个像素分配了四个字节的内存，因此如果`width`和`height`都设置为100，画布将分配40,000字节来表示10,000个像素。
- en: The `width` and `height` attributes also specify the default size (in CSS pixels)
    at which the canvas will be displayed on the screen. If `window.devicePixelRatio`
    is 2, then 100 × 100 CSS pixels is actually 40,000 hardware pixels. When the contents
    of the canvas are drawn onto the screen, the 10,000 pixels in memory will need
    to be enlarged to cover 40,000 physical pixels on the screen, and this means that
    your graphics will not be as crisp as they could be.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`width`和`height`属性还指定了画布在屏幕上显示的默认大小（以CSS像素为单位）。如果`window.devicePixelRatio`为2，则100×100个CSS像素实际上是40,000个硬件像素。当画布的内容绘制到屏幕上时，内存中的10,000个像素需要放大到覆盖屏幕上的40,000个物理像素，这意味着您的图形不会像它们本应该那样清晰。'
- en: For optimum image quality, you should not use the `width` and `height` attributes
    to set the on-screen size of the canvas. Instead, set the desired on-screen size
    CSS pixel size of the canvas with CSS `width` and `height` style attributes. Then,
    before you begin drawing in your JavaScript code, set the `width` and `height`
    properties of the canvas object to the number of CSS pixels times `window.devicePixelRatio`.
    Continuing with the preceding example, this technique would result in the canvas
    being displayed at 100 × 100 CSS pixels but allocating memory for 200 × 200 pixels.
    (Even with this technique, the user can zoom in on the canvas and may see fuzzy
    or pixelated graphics if they do. This is in contrast to SVG graphics, which remain
    crisp no matter the on-screen size or zoom level.)
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳的图像质量，您不应该使用`width`和`height`属性来设置画布的屏幕大小。相反，应该使用CSS的`width`和`height`样式属性设置画布的所需屏幕大小的CSS像素大小。然后，在开始JavaScript代码绘制之前，将画布对象的`width`和`height`属性设置为CSS像素乘以`window.devicePixelRatio`的数量。继续前面的例子，这种技术会导致画布显示为100×100个CSS像素，但分配内存为200×200个像素。（即使使用这种技术，用户也可以放大画布，如果放大，可能会看到模糊或像素化的图形。这与SVG图形形成对比，无论屏幕大小或缩放级别如何，SVG图形始终保持清晰。）
- en: 15.8.3 Graphics Attributes
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.3 图形属性
- en: '[Example 15-5](#polygons.js) set the properties `fillStyle`, `strokeStyle`,
    and `lineWidth` on the context object of the canvas. These properties are graphics
    attributes that specify the color to be used by `fill()` and by `stroke()`, and
    the width of the lines to be drawn by `stroke()`. Notice that these parameters
    are not passed to the `fill()` and `stroke()` methods, but are instead part of
    the general *graphics state* of the canvas. If you define a method that draws
    a shape and do not set these properties yourself, the caller of your method can
    define the color of the shape by setting the `strokeStyle` and `fillStyle` properties
    before calling your method. This separation of graphics state from drawing commands
    is fundamental to the Canvas API and is akin to the separation of presentation
    from content achieved by applying CSS stylesheets to HTML documents.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-5](#polygons.js) 在画布的上下文对象上设置了 `fillStyle`、`strokeStyle` 和 `lineWidth`
    属性。这些属性是指定由 `fill()` 和 `stroke()` 使用的颜色以及由 `stroke()` 绘制的线条的宽度的图形属性。请注意，这些参数不是传递给
    `fill()` 和 `stroke()` 方法的，而是画布的一般 *图形状态* 的一部分。如果定义了一个绘制形状的方法，并且没有自己设置这些属性，那么调用该方法的调用者可以在调用方法之前通过设置
    `strokeStyle` 和 `fillStyle` 属性来定义形状的颜色。图形状态与绘图命令的分离是 Canvas API 的基础，并类似于通过将 CSS
    样式表应用于 HTML 文档来实现的演示与内容的分离。'
- en: There are a number of properties (and also some methods) on the context object
    that affect the graphics state of the canvas. They are detailed below.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 画布的上下文对象上有许多属性（以及一些方法），它们会影响画布的图形状态。下面详细介绍了它们。
- en: Line styles
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线条样式
- en: The `lineWidth` property specifies how wide (in CSS pixels) the lines drawn
    by `stroke()` will be. The default value is 1\. It is important to understand
    that line width is determined by the `lineWidth` property at the time `stroke()`
    is called, not at the time that `lineTo()` and other path-building methods are
    called. To fully understand the `lineWidth` property, it is important to visualize
    paths as infinitely thin one-dimensional lines. The lines and curves drawn by
    the `stroke()` method are centered over the path, with half of the `lineWidth`
    on either side. If you’re stroking a closed path and only want the line to appear
    outside the path, stroke the path first, then fill with an opaque color to hide
    the portion of the stroke that appears inside the path. Or if you only want the
    line to appear inside a closed path, call the `save()` and `clip()` methods first,
    then call `stroke()` and `restore()`. (The `save()`, `restore()`, and `clip()`
    methods are described later.)
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineWidth` 属性指定了 `stroke()` 绘制的线条的宽度（以 CSS 像素为单位）。默认值为 1。重要的是要理解线条宽度是在调用 `stroke()`
    时由 `lineWidth` 属性确定的，而不是在调用 `lineTo()` 和其他构建路径方法时确定的。要完全理解 `lineWidth` 属性，重要的是将路径视为无限细的一维线条。`stroke()`
    方法绘制的线条和曲线位于路径的中心，`lineWidth` 的一半位于路径的两侧。如果要描边一个闭合路径，并且只希望线条出现在路径外部，先描边路径，然后用不透明颜色填充以隐藏出现在路径内部的描边部分。或者如果只希望线条出现在闭合路径内部，先调用
    `save()` 和 `clip()` 方法，然后调用 `stroke()` 和 `restore()`。（`save()`、`restore()` 和 `clip()`
    方法将在后面描述。）'
- en: When drawing lines that are more than about two pixels wide, the `lineCap` and
    `lineJoin` properties can have a significant impact on the visual appearance of
    the ends of a path and the vertices at which two path segments meet. [Figure 15-9](Images/#linestyles.png)
    illustrates the values and resulting graphical appearance of `lineCap` and `lineJoin`.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 当绘制宽度超过大约两个像素的线条时，`lineCap` 和 `lineJoin` 属性会对路径端点的视觉外观以及两个路径段相遇的顶点产生显著影响。[图 15-9](Images/#linestyles.png)展示了
    `lineCap` 和 `lineJoin` 的值及其结果的图形外观。
- en: '![js7e 1508](Images/js7e_1508.png)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1508](Images/js7e_1508.png)'
- en: Figure 15-9\. The lineCap and lineJoin attributes
  id: totrans-608
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-9\. lineCap 和 lineJoin 属性
- en: The default value for `lineCap` is “butt.” The default value for `lineJoin`
    is “miter.” Note, however, that if two lines meet at a very narrow angle, then
    the resulting miter can become quite long and visually distracting. If the miter
    at a given vertex would be longer than half of the line width times the `miterLimit`
    property, that vertex will be drawn with a beveled join instead of a mitered join.
    The default value for `miterLimit` is 10.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineCap` 的默认值为“butt”。`lineJoin` 的默认值为“miter”。但是，请注意，如果两条线以非常狭窄的角度相交，则结果的斜接可能会变得非常长并且在视觉上会分散注意力。如果给定顶点处的斜接长度超过线宽的一半乘以
    `miterLimit` 属性的值，那么该顶点将以斜角连接而不是斜接连接绘制。`miterLimit` 的默认值为 10。'
- en: 'The `stroke()` method can draw dashed and dotted lines as well as solid lines,
    and a canvas’s graphics state includes an array of numbers that serves as a “dash
    pattern” by specifying how many pixels to draw, then how many to omit. Unlike
    other line-drawing properties, the dash pattern is set and queried with the methods
    `setLineDash()` and `getLineDash()` instead of with a property. To specify a dotted
    dash pattern, you might use `setLineDash()` like this:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`stroke()` 方法可以绘制虚线、点线以及实线，画布的图形状态包括一个作为“虚线模式”的数字数组，指定要绘制多少像素，然后要省略多少像素。与其他线条绘制属性不同，虚线模式是使用
    `setLineDash()` 和 `getLineDash()` 方法设置和查询的，而不是使用属性。要指定一个点线模式，可以像这样使用 `setLineDash()`：'
- en: '[PRE87]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Finally, the `lineDashOffset` property specifies how far into the dash pattern
    drawing should begin. The default is 0\. Paths stroked with the dash pattern shown
    here begin with an 18-pixel dash, but if `lineDashOffset` is set to 21, then that
    same path would begin with a dot followed by a space and a dash.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`lineDashOffset` 属性指定了从哪里开始绘制虚线模式。默认值为 0。使用这里显示的虚线模式描绘的路径以一个 18 像素的虚线开始，但如果将
    `lineDashOffset` 设置为 21，则相同的路径将以一个点开始，然后是一个空格和一个虚线。
- en: Colors, patterns, and gradients
  id: totrans-613
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色、图案和渐变
- en: The `fillStyle` and `strokeStyle` properties specify how paths are filled and
    stroked. The word “style” often means color, but these properties can also be
    used to specify a color gradient or an image to be used for filling and stroking.
    (Note that drawing a line is basically the same as filling a narrow region on
    both sides of the line, and filling and stroking are fundamentally the same operation.)
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillStyle`和`strokeStyle`属性指定如何填充和描边路径。单词“style”通常表示颜色，但这些属性也可用于指定颜色渐变或用于填充和描边的图像。（请注意，绘制线基本上与在线两侧填充一个窄区域相同，填充和描边本质上是相同的操作。）'
- en: If you want to fill or stroke with a solid color (or a translucent color), simply
    set these properties to a valid CSS color string. Nothing else is required.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用纯色（或半透明颜色）进行填充或描边，只需将这些属性设置为有效的CSS颜色字符串即可。不需要其他操作。
- en: To fill (or stroke) with a color gradient, set `fillStyle` (or `strokeStyle`)
    to a CanvasGradient object returned by the `createLinearGradient()` or `createRadialGradient()`
    methods of the context. The arguments to `createLinearGradient()` are the coordinates
    of two points that define a line (it does not need to be horizontal or vertical)
    along which the colors will vary. The arguments to `createRadialGradient()` specify
    the centers and radii of two circles. (They need not be concentric, but the first
    circle typically lies entirely inside the second.) Areas inside the smaller circle
    or outside the larger will be filled with solid colors; areas between the two
    will be filled with a color gradient.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用颜色渐变进行填充（或描边），将`fillStyle`（或`strokeStyle`）设置为上下文的`createLinearGradient()`或`createRadialGradient()`方法返回的CanvasGradient对象。`createLinearGradient()`的参数是定义颜色沿其变化的线的两点的坐标（它不需要是水平或垂直的）。`createRadialGradient()`的参数指定两个圆的中心和半径。（它们不需要同心，但第一个圆通常完全位于第二个圆内部。）小圆内部或大圆外部的区域将填充为纯色；两者之间的区域将填充为颜色渐变。
- en: 'After creating the CanvasGradient object that defines the regions of the canvas
    that will be filled, you must define the gradient colors by calling the `addColorStop()`
    method of the CanvasGradient. The first argument to this method is a number between
    0.0 and 1.0\. The second argument is a CSS color specification. You must call
    this method at least twice to define a simple color gradient, but you may call
    it more than that. The color at 0.0 will appear at the start of the gradient,
    and the color at 1.0 will appear at the end. If you specify additional colors,
    they will appear at the specified fractional position within the gradient. Between
    the points you specify, colors will be smoothly interpolated. Here are some examples:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 创建定义将填充画布区域的CanvasGradient对象后，必须通过调用CanvasGradient的`addColorStop()`方法来定义渐变颜色。该方法的第一个参数是介于0.0和1.0之间的数字。第二个参数是CSS颜色规范。您必须至少调用此方法两次来定义简单的颜色渐变，但可以调用多次。0.0处的颜色将出现在渐变的起始处，而1.0处的颜色将出现在结束处。如果指定了其他颜色，它们将出现在渐变中指定的分数位置。在您指定的点之间，颜色将平滑插值。以下是一些示例：
- en: '[PRE88]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: An important point to understand about gradients is that they are not position-independent.
    When you create a gradient, you specify bounds for the gradient. If you then attempt
    to fill an area outside of those bounds, you’ll get the solid color defined at
    one end or the other of the gradient.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 关于渐变的一个重要点是，它们不是位置无关的。创建渐变时，您为渐变指定边界。如果您尝试填充超出这些边界的区域，您将得到渐变的一端或另一端定义的纯色。
- en: In addition to colors and color gradients, you can also fill and stroke using
    images. To do this, set `fillStyle` or `strokeStyle` to a CanvasPattern returned
    by the `createPattern()` method of the context object. The first argument to this
    method should be an `<img>` or `<canvas>` element that contains the image you
    want to fill or stroke with. (Note that the source image or canvas does not need
    to be inserted into the document in order to be used in this way.) The second
    argument to `createPattern()` is the string “repeat,” “repeat-x,” “repeat-y,”
    or “no-repeat,” which specifies whether (and in which dimensions) the background
    images repeat.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 除了颜色和颜色渐变外，您还可以使用图像进行填充和描边。要实现这一点，将`fillStyle`或`strokeStyle`设置为上下文对象的`createPattern()`方法返回的CanvasPattern。该方法的第一个参数应为包含您要填充或描边的图像的`<img>`或`<canvas>`元素。（请注意，源图像或画布不需要插入文档中才能以这种方式使用。）`createPattern()`的第二个参数是字符串“repeat”，“repeat-x”，“repeat-y”或“no-repeat”，指定背景图像是否（以及在哪些维度上）重复。
- en: Text styles
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本样式
- en: The `font` property specifies the font to be used by the text-drawing methods
    `fillText()` and `strokeText()` (see [“Text”](#canvastext)). The value of the
    `font` property should be a string in the same syntax as the CSS `font` attribute.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`font`属性指定文本绘制方法`fillText()`和`strokeText()`使用的字体（请参阅[“文本”](#canvastext)）。`font`属性的值应为与CSS
    `font`属性相同语法的字符串。'
- en: The `textAlign` property specifies how the text should be horizontally aligned
    with respect to the X coordinate passed to `fillText()` or `strokeText()`. Legal
    values are “start,” “left,” “center,” “right,” and “end.” The default is “start,”
    which, for left-to-right text, has the same meaning as “left.”
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '`textAlign`属性指定文本在调用`fillText()`或`strokeText()`时相对于传递给X坐标的水平对齐方式。合法值为“start”，“left”，“center”，“right”和“end”。默认���为“start”，对于从左到右的文本，其含义与“left”相同。'
- en: The `textBaseline` property specifies how the text should be vertically aligned
    with respect to the *y* coordinate. The default value is “alphabetic,” and it
    is appropriate for Latin and similar scripts. The value “ideographic” is intended
    for use with scripts such as Chinese and Japanese. The value “hanging” is intended
    for use with Devanagari and similar scripts (which are used for many of the languages
    of India). The “top,” “middle,” and “bottom” baselines are purely geometric baselines,
    based on the “em square” of the font.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`textBaseline`属性指定文本在*y*坐标上如何与垂直对齐。默认值为“alphabetic”，适用于拉丁文和类似脚本。值“ideographic”适用于中文和日文等脚本。值“hanging”适用于梵文和类似脚本（用于印度许多语言）。“top”、“middle”和“bottom”基线纯粹是几何基线，基于字体的“em
    方块”。'
- en: Shadows
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阴影
- en: Four properties of the context object control the drawing of drop shadows. If
    you set these properties appropriately, any line, area, text, or image you draw
    will be given a shadow, which will make it appear as if it is floating above the
    canvas surface.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文对象的四个属性控制阴影的绘制。如果适当设置这些属性，你绘制的任何线条、区域、文本或图像都将产生阴影，使其看起来好像漂浮在画布表面之上。
- en: 'The `shadowColor` property specifies the color of the shadow. The default is
    fully transparent black, and shadows will never appear unless you set this property
    to a translucent or opaque color. This property can only be set to a color string:
    patterns and gradients are not allowed for shadows. Using a translucent shadow
    color produces the most realistic shadow effects because it allows the background
    to show through.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '`shadowColor`属性指定阴影的颜色。默认为完全透明的黑色，除非将此属性设置为半透明或不透明颜色，否则阴影将不会出现。此属性只能设置为颜色字符串：不允许使用图案和渐变来创建阴影。使用半透明阴影颜色会产生最逼真的阴影效果，因为它允许背景透过阴影显示出来。'
- en: 'The `shadowOffsetX` and `shadowOffsetY` properties specify the X and Y offsets
    of the shadow. The default for both properties is 0, which places the shadow directly
    beneath your drawing, where it is not visible. If you set both properties to a
    positive value, shadows will appear below and to the right of what you draw, as
    if there were a light source above and to the left, shining onto the canvas from
    outside the computer screen. Larger offsets produce larger shadows and make drawn
    objects appear as if they are floating “higher” above the canvas. These values
    are not affected by coordinate transformations ([§15.8.5](#canvastransforms)):
    shadow direction and “height” remain consistent even when shapes are rotated and
    scaled.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '`shadowOffsetX`和`shadowOffsetY`属性指定阴影的X和Y偏移量。两个属性的默认值都为 0，将阴影直接放在你的绘图下方，看不见。如果将这两个属性都设置为正值，阴影将出现在你绘制的下方和右侧，就好像有一个光源在屏幕外部的左上方��射到画布上。较大的偏移量会产生更大的阴影，并使绘制的对象看起来好像漂浮在画布上方。这些值不受坐标变换的影响（[§15.8.5](#canvastransforms)）：阴影方向和“高度”保持一致，即使形状被旋转和缩放。'
- en: The `shadowBlur` property specifies how blurred the edges of the shadow are.
    The default value is 0, which produces crisp, unblurred shadows. Larger values
    produce more blur, up to an implementation-defined upper bound.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`shadowBlur`属性指定阴影边缘的模糊程度。默认值为 0，产生清晰、未模糊的阴影。较大的值会产生更多模糊，直到达到一个实现定义的上限。'
- en: Translucency and compositing
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 半透明和合成
- en: If you want to stroke or fill a path using a translucent color, you can set
    `strokeStyle` or `fillStyle` using a CSS color syntax like “rgba(…)” that supports
    alpha transparency. The “a” in “RGBA” stands for “alpha” and is a value between
    0 (fully transparent) and 1 (fully opaque). But the Canvas API provides another
    way to work with translucent colors. If you do not want to explicitly specify
    an alpha channel for each color, or if you want to add translucency to opaque
    images or patterns, you can set the `globalAlpha` property. Every pixel you draw
    will have its alpha value multiplied by `globalAlpha`. The default is 1, which
    adds no transparency. If you set `globalAlpha` to 0, everything you draw will
    be fully transparent, and nothing will appear in the canvas. But if you set this
    property to 0.5, then pixels that would otherwise have been opaque will be 50%
    opaque, and pixels that would have been 50% opaque will be 25% opaque instead.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用半透明颜色描边或填充路径，可以使用支持 alpha 透明度的 CSS 颜色语法，如“rgba(…)”来设置`strokeStyle`或`fillStyle`。
    “RGBA”中的“a”代表“alpha”，取值范围在 0（完全透明）和 1（完全不透明）之间。但 Canvas API 提供了另一种处理半透明颜色的方式。如果你不想为每种颜色显式指定
    alpha 通道，或者想要向不透明图像或图案添加半透明度，可以设置`globalAlpha`属性。你绘制的每个像素的 alpha 值都将乘以`globalAlpha`。默认值为
    1，不添加透明度。如果将`globalAlpha`设置为 0，则绘制的所有内容将完全透明，画布上将不会显示任何内容。但如果将此属性设置为 0.5，则原本不透明的像素将变为
    50% 不透明，原本 50% 不透明的像素将变为 25% 不透明。
- en: When you stroke lines, fill regions, draw text, or copy images, you generally
    expect the new pixels to be drawn on top of the pixels that are already in the
    canvas. If you are drawing opaque pixels, they simply replace the pixels that
    are already there. If you are drawing with translucent pixels, the new (“source”)
    pixel is combined with the old (“destination”) pixel so that the old pixel shows
    through the new pixel based on how transparent that pixel is.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当你描边线条、填充区域、绘制文本或复制图像时，通常期望新像素绘制在已经存在于画布中的像素之上。如果绘制的是不透明像素，它们将简单地替换已经存在的像素。如果绘制的是半透明像素，则新的（“源”）像素将与旧的（“目标”）像素结合，使旧像素透过新像素显示出来，透明度取决于该像素的透明度。
- en: This process of combining new (possibly translucent) source pixels with existing
    (possibly translucent) destination pixels is called *compositing*, and the compositing
    process described previously is the default way that the Canvas API combines pixels.
    But you can set the `globalCompositeOperation` property to specify other ways
    of combining pixels. The default value is “source-over,” which means that source
    pixels are drawn “over” the destination pixels and are combined with them if the
    source is translucent. But if you set `globalCompositeOperation` to “destination-over”,
    then the canvas will combine pixels as if the new source pixels were drawn beneath
    the existing destination pixels. If the destination is translucent or transparent,
    some or all of the source pixel color is visible in the resulting color. As another
    example, the compositing mode “source-atop” combines the source pixels with the
    transparency of the destination pixels so that nothing is drawn on portions of
    the canvas that are already fully transparent. There are a number of legal values
    for `globalCompositeOperation`, but most have only specialized uses and are not
    covered here.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 将新的（可能是半透明的）源像素与现有的（可能是半透明的）目标像素组合的过程称为*合成*，先前描述的合成过程是 Canvas API 结合像素的默认方式。但是，您可以设置`globalCompositeOperation`属性以指定其他组合像素的方式。默认值是“source-over”，这意味着源像素被绘制在目标像素“上方”，如果源是半透明的，则与目标像素组合。但是，如果将`globalCompositeOperation`设置为“destination-over”，则画布将像新的源像素被绘制在现有目标像素下方一样组合像素。如果目标是半透明或透明的，则结果颜色中的一些或全部源像素颜色是可见的。作为另一个示例，合成模式“source-atop”将源像素与目标像素的透明度组合，以便在已完全透明的画布部分上不绘制任何内容。`globalCompositeOperation`有许多合法值，但大多数只有专门用途，���里不涵盖。
- en: Saving and restoring graphics state
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存和恢复图形状态
- en: 'Since the Canvas API defines graphics attributes on the context object, you
    might be tempted to call `getContext()` multiple times to obtain multiple context
    objects. If you could do this, you could define different attributes on each context:
    each context would then be like a different brush and would paint with a different
    color or draw lines of different widths. Unfortunately, you cannot use the canvas
    in this way. Each `<canvas>` element has only a single context object, and every
    call to `getContext()` returns the same CanvasRenderingContext2D object.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Canvas API 在上下文对象上定义了图形属性，您可能会尝试多次调用`getContext()`以获取多个上下文对象。如果可以这样做，您可以在每个上下文中定义不同的属性：每个上下文将像不同的画笔一样，可以使用不同的颜色绘制或绘制不同宽度的线条。不幸的是，您不能以这种方式使用画布。每个`<canvas>`元素只有一个上下文对象，每次调用`getContext()`都会返回相同的
    CanvasRenderingContext2D 对象。
- en: Although the Canvas API only allows you to define a single set of graphics attributes
    at a time, it does allow you to save the current graphics state so that you can
    alter it and then easily restore it later. The `save()` method pushes the current
    graphics state onto a stack of saved states. The `restore()` method pops the stack
    and restores the most recently saved state. All of the properties that have been
    described in this section are part of the saved state, as are the current transformation
    and clipping region (both of which are explained later). Importantly, the currently
    defined path and the current point are not part of the graphics state and cannot
    be saved and restored.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Canvas API 只允许您一次定义一组图形属性，但它允许您保存当前的图形状态，以便稍后可以更改它并轻松地恢复它。`save()`方法将当前的图形状态推送到保存状态的堆栈上。`restore()`方法弹出堆栈并恢复最近保存的状态。本节中描述的所有属性都是保存状态的一部分，当前的变换和裁剪区域也是如此（稍后将对两者进行解释）。重要的是，当前定义的路径和当前点不是图形状态的一部分，不能保存和恢复。
- en: 15.8.4 Canvas Drawing Operations
  id: totrans-637
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.4 画布绘图操作
- en: We’ve already seen some basic canvas methods—`beginPath()`, `moveTo()`, `lineTo()`,
    `closePath()`, `fill()`, and `stroke()`—for defining, filling, and drawing lines
    and polygons. But the Canvas API includes other drawing methods as well.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些基本的画布方法——`beginPath()`、`moveTo()`、`lineTo()`、`closePath()`、`fill()`
    和 `stroke()`——用于定义、填充和绘制线条和多边形。但 Canvas API 还包括其他绘图方法。
- en: Rectangles
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形
- en: CanvasRenderingContext2D defines four methods for drawing rectangles. All four
    of these rectangle methods expect two arguments that specify one corner of the
    rectangle followed by the rectangle width and height. Normally, you specify the
    upper-left corner and then pass a positive width and positive height, but you
    may also specify other corners and pass negative dimensions.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: CanvasRenderingContext2D 定义了四种绘制矩形的方法。这四种矩形方法都需要两个参数，指定矩形的一个角，然后是矩形的宽度和高度。通常，您指定左上角，然后传递正宽度和正高度，但也可以指定其他角并传递负尺寸。
- en: '`fillRect()` fills the specified rectangle with the current `fillStyle`. `strokeRect()`
    strokes the outline of the specified rectangle using the current `strokeStyle`
    and other line attributes. `clearRect()` is like `fillRect()`, but it ignores
    the current fill style and fills the rectangle with transparent black pixels (the
    default color of all blank canvases). The important thing about these three methods
    is that they do not affect the current path or the current point within that path.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillRect()` 使用当前的`fillStyle`填充指定的矩形。`strokeRect()` 使用当前的`strokeStyle`和其他线条属性描绘指定矩形的轮廓。`clearRect()`
    类似于`fillRect()`，但它忽略当前的填充样式，并用透明黑色像素（所有空画布的默认颜色）填充矩形。这三种方法的重要之处在于它们不会影响当前路径或路径中的当前点。'
- en: 'The final rectangle method is named `rect()`, and it does affect the current
    path: it adds the specified rectangle, in a subpath of its own, to the path. Like
    other path-definition methods, it does not fill or stroke anything itself.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个矩形方法被命名为`rect()`，它会影响当前路径：它将指定的矩形添加到路径的子路径中。与其他定义路径方法一样，它本身不填充或描边任何内容。
- en: Curves
  id: totrans-643
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 曲线
- en: 'A path is a sequence of subpaths, and a subpath is a sequence of connected
    points. In the paths we defined in [§15.8.1](#canvaspaths), those points were
    connected with straight line segments, but that need not always be the case. The
    CanvasRenderingContext2D object defines a number of methods that add a new point
    to the subpath and connect the current point to that new point with a curve:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是子路径的序列，子路径是连接点的序列。在我们在[§15.8.1](#canvaspaths)中定义的路径中，这些点是用直线段连接的，但这并不总是这样。CanvasRenderingContext2D对象定义了许多方法，这些方法向子路径添加一个新点，并使用曲线将当前点连接到该新点：
- en: '`arc()`'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '`arc()`'
- en: 'This method adds a circle, or a portion of a circle (an arc), to the path.
    The arc to be drawn is specified with six parameters: the *x* and *y* coordinates
    of the center of a circle, the radius of the circle, the start and end angles
    of the arc, and the direction (clockwise or counterclockwise) of the arc between
    those two angles. If there is a current point in the path, then this method connects
    the current point to the beginning of the arc with a straight line (which is useful
    when drawing wedges or pie slices), then connects the beginning of the arc to
    the end of the arc with a portion of a circle, leaving the end of the arc as the
    new current point. If there is no current point when this method is called, then
    it only adds the circular arc to the path.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法向路径中添加一个圆或圆的一部分（弧）。要绘制的圆弧由六个参数指定：圆的中心的*x*和*y*坐标，圆的半径，圆弧的起始和结束角度，以及这两个角度之间的圆弧的方向（顺时针或逆时针）。如果路径中有当前点，则此方法将当前点与圆弧的起始点用一条直线连接（在绘制楔形或饼状图时很有用），然后将圆弧的起始点与圆弧的结束点用一部分圆连接起来，将圆弧的结束点作为新的当前点。如果在调用此方法时没有当前点，则它只会将圆弧添加到路径中。
- en: '`ellipse()`'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`ellipse()`'
- en: 'This method is much like `arc()` except that it adds an ellipse or a portion
    of an ellipse to the path. Instead of one radius, it has two: an *x*-axis radius
    and a *y*-axis radius. Also, because ellipses are not radially symmetrical, this
    method takes another argument that specifies the number of radians by which the
    ellipse is rotated clockwise about its center.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与`arc()`非常相似，但它向路径中添加一个椭圆或椭圆的一部分。它有两个半径而不是一个：一个*x*轴半径和一个*y*轴半径。此外，由于椭圆不是径向对称的，因此此方法需要另一个参数，指定椭圆围绕其中心顺时针旋转的弧度数。
- en: '`arcTo()`'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcTo()`'
- en: This method draws a straight line and a circular arc just like the `arc()` method
    does, but it specifies the arc to be drawn using different parameters. The arguments
    to `arcTo()` specify points P1 and P2 and a radius. The arc that is added to the
    path has the specified radius. It begins at the tangent point with the (imaginary)
    line from the current point to P1 and ends at the tangent point with the (imaginary)
    line between P1 and P2\. This unusual-seeming method of specifying arcs is actually
    quite useful for drawing shapes with rounded corners. If you specify a radius
    of 0, this method just draws a straight line from the current point to P1\. With
    a nonzero radius, however, it draws a straight line from the current point in
    the direction of P1, then curves that line around in a circle until it is heading
    in the direction of P2.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法绘制一条直线和一个圆弧，就像`arc()`方法一样，但它使用不同的参数指定要绘制的圆弧。`arcTo()`的参数指定了点P1和P2以及半径。添加到路径中的圆弧具有指定的半径。它从当前点到P1的切线点开始，并在P1和P2之间的（虚拟）线的切线点结束。这种看似不寻常的指定圆弧的方法实际上非常有用，用于绘制具有圆角的形状。如果指定半径为0，此方法只会从当前点画一条直线到P1。然而，如果半径不为零，则它会从当前点沿着P1的方向画一条直线，然后将该线围绕成一个圆，直到指向P2的方向。
- en: '`bezierCurveTo()`'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '`bezierCurveTo()`'
- en: This method adds a new point P to the subpath and connects it to the current
    point with a cubic Bezier curve. The shape of the curve is specified by two “control
    points,” C1 and C2\. At the start of the curve (at the current point), the curve
    heads in the direction of C1\. At the end of the curve (at point P), the curve
    arrives from the direction of C2\. In between these points, the direction of the
    curve varies smoothly. The point P becomes the new current point for the subpath.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法向子路径添加一个新点P，并使用三次贝塞尔曲线将其连接到当前点。曲线的形状由两个“控制点”C1和C2指定。在曲线的起始点（当前点处），曲线朝向C1的方向。在曲线的结束点（点P处），曲线从C2的方向到达。在这些点之间，曲线的方向平滑变化。点P成为子路径的新当前点。
- en: '`quadraticCurveTo()`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`quadraticCurveTo()`'
- en: This method is like `bezierCurveTo()`, but it uses a quadratic Bezier curve
    instead of a cubic Bezier curve and has only a single control point.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于`bezierCurveTo()`，但它使用二次贝塞尔曲线而不是三次贝塞尔曲线，并且只有一个控制点。
- en: You can use these methods to draw paths like those in [Figure 15-10](Images/#curves.png).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些方法绘制类似于[图 15-10](Images/#curves.png)中的路径。
- en: '![js7e 1509](Images/js7e_1509.png)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1509](Images/js7e_1509.png)'
- en: Figure 15-10\. Curved paths in a canvas
  id: totrans-657
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-10。画布中的曲线路径
- en: '[Example 15-6](#curves.js) shows the code used to create [Figure 15-10](Images/#curves.png).
    The methods demonstrated in this code are some of the most complicated in the
    Canvas API; consult an online reference for complete details on the methods and
    their arguments.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-6](#curves.js)显示了用于创建[图 15-10](Images/#curves.png)的代码。此代码中演示的方法是Canvas
    API中最复杂的方法之一；请参考在线参考资料以获取有关这些方法及其参数的完整详细信息。'
- en: Example 15-6\. Adding curves to a path
  id: totrans-659
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-6。向路径添加曲线
- en: '[PRE89]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Text
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本
- en: To draw text in a canvas, you normally use the `fillText()` method, which draws
    text using the color (or gradient or pattern) specified by the `fillStyle` property.
    For special effects at large text sizes, you can use `strokeText()` to draw the
    outline of the individual font glyphs. Both methods take the text to be drawn
    as their first argument and take the *x* and *y* coordinates of the text as the
    second and third arguments. Neither method affects the current path or the current
    point.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画布中绘制文本，通常使用`fillText()`方法，该方法使用`fillStyle`属性指定的颜色（或渐变或图案）绘制文本。对于大文本尺寸的特殊效果，可以使用`strokeText()`绘制单个字体字形的轮廓。这两种方法的第一个参数是要绘制的文本，第二个和第三个参数是文本的*x*和*y*坐标。这两种方法都不会影响当前路径或当前点。
- en: '`fillText()` and `strokeText()` take an optional fourth argument. If given,
    this argument specifies the maximum width of the text to be displayed. If the
    text would be wider than the specified value when drawn using the `font` property,
    the canvas will make it fit by scaling it or by using a narrower or smaller font.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillText()`和`strokeText()`接受一个可选的第四个参数。如果提供了这个参数，则指定要显示的文本的最大宽度。如果使用`font`属性绘制的文本宽度超过指定值，画布将通过缩放或使用更窄或更小的字体来适应它。'
- en: 'If you need to measure text yourself before drawing it, pass it to the `measureText()`
    method. This method returns a TextMetrics object that specifies the measurements
    of the text when drawn with the current `font`. At the time of this writing, the
    only “metric” contained in the `TextMetrics` object is the width. Query the on-screen
    width of a string like this:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在绘制文本之前自行测量文本，请将其传递给`measureText()`方法。该方法返回一个指定使用当前`font`绘制时文本测量的TextMetrics对象。在撰写本文时，`TextMetrics`对象中唯一包含的“度量”是宽度。像这样查询字符串的屏幕宽度：
- en: '[PRE90]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is useful if you want to center a string of text within a canvas, for example.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在画布中居中显示一串文本，这将非常有用。
- en: Images
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像
- en: In addition to vector graphics (paths, lines, etc.), the Canvas API also supports
    bitmap images. The `drawImage()` method copies the pixels of a source image (or
    of a rectangle within the source image) onto the canvas, scaling and rotating
    the pixels of the image as necessary.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 除了矢量图形（路径、线条等）外，Canvas API还支持位图图像。`drawImage()`方法将源图像的像素（或源图像内的矩形）复制到画布上，并根据需要对图像的像素进行缩放和旋转。
- en: '`drawImage()` can be invoked with three, five, or nine arguments. In all cases,
    the first argument is the source image from which pixels are to be copied. This
    image argument is often an `<img>` element, but it can also be another `<canvas>`
    element or even a `<video>` element (from which a single frame will be copied).
    If you specify an `<img>` or `<video>` element that is still loading its data,
    the `drawImage()` call will do nothing.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawImage()`可以使用三、五或九个参数调用。在所有情况下，第一个参数都是要复制像素的源图像。这个图像参数通常是一个`<img>`元素，但也可以是另一个`<canvas>`元素，甚至是一个`<video>`元素（从中将复制一帧）。如果指定的`<img>`或`<video>`元素仍在加载数据，则`drawImage()`调用将不起作用。'
- en: In the three-argument version of `drawImage()`, the second and third arguments
    specify the *x* and *y* coordinates at which the upper-left corner of the image
    is to be drawn. In this version of the method, the entire source image is copied
    to the canvas. The *x* and *y* coordinates are interpreted in the current coordinate
    system, and the image is scaled and rotated if necessary, depending on the canvas
    transform currently in effect.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawImage()`的三参数版本中，第二个和第三个参数指定要绘制图像左上角的*x*和*y*坐标。在此方法的版本中，整个源图像都会被复制到画布上。*x*和*y*坐标在当前坐标系中解释，并且根据当前生效的画布变换，必要时会对图像进行缩放和旋转。
- en: The five-argument version of `drawImage()` adds `width` and `height` arguments
    to the `x` and `y` arguments described earlier. These four arguments define a
    destination rectangle within the canvas. The upper-left corner of the source image
    goes at `(x,y)`, and the lower-right corner goes at `(x+width, y+height)`. Again,
    the entire source image is copied. With this version of the method, the source
    image will be scaled to fit the destination rectangle.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawImage()`的五参数版本在前述的`x`和`y`参数中添加了`width`和`height`参数。这四个参数定义了画布内的目标矩形。源图像的左上角位于`(x,y)`，右下角位于`(x+width,
    y+height)`。同样，整个源图像都会被复制。使用此方法的版本，源图像将被缩放以适应目标矩形。'
- en: The nine-argument version of `drawImage()` specifies both a source rectangle
    and a destination rectangle and copies only the pixels within the source rectangle.
    Arguments two through five specify the source rectangle. They are measured in
    CSS pixels. If the source image is another canvas, the source rectangle uses the
    default coordinate system for that canvas and ignores any transformations that
    have been specified. Arguments six through nine specify the destination rectangle
    into which the image is drawn and are in the current coordinate system of the
    canvas, not in the default coordinate system.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawImage()`的九参数版本同时指定源矩形和目标矩形，并仅复制源矩形内的像素。第二至第五个参数指定源矩形，它们以 CSS 像素为单位。如果源图像是另一个画布，则源矩形使用该画布的默认坐标系，并忽略已指定的任何变换。第六至第九个参数指定将绘制图像的目标矩形，并且以画布的当前坐标系而不是默认坐标系为准。'
- en: 'In addition to drawing images into a canvas, we can also extract the content
    of a canvas as an image using the `toDataURL()` method. Unlike all the other methods
    described here, `toDataURL()` is a method of the Canvas element itself, not of
    the context object. You normally invoke `toDataURL()` with no arguments, and it
    returns the content of the canvas as a PNG image, encoded as a string using a
    `data:` URL. The returned URL is suitable for use with an `<img>` element, and
    you can make a static snapshot of a canvas with code like this:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将图像绘制到画布中，我们还可以使用 `toDataURL()` 方法将画布的内容提取为图像。与这里描述的所有其他方法不同，`toDataURL()`
    是 Canvas 元素本身的方法，而不是上下文对象的方法。通常不带参数调用 `toDataURL()`，它会将画布的内容作为 PNG 图像编码为字符串返回，使用
    `data:` URL。返回的 URL 适用于 `<img>` 元素的使用，您可以使用类似以下代码对画布进行静态快照：
- en: '[PRE91]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 15.8.5 Coordinate System Transforms
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.5 坐标系变换
- en: As we’ve noted, the default coordinate system of a canvas places the origin
    in the upper-left corner, has *x* coordinates increasing to the right, and has
    *y* coordinates increasing downward. In this default system, the coordinates of
    a point map directly to a CSS pixel (which then maps directly to one or more device
    pixels). Certain canvas operations and attributes (such as extracting raw pixel
    values and setting shadow offsets) always use this default coordinate system.
    In addition to the default coordinate system, however, every canvas has a “current
    transformation matrix” as part of its graphics state. This matrix defines the
    current coordinate system of the canvas. In most canvas operations, when you specify
    the coordinates of a point, it is taken to be a point in the current coordinate
    system, not in the default coordinate system. The current transformation matrix
    is used to convert the coordinates you specified to the equivalent coordinates
    in the default coordinate system.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所指出的，画布的默认坐标系将原点放在左上角，*x* 坐标向右增加，*y* 坐标向下增加。在此默认系统中，点的坐标直接映射到 CSS 像素（然后直接映射到一个或多个设备像素）。某些画布操作和属性（例如提取原始像素值和设置阴影偏移）始终使用此默认坐标系。除了默认坐标系外，每个画布还有一个“当前变换矩阵��作为其图形状态的一部分。该矩阵定义了画布的当前坐标系。在大多数画布操作中，当您指定点的坐标时，它被视为当前坐标系中的点，而不是默认坐标系中的点。当前变换矩阵用于将您指定的坐标转换为默认坐标系中的等效坐标。
- en: The `setTransform()` method allows you to set a canvas’s transformation matrix
    directly, but coordinate system transformations are usually easier to specify
    as a sequence of translations, rotations, and scaling operations. [Figure 15-11](Images/#transforms.png)
    illustrates these operations and their effect on the canvas coordinate system.
    The program that produced the figure drew the same set of axes seven times in
    a row. The only thing that changed each time was the current transform. Notice
    that the transforms affect the text as well as the lines that are drawn.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTransform()` 方法允许您直接设置画布的变换矩阵，但坐标系变换通常更容易指定为一系列平移、旋转和缩放操作。[图 15-11](Images/#transforms.png)
    说明了这些操作及其对画布坐标系的影响。生成该图的程序连续七次绘制了相同的坐标轴。每次变化的唯一事物是当前变换。请注意，变换不仅影响绘制的线条，还影响文本。'
- en: '![js7e 1510](Images/js7e_1510.png)'
  id: totrans-678
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1510](Images/js7e_1510.png)'
- en: Figure 15-11\. Coordinate system transformations
  id: totrans-679
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-11\. 坐标系变换
- en: The `translate()` method simply moves the origin of the coordinate system left,
    right, up, or down. The `rotate()` method rotates the axes clockwise by the specified
    angle. (The Canvas API always specifies angles in radians. To convert degrees
    to radians, divide by 180 and multiply by `Math.PI`.) The `scale()` method stretches
    or contracts distances along the *x* or *y* axes.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate()` 方法简单地将坐标系的原点向左、向右、向上或向下移动。`rotate()` 方法按指定角度顺时针旋转坐标轴。（Canvas
    API 总是用弧度指定角度。要将度数转换为弧度，除以 180 并乘以 `Math.PI`。）`scale()` 方法沿着 *x* 或 *y* 轴拉伸或收缩距离。'
- en: 'Passing a negative scale factor to the `scale()` method flips that axis across
    the origin, as if it were reflected in a mirror. This is what was done in the
    lower left of [Figure 15-11](Images/#transforms.png): `translate()` was used to
    move the origin to the bottom-left corner of the canvas, then `scale()` was used
    to flip the *y* axis around so that *y* coordinates increase as we go up the page.
    A flipped coordinate system like this is familiar from algebra class and may be
    useful for plotting data points on charts. Note, however, that it makes text difficult
    to read!'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 将负的比例因子传递给 `scale()` 方法会使该轴在原点处翻转，就像在镜子中反射一样。这就是在 [图 15-11](Images/#transforms.png)
    的左下角所做的事情：`translate()` 用于将原点移动到画布的左下角，然后 `scale()` 用于翻转 *y* 轴，使得随着页面向上移动，*y*
    坐标增加。这样的翻转坐标系在代数课上很常见，可能对绘制图表上的数据点有用。但请注意，这会使文本难以阅读！
- en: Understanding transformations mathematically
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学上理解变换
- en: I find it easiest to understand transforms geometrically, thinking about `translate()`,
    `rotate()`, and `scale()` as transforming the axes of the coordinate system as
    illustrated in [Figure 15-11](Images/#transforms.png). It is also possible to
    understand transforms algebraically as equations that map the coordinates of a
    point `(x,y)` in the transformed coordinate system back to the coordinates `(x',y')`
    of the same point in the previous coordinate system.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现最容易理解变换的方法是几何上的，将 `translate()`、`rotate()` 和 `scale()` 视为转换坐标系的轴，如 [图 15-11](Images/#transforms.png)
    所示。也可以将变换理解为代数方程，这些方程将变换后坐标系中点 `(x,y)` 的坐标映射回先前坐标系中相同点 `(x',y')` 的坐标。
- en: 'The method call `c.translate(dx,dy)` can be described with these equations:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用 `c.translate(dx,dy)` 可以用以下方程描述：
- en: '[PRE92]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Scaling operations have similarly simple equations. A call `c.scale(sx,sy)`
    can be described like this:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放操作有类似简单的方程。调用 `c.scale(sx,sy)` 可以描述如下：
- en: '[PRE93]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Rotations are more complicated. The call `c.rotate(a)` is described by these
    trigonometric equations:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转更加复杂。调用 `c.rotate(a)` 由以下三角函数方程描述：
- en: '[PRE94]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Notice that the order of transformations matters. Suppose we start with the
    default coordinate system of a canvas, then translate it, and then scale it. In
    order to map the point `(x,y)` in the current coordinate system back to the point
    `(x'''',y'''')` in the default coordinate system, we must first apply the scaling
    equations to map the point to an intermediate point `(x'',y'')` in the translated
    but unscaled coordinate system, then use the translation equations to map from
    this intermediate point to `(x'''',y'''')`. The result is this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 注意变换的顺序很重要。 假设我们从画布的默认坐标系开始，然后将其平移，然后缩放。 为了将当前坐标系中的点`(x,y)`映射回默认坐标系中的点`(x'',y'')`，我们必须首先应用缩放方程将点映射到平移但未缩放的坐标系中的中间点`(x',y')`，然后使用平移方程从这个中间点映射到`(x'',y'')`。
    结果如下：
- en: '[PRE95]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If, on the other hand, we’d called `scale()` before calling `translate()`,
    the resulting equations would be different:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们在调用`translate()`之前调用了`scale()`，则得到的方程将不同：
- en: '[PRE96]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The key thing to remember when thinking algebraically about sequences of transformations
    is that you must work backward from the last (most recent) transformation to the
    first. When thinking geometrically about transformed axes, however, you work forward
    from first transformation to last.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数上考虑变换序列时，要记住的关键是必须从最后（最近）的变换向前工作到第一个。 然而，在几何上考虑变换的轴时，您从第一个变换向最后一个变换工作。
- en: 'The transformations supported by the canvas are known as *affine transforms*.
    Affine transforms may modify the distances between points and the angles between
    lines, but parallel lines always remain parallel after an affine transformation—it
    is not possible, for example, to specify a fish-eye lens distortion with an affine
    transform. An arbitrary affine transform can be described by the six parameters
    `a` through `f` in these equations:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 画布支持的变换称为*仿射变换*。 仿射变换可以修改点之间的距离和线之间的角度，但平行线在仿射变换后始终保持平行——例如，不可能用仿射变换指定鱼眼镜头畸变。
    任意仿射变换可以用这些方程中的六个参数`a`到`f`来描述：
- en: '[PRE97]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'You can apply an arbitrary transformation to the current coordinate system
    by passing those six parameters to the `transform()` method. [Figure 15-11](Images/#transforms.png)
    illustrates two types of transformations—shears and rotations about a specified
    point—that you can implement with the `transform()` method like this:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将这六个参数传递给`transform()`方法，对当前坐标系应用任意变换。 [图 15-11](Images/#transforms.png)展示了两种类型的变换——倾斜和围绕指定点旋转——您可以像这样使用`transform()`方法实现：
- en: '[PRE98]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `setTransform()` method takes the same arguments as `transform()`, but
    instead of transforming the current coordinate system, it ignores the current
    system, transforms the default coordinate system, and makes the result the new
    current coordinate system. `setTransform()` is useful to temporarily reset the
    canvas to its default coordinate system:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTransform()`方法接受与`transform()`相同的参数，但是不是转换当前坐标系，而是忽略当前系统，转换默认坐标系，并使结果成为新的当前坐标系。
    `setTransform()`对于临时将画布重置为其默认坐标系很有用：'
- en: '[PRE99]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Transformation example
  id: totrans-701
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变换示例
- en: '[Example 15-7](#koch.js) demonstrates the power of coordinate system transformations
    by using the `translate()`, `rotate()`, and `scale()` methods recursively to draw
    a Koch snowflake fractal. The output of this example appears in [Figure 15-12](Images/#koch.png),
    which shows Koch snowflakes with 0, 1, 2, 3, and 4 levels of recursion.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-7](#koch.js)通过递归使用`translate()`、`rotate()`和`scale()`方法来绘制科赫雪花分形图，展示了坐标系变换的强大功能。
    此示例的输出显示在[图 15-12](Images/#koch.png)中，显示了具有0、1、2、3和4个递归级别的科赫雪花。'
- en: '![js7e 1511](Images/js7e_1511.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1511](Images/js7e_1511.png)'
- en: Figure 15-12\. Koch snowflakes
  id: totrans-704
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-12\. 科赫雪花
- en: 'The code that produces these figures is elegant, but its use of recursive coordinate
    system transformations makes it somewhat difficult to understand. Even if you
    don’t follow all the nuances, note that the code includes only a single invocation
    of the `lineTo()` method. Every single line segment in [Figure 15-12](Images/#koch.png)
    is drawn like this:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 生成这些图形的代码很简洁，但其使用递归坐标系变换使其有些难以理解。 即使您不理解所有细微之处，也请注意代码中仅包含一次对`lineTo()`方法的调用。
    [图 15-12](Images/#koch.png)中的每个线段都是这样绘制的：
- en: '[PRE100]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The value of the variable `len` does not change during the execution of the
    program, so the position, orientation, and length of each of the line segments
    is determined by translations, rotations, and scaling operations.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`len`的值在程序执行过程中不会改变，因此每个线段的位置、方向和长度由平移、旋转和缩放操作确定。
- en: Example 15-7\. A Koch snowflake with transformations
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-7\. 具有变换的科赫雪花
- en: '[PRE101]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 15.8.6 Clipping
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.6 裁剪
- en: After defining a path, you usually call `stroke()` or `fill()` (or both). You
    can also call the `clip()` method to define a clipping region. Once a clipping
    region is defined, nothing will be drawn outside of it. [Figure 15-13](Images/#clip.png)
    shows a complex drawing produced using clipping regions. The vertical stripe running
    down the middle and the text along the bottom of the figure were stroked with
    no clipping region and then filled after the triangular clipping region was defined.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 定义路径后，通常会调用`stroke()`或`fill()`（或两者）。 您还可以调用`clip()`方法来定义裁剪区域。 一旦定义了裁剪区域，就不会在其外部绘制任何内容。
    [图 15-13](Images/#clip.png)展示了使用裁剪区域生成的复杂图形。 图中垂直条纹沿中间运行，底部的文本是在定义三角形裁剪区域之后未裁剪的描边，然后填充的。
- en: '![js7e 1512](Images/js7e_1512.png)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1512](Images/js7e_1512.png)'
- en: Figure 15-13\. Unclipped strokes and clipped fills
  id: totrans-713
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-13\. 未裁剪的笔画和裁剪的填充
- en: '[Figure 15-13](Images/#clip.png) was generated using the `polygon()` method
    of [Example 15-5](#polygons.js) and the following code:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-13](Images/#clip.png)是使用[示例 15-5](#polygons.js)的`polygon()`方法和以下代码生成的：'
- en: '[PRE102]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: It is important to note that when you call `clip()`, the current path is itself
    clipped to the current clipping region, then that clipped path becomes the new
    clipping region. This means that the `clip()` method can shrink the clipping region
    but can never enlarge it. There is no method to reset the clipping region, so
    before calling `clip()`, you should typically call `save()` so that you can later
    `restore()` the unclipped region.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当你调用`clip()`时，当前路径本身会被剪切到当前剪切区域，然后被剪切的路径成为新的剪切区域。这意味着`clip()`方法可以缩小剪切区域，但不能扩大它。没有方法可以重置剪切区域，因此在调用`clip()`之前，通常应该调用`save()`，这样以后就可以`restore()`未剪切的区域。
- en: 15.8.7 Pixel Manipulation
  id: totrans-717
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.7 像素处理
- en: The `getImageData()` method returns an ImageData object that represents the
    raw pixels (as R, G, B, and A components) from a rectangular region of your canvas.
    You can create empty `ImageData` objects with `createImageData()`. The pixels
    in an ImageData object are writable, so you can set them any way you want, then
    copy those pixels back onto the canvas with `putImageData()`.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`getImageData()`方法返回一个表示画布矩形区域的原始像素（作为R、G、B和A分量）的ImageData对象。您可以使用`createImageData()`创建空的`ImageData`对象。ImageData对象中的像素是可写的，因此您可以按照自己的方式设置它们，然后使用`putImageData()`将这些像素复制回画布。'
- en: 'These pixel manipulation methods provide very low-level access to the canvas.
    The rectangle you pass to `getImageData()` is in the default coordinate system:
    its dimensions are measured in CSS pixels, and it is not affected by the current
    transformation. When you call `putImageData()`, the position you specify is also
    measured in the default coordinate system. Furthermore, `putImageData()` ignores
    all graphics attributes. It does not perform any compositing, it does not multiply
    pixels by `globalAlpha`, and it does not draw shadows.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这些像素处理方法提供了对画布的非常低级访问。您传递给`getImageData()`的矩形位于默认坐标系统中：其尺寸以CSS像素为单位，不受当前变换的影响。当您调用`putImageData()`时，您指定的位置也是以默认坐标系统中的尺寸来衡量的。此外，`putImageData()`忽略所有图形属性���它不执行任何合成，不将像素乘以`globalAlpha`，也不绘制阴影。
- en: Pixel manipulation methods are useful for implementing image processing. [Example 15-8](#smear.js)
    shows how to create a simple motion blur or “smear” effect like that shown in
    [Figure 15-14](Images/#smear.png).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 像素处理方法对于实现图像处理非常有用。[示例 15-8](#smear.js)展示了如何创建一个简单的运动模糊或“涂抹”效果，就像[图 15-14](Images/#smear.png)中显示的那样。
- en: '![js7e 1513](Images/js7e_1513.png)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1513](Images/js7e_1513.png)'
- en: Figure 15-14\. A motion blur effect created by image processing
  id: totrans-722
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-14\. 通过图像处理创建的运动模糊效果
- en: The following code demonstrates `getImageData()` and `putImageData()` and shows
    how to iterate through and modify the pixel values in an ImageData object.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了`getImageData()`和`putImageData()`，并展示了如何迭代并修改ImageData对象中的像素值。
- en: Example 15-8\. Motion blur with ImageData
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-8\. 使用ImageData进行运动模糊
- en: '[PRE103]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 15.9 Audio APIs
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.9 音频API
- en: The HTML `<audio>` and `<video>` tags allow you to easily include sound and
    videos in your web pages. These are complex elements with significant APIs and
    nontrivial user interfaces. You can control media playback with the `play()` and
    `pause()` methods. You can set the `volume` and `playbackRate` properties to control
    the audio volume and speed of playback. And you can skip to a particular time
    within the media by setting the `currentTime` property.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: HTML `<audio>`和`<video>`标签允许您轻松地在网页中包含声音和视频。这些是具有重要API和复杂用户界面的复杂元素。您可以使用`play()`和`pause()`方法控制媒体播放。您可以设置`volume`和`playbackRate`属性来控制音频音量和播放速度。您可以通过设置`currentTime`属性跳转到媒体中的特定时间。
- en: We will not cover `<audio>` and `<video>` tags in any further detail here, however.
    The following subsections demonstrate two ways to add scripted sound effects to
    your web pages.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里进一步详细介绍`<audio>`和`<video>`标签。以下小节演示了两种向网页添加脚本化声音效果的方法。
- en: 15.9.1 The Audio() Constructor
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.1 Audio()构造函数
- en: 'You don’t have to include an `<audio>` tag in your HTML document in order to
    include sound effects in your web pages. You can dynamically create `<audio>`
    elements with the normal DOM `document.createElement()` method, or, as a shortcut,
    you can simply use the `Audio()` constructor. You do not have to add the created
    element to your document in order to play it. You can simply call its `play()`
    method:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必在HTML文档中包含`<audio>`标签以在网页中包含声音效果。您可以使用普通的DOM`document.createElement()`方法动态创建`<audio>`元素，或者作为快捷方式，您可以简单地使用`Audio()`构造函数。您不必将创建的元素添加到文档中才能播放它。您只需调用其`play()`方法即可：
- en: '[PRE104]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note the use of `cloneNode()` here. If the user clicks the mouse rapidly, we
    want to be able to have multiple overlapping copies of the sound effect playing
    at the same time. To do that, we need multiple Audio elements. Because the Audio
    elements are not added to the document, they will be garbage collected when they
    are done playing.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里使用了`cloneNode()`。如果用户快速点击鼠标，我们希望能够同时播放多个重叠的声音效果副本。为了做到这一点，我们需要多个音频元素。因为音频元素没有添加到文档中，所以当它们播放完毕时会被垃圾回收。
- en: 15.9.2 The WebAudio API
  id: totrans-733
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.2 WebAudio API
- en: In addition to playback of recorded sounds with Audio elements, web browsers
    also allow the generation and playback of synthesized sounds with the WebAudio
    API. Using the WebAudio API is like hooking up an old-style electronic synthesizer
    with patch cords. With WebAudio, you create a set of AudioNode objects, which
    represents sources, transformations, or destinations of waveforms, and then connect
    these nodes together into a network to produce sounds. The API is not particularly
    complex, but a full explanation requires an understanding of electronic music
    and signal processing concepts that are beyond the scope of this book.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Audio元素播放录制的声音外，Web浏览器还允许使用WebAudio API生成和播放合成声音。使用WebAudio API就像连接旧式电子合成器的插线一样。使用WebAudio，您创建一组AudioNode对象，表示波形的源、变换或目的地，然后将这些节点连接到一个网络中以产生声音。API并不特别复杂，但要全面解释需要理解超出本书范围的电子音乐和信号处理概念。
- en: 'The following code below uses the WebAudio API to synthesize a short chord
    that fades out over about a second. This example demonstrates the basics of the
    WebAudio API. If this is interesting to you, you can find much more about this
    API online:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码示例使用WebAudio API合成一个在大约一秒钟内淡出的短和弦。这个示例演示了WebAudio API的基础知识。如果你对此感兴趣，你可以在网上找到更多关于这个API的信息：
- en: '[PRE105]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 15.10 Location, Navigation, and History
  id: totrans-737
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.10 位置、导航和历史
- en: The `location` property of both the Window and Document objects refers to the
    Location object, which represents the current URL of the document displayed in
    the window, and which also provides an API for loading new documents into the
    window.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`属性既可以用于Window对象，也可以用于Document对象，它指的是Location对象，代表着窗口中显示的文档的当前URL，并提供了一个API用于在窗口中加载新文档。'
- en: The Location object is very much like a URL object ([§11.9](ch11.xhtml#urlapi)),
    and you can use properties like `protocol`, `hostname`, `port`, and `path` to
    access the various parts of the URL of the current document. The `href` property
    returns the entire URL as a string, as does the `toString()` method.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: Location对象非常类似于URL对象（[§11.9](ch11.xhtml#urlapi)），你可以使用`protocol`、`hostname`、`port`和`path`等属性来访问当前文档的URL的各个部分。`href`属性返回整个URL作为字符串，`toString()`方法也是如此。
- en: 'The `hash` and `search` properties of the Location object are interesting ones.
    The `hash` property returns the “fragment identifier” portion of the URL, if there
    is one: a hash mark (#) followed by an element ID. The `search` property is similar.
    It returns the portion of the URL that starts with a question mark: often some
    sort of query string. In general, this portion of a URL is used to parameterize
    the URL and provides a way to embed arguments in it. While these arguments are
    usually intended for scripts run on a server, there is no reason why they cannot
    also be used in JavaScript-enabled pages.'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: Location对象的`hash`和`search`属性是比较有趣的。`hash`属性返回URL中的“片段标识符”部分，如果有的话：一个井号(#)后跟一个元素ID。`search`属性类似。它返回以问号开头的URL部分：通常是某种查询字符串。一般来说，URL的这部分用于对URL进行参数化，并提供了一种在其中嵌入参数的方式。虽然这些参数通常是为在服务器上运行的脚本而设计的，但也可以在启用JavaScript的页面中使用。
- en: 'URL objects have a `searchParams` property that is a parsed representation
    of the `search` property. The Location object does not have a `searchParams` property,
    but if you want to parse `window.location.search`, you can simply create a URL
    object from the Location object and then use the URL’s `searchParams`:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: URL对象有一个`searchParams`属性，它是`search`属性的解析表示。Location对象没有`searchParams`属性，但如果你想解析`window.location.search`，你可以简单地从Location对象创建一个URL对象，然后使用URL的`searchParams`：
- en: '[PRE106]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In addition to the Location object that you can refer to as `window.location`
    or `document.location`, and the `URL()` constructor that we used earlier, browsers
    also define a `document.URL` property. Surprisingly, the value of this property
    is not a URL object, but just a string. The string holds the URL of the current
    document.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以引用为`window.location`或`document.location`的Location对象，以及我们之前使用的`URL()`构造函数，浏览器还定义了一个`document.URL`属性。令人惊讶的是，这个属性的值不是一个URL对象，而只是一个字符串。该字符串保存当前文档的URL。
- en: 15.10.1 Loading New Documents
  id: totrans-744
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.1 加载新文档
- en: 'If you assign a string to `window.location` or to `document.location`, that
    string is interpreted as a URL and the browser loads it, replacing the current
    document with a new one:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个字符串分配给`window.location`或`document.location`，那么该字符串会被解释为一个URL，浏览器会加载它，用新文档替换当前文档：
- en: '[PRE107]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'You can also assign relative URLs to `location`. They are resolved relative
    to the current URL:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将相对URL分配给`location`。它们相对于当前URL解析：
- en: '[PRE108]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'A bare fragment identifier is a special kind of relative URL that does not
    cause the browser to load a new document but simply to scroll so that the document
    element with `id` or `name` that matches the fragment is visible at the top of
    the browser window. As a special case, the fragment identifier `#top` makes the
    browser jump to the start of the document (assuming no element has an `id="top"`
    attribute):'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 一个裸的片段标识符是一种特殊类型的相对URL，它不会导致浏览器加载���文档，而只是滚动，以使具有与片段匹配的`id`或`name`的文档元素在浏览器窗口顶部可见。作为一个特例，片段标识符`#top`会使浏览器跳转到文档的开头（假设没有元素具有`id="top"`属性）：
- en: '[PRE109]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The individual properties of the Location object are writable, and setting
    them changes the location URL and also causes the browser to load a new document
    (or, in the case of the `hash` property, to navigate within the current document):'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: Location对象的各个属性都是可写的，设置它们会改变位置URL，并导致浏览器加载一个新文档（或者在`hash`属性的情况下，在当前文档内导航）：
- en: '[PRE110]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: You can also load a new page by passing a new string to the `assign()` method
    of the Location object. This is the same as assigning the string to the `location`
    property, however, so it’s not particularly interesting.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过向Location对象的`assign()`方法传递一个新字符串来加载新页面。这与将字符串分配给`location`属性相同，因此并不特别有趣。
- en: The `replace()` method of the Location object, on the other hand, is quite useful.
    When you pass a string to `replace()`, it is interpreted as a URL and causes the
    browser to load a new page, just as `assign()` does. The difference is that `replace()`
    replaces the current document in the browser’s history. If a script in document
    A sets the `location` property or calls `assign()` to load document B and then
    the user clicks the Back button, the browser will go back to document A. If you
    use `replace()` instead, then document A is erased from the browser’s history,
    and when the user clicks the Back button, the browser returns to whatever document
    was displayed before document A.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Location对象的`replace()`方法非常有用。当你向`replace()`传递一个字符串时，它被解释为一个URL，并导致浏览器加载一个新页面，就像`assign()`一样。不同之处在于`replace()`替换了浏览器历史中的当前文档。如果文档A中的脚本设置`location`属性或调用`assign()`加载文档B，然后用户点击返回按钮，浏览器将返回到文档A。如果你使用`replace()`，那么文档A将从浏览器历史中删除，当用户点击返回按钮时，浏览器将返回到在显示文档A之前显示的文档。
- en: 'When a script unconditionally loads a new document, the `replace()` method
    is a better choice than `assign()`. Otherwise, the Back button would take the
    browser back to the original document, and the same script would again load the
    new document. Suppose you have a JavaScript-enhanced version of your page and
    a static version that does not use JavaScript. If you determine that the user’s
    browser does not support the web platform APIs that you want to use, you could
    use `location.replace()` to load the static version:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本无条件加载新文档时，`replace()` 方法比 `assign()` 更好。否则，点击返回按钮会将浏览器返回到原始文档，并且同样的脚本会再次加载新文档。假设你有一个使用
    JavaScript 增强的页面版本和一个不使用 JavaScript 的静态版本。如果确定用户的浏览器不支持你想要使用的 Web 平台 API，你可以使用
    `location.replace()` 来加载静态版本：
- en: '[PRE111]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Notice that the URL passed to `replace()` is a relative one. Relative URLs are
    interpreted relative to the page in which they appear, just as they would be if
    they were used in a hyperlink.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，传递给 `replace()` 的 URL 是相对的。相对 URL 被解释为相对于其出现的页面，就像它们在超链接中使用时一样。
- en: In addition to the `assign()` and `replace()` methods, the Location object also
    defines `reload()`, which simply makes the browser reload the document.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `assign()` 和 `replace()` 方法，Location 对象还定义了 `reload()`，它简单地使浏览器重新加载文档。
- en: 15.10.2 Browsing History
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.2 浏览历史
- en: The `history` property of the Window object refers to the History object for
    the window. The History object models the browsing history of a window as a list
    of documents and document states. The `length` property of the History object
    specifies the number of elements in the browsing history list, but for security
    reasons, scripts are not allowed to access the stored URLs. (If they could, any
    scripts could snoop through your browsing history.)
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: Window 对象的 `history` 属性指的是窗口的 History 对象。History 对象将窗口的浏览历史建模为文档和文档状态的列表。History
    对象的 `length` 属性指定浏览历史列表中的元素数量，但出于安全原因，脚本不允许访问存储的 URL。（如果允许，任何脚本都可以窥探您的浏览历史。）
- en: 'The History object has `back()` and `forward()` methods that behave like the
    browser’s Back and Forward buttons do: they make the browser go backward or forward
    one step in its browsing history. A third method, `go()`, takes an integer argument
    and can skip any number of pages forward (for positive arguments) or backward
    (for negative arguments) in the history list:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: History 对象有 `back()` 和 `forward()` 方法，行为类似于浏览器的返回和前进按钮：它们使浏览器在其浏览历史中向后或向前移动一步。第三个方法
    `go()` 接受一个整数参数，可以在历史记录列表中跳过任意数量的页面向前（对于正参数）或向后（对于负参数）：
- en: '[PRE112]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: If a window contains child windows (such as `<iframe>` elements), the browsing
    histories of the child windows are chronologically interleaved with the history
    of the main window. This means that calling `history.back()` (for example) on
    the main window may cause one of the child windows to navigate back to a previously
    displayed document but leaves the main window in its current state.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个窗口包含子窗口（如 `<iframe>` 元素），子窗口的浏览历史与主窗口的历史按时间顺序交错。这意味着在主窗口上调用 `history.back()`（例如）可能会导致其中一个子窗口导航回到先前显示的文档，但保持主窗口处于当前状态。
- en: The History object described here dates back to the early days of the web when
    documents were passive and all computation was performed on the server. Today,
    web applications often generate or load content dynamically and display new application
    states without actually loading new documents. Applications like these must perform
    their own history management if they want the user to be able to use the Back
    and Forward buttons (or the equivalent gestures) to navigate from one application
    state to another in an intuitive way. There are two ways to accomplish this, described
    in the next two sections.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的 History 对象可以追溯到 Web 早期，当时文档是被动的，所有计算都在服务器上执行。如今，Web 应用程序经常动态生成或加载内容，并显示新的应用程序状态，而不实际加载新文档。如果这样的应用程序希望用户能够使用返回和前进按钮（或等效手势）以直观的方式从一个应用程序状态导航到另一个状态，它们必须执行自己的历史管理。有两种方法可以实现这一点，将在接下来的两个部分中描述。
- en: 15.10.3 History Management with hashchange Events
  id: totrans-765
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.3 使用 hashchange 事件进行历史管理
- en: 'One history management technique involves `location.hash` and the “hashchange”
    event. Here are the key facts you need to know to understand this technique:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 一种历史管理技术涉及 `location.hash` 和“hashchange”事件。以下是您需要了解的关键事实，以理解这种技术：
- en: 'The `location.hash` property sets the fragment identifier of the URL and is
    traditionally used to specify the ID of a document section to scroll to. But `location.hash`
    does not have to be an element ID: you can set it to any string. As long as no
    element happens to have that string as its ID, the browser won’t scroll when you
    set the `hash` property like this.'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location.hash` 属性设置 URL 的片段标识符，传统上用于指定要滚动到的文档部分的 ID。但 `location.hash` 不一定要是元素
    ID：你可以将其设置为任何字符串。只要没有元素恰好将该字符串作为其 ID，当你像这样设置 `hash` 属性时，浏览器不会滚动。'
- en: Setting the `location.hash` property updates the URL displayed in the location
    bar and, very importantly, adds an entry to the browser’s history.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `location.hash` 属性会更新在位置栏中显示的 URL，并且非常重要的是，会向浏览器的历史记录中添加一个条目。
- en: Whenever the fragment identifier of the document changes, the browser fires
    a “hashchange” event on the Window object. If you set `location.hash` explictly,
    a “hashchange” event is fired. And, as we’ve mentioned, this change to the Location
    object creates a new entry in the browser’s browsing history. So if the user now
    clicks the Back button, the browser will return to its previous URL before you
    set `location.hash`. But this means that the fragment identifier has changed again,
    so another “hashchange” event is fired in this case. This means that as long as
    you can create a unique fragment identifier for each possible state of your application,
    “hashchange” events will notify you if the user moves backward and forward though
    their browsing history.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当文档的片段标识符发生变化时，浏览器会在 Window 对象上触发“hashchange”事件。如果你明确设置了`location.hash`，就会触发“hashchange”事件。正如我们所提到的，对
    Location 对象的更改会在浏览器的浏览历史中创建一个新条目。因此，如果用户现在点击“后退”按钮，浏览器将返回到在设置`location.hash`之前的上一个
    URL。但这意味着片段标识符再次发生了变化，因此在这种情况下会再次触发“hashchange”事件。这意味着只要你能为应用程序的每种可能状态创建一个唯一的片段标识符，“hashchange”事件将通知你用户在浏览历史中前进和后退的情况。
- en: To use this history management mechanism, you’ll need to be able to encode the
    state information necessary to render a “page” of your application into a relatively
    short string of text that is suitable for use as a fragment identifier. And you’ll
    need to write a function to convert page state into a string and another function
    to parse the string and re-create the page state it represents.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种历史管理机制，您需要能够将渲染应用程序“页面”所需的状态信息编码为相对较短的文本字符串，适合用作片段标识符。您还需要编写一个将页面状态转换为字符串的函数，以及另一个函数来解析字符串并重新创建它表示的页面状态。
- en: Once you have written those functions, the rest is easy. Define a `window.onhashchange`
    function (or register a “hashchange” listener with `addEventListener()`) that
    reads `location.hash`, converts that string into a representation of your application
    state, and then takes whatever actions are necessary to display that new application
    state.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了这些函数，剩下的就很容易了。定义一个`window.onhashchange`函数（或使用`addEventListener()`注册一个“hashchange”监听器），读取`location.hash`，将该字符串转换为你的应用程序状态的表示，并采取必要的操作来显示新的应用程序状态。
- en: When the user interacts with your application (such as by clicking a link) in
    a way that would cause the application to enter a new state, don’t render the
    new state directly. Instead, encode the desired new state as a string and set
    `location.hash` to that string. This will trigger a “hashchange” event, and your
    handler for that event will display the new state. Using this roundabout technique
    ensures that the new state is inserted into the browsing history so that the Back
    and Forward buttons continue to work.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与您的应用程序交互（例如点击链接）以导致应用程序进入新状态时，不要直接呈现新状态。相反，将所需的新状态编码为字符串，并将`location.hash`设置为该字符串。这将触发“hashchange”事件，您对该事件的处理程序将显示新状态。使用这种迂回的技术确保新状态被插入到浏览历史中，以便“后退”和“前进”按钮继续工作。
- en: 15.10.4 History Management with pushState()
  id: totrans-773
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.4 使用 pushState() 进行历史管理
- en: The second technique for managing history is somewhat more complex but is less
    of a hack than the “hashchange” event. This more robust history-management technique
    is based on the `history.pushState()` method and the “popstate” event. When a
    web app enters a new state, it calls `history.pushState()` to add an object representing
    the state to the browser’s history. If the user then clicks the Back button, the
    browser fires a “popstate” event with a copy of that saved state object, and the
    app uses that object to re-create its previous state. In addition to the saved
    state object, applications can also save a URL with each state, which is important
    if you want users to be able to bookmark and share links to the internal states
    of the app.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 管理历史的第二种技术略微复杂，但比“hashchange”事件更不像是一种黑客技巧。这种更健壮的历史管理技术基于`history.pushState()`方法和“popstate”事件。当
    Web 应用程序进入新状态时，它调用`history.pushState()`将表示状态的对象添加到浏览器的历史记录中。如果用户然后点击“后退”按钮，浏览器将触发一个带有保存的状态对象副本的“popstate”事件，应用程序使用该对象重新创建其先前的状态。除了保存的状态对象外，应用程序还可以保存每个状态的
    URL，如果您希望用户能够将应用程序的内部状态添加到书签并共享链接，则这一点很重要。
- en: The first argument to `pushState()` is an object that contains all the state
    information necessary to restore the current state of the document. This object
    is saved using HTML’s *structured clone* algorithm, which is more versatile than
    `JSON.stringify()` and can support Map, Set, and Date objects as well as typed
    arrays and ArrayBuffers.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushState()`的第一个参数是一个包含恢复文档当前状态所需的所有状态信息的对象。这个对象使用 HTML 的*结构化克隆*算法保存，比`JSON.stringify()`更灵活，可以支持
    Map、Set 和 Date 对象以及类型化数组和 ArrayBuffers。'
- en: 'The second argument was intended to be a title string for the state, but most
    browsers do not support it, and you should just pass an empty string. The third
    argument is an optional URL that will be displayed in the location bar immediately
    and also if the user returns to this state via Back and Forward buttons. Relative
    URLs are resolved against the current location of the document. Associating a
    URL with each state allows the user to bookmark internal states of your application.
    Remember, though, that if the user saves a bookmark and then visits it a day later,
    you won’t get a “popstate” event about that visit: you’ll have to restore your
    application state by parsing the URL.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数原本是状态的标题字符串，但大多数浏览器不支持，你应该只传递一个空字符串。第三个参数是一个可选的 URL，将立即显示在位置栏中，用户通过“后退”和“前进”按钮返回到该状态时也会显示。相对
    URL 会相对于文档的当前位置解析。将每个状态与 URL 关联起来允许用户将应用程序的内部状态添加到书签。但请记住，如果用户保存了书签，然后一天后访问它，你将不会收到关于该访问的“popstate”事件：你将需要��过解析
    URL 来恢复应用程序状态。
- en: In addition to the `pushState()` method, the History object also defines `replaceState()`,
    which takes the same arguments but replaces the current history state instead
    of adding a new state to the browsing history. When an application that uses `pushState()`
    is first loaded, it is often a good idea to call `replaceState()` to define a
    state object for this initial state of the application.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`pushState()`方法外，History对象还定义了`replaceState()`，它接受相同的参数，但是替换当前历史状态而不是向浏览历史添加新状态。当首次加载使用`pushState()`的应用程序时，通常最好调用`replaceState()`来为应用程序的初始状态定义一个状态对象。
- en: When the user navigates to saved history states using the Back or Forward buttons,
    the browser fires a “popstate” event on the Window object. The event object associated
    with the event has a property named `state`, which contains a copy (another structured
    clone) of the state object you passed to `pushState()`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用“后退”或“前进”按钮导航到保存的历史状态时，浏览器在Window对象上触发“popstate”事件。与事件相关联的事件对象有一个名为`state`的属性，其中包含您传递给`pushState()`的状态对象的副本（另一个结构化克隆）。
- en: '[Example 15-9](#guessinggame.xhtml) is a simple web application—the number-guessing
    game pictured in [Figure 15-15](Images/#guessinggame.png)—that uses `pushState()`
    to save its history, allowing the user to “go back” to review or redo their guesses.'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例15-9](#guessinggame.xhtml)是一个简单的Web应用程序——在[图15-15](Images/#guessinggame.png)中显示的猜数字游戏——它使用`pushState()`保存其历史记录，允许用户“返回”以查看或重新做出他们的猜测。'
- en: '![js7e 1514](Images/js7e_1514.png)'
  id: totrans-780
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1514](Images/js7e_1514.png)'
- en: Figure 15-15\. A number-guessing game
  id: totrans-781
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-15。一个猜数字游戏
- en: Example 15-9\. History management with pushState()
  id: totrans-782
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-9。使用pushState()进行历史管理
- en: '[PRE113]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 15.11 Networking
  id: totrans-784
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.11 网络
- en: Every time you load a web page, the browser makes network requests—using the
    HTTP and HTTPS protocols—for an HTML file as well as the images, fonts, scripts,
    and stylesheets that the file depends on. But in addition to being able to make
    network requests in response to user actions, web browsers also expose JavaScript
    APIs for networking as well.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 每次加载网页时，浏览器都会使用HTTP和HTTPS协议进行网络请求，获取HTML文件以及文件依赖的图像、字体、脚本和样式表。但除了能够响应用户操作进行网络请求外，Web浏览器还公开了用于网络的JavaScript
    API。
- en: 'This section covers three network APIs:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了三个网络API：
- en: The `fetch()` method defines a Promise-based API for making HTTP and HTTPS requests.
    The `fetch()` API makes basic GET requests simple but has a comprehensive feature
    set that also supports just about any possible HTTP use case.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()`方法为进行HTTP和HTTPS请求定义了基于Promise的API。`fetch()` API使基本的GET请求变得简单，但也具有全面的功能集，支持几乎任何可能的HTTP用例。'
- en: The Server-Sent Events (or SSE) API is a convenient, event-based interface to
    HTTP “long polling” techniques where the web server holds the network connection
    open so that it can send data to the client whenever it wants.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送事件（Server-Sent Events，简称SSE）API是HTTP“长轮询”技术的一种方便的基于事件的接口，其中Web服务器保持网络连接打开，以便在需要时向客户端发送数据。
- en: WebSockets is a networking protocol that is not HTTP but is designed to interoperate
    with HTTP. It defines an asynchronous message-passing API where clients and servers
    can send and receive messages from each other in a way that is similar to TCP
    network sockets.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSockets是一种不是HTTP的网络协议，但设计用于与HTTP互操作。它定义了一个异步消息传递API，客户端和服务器可以相互发送和接收消息，类似于TCP网络套接字。
- en: 15.11.1 fetch()
  id: totrans-790
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.11.1 fetch()
- en: 'For basic HTTP requests, using `fetch()` is a three-step process:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本的HTTP请求，使用`fetch()`是一个三步过程：
- en: Call `fetch()`, passing the URL whose content you want to retrieve.
  id: totrans-792
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fetch()`，传递要检索内容的URL。
- en: Get the response object that is asynchronously returned by step 1 when the HTTP
    response begins to arrive and call a method of this response object to ask for
    the body of the response.
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由第1步异步返回的响应对象，当HTTP响应开始到达时调用此响应对象的方法来请求响应的主体。
- en: Get the body object that is asynchronously returned by step 2 and process it
    however you want.
  id: totrans-794
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取由第2步异步返回的主体对象，并根据需要进行处理。
- en: The `fetch()` API is completely Promise-based, and there are two asynchronous
    steps here, so you typically expect two `then()` calls or two `await` expressions
    when using `fetch()`. (And if you’ve forgotten what those are, you may want to
    reread [Chapter 13](ch13.xhtml#async) before continuing with this section.)
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` API完全基于Promise，并且这里有两个异步步骤，因此当使用`fetch()`时，通常期望有两个`then()`调用或两个`await`表达式。（如果你忘记了它们是什么，可能需要重新阅读[第13章](ch13.xhtml#async)后再继续本节。）'
- en: 'Here’s what a `fetch()` request looks like if you are using `then()` and expect
    the server’s response to your request to be JSON-formatted:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`then()`并期望服务器响应你的请求是JSON格式的，`fetch()`请求看起来是这样的：
- en: '[PRE114]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here’s a similar request made using the `async` and `await` keywords to an
    API that returns a plain string rather than a JSON object:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async`和`await`关键字向返回普通字符串而不是JSON对象的API发出类似请求：
- en: '[PRE115]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: If you understand these two code examples, then you know 80% of what you need
    to know to use the `fetch()` API. The subsections that follow will demonstrate
    how to make requests and receive responses that are somewhat more complicated
    than those shown here.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了这两个代码示例，那么你就知道了使用`fetch()` API所需了解的80%。接下来的小节将演示如何进行比这里显示的更复杂的请求和接收响应。
- en: HTTP status codes, response headers, and network errors
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP状态码、响应头和网络错误
- en: 'The three-step `fetch()` process shown in [§15.11.1](#fetch) elides all error-handling
    code. Here’s a more realistic version:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 在[§15.11.1](#fetch)中显示的三步`fetch()`过程省略了所有错误处理代码。这里是一个更现实的版本：
- en: '[PRE116]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The Promise returned by `fetch()` resolves to a Response object. The `status`
    property of this object is the HTTP status code, such as 200 for successful requests
    or 404 for “Not Found” responses. (`statusText` gives the standard English text
    that goes along with the numeric status code.) Conveniently, the `ok` property
    of a Response is `true` if `status` is 200 or any code between 200 and 299 and
    is `false` for any other code.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 返回的 Promise 解析为一个 Response 对象。这个对象的 `status` 属性是 HTTP 状态码，比如成功请求的
    200 或“未找���”响应的 404。(`statusText` 给出与数字状态码相对应的标准英文文本。)方便的是，Response 的 `ok` 属性在
    `status` 为 200 或 200 到 299 之间的任何代码时为 `true`，对于其他任何代码都为 `false`。'
- en: '`fetch()` resolves its Promise when the server’s response starts to arrive,
    as soon as the HTTP status and response headers are available, but typically before
    the full response body has arrived. Even though the body is not available yet,
    you can examine the headers in this second step of the fetch process. The `headers`
    property of a Response object is a Headers object. Use its `has()` method to test
    for the presence of a header, or use its `get()` method to get the value of a
    header. HTTP header names are case-insensitive, so you can pass lowercase or mixed-case
    header names to these functions.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 在服务器响应开始到达时解析其 Promise，通常在完整响应体到达之前。即使响应体还不可用，你也可以在 fetch 过程的第二步检查头部信息。Response
    对象的 `headers` 属性是一个 Headers 对象。使用它的 `has()` 方法测试头部是否存在，或使用 `get()` 方法获取头部的值。HTTP
    头部名称不区分大小写，因此你可以向这些函数传递小写或混合大小写的头部名称。'
- en: 'The Headers object is also iterable if you ever need to do that:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: Headers 对象也是可迭代的，如果你需要的话：
- en: '[PRE117]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: If a web server responds to your `fetch()` request, then the Promise that was
    returned will be fulfilled with a Response object, even if the server’s response
    was a 404 Not Found error or a 500 Internal Server Error. `fetch()` only rejects
    the Promise it returns if it cannot contact the web server at all. This can happen
    if the user’s computer is offline, the server is unresponsive, or the URL specifies
    a hostname that does not exist. Because these things can happen on any network
    request, it is always a good idea to include a `.catch()` clause any time you
    make a `fetch()` call.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Web 服务器响应你的 `fetch()` 请求，那么返回的 Promise 将以 Response 对象实现，即使服务器的响应是 404 Not
    Found 错误或 500 Internal Server Error。`fetch()` 仅在无法完全联系到 Web 服务器时拒绝其返回的 Promise。如果用户的计算机离线，服务器无响应，或
    URL 指定的主机名不存在，就会发生这种情况。因为这些情况可能发生在任何网络请求上，所以每次进行 `fetch()` 调用时都包含一个 `.catch()`
    子句总是一个好主意。
- en: Setting request parameters
  id: totrans-809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置请求参数
- en: 'Sometimes you want to pass extra parameters along with the URL when you make
    a request. This can be done by adding name/value pairs at the end of a URL after
    a `?`. The URL and URLSearchParams classes (which were covered in [§11.9](ch11.xhtml#urlapi))
    make it easy to construct URLs in this form, and the `fetch()` function accepts
    URL objects as its first argument, so you can include request parameters in a
    `fetch()` request like this:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在发起请求时，你可能想要传递额外的参数。这可以通过在 URL 后面添加 `?` 后的名称/值对来实现。URL 和 URLSearchParams
    类（在 [§11.9](ch11.xhtml#urlapi) 中介绍）使得构造这种形式的 URL 变得容易，`fetch()` 函数接受 URL 对象作为其第一个参数，因此你可以像这样在
    `fetch()` 请求中包含请求参数：
- en: '[PRE118]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Setting request headers
  id: totrans-812
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置请求头部
- en: 'Sometimes you need to set headers in your `fetch()` requests. If you’re making
    web API requests that require credentials, for example, then you may need to include
    an Authorization header that contains those credentials. In order to do this,
    you can use the two-argument version of `fetch()`. As before, the first argument
    is a string or URL object that specifies the URL to fetch. The second argument
    is an object that can provide additional options, including request headers:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要在 `fetch()` 请求中设置头部。例如，如果你正在进行需要凭据的 Web API 请求，那么可能需要包含包含这些凭据的 Authorization
    头部。为了做到这一点，你可以使用 `fetch()` 的两个参数版本。与之前一样，第一个参数是指定要获取的 URL 的字符串或 URL 对象。第二个参数是一个对象，可以提供额外的选项，包括请求头部：
- en: '[PRE119]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'There are a number of other options that can be specified in the second argument
    to `fetch()`, and we’ll see it again later. An alternative to passing two arguments
    to `fetch()` is to instead pass the same two arguments to the `Request()` constructor
    and then pass the resulting Request object to `fetch()`:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `fetch()` 的第二个参数中可以指定许多其他选项，我们稍后会再次看到它。将两个参数传递给 `fetch()` 的替代方法是将相同的两个参数传递给
    `Request()` 构造函数，然后将生成的 Request 对象传递给 `fetch()`：
- en: '[PRE120]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Parsing response bodies
  id: totrans-817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析响应体
- en: In the three-step `fetch()` process that we’ve demonstrated, the second step
    ends by calling the `json()` or `text()` methods of the Response object and returning
    the Promise object that those methods return. Then, the third step begins when
    that Promise resolves with the body of the response parsed as a JSON object or
    simply as a string of text.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们演示的三步 `fetch()` 过程中，第二步通过调用 Response 对象的 `json()` 或 `text()` 方法结束，并返回这些方法返回的
    Promise 对象。然后，第三步开始，当该 Promise 解析为响应体解析为 JSON 对象或简单文本字符串时。
- en: 'These are probably the two most common scenarios, but they are not the only
    ways to obtain the body of a web server’s response. In addition to `json()` and
    `text()`, the Response object also has these methods:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是两种最常见的情况，但并不是获取 Web 服务器响应体的唯一方式。除了 `json()` 和 `text()`，Response 对象还有这些方法：
- en: '`arrayBuffer()`'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrayBuffer()`'
- en: This method returns a Promise that resolves to an ArrayBuffer. This is useful
    when the response contains binary data. You can use the ArrayBuffer to create
    a typed array ([§11.2](ch11.xhtml#typedarrays)) or a DataView object ([§11.2.5](ch11.xhtml#typedarrays-dataview))
    from which you can read the binary data.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法返回一个解析为 ArrayBuffer 的 Promise。当响应包含二进制数据时，这是很有用的。你可以使用 ArrayBuffer 创建一个类型化数组（[§11.2](ch11.xhtml#typedarrays)）或一个
    DataView 对象（[§11.2.5](ch11.xhtml#typedarrays-dataview)），从中读取二进制数据。
- en: '`blob()`'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '`blob()`'
- en: This method returns a Promise that resolves to a Blob object. Blobs are not
    covered in any detail in this book, but the name stands for “Binary Large Object,”
    and they are useful when you expect large amounts of binary data. If you ask for
    the body of the response as a Blob, the browser implementation may stream the
    response data to a temporary file and then return a Blob object that represents
    that temporary file. Blob objects, therefore, do not allow random access to the
    response body the way that an ArrayBuffer does. Once you have a Blob, you can
    create a URL that refers to it with `URL.createObjectURL()`, or you can use the
    event-based FileReader API to asynchronously obtain the content of the Blob as
    a string or an ArrayBuffer. At the time of this writing, some browsers also define
    Promise-based `text()` and `arrayBuffer()` methods that give a more direct route
    for obtaining the content of a Blob.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个解析为 Blob 对象的 Promise。本书未详细介绍 Blob，但其名称代表“二进制大对象”，在期望大量二进制数据时非常有用。如果要求响应主体为
    Blob，则浏览器实现可能会将响应数据流式传输到临时文件，然后返回表示该临时文件的 Blob 对象。因此，Blob 对象不允许像 ArrayBuffer 一样随机访问响应主体。一旦有了
    Blob，你可以使用 `URL.createObjectURL()` 创建一个引用它的 URL，或者你可以使用基于事件的 FileReader API 异步获取
    Blob 的内容作为字符串或 ArrayBuffer。在撰写本文时，一些浏览器还定义了基于 Promise 的 `text()` 和 `arrayBuffer()`
    方法，提供了更直接的方式来获取 Blob 的内容。
- en: '`formData()`'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: '`formData()`'
- en: This method returns a Promise that resolves to a FormData object. You should
    use this method if you expect the body of the Response to be encoded in “multipart/form-data”
    format. This format is common in POST requests made to a server, but uncommon
    in server responses, so this method is not frequently used.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个解析为 FormData 对象的 Promise。如果你期望 Response 的主体以“multipart/form-data”格式编码，则应使用此方法。这种格式在向服务器发出
    POST 请求时很常见，但在服务器响应中不常见，因此此方法不经常使用。
- en: Streaming response bodies
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式传输响应主体
- en: In addition to the five response methods that asynchronously return some form
    of the complete response body to you, there is also an option to stream the response
    body, which is useful if there is some kind of processing you can do on the chunks
    of the response body as they arrive over the network. But streaming the response
    is also useful if you want to display a progress bar so that the user can see
    the progress of the download.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异步返回完整响应主体的五种响应方法之外，还有一种选项可以流式传输响应主体，这在网络上到达响应主体的块时可以进行某种处理时非常有用。但是，如果你想要显示进度条，让用户看到下载的进度，流式传输响应也很有用。
- en: The `body` property of a Response object is a ReadableStream object. If you
    have already called a response method like `text()` or `json()` that reads, parses,
    and returns the body, then `bodyUsed` will be `true` to indicate that the `body`
    stream has already been read. If `bodyUsed` is `false`, however, then the stream
    has not yet been read. In this case, you can call `getReader()` on `response.body`
    to obtain a stream reader object, then use the `read()` method of this reader
    object to asynchronously read chunks of text from the stream. The `read()` method
    returns a Promise that resolves to an object with `done` and `value` properties.
    `done` will be `true` if the entire body has been read or if the stream was closed.
    And `value` will either be the next chunk, as a Uint8Array, or `undefined` if
    there are no more chunks.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: Response 对象的 `body` 属性是一个 ReadableStream 对象。如果你已经调用了像 `text()` 或 `json()` 这样读取、解析和返回主体的响应方法，那么
    `bodyUsed` 将为 `true`，表示 `body` 流已经被读取。但是，如果 `bodyUsed` 为 `false`，则表示流尚未被读取。在这种情况下，你可以调用
    `response.body` 上的 `getReader()` 来获取一个流读取器对象，然后使用该读取器对象的 `read()` 方法异步从流中读取文本块。`read()`
    方法返回一个解析为具有 `done` 和 `value` 属性的对象的 Promise。如果整个主体已被读取或流已关闭，则 `done` 将为 `true`。而
    `value` 将是下一个块，作为 Uint8Array，如果没有更多块，则为 `undefined`。
- en: 'This streaming API is relatively straightforward if you use `async` and `await`
    but is surprisingly complex if you attempt to use it with raw Promises. [Example 15-10](#streamBody.js)
    demonstrates the API by defining a `streamBody()` function. Suppose you wanted
    to download a large JSON file and report download progress to the user. You can’t
    do that with the `json()` method of the Response object, but you could do it with
    the `streamBody()` function, like this (assuming that an `updateProgress()` function
    is defined to set the `value` attribute on an HTML `<progress>` element):'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `async` 和 `await`，则此流式 API 相对简单，但如果尝试使用原始 Promise，则会出乎意料地复杂。[示例 15-10](#streamBody.js)
    通过定义一个 `streamBody()` 函数来演示该 API。假设你想要下载一个大型 JSON 文件并向用户报告下载进度。你无法使用 Response
    对象的 `json()` 方法来实现，但可以使用 `streamBody()` 函数，如下所示（假设已定义了一个 `updateProgress()` 函数来设置
    HTML `<progress>` 元素的 `value` 属性）：
- en: '[PRE121]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The `streamBody()` function can be implemented as shown in [Example 15-10](#streamBody.js).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照 [示例 15-10](#streamBody.js) 中所示实现 `streamBody()` 函数。
- en: Example 15-10\. Streaming the response body from a fetch() request
  id: totrans-832
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-10\. 从 fetch() 请求中流式传输响应主体
- en: '[PRE122]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This streaming API is new at the time of this writing and is expected to evolve.
    In particular, there are plans to make ReadableStream objects asynchronously iterable
    so that they can be used with `for/await` loops ([§13.4.1](ch13.xhtml#async-for-await)).
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 此流式 API 在撰写本文时是新的，并预计会发展。特别是，计划使 ReadableStream 对象异步可迭代，以便可以与 `for/await` 循环一起使用（[§13.4.1](ch13.xhtml#async-for-await)）。
- en: Specifying the request method and request body
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定请求方法和请求体
- en: 'In each of the `fetch()` examples shown so far, we have made an HTTP (or HTTPS)
    GET request. If you want to use a different request method (such as POST, PUT,
    or DELETE), simply use the two-argument version of `fetch()`, passing an Options
    object with a `method` parameter:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示的每个 `fetch()` 示例都是进行了 HTTP（或 HTTPS）GET 请求。如果你想要使用不同的请求方法（如 POST、PUT
    或 DELETE），只需使用 `fetch()` 的两个参数版本，传递一个带有 `method` 参数的 Options 对象：
- en: '[PRE123]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'POST and PUT requests typically have a request body containing data to be sent
    to the server. As long as the `method` property is not set to `"GET"` or `"HEAD"`
    (which do not support request bodies), you can specify a request body by setting
    the `body` property of the Options object:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: POST 和 PUT 请求通常具有包含要发送到服务器的数据的请求体。只要 `method` 属性未设置为 `"GET"` 或 `"HEAD"`（不支持请求体），您可以通过设置
    Options 对象的 `body` 属性来指定请求体：
- en: '[PRE124]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'When you specify a request body, the browser automatically adds an appropriate
    “Content-Length” header to the request. When the body is a string, as in the preceding
    example, the browser defaults the “Content-Type” header to “text/plain;charset=UTF-8.”
    You may need to override this default if you specify a string body of some more
    specific type such as “text/html” or “application/json”:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定请求体时，浏览器会自动向请求添加适当的 “Content-Length” 头。当请求体是字符串时，如前面的示例中，浏览器将默认将 “Content-Type”
    头设置为 “text/plain;charset=UTF-8”。如果您指定了更具体类型的字符串体，如 “text/html” 或 “application/json”，则可能需要覆盖此默认值：
- en: '[PRE125]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `body` property of the `fetch()` options object does not have to be a string.
    If you have binary data in a typed array or a DataView object or an ArrayBuffer,
    you can set the `body` property to that value and specify an appropriate “Content-Type”
    header. If you have binary data in Blob form, you can simply set `body` to the
    Blob. Blobs have a `type` property that specifies their content type, and the
    value of this property is used as the default value of the “Content-Type” header.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` 选项对象的 `body` 属性不一定要是字符串。如果您有二进制数据在类型化数组、DataView 对象或 ArrayBuffer
    中，可以将 `body` 属性设置为该值，并指定适当的 “Content-Type” 头。如果您有 Blob 形式的二进制数据，只需将 `body` 设置为
    Blob。Blob 具有指定其内容类型的 `type` 属性，该属性的值用作 “Content-Type” 头的默认值。'
- en: 'With POST requests, is it somewhat common to pass a set of name/value parameters
    in the request body (instead of encoding them into the query portion of the URL).
    There are two ways to do this:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 POST 请求时，将一组名称/值参数传递到请求体中（而不是将它们编码到 URL 的查询部分）是相当常见的。有两种方法可以实现这一点：
- en: You can specify your parameter names and values with URLSearchParams (which
    we saw earlier in this section, and which is documented in [§11.9](ch11.xhtml#urlapi))
    and then pass the URLSearchParams object as the value of the `body` property.
    If you do this, the body will be set to a string that looks like the query portion
    of a URL, and the “Content-Type” header will be automatically set to “application/x-www-form-urlencoded;charset=UTF-8.”
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 URLSearchParams 指定参数名称和值（我们在本节前面看到过，并在 [§11.9](ch11.xhtml#urlapi) 中有文档），然后将
    URLSearchParams 对象作为 `body` 属性的值传递。如果这样做，请求体将设置为类似 URL 查询部分的字符串，并且“Content-Type”
    头将自动设置为 “application/x-www-form-urlencoded;charset=UTF-8”。
- en: If instead you specify your parameter names and values with a FormData object,
    the body will use a more verbose multipart encoding and “Content-Type” will be
    set to “multipart/form-data; boundary=…” with a unique boundary string that matches
    the body. Using a FormData object is particularly useful when the values you want
    to upload are long, or are File or Blob objects that may each have its own “Content-Type.”
    FormData objects can be created and initialized with values by passing a `<form>`
    element to the `FormData()` constructor. But you can also create “multipart/form-data”
    request bodies by invoking the `FormData()` constructor with no arguments and
    initializing the name/value pairs it represents with the `set()` and `append()`
    methods.
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用 FormData 对象指定参数名称和值，请求体将使用更详细的多部分编码，并且“Content-Type” 将设置为 “multipart/form-data;
    boundary=…”，其中包含一个与请求体匹配的唯一边界字符串。当您要上传的值很长，或者是每个都可能具有自己的“Content-Type”的文件或 Blob
    对象时，使用 FormData 对象特别有用。可以通过将 `<form>` 元素传递给 `FormData()` 构造函数来创建和初始化 FormData
    对象的值。但也可以通过调用不带参数的 `FormData()` 构造函数并使用 `set()` 和 `append()` 方法初始化它表示的名称/值对来创建“multipart/form-data”
    请求体。
- en: File upload with fetch()
  id: totrans-846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 fetch() 上传文件
- en: Uploading files from a user’s computer to a web server is a common task and
    can be accomplished using a FormData object as the request body. A common way
    to obtain a File object is to display an `<input type="file">` element on your
    web page and listen for “change” events on that element. When a “change” event
    occurs, the `files` array of the input element should contain at least one File
    object. File objects are also available through the HTML drag-and-drop API. That
    API is not covered in this book, but you can get files from the `dataTransfer.files`
    array of the event object passed to an event listener for “drop” events.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户计算机上传文件到 Web 服务器是一项常见任务，可以使用 FormData 对象作为请求体。获取 File 对象的常见方法是在 Web 页面上显示一个
    `<input type="file">` 元素，并侦听该元素上的 “change” 事件。当发生 “change” 事件时，输入元素的 `files` 数组应至少包含一个
    File 对象。还可以通过 HTML 拖放 API 获取 File 对象。该 API 不在本书中介绍，但您可以从传递给 “drop” 事件的事件对象的 `dataTransfer.files`
    数组中获取文件。
- en: 'Remember also that File objects are a kind of Blob, and sometimes it can be
    useful to upload Blobs. Suppose you’ve written a web application that allows the
    user to create drawings in a `<canvas>` element. You can upload the user’s drawings
    as PNG files with code like the following:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，File 对象是 Blob 的一种，有时上传 Blob 可能很有用。假设您编写了一个允许用户在 `<canvas>` 元素中创建绘图的 Web
    应用程序。您可以使用以下代码将用户的绘图上传为 PNG 文件：
- en: '[PRE126]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Cross-origin requests
  id: totrans-850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨域请求
- en: Most often, `fetch()` is used by web applications to request data from their
    own web server. Requests like these are known as same-origin requests because
    the URL passed to `fetch()` has the same origin (protocol plus hostname plus port)
    as the document that contains the script that is making the request.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，`fetch()` 被 Web 应用程序用于从自己的 Web 服务器请求数据。这些请求被称为同源请求，因为传递给 `fetch()` 的
    URL 与包含发出请求的脚本的文档具有相同的源（协议加主机名加端口）。
- en: For security reasons, web browsers generally disallow (though there are exceptions
    for images and scripts) cross-origin network requests. However, Cross-Origin Resource
    Sharing, or CORS, enables safe cross-origin requests. When `fetch()` is used with
    a cross-origin URL, the browser adds an “Origin” header to the request (and does
    not allow it to be overridden via the `headers` property) to notify the web server
    that the request is coming from a document with a different origin. If the server
    responds to the request with an appropriate “Access-Control-Allow-Origin” header,
    then the request proceeds. Otherwise, if the server does not explicitly allow
    the request, then the Promise returned by `fetch()` is rejected.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，Web浏览器通常禁止（尽管对于图像和脚本有例外）跨域网络请求。然而，跨域资源共享（CORS）使安全的跨域请求成为可能。当`fetch()`与跨域URL一起使用时，浏览���会向请求添加一个“Origin”头部（并且不允许通过`headers`属性覆盖它）以通知Web服务器请求来自具有不同来源的文档。如果服务器用适当的“Access-Control-Allow-Origin”头部响应请求，那么请求会继续。否则，如果服务器没有明确允许请求，那么`fetch()`返回的Promise将被拒绝。
- en: Aborting a request
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中止请求
- en: Sometimes you may want to abort a `fetch()` request that you have already issued,
    perhaps because the user clicked a Cancel button or the request is taking too
    long. The fetch API allows requests to be aborted using the AbortController and
    AbortSignal classes. (These classes define a generic abort mechanism suitable
    for use by other APIs as well.)
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能想要中止一个已经发出的`fetch()`请求，也许是因为用户点击了取消按钮或请求花费的时间太长。fetch API允许使用AbortController和AbortSignal类来中止请求。（这些类定义了一个通用的中止机制，适用于其他API的使用。）
- en: If you want to have the option of aborting a `fetch()` request, then create
    an AbortController object before starting the request. The `signal` property of
    the controller object is an AbortSignal object. Pass this signal object as the
    value of the `signal` property of the options object that you pass to `fetch()`.
    Having done that, you can call the `abort()` method of the controller object to
    abort the request, which will cause any Promise objects related to the fetch request
    to reject with an exception.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要中止一个`fetch()`请求的选项，那么在开始请求之前创建一个AbortController对象。控制器对象的`signal`属性是一个AbortSignal对象。将这个信号对象作为你传递给`fetch()`的选项对象的`signal`属性的值。这样做后，你可以调用控制器对象的`abort()`方法来中止请求，这将导致与fetch请求相关的任何Promise对象拒绝并抛出异常。
- en: 'Here is an example of using the AbortController mechanism to enforce a timeout
    for fetch requests:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用AbortController机制强制执行fetch请求超时的示例：
- en: '[PRE127]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Miscellaneous request options
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项请求选项
- en: 'We’ve seen that an Options object can be passed as the second argument to `fetch()`
    (or as the second argument to the `Request()` constructor) to specify the request
    method, request headers, and request body. It supports a number of other options
    as well, including these:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Options对象可以作为`fetch()`的第二个参数（或`Request()`构造函数的第二个参数）传递，以指定请求方法、请求头和请求体。它还支持许多其他选项，包括这些：
- en: '`cache`'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache`'
- en: 'Use this property to override the browser’s default caching behavior. HTTP
    caching is a complex topic that is beyond the scope of this book, but if you know
    something about how it works, you can use the following legal values of `cache`:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个属性来覆盖浏览器的默认缓存行为。HTTP缓存是一个复杂的主题，超出了本书的范围，但如果你了解它的工作原理，你可以使用以下`cache`的合法值：
- en: '`"default"`'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '`"default"`'
- en: This value specifies the default caching behavior. Fresh responses in the cache
    are served directly from the cache, and stale responses are revalidated before
    being served.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值指定了默认的缓存行为。缓存中的新鲜响应直接从缓存中提供，而陈旧响应在提供之前会被重新验证。
- en: '`"no-store"`'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`"no-store"`'
- en: This value makes the browser ignore its cache. The cache is not checked for
    matches when the request is made and is not updated when the response arrives.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值使浏览器忽略其缓存。当请求发出时，不会检查缓存是否匹配，并且当响应到达时也不会更新缓存。
- en: '`"reload"`'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '`"reload"`'
- en: This value tells the browser to always make a normal network request, ignoring
    the cache. When the response arrives, however, it is stored in the cache.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值告诉浏览器始终进行正常的网络请求，忽略缓存。然而，当响应到达时，它会被存储在缓存中。
- en: '`"no-cache"`'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '`"no-cache"`'
- en: This (misleadingly named) value tells the browser to not serve fresh values
    from the cache. Fresh or stale cached values are revalidated before being returned.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 这个（误导性命名的）值告诉浏览器不要从缓存中提供新鲜值。在返回之前，新鲜或陈旧的缓存值会被重新验证。
- en: '`"force-cache"`'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '`"force-cache"`'
- en: This value tells the browser to serve responses from the cache even if they
    are stale.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值告诉浏览器即使缓存中的响应是陈旧的也要提供。
- en: '`redirect`'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect`'
- en: 'This property controls how the browser handles redirect responses from the
    server. The three legal values are:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性控制浏览器如何处理来自服务器的重定向响应。三个合法的值是：
- en: '`"follow"`'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '`"follow"`'
- en: This is the default value, and it makes the browser follow redirects automatically.
    If you use this default, the Response objects you get with `fetch()` should never
    have a `status` in the 300 to 399 range.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认值，它使浏览器自动跟随重定向。如果使用这个默认值，通过`fetch()`获取的Response对象不应该有`status`在300到399范围内。
- en: '`"error"`'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '`"error"`'
- en: This value makes `fetch()` reject its returned Promise if the server returns
    a redirect response.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值使`fetch()`在服务器返回重定向响应时拒绝其返回的Promise。
- en: '`"manual"`'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '`"manual"`'
- en: This value means that you want to manually handle redirect responses, and the
    Promise returned by `fetch()` may resolve to a Response object with a `status`
    in the 300 to 399 range. In this case, you will have to use the “Location” header
    of the Response to manually follow the redirection.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值意味着你想要手动处理重定向响应，并且`fetch()`返回的Promise可能会解析为一个带有`status`在300到399范围内的Response对象。在这种情况下，你将不得不使用Response的“Location”头部来手动跟随重定向。
- en: '`referrer`'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '`referrer`'
- en: You can set this property to a string that contains a relative URL to specify
    the value of the HTTP “Referer” header (which is historically misspelled with
    three Rs instead of four). If you set this property to the empty string, then
    the “Referer” header will be omitted from the request.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此属性设置为包含相对URL的字符串，以指定HTTP“Referer”标头的值（历史上错误拼写为三个R而不是四个）。如果将此属性设置为空字符串，则“Referer”标头将从请求中省略。
- en: 15.11.2 Server-Sent Events
  id: totrans-882
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.11.2 服务器发送事件
- en: A fundamental feature of the HTTP protocol upon which the web is built is that
    clients initiate requests and servers respond to those requests. Some web apps
    find it useful, however, to have their server send them notifications when events
    occur. This does not come naturally to HTTP, but the technique that has been devised
    is for the client to make a request to the server, and then neither the client
    nor the server close the connection. When the server has something to tell the
    client about, it writes data to the connection but keeps it open. The effect is
    as if the client makes a network request and the server responds in a slow and
    bursty way with significant pauses between bursts of activity. Network connections
    like this don’t usually stay open forever, but if the client detects that the
    connection has closed, it can simply make another request to reopen the connection.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议构建在其上的Web的一个基本特性是客户端发起请求，服务器响应这些请求。然而，一些Web应用程序发现，当事件发生时，让服务器向它们发送通知很有用。这对HTTP来说并不是自然的，但已经设计了一种技术，即客户端向服务器发出请求，然后客户端和服务器都不关闭连接。当服务器有事情要告诉客户端时，它会向连接写入数据但保持连接打开。效果就好像客户端发出网络请求，服务器以缓慢且突发的方式做出响应，活动之间有显著的暂停。这样的网络连接通常不会永远保持打开，但如果客户端检测到连接已关闭，它可以简单地发出另一个请求以重新打开连接。
- en: 'This technique for allowing servers to send messages to clients is surprisingly
    effective (though it can be expensive on the server side because the server must
    maintain an active connection to all of its clients). Because it is a useful programming
    pattern, client-side JavaScript supports it with the EventSource API. To create
    this kind of long-lived request connection to a web server, simply pass a URL
    to the `EventSource()` constructor. When the server writes (properly formatted)
    data to the connection, the EventSource object translates those into events that
    you can listen for:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 允许服务器向客户端发送消息的这种技术非常有效（尽管在服务器端可能会很昂贵，因为服务器必须维护与所有客户端的活动连接）。由于这是一种有用的编程模式，客户端JavaScript通过EventSource
    API支持它。要创建这种长连接到Web服务器的请求连接，只需将URL传递给`EventSource()`构造函数。当服务器向连接写入（格式正确的）数据时，EventSource对象将这些数据转换为您可以监听的事件：
- en: '[PRE128]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The event object associated with a message event has a `data` property that
    holds whatever string the server sent as the payload for this event. The event
    object also has a `type` property, like all event objects do, that specifies the
    name of the event. The server determines the type of the events that are generated.
    If the server omits an event name in the data it writes, then the event type defaults
    to “message.”
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 与消息事件相关联的事件对象具有一个`data`属性，其中保存服务器作为此事件的有效负载发送的任何字符串。事件对象还具有一个`type`属性，就像所有事件对象一样，指定事件的名称。服务器确定生成的事件的类型。如果服务器在写入的数据中省略了事件名称，则事件类型默认为“message”。
- en: 'The Server-Sent Event protocol is straightforward. The client initiates a connection
    to the server (when it creates the `EventSource` object), and the server keeps
    this connection open. When an event occurs, the server writes lines of text to
    the connection. An event going over the wire might look like this, if the comments
    were omitted:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送事件协议很简单。客户端启动与服务器的连接（当创建`EventSource`对象时），服务器保持此连接处于打开状态。当事件发生时，服务器向连接写入文本行。如果省略了注释，通过网络传输的事件可能如下所示：
- en: '[PRE129]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: There are some additional details to the protocol that allow events to be given
    IDs and allow a reconnecting client to tell the server what the ID of the last
    event it received was, so that a server can resend any events it missed. Those
    details are invisible on the client side, however, and are not discussed here.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 协议的一些附加细节允许事件被赋予ID，并允许重新连接的客户端告诉服务器它收到的最后一个事件的ID，以便服务器可以重新发送任何错过的事件。然而，这些细节在客户端端是不可见的，并且这里不讨论。
- en: One obvious application for Server-Sent Events is for multiuser collaborations
    like online chat. A chat client might use `fetch()` to post messages to the chat
    room and subscribe to the stream of chatter with an EventSource object. [Example 15-11](#chatClient.xhtml)
    demonstrates how easy it is to write a chat client like this with EventSource.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器发送事件的一个明显应用是用于多用户协作，如在线聊天。聊天客户端可能使用`fetch()`来向聊天室发布消息，并使用EventSource对象订阅聊天内容的流。[示例 15-11](#chatClient.xhtml)演示了如何使用EventSource轻松编写这样的聊天客户端。
- en: Example 15-11\. A simple chat client using EventSource
  id: totrans-891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-11\. 使用EventSource的简单聊天客户端
- en: '[PRE130]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The server-side code for this chat program is not much more complicated than
    the client-side code. [Example 15-12](#chatServer.js) is a simple Node HTTP server.
    When a client requests the root URL “/”, it sends the chat client code shown in
    [Example 15-11](#chatClient.xhtml). When a client makes a GET request for the
    URL “/chat”, it saves the response object and keeps that connection open. And
    when a client makes a POST request to “/chat”, it uses the body of the request
    as a chat message and writes it, using the “text/event-stream” format to each
    of the saved response objects. The server code listens on port 8080, so after
    running it with Node, point your browser to `http://localhost:8080` to connect
    and begin chatting with yourself.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聊天程序的服务器端代码并不比客户端代码复杂多少。[示例 15-12](#chatServer.js)是一个简单的Node HTTP服务器。当客户端请求根URL“/”时，它发送了[示例 15-11](#chatClient.xhtml)中显示的聊天客户端代码。当客户端请求URL“/chat”时，它保存响应对象并保持该连接打开。当客户端向“/chat”发出POST请求时，它使用请求的主体作为聊天消息，并使用“text/event-stream”格式将其写入到每个保存的响应对象中。服务器代码监听端口8080，因此在使用Node运行后，将浏览器指向`http://localhost:8080`以连接并开始与自己聊天。
- en: Example 15-12\. A Server-Sent Events chat server
  id: totrans-894
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-12\. 一个服务器发送事件聊天服务器
- en: '[PRE131]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 15.11.3 WebSockets
  id: totrans-896
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.11.3 WebSockets
- en: The WebSocket API is a simple interface to a complex and powerful network protocol.
    WebSockets allow JavaScript code in the browser to easily exchange text and binary
    messages with a server. As with Server-Sent Events, the client must establish
    the connection, but once the connection is established, the server can asynchronously
    send messages to the client. Unlike SSE, binary messages are supported, and messages
    can be sent in both directions, not just from server to client.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket API是一个简单接口，用于复杂和强大的网络协议。WebSockets允许浏览器中的JavaScript代码与服务器轻松交换文本和二进制消息。与服务器发送事件一样，客户端必须建立连接，但一旦连接建立，服务器可以异步向客户端发送消息。与SSE不同，支持二进制消息，并且消息可以在双向发送，不仅仅是从服务器到客户端。
- en: The network protocol that enables WebSockets is a kind of extension to HTTP.
    Although the WebSocket API is reminiscent of low-level network sockets, connection
    endpoints are not identified by IP address and port. Instead, when you want to
    connect to a service using the WebSocket protocol, you specify the service with
    a URL, just as you would for a web service. WebSocket URLs begin with `wss://`
    instead of `https://`, however. (Browsers typically restrict WebSockets to only
    work in pages loaded over secure `https://` connections).
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 使WebSockets能够连接的网络协议是HTTP的一种扩展。虽然WebSocket API让人想起低级网络套接字���但连接端点并不是通过IP地址和端口来标识的。相反，当你想使用WebSocket协议连接到一个服务时，你使用URL指定服务，就像你为Web服务所做的那样。然而，WebSocket
    URL以`wss://`开头，而不是`https://`。 （浏览器通常限制WebSockets仅在通过安全的`https://`连接加载的页面中工作）。
- en: 'To establish a WebSocket connection, the browser first establishes an HTTP
    connection and sends the server an `Upgrade: websocket` header requesting that
    the connection be switched from the HTTP protocol to the WebSocket protocol. What
    this means is that in order to use WebSockets in your client-side JavaScript,
    you will need to be working with a web server that also speaks the WebSocket protocol,
    and you will need to have server-side code written to send and receive data using
    that protocol. If your server is set up that way, then this section will explain
    everything you need to know to handle the client-side end of the connection. If
    your server does not support the WebSocket protocol, consider using Server-Sent
    Events ([§15.11.2](#sse)) instead.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '要建立WebSocket连接，浏览器首先建立一个HTTP连接，并发送一个`Upgrade: websocket`头部到服务器，请求将连接从HTTP协议切换到WebSocket协议。这意味着为了在客户端JavaScript中使用WebSockets，你需要与一个也支持WebSocket协议的Web服务器一起工作，并且需要编写服务器端代码来使用该协议发送和接收数据。如果你的服务器是这样设置的，那么本节将解释一切你需要了解的来处理连接的客户端端。如果你的服务器不支持WebSocket协议，考虑使用服务器发送事件（[§15.11.2](#sse)）。'
- en: Creating, connecting, and disconnecting WebSockets
  id: totrans-900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建、连接和断开WebSocket
- en: 'If you want to communicate with a WebSocket-enabled server, create a WebSocket
    object, specifying the `wss://` URL that identifies the server and service you
    want to use:'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想与支持WebSocket的服务器通信，创建一个WebSocket对象，指定`wss://` URL来标识你想使用的服务器和服务：
- en: '[PRE132]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When you create a WebSocket, the connection process begins automatically. But
    a newly created WebSocket will not be connected when it is first returned.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个WebSocket时，连接过程会自动开始。但是当首次返回时，新创建的WebSocket不会连接。
- en: 'The `readyState` property of the socket specifies what state the connection
    is in. This property can have the following values:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: socket的`readyState`属性指定连接所处的状态。该属性可以有以下值：
- en: '`WebSocket.CONNECTING`'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket.CONNECTING`'
- en: This WebSocket is connecting.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WebSocket正在连接。
- en: '`WebSocket.OPEN`'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket.OPEN`'
- en: This WebSocket is connected and ready for communication.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WebSocket已连接并准备好通信。
- en: '`WebSocket.CLOSING`'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket.CLOSING`'
- en: This WebSocket connection is being closed.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WebSocket连接正在关闭。
- en: '`WebSocket.CLOSED`'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSocket.CLOSED`'
- en: This WebSocket has been closed; no further communication is possible. This state
    can also occur when the initial connection attempt fails.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WebSocket已经关闭；无法进行进一步的通信。当初始连接尝试失败时，也会出现这种状态。
- en: When a WebSocket transitions from the CONNECTING to the OPEN state, it fires
    an “open” event, and you can listen for this event by setting the `onopen` property
    of the WebSocket or by calling `addEventListener()` on that object.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 当WebSocket从连接状态转换到打开状态时，它会触发一个“open”事件，你可以通过设置WebSocket的`onopen`属性或在该对象上调用`addEventListener()`来监听此事件。
- en: If a protocol or other error occurs for a WebSocket connection, the WebSocket
    object fires an “error” event. You can set `onerror` to define a handler, or,
    alternatively, use `addEventListener()`.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 如果WebSocket连接发生协议或其他错误，WebSocket对象会触发一个“error”事件。你可以设置`onerror`来定义一个处理程序，或者使用`addEventListener()`。
- en: When you are done with a WebSocket, you can close the connection by calling
    the `close()` method of the WebSocket object. When a WebSocket changes to the
    CLOSED state, it fires a “close” event, and you can set the `onclose` property
    to listen for this event.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成一个 WebSocket 时，可以通过调用 WebSocket 对象的 `close()` 方法来关闭连接。当 WebSocket 变为 CLOSED
    状态时，它会触发一个“close”事件，您可以设置 `onclose` 属性来监听此事件。
- en: Sending messages over a WebSocket
  id: totrans-916
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 WebSocket 发送消息
- en: To send a message to the server on the other end of a WebSocket connection,
    simply invoke the `send()` method of the WebSocket object. `send()` expects a
    single message argument, which can be a string, Blob, ArrayBuffer, typed array,
    or DataView object.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 要向 WebSocket 连接的另一端的服务器发送消息，只需调用 WebSocket 对象的 `send()` 方法。`send()` 需要一个消息参数，可以是字符串、Blob、ArrayBuffer、类型化数组或
    DataView 对象。
- en: The `send()` method buffers the specified message to be transmitted and returns
    before the message is actually sent. The `bufferedAmount` property of the WebSocket
    object specifies the number of bytes that are buffered but not yet sent. (Surprisingly,
    WebSockets do not fire any event when this value reaches 0.)
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()` 方法缓冲要传输的指定消息，并在消息实际发送之前返回。WebSocket 对象的 `bufferedAmount` 属性指定已缓冲但尚未发送的字节数。（令人惊讶的是，当此值达到
    0 时，WebSocket 不会触发任何事件。）'
- en: Receiving messages from a WebSocket
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 WebSocket 接收消息
- en: To receive messages from a server over a WebSocket, register an event handler
    for “message” events, either by setting the `onmessage` property of the WebSocket
    object, or by calling `addEventListener()`. The object associated with a “message”
    event is a MessageEvent instance with a `data` property that contains the server’s
    message. If the server sent UTF-8 encoded text, then `event.data` will be a string
    containing that text.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 要从服务器通过 WebSocket 接收消息，请为“message”事件注册事件处理程序，可以通过设置 WebSocket 对象的 `onmessage`
    属性或调用 `addEventListener()` 来实现。与“message”事件关联的对象是一个具有包含服务器消息的 `data` 属性的 MessageEvent
    实例。如果服务器发送 UTF-8 编码的文本，则 `event.data` 将是包含该文本的字符串。
- en: If the server sends a message that consists of binary data instead of text,
    then the `data` property will (by default) be a Blob object representing that
    data. If you prefer to receive binary messages as ArrayBuffers instead of Blobs,
    set the `binaryType` property of the WebSocket object to the string “arraybuffer.”
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器发送的消息由二进制数据而不是文本组成，则 `data` 属性（默认情况下）将是表示该数据的 Blob 对象。如果您希望将二进制消息接收为 ArrayBuffer
    而不是 Blob，请将 WebSocket 对象的 `binaryType` 属性设置为字符串“arraybuffer”。
- en: 'There are a number of Web APIs that use MessageEvent objects for exchanging
    messages. Some of these APIs use the structured clone algorithm (see [“The Structured
    Clone Algorithm”](#structuredclone)) to allow complex data structures as the message
    payload. WebSockets is not one of those APIs: messages exchanged over a WebSocket
    are either a single string of Unicode characters or a single string of bytes (represented
    as a Blob or an ArrayBuffer).'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 Web API 使用 MessageEvent 对象交换消息。其中一些 API 使用结构化克隆算法（参见[“结构化克隆算法”](#structuredclone)）允许复杂的数据结构作为消息负载。WebSocket
    不是这些 API 之一：通过 WebSocket 交换的消息要么是单个 Unicode 字符串，要么是单个字节字符串（表示为 Blob 或 ArrayBuffer）。
- en: Protocol negotiation
  id: totrans-923
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协议协商
- en: 'The WebSocket protocol enables the exchange of text and binary messages, but
    says nothing at all about the structure or meaning of those messages. Applications
    that use WebSockets must build their own communication protocol on top of this
    simple message-exchange mechanism. The use of `wss://` URLs helps with this: each
    URL will typically have its own rules for how messages are to be exchanged. If
    you write code to connect to `wss://example.com/stockticker`, then you probably
    know that you will be receiving messages about stock prices.'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议允许交换文本和二进制消息，但对这些消息的结构或含义一无所知。使用 WebSocket 的应用程序必须在这种简单的消息交换机制之上构建自己的通信协议。使用
    `wss://` URL 有助于此：每个 URL 通常都有自己的消息交换规则。如果您编写代码连接到 `wss://example.com/stockticker`，那么您可能知道您将收到有关股票价格的消息。
- en: Protocols tend to evolve, however. If a hypothetical stock quotation protocol
    is updated, you can define a new URL and connect to the updated service as `wss://example.com/stockticker/v2`.
    URL-based versioning is not always sufficient, however. With complex protocols
    that have evolved over time, you may end up with deployed servers that support
    multiple versions of the protocol and deployed clients that support a different
    set of protocol versions.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，协议往往会发展。如果一个假设的股票行情协议被更新，你可以定义一个新的 URL 并连接到更新的服务，如 `wss://example.com/stockticker/v2`。基于
    URL 的版本控制并不总是足够的。对于随时间演变的复杂协议，您可能会遇到支持多个协议版本的部署服务器和支持不同协议版本集的部署客户端。
- en: Anticipating this situation, the WebSocket protocol and API include an application-level
    protocol negotiation feature. When you call the `WebSocket()` constructor, the
    `wss://` URL is the first argument, but you can also pass an array of strings
    as the second argument. If you do this, you are specifying a list of application
    protocols that you know how to handle and asking the server to pick one. During
    the connection process, the server will choose one of the protocols (or will fail
    with an error if it does not support any of the client’s options). Once the connection
    has been established, the `protocol` property of the WebSocket object specifies
    which protocol version the server chose.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 为了预料到这种情况，WebSocket 协议和 API 包括一个应用级协议协商功能。当你调用 `WebSocket()` 构造函数时，`wss://`
    URL 是第一个参数，但你也可以将字符串数组作为第二个参数传递。如果这样做，你正在指定一个你知道如何处理的应用程序协议列表，并要求服务器选择一个。在连接过程中，服务器将选择一个协议（或者如果不支持客户端的任何选项，则会失败并显示错误）。一旦建立连接，WebSocket
    对象的 `protocol` 属性指定服务器选择的协议版本。
- en: 15.12 Storage
  id: totrans-927
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储
- en: 'Web applications can use browser APIs to store data locally on the user’s computer.
    This client-side storage serves to give the web browser a memory. Web apps can
    store user preferences, for example, or even store their complete state, so that
    they can resume exactly where you left off at the end of your last visit. Client-side
    storage is segregated by origin, so pages from one site can’t read the data stored
    by pages from another site. But two pages from the same site can share storage
    and use it as a communication mechanism. Data input in a form on one page can
    be displayed in a table on another page, for example. Web applications can choose
    the lifetime of the data they store: data can be stored temporarily so that it
    is retained only until the window closes or the browser exits, or it can be saved
    on the user’s computer and stored permanently so that it is available months or
    years later.'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序可以使用浏览器API在用户计算机上本地存储数据。这种客户端存储用于给Web浏览器提供内存。Web应用程序可以存储用户偏好设置，例如，甚至可以存储它们的完整状态，以便它们可以在上次访问结束时恢复到离开的地方。客户端存储按来源分隔，因此来自一个站点的页面无法读取另一个站点的页面存储的数据。但来自同一站点的两个页面可以共享存储并将其用作通信机制。例如，一个页面上的表单中输入的数据可以在另一个页面上的表格中显示。Web应用程序可以选择存储数据的生命周期：数据可以临时存储，以便仅在窗口关闭或浏览器退出时保留，或者可以保存在用户计算机上并永久存储，以便在几个月或几年后可用。
- en: 'There are a number of forms of client-side storage:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端存储有许多形式：
- en: Web Storage
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储
- en: The Web Storage API consists of the `localStorage` and `sessionStorage` objects,
    which are essentially persistent objects that map string keys to string values.
    Web Storage is very easy to use and is suitable for storing large (but not huge)
    amounts of data.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: Web存储API由`localStorage`和`sessionStorage`对象组成，它们本质上是将字符串键映射到字符串值的持久对象。Web存储非常易于使用，适用于存储大量（但不是巨大量）的数据。
- en: Cookies
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies
- en: Cookies are an old client-side storage mechanism that was designed for use by
    server-side scripts. An awkward JavaScript API makes cookies scriptable on the
    client side, but they’re hard to use and suitable only for storing small amounts
    of textual data. Also, any data stored as cookies is always transmitted to the
    server with every HTTP request, even if the data is only of interest to the client.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies是一种旧的客户端存储机制，设计用于服务器端脚本使用。一个笨拙的JavaScript API使得cookies在客户端端可脚本化，但它们很难使用，只适用于存储少量文本数据。此外，任何存储为cookie的数据都会随着每个HTTP请求传输到服务器，即使数据只对客户端感兴趣。
- en: IndexedDB
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB
- en: IndexedDB is an asynchronous API to an object database that supports indexing.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB是支持索引的对象数据库的异步API。
- en: 15.12.1 localStorage and sessionStorage
  id: totrans-936
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.12.1 localStorage和sessionStorage
- en: 'The `localStorage` and `sessionStorage` properties of the Window object refer
    to Storage objects. A Storage object behaves much like a regular JavaScript object,
    except that:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: Window对象的`localStorage`和`sessionStorage`属性指向Storage对象。Storage对象的行为类似于常规的JavaScript对象，只是：
- en: The property values of Storage objects must be strings.
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Storage对象的属性值必须是字符串。
- en: The properties stored in a Storage object persist. If you set a property of
    the localStorage object and then the user reloads the page, the value you saved
    in that property is still available to your program.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在Storage对象中的属性是持久的。如果你设置了localStorage对象的一个属性，然后用户重新加载页面，你保存在该属性中的值仍然对你的程序可用。
- en: 'You can use the localStorage object like this, for example:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用localStorage对象，例如：
- en: '[PRE133]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'You can use the `delete` operator to remove properties from `localStorage`
    and `sessionStorage`, and you can use a `for/in` loop or `Object.keys()` to enumerate
    the properties of a Storage object. If you want to remove all properties of a
    storage object, call the `clear()` method:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`delete`运算符从`localStorage`和`sessionStorage`中删除属性，并且可以使用`for/in`循环或`Object.keys()`来枚举Storage对象的属性。如果你想要移除存储对象的所有属性，调用`clear()`方法：
- en: '[PRE134]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Storage objects also define `getItem()`, `setItem()`, and `deleteItem()` methods,
    which you can use instead of direct property access and the `delete` operator
    if you want to.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: Storage对象还定义了`getItem()`、`setItem()`和`deleteItem()`方法，如果你想要的话，可以使用这些方法代替直接属性访问和`delete`运算符。
- en: Keep in mind that the properties of Storage objects can only store strings.
    If you want to store and retrieve other kinds of data, you’ll have to encode and
    decode it yourself.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Storage对象的属性只能存储字符串。如果你想要存储和检索其他类型的数据，你必须自己进行编码和解码。
- en: 'For example:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE135]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Storage lifetime and scope
  id: totrans-948
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储的生命周期和范围
- en: 'The difference between `localStorage` and `sessionStorage` involves the lifetime
    and scope of the storage. Data stored through `localStorage` is permanent: it
    does not expire and remains stored on the user’s device until a web app deletes
    it or the user asks the browser (through some browser-specific UI) to delete it.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`和`sessionStorage`之间的区别涉及存储的生命周期和范围。通过`localStorage`存储的数据是永久的：它不会过期，并且会一直存储在用户设备上，直到Web应用将其删除或用户要求浏览器（通过某些特定于浏览器的UI）将其删除。'
- en: '`localStorage` is scoped to the document origin. As explained in [“The same-origin
    policy”](#sameoriginpolicy), the origin of a document is defined by its protocol,
    hostname, and port. All documents with the same origin share the same `localStorage`
    data (regardless of the origin of the scripts that actually access `localStorage`).
    They can read each other’s data, and they can overwrite each other’s data. But
    documents with different origins can never read or overwrite each other’s data
    (even if they’re both running a script from the same third-party server).'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`的范围是文档来源。正如在[“同源策略”](#sameoriginpolicy)中解释的那样，文档的来源由其协议、主机名和端口定义。具有相同来源的所有文档共享相同的`localStorage`数据（无论实际访问`localStorage`的脚本的来源如何）。它们可以读取彼此的数据，并且可以覆盖彼此的数据。但具有不同来源的文档永远无法读取或覆盖彼此的数据（即使它们都从同一个第三方服务器运行脚本）。'
- en: Note that `localStorage` is also scoped by browser implementation. If you visit
    a site using Firefox and then visit again using Chrome (for example), any data
    stored during the first visit will not be accessible during the second visit.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`localStorage`也受浏览器实现的范围限制。如果您使用Firefox访问网站，然后再次使用Chrome访问（例如），则在第一次访问期间存储的任何数据在第二次访问期间将无法访问。
- en: 'Data stored through `sessionStorage` has a different lifetime than data stored
    through `localStorage`: it has the same lifetime as the top-level window or browser
    tab in which the script that stored it is running. When the window or tab is permanently
    closed, any data stored through `sessionStorage` is deleted. (Note, however, that
    modern browsers have the ability to reopen recently closed tabs and restore the
    last browsing session, so the lifetime of these tabs and their associated `sessionStorage`
    may be longer than it seems.)'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`sessionStorage`存储的数据的生存期与存储它的脚本所在的顶级窗口或浏览器标签页的生存期相同。当窗口或标签页永久关闭时，通过`sessionStorage`存储的任何数据都将被删除。（但是，请注意，现代浏览器具有重新打开最近关闭的标签页并恢复上次浏览会话的功能，因此这些标签页及其关联的`sessionStorage`的生存期可能比看起来更长。）
- en: 'Like `localStorage`, `sessionStorage` is scoped to the document origin so that
    documents with different origins will never share `sessionStorage`. But `sessionStorage`
    is also scoped on a per-window basis. If a user has two browser tabs displaying
    documents from the same origin, those two tabs have separate `sessionStorage`
    data: the scripts running in one tab cannot read or overwrite the data written
    by scripts in the other tab, even if both tabs are visiting exactly the same page
    and are running exactly the same scripts.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 与`localStorage`类似，`sessionStorage`也受文档源的范围限制，因此具有不同源的文档永远不会共享`sessionStorage`。但是，`sessionStorage`还受每个窗口的范围限制。如果用户有两个显示来自相同源的浏览器标签页，这两个标签页具有单独的`sessionStorage`数据：运行在一个标签页中的脚本无法读取或覆盖另一个标签页中的脚本写入的数据，即使这两个标签页正在访问完全相同的页面并运行完全相同的脚本。
- en: Storage events
  id: totrans-954
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储事件
- en: Whenever the data stored in `localStorage` changes, the browser triggers a “storage”
    event on any other Window objects to which that data is visible (but not on the
    window that made the change). If a browser has two tabs open to pages with the
    same origin, and one of those pages stores a value in `localStorage`, the other
    tab will receive a “storage” event.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 每当存储在`localStorage`中的数据发生变化时，浏览器会在任何其他可见该数据的窗口对象上触发“storage”事件（但不会在进行更改的窗口上触发）。如果浏览器有两个打开到具有相同源的页面的标签页，并且其中一个页面在`localStorage`中存储一个值，另一个标签页将接收到“storage”事件。
- en: Register a handler for “storage” events either by setting `window.onstorage`
    or by calling `window.addEventListener()` with event type “storage”.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`window.onstorage`或调用`window.addEventListener()`并设置事件类型为“storage”来为“storage”事件注册处理程序。
- en: 'The event object associated with a “storage” event has some important properties:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 与“storage”事件关联的事件对象具有一些重要属性：
- en: '`key`'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`'
- en: The name or key of the item that was set or removed. If the `clear()` method
    was called, this property will be `null`.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 设置或删除的项目的名称或键。如果调用了`clear()`方法，则此属性将为`null`。
- en: '`newValue`'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '`newValue`'
- en: Holds the new value of the item, if there is one. If `removeItem()` was called,
    this property will not be present.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在新项目的新值，则保存该值。如果调用了`removeItem()`，则此属性将不存在。
- en: '`oldValue`'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '`oldValue`'
- en: Holds the old value of an existing item that changed or was deleted. If a new
    property (with no old value) is added, then this property will not be present
    in the event object.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 保存更改或删除的现有项目的旧值。如果调用了`removeItem()`，则此属性将不存在。
- en: '`storageArea`'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '`storageArea`'
- en: The Storage object that changed. This is usually the `localStorage` object.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 发生更改的Storage对象。这通常是`localStorage`对象。
- en: '`url`'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '`url`'
- en: The URL (as a string) of the document whose script made this storage change.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 使此存储更改的文档的URL（作为字符串）。
- en: Note that `localStorage` and the “storage” event can serve as a broadcast mechanism
    by which a browser sends a message to all windows that are currently visiting
    the same website. If a user requests that a website stop performing animations,
    for example, the site might store that preference in `localStorage` so that it
    can honor it in future visits. And by storing the preference, it generates an
    event that allows other windows displaying the same site to honor the request
    as well.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`localStorage`和“storage”事件可以作为浏览器向当前访问同一网站的所有窗口发送消息的广播机制。例如，如果用户要求网站停止执行动画，网站可能会将该偏好存储在`localStorage`中，以便在将来的访问中遵守该偏好。通过存储偏好，它生成一个事件，允许显示相同网站的其他窗口也遵守请求。
- en: As another example, imagine a web-based image-editing application that allows
    the user to display tool palettes in separate windows. When the user selects a
    tool, the application uses `localStorage` to save the current state and to generate
    a notification to other windows that a new tool has been selected.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，想象一个基于Web的图像编辑应用程序，允许用户在单独的窗口中显示工具面板。当用户选择工具时，应用程序使用`localStorage`保存当前状态，并向其他窗口生成通知，表示已选择新工具。
- en: 15.12.2 Cookies
  id: totrans-970
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.12.2 Cookies
- en: A *cookie* is a small amount of named data stored by the web browser and associated
    with a particular web page or website. Cookies were designed for server-side programming,
    and at the lowest level, they are implemented as an extension to the HTTP protocol.
    Cookie data is automatically transmitted between the web browser and web server,
    so server-side scripts can read and write cookie values that are stored on the
    client. This section demonstrates how client-side scripts can also manipulate
    cookies using the `cookie` property of the Document object.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cookie*是由Web浏览器存储的一小部分命名数据，并与特定网页或网站相关联。 Cookie是为服务器端编程设计的，在最低级别上，它们是作为HTTP协议的扩展实现的。
    Cookie数据会在Web浏览器和Web服务器之间自动传输，因此服务器端脚本可以读取和写入存储在客户端上的Cookie值。 本节演示了客户端脚本如何使用Document对象的`cookie`属性来操作Cookie。'
- en: 'The API for manipulating cookies is an old and cryptic one. There are no methods
    involved: cookies are queried, set, and deleted by reading and writing the `cookie`
    property of the Document object using specially formatted strings. The lifetime
    and scope of each cookie can be individually specified with cookie attributes.
    These attributes are also specified with specially formatted strings set on the
    same `cookie` property.'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 操纵cookie的API是一个古老而神秘的API。没有涉及方法：通过读取和写入Document对象的`cookie`属性，使用特殊格式的字符串来查询、设置和删除cookie。每个cookie的生存期和范围可以通过cookie属性单独指定。这些属性也是通过设置在同一`cookie`属性上的特殊格式的字符串来指定的。
- en: The subsections that follow explain how to query and set cookie values and attributes.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的小节将解释如何查询和设置cookie的值和属性。
- en: Reading cookies
  id: totrans-974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取cookie
- en: When you read the `document.cookie` property, it returns a string that contains
    all the cookies that apply to the current document. The string is a list of name/value
    pairs separated from each other by a semicolon and a space. The cookie value is
    just the value itself and does not include any of the attributes that may be associated
    with that cookie. (We’ll talk about attributes next.) In order to make use of
    the `document.cookie` property, you must typically call the `split()` method to
    break it into individual name/value pairs.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 当你读取`document.cookie`属性时，它会返回一个包含当前文档适用的所有cookie的字符串。该字符串是一个由分号和空格分隔的名称/值对列表。cookie值只是值本身，不包括与该cookie相关的任何属性。（我们将在下面讨论属性。）为了利用`document.cookie`属性，你通常需要调用`split()`方法将其分割成单独的名称/值对。
- en: Once you have extracted the value of a cookie from the `cookie` property, you
    must interpret that value based on whatever format or encoding was used by the
    cookie’s creator. You might, for example, pass the cookie value to `decodeURIComponent()`
    and then to `JSON.parse()`.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从`cookie`属性中提取了cookie的值，你必须根据cookie创建者使用的格式或编码来解释该值。例如，你可以将cookie值传递给`decodeURIComponent()`，然后再传递给`JSON.parse()`。
- en: 'The code that follows defines a `getCookie()` function that parses the `document.cookie`
    property and returns an object whose properties specify the names and values of
    the document’s cookies:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码定义了一个`getCookie()`函数，该函数解析`document.cookie`属性并返回一个对象，该对象的属性指定了文档的cookie的名称和值：
- en: '[PRE136]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Cookie attributes: lifetime and scope'
  id: totrans-979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookie属性：生存期和范围
- en: In addition to a name and a value, each cookie has optional attributes that
    control its lifetime and scope. Before we can describe how to set cookies with
    JavaScript, we need to explain cookie attributes.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 除了名称和值之外，每个cookie还有可选属性来控制其生存期和范围。在我们描述如何使用JavaScript设置cookie之前，我们需要解释cookie属性。
- en: Cookies are transient by default; the values they store last for the duration
    of the web browser session but are lost when the user exits the browser. If you
    want a cookie to last beyond a single browsing session, you must tell the browser
    how long (in seconds) you would like it to retain the cookie by specifying a `max-age`
    attribute. If you specify a lifetime, the browser will store cookies in a file
    and delete them only once they expire.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，cookie是短暂的；它们存储的值在Web浏览器会话期间持续，但当用户退出浏览器时会丢失。如果你希望cookie在单个浏览会话之外持续存在，你必须告诉浏览器你希望它保留cookie的时间（以秒为单位），通过指定`max-age`属性。如果指定了生存期，浏览器将把cookie存储在一个文件中，并在它们过期时才删除。
- en: Cookie visibility is scoped by document origin as `localStorage` and `sessionStorage`
    are, but also by document path. This scope is configurable through cookie attributes
    `path` and `domain`. By default, a cookie is associated with, and accessible to,
    the web page that created it and any other web pages in the same directory or
    any subdirectories of that directory. If the web page *example.com/catalog/index.html*
    creates a cookie, for example, that cookie is also visible to *example.com/catalog/order.html*
    and *example.com/catalog/widgets/index.html*, but it is not visible to *example.com/about.html*.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie的可见性受文档来源的范围限制，就像`localStorage`和`sessionStorage`一样，但还受文档路径的限制。这个范围可以通过cookie属性`path`和`domain`进行配置。默认情况下，一个cookie与创建它的网页以及该目录或该目录的任何子目录中的任何其他网页相关联并可访问。例如，如果网页*example.com/catalog/index.html*创建了一个cookie，那么该cookie也对*example.com/catalog/order.html*和*example.com/catalog/widgets/index.html*可见，但对*example.com/about.html*不可见。
- en: This default visibility behavior is often exactly what you want. Sometimes,
    though, you’ll want to use cookie values throughout a website, regardless of which
    page creates the cookie. For instance, if the user enters their mailing address
    in a form on one page, you may want to save that address to use as the default
    the next time they return to the page and also as the default in an entirely unrelated
    form on another page where they are asked to enter a billing address. To allow
    this usage, you specify a `path` for the cookie. Then, any web page from the same
    web server whose URL begins with the path prefix you specified can share the cookie.
    For example, if a cookie set by *example.com/catalog/widgets/index.html* has its
    path set to “/catalog”, that cookie is also visible to *example.com/catalog/order.html*.
    Or, if the path is set to “/”, the cookie is visible to any page in the *example.com*
    domain, giving the cookie a scope like that of `localStorage`.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的可见性行为通常是你想要的。但有时，你可能希望在整个网站中使用cookie值，无论哪个页面创建了cookie。例如，如果用户在一个页面的表单中输入了他们的邮寄地址，你可能希望保存该地址以便在他们下次返回该页面时作为默认地址，并且在另一个页面的一个完全不相关的表单中也作为默认地址。为了允许这种用法，你需要为cookie指定一个`path`。然后，任何以你指定的路径前缀开头的同一Web服务器的网页都可以共享该cookie。例如，如果由*example.com/catalog/widgets/index.html*设置的cookie的路径设置为“/catalog”，那么该cookie也对*example.com/catalog/order.html*可见。或者，如果路径设置为“/”，则该cookie对*example.com*域中的任何页面都可见，使得该cookie的范围类似于`localStorage`。
- en: By default, cookies are scoped by document origin. Large websites may want cookies
    to be shared across subdomains, however. For example, the server at *order.example.com*
    may need to read cookie values set from *catalog.example.com*. This is where the
    `domain` attribute comes in. If a cookie created by a page on *catalog.example.com*
    sets its `path` attribute to “/” and its `domain` attribute to “.example.com,”
    that cookie is available to all web pages on *catalog.example.com*, *orders.example.com*,
    and any other server in the *example.com* domain. Note that you cannot set the
    domain of a cookie to a domain other than a parent domain of your server.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，cookie由文档来源限定。然而，大型网站可能希望cookie在子域之间共享。例如，*order.example.com*服务器可能需要读取从*catalog.example.com*设置的cookie值。这就是`domain`属性发挥作用的地方。如果由*catalog.example.com*页面创建的cookie将其`path`属性设置为“/”并将其`domain`属性设置为“.example.com”，那么该cookie对*catalog.example.com*、*orders.example.com*和*example.com*域中的所有网页都可用。请注意，您不能将cookie的域设置为服务器的父域之外的域。
- en: The final cookie attribute is a boolean attribute named `secure` that specifies
    how cookie values are transmitted over the network. By default, cookies are insecure,
    which means that they are transmitted over a normal, insecure HTTP connection.
    If a cookie is marked secure, however, it is transmitted only when the browser
    and server are connected via HTTPS or another secure protocol.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个cookie属性是一个名为`secure`的布尔属性，指定cookie值在网络上传输的方式。默认情况下，cookie是不安全的，这意味着它们通过普通的不安全HTTP连接传输。但是，如果标记了安全的cookie，则只有在浏览器和服务器通过HTTPS或其他安全协议连接时才会传输。
- en: Storing cookies
  id: totrans-986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储cookie
- en: 'To associate a transient cookie value with the current document, simply set
    the `cookie` property to a `name=value` string. For example:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 要将瞬态cookie值与当前文档关联起来，只需将`cookie`属性设置为`name=value`字符串。例如：
- en: '[PRE137]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The next time you read the `cookie` property, the name/value pair you stored
    is included in the list of cookies for the document. Cookie values cannot include
    semicolons, commas, or whitespace. For this reason, you may want to use the core
    JavaScript global function `encodeURIComponent()` to encode the value before storing
    it in the cookie. If you do this, you’ll have to use the corresponding `decodeURIComponent()`
    function when you read the cookie value.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 下次读取`cookie`属性时，您存储的名称/值对将包含在文档的cookie列表中。Cookie值不能包含分号、逗号或空格。因此，您可能希望在将其存储在cookie中之前使用核心JavaScript全局函数`encodeURIComponent()`对值进行编码。如果这样做，读取cookie值时必须使用相应的`decodeURIComponent()`函数。
- en: 'A cookie written with a simple name/value pair lasts for the current web-browsing
    session but is lost when the user exits the browser. To create a cookie that can
    last across browser sessions, specify its lifetime (in seconds) with a `max-age`
    attribute. You can do this by setting the `cookie` property to a string of the
    form: `name=value; max-age=seconds`. The following function sets a cookie with
    an optional `max-age` attribute:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的名称/值对编写的cookie在当前的Web浏览会话中持续存在，但当用户退出浏览器时会丢失。要创建一个可以跨浏览器会话持续存在的cookie，请使用`max-age`属性指定其生存期（以秒为单位）。您可以通过将`cookie`属性设置为形式为`name=value;
    max-age=seconds`的字符串来实现。以下函数设置了一个带有可选`max-age`属性的cookie：
- en: '[PRE138]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Similarly, you can set the `path` and `domain` attributes of a cookie by appending
    strings of the form `;path=value` or `;domain=value` to the string that you set
    on the `document.cookie` property. To set the `secure` property, simply append
    `;secure`.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以通过在`document.cookie`属性上附加形式为`;path=value`或`;domain=value`的字符串来设置cookie的`path`和`domain`属性。要设置`secure`属性，只需附加`;secure`。
- en: To change the value of a cookie, set its value again using the same name, path,
    and domain along with the new value. You can change the lifetime of a cookie when
    you change its value by specifying a new `max-age` attribute.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改cookie的值，只需再次使用相同的名称、路径和域以及新值设置其值。通过指定新的`max-age`属性，您可以在更改其值时更改cookie的生存期。
- en: To delete a cookie, set it again using the same name, path, and domain, specifying
    an arbitrary (or empty) value, and a `max-age` attribute of 0.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除cookie，只需再次使用相同的名称、路径和域设置它，指定任意（或空）值，并将`max-age`属性设置为0。
- en: 15.12.3 IndexedDB
  id: totrans-995
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.12.3 IndexedDB
- en: Web application architecture has traditionally featured HTML, CSS, and JavaScript
    on the client and a database on the server. You may find it surprising, therefore,
    to learn that the web platform includes a simple object database with a JavaScript
    API for persistently storing JavaScript objects on the user’s computer and retrieving
    them as needed.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Web应用程序架构在客户端使用HTML、CSS和JavaScript，在服务器上使用数据库。因此，您可能会惊讶地发现，Web平台包括一个简单的对象数据库，具有JavaScript
    API，用于在用户计算机上持久存储JavaScript对象并根据需要检索它们。
- en: 'IndexedDB is an object database, not a relational database, and it is much
    simpler than databases that support SQL queries. It is more powerful, efficient,
    and robust than the key/value storage provided by the `localStorage`, however.
    Like the `localStorage`, IndexedDB databases are scoped to the origin of the containing
    document: two web pages with the same origin can access each other’s data, but
    web pages from different origins cannot.'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB是一个对象数据库，而不是关系数据库，比支持SQL查询的数据库简单得多。然而，它比`localStorage`提供的键/值存储更强大、高效和健壮。与`localStorage`一样，IndexedDB数据库的作用域限定在包含文档的来源：具有相同来源的两个网页可以访问彼此的数据，但来自不同来源的网页则不能。
- en: Each origin can have any number of IndexedDB databases. Each one has a name
    that must be unique within the origin. In the IndexedDB API, a database is simply
    a collection of named *object stores*. As the name implies, an object store stores
    objects. Objects are serialized into the object store using the structured clone
    algorithm (see [“The Structured Clone Algorithm”](#structuredclone)), which means
    that the objects you store can have properties whose values are Maps, Sets, or
    typed arrays. Each object must have a *key* by which it can be sorted and retrieved
    from the store. Keys must be unique—two objects in the same store may not have
    the same key—and they must have a natural ordering so that they can be sorted.
    JavaScript strings, numbers, and Date objects are valid keys. An IndexedDB database
    can automatically generate a unique key for each object you insert into the database.
    Often, though, the objects you insert into an object store will already have a
    property that is suitable for use as a key. In this case, you specify a “key path”
    for that property when you create the object store. Conceptually, a key path is
    a value that tells the database how to extract an object’s key from the object.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 每个源可以拥有任意数量的 IndexedDB 数据库。每个数据库都有一个在源内必须是唯一的名称。在 IndexedDB API 中，数据库只是一组命名的*对象存储*。顾名思义，对象存储存储对象。对象使用结构化克隆算法（参见[“结构化克隆算法”](#structuredclone)）序列化到对象存储中，这意味着您存储的对象可以具有值为
    Maps、Sets 或类型化数组的属性。每个对象必须有一个*键*，通过该键可以对其进行排序并从存储中检索。键必须是唯一的——同一存储中的两个对象不能具有相同的键——并且它们必须具有自然排序，以便对其进行排序。JavaScript
    字符串、数字和日期对象是有效的键。IndexedDB 数据库可以自动生成每个插入到数据库中的对象的唯一键。不过，通常情况下，您插入到对象存储中的对象已经具有适合用作键的属性。在这种情况下，您在创建对象存储时指定该属性的“键路径”。在概念上，键路径是一个值，告诉数据库如何从对象中提取对象的键。
- en: In addition to retrieving objects from an object store by their primary key
    value, you may want to be able to search based on the value of other properties
    in the object. In order to be able to do this, you can define any number of *indexes*
    on the object store. (The ability to index an object store explains the name “IndexedDB.”)
    Each index defines a secondary key for the stored objects. These indexes are not
    generally unique, and multiple objects may match a single key value.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过其主键值从对象存储中检索对象之外，您可能希望能够根据对象中其他属性的值进行搜索。为了能够做到这一点，您可以在对象存储上定义任意数量的*索引*。（对对象存储进行索引的能力解释了“IndexedDB”这个名称。）每个索引为存储的对象定义了一个次要键。这些索引通常不是唯一的，多个对象可能匹配单个键值。
- en: 'IndexedDB provides atomicity guarantees: queries and updates to the database
    are grouped within a *transaction* so that they all succeed together or all fail
    together and never leave the database in an undefined, partially updated state.
    Transactions in IndexedDB are simpler than in many database APIs; we’ll mention
    them again later.'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB 提供原子性保证：对数据库的查询和更新被分组在一个*事务*中，以便它们一起成功或一起失败，并且永远不会使数据库处于未定义的、部分更新的状态。IndexedDB
    中的事务比许多数据库 API 中的事务更简单；我们稍后会再次提到它们。
- en: Conceptually, the IndexedDB API is quite simple. To query or update a database,
    you first open the database you want (specifying it by name). Next, you create
    a transaction object and use that object to look up the desired object store within
    the database, also by name. Finally, you look up an object by calling the `get()`
    method of the object store or store a new object by calling `put()` (or by calling
    `add()`, if you want to avoid overwriting existing objects).
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，IndexedDB API 相当简单。要查询或更新数据库，首先打开您想要的数据库（通过名称指定）。接下来，创建一个事务对象，并使用该对象按名称查找数据库中所需的对象存储。最后，通过调用对象存储的`get()`方法查找对象，或通过调用`put()`（或通过调用`add()`，如果要避免覆盖现有对象）存储新对象。
- en: If you want to look up the objects for a range of keys, you create an IDBRange
    object that specifies the upper and lower bounds of the range and pass it to the
    `getAll()` or `openCursor()` methods of the object store.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查找一系列键的对象，可以创建一个指定范围的 IDBRange 对象，并将其传递给对象存储的`getAll()`或`openCursor()`方法。
- en: If you want to make a query using a secondary key, you look up the named index
    of the object store, then call the `get()`, `getAll()`, or `openCursor()` methods
    of the index object, passing either a single key or an IDBRange object.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用次要键进行查询，可以查找对象存储的命名索引，然后调用索引对象的`get()`、`getAll()`或`openCursor()`方法，传递单个键或
    IDBRange 对象。
- en: This conceptual simplicity of the IndexedDB API is complicated, however, by
    the fact that the API is asynchronous (so that web apps can use it without blocking
    the browser’s main UI thread). IndexedDB was defined before Promises were widely
    supported, so the API is event-based rather than Promise-based, which means that
    it does not work with `async` and `await`.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，IndexedDB API 的概念简单性受到了其异步性的影响（以便 Web 应用程序可以在不阻塞浏览器主 UI 线程的情况下使用它）。IndexedDB
    在 Promises 广泛支持之前就���定义，因此 API 是基于事件而不是基于 Promise 的，这意味着它不支持`async`和`await`。
- en: Creating transactions and looking up object stores and indexes are synchronous
    operations. But opening a database, updating an object store, and querying a store
    or index are all asynchronous operations. These asynchronous methods all immediately
    return a request object. The browser triggers a success or error event on the
    request object when the request succeeds or fails, and you can define handlers
    with the `onsuccess` and `onerror` properties. Inside an `onsuccess` handler,
    the result of the operation is available as the `result` property of the request
    object. Another useful event is the “complete” event dispatched on transaction
    objects when a transaction has completed successfully.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 创建事务、查找对象存储和索引都是同步操作。但打开数据库、更新对象存储和查询存储或索引都是异步操作。这些异步方法都会立即返回一个请求对象。当请求成功或失败时，浏览器会在请求对象上触发成功或错误事件，并且你可以使用
    `onsuccess` 和 `onerror` 属性定义处理程序。在 `onsuccess` 处理程序中，操作的结果可以作为请求对象的 `result` 属性获得。另一个有用的事件是当事务成功完成时在事务对象上分派的“complete”事件。
- en: One convenient feature of this asynchronous API is that it simplifies transaction
    management. The IndexedDB API forces you to create a transaction object in order
    to get the object store on which you can perform queries and updates. In a synchronous
    API, you would expect to explicitly mark the end of the transaction by calling
    a `commit()` method. But with IndexedDB, transactions are automatically committed
    (if you do not explicitly abort them) when all the `onsuccess` event handlers
    have run and there are no more pending asynchronous requests that refer to that
    transaction.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异步 API 的一个便利特性是它简化了事务管理。IndexedDB API 强制你创建一个事务对象，以便获取可以执行查询和更新的对象存储。在同步 API
    中，你期望通过调用 `commit()` 方法显式标记事务的结束。但是在 IndexedDB 中，当所有 `onsuccess` 事件处理程序运行并且没有更多引用该事务的待处理异步请求时，事务会自动提交（如果你没有显式中止它们）。
- en: There is one more event that is important to the IndexedDB API. When you open
    a database for the first time, or when you increment the version number of an
    existing database, IndexedDB fires an “upgradeneeded” event on the request object
    returned by the `indexedDB.open()` call. The job of the event handler for “upgradeneeded”
    events is to define or update the schema for the new database (or the new version
    of the existing database). For IndexedDB databases, this means creating object
    stores and defining indexes on those object stores. And in fact, the only time
    the IndexedDB API allows you to create an object store or an index is in response
    to an “upgradeneeded” event.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: IndexedDB API 中还有一个重要的事件。当你首次打开数据库，或者增加现有数据库的版本号时，IndexedDB 会在由 `indexedDB.open()`
    调用返回的请求对象上触发一个“upgradeneeded”事件。对于“upgradeneeded”事件的事件处理程序的工作是定义或更新新数据库（或现有数据库的新版本）的模式。对于
    IndexedDB 数据库，这意味着创建对象存储并在这些对象存储上定义索引。实际上，IndexedDB API 允许你创建对象存储或索引的唯一时机就是响应“upgradeneeded”事件。
- en: With this high-level overview of IndexedDB in mind, you should now be able to
    understand [Example 15-13](#zipcodeDatabase.js). That example uses IndexedDB to
    create and query a database that maps US postal codes (zip codes) to US cities.
    It demonstrates many, but not all, of the basic features of IndexedDB. [Example 15-13](#zipcodeDatabase.js)
    is long, but well commented.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对 IndexedDB 的高级概述，你现在应该能够理解 [示例 15-13](#zipcodeDatabase.js)。该示例使用 IndexedDB
    创建和查询一个将美国邮政编码（邮政编码）映射到美国城市的数据库。它展示了 IndexedDB 的许多基本特性，但并非全部。[示例 15-13](#zipcodeDatabase.js)
    非常长，但有很好的注释。
- en: Example 15-13\. A IndexedDB database of US postal codes
  id: totrans-1009
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-13。一个美国邮政编码的 IndexedDB 数据库
- en: '[PRE139]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 15.13 Worker Threads and Messaging
  id: totrans-1011
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.13 工作线程和消息传递
- en: 'One of the fundamental features of JavaScript is that it is single-threaded:
    a browser will never run two event handlers at the same time, and it will never
    trigger a timer while an event handler is running, for example. Concurrent updates
    to application state or to the document are simply not possible, and client-side
    programmers do not need to think about, or even understand, concurrent programming.
    A corollary is that client-side JavaScript functions must not run too long; otherwise,
    they will tie up the event loop and the web browser will become unresponsive to
    user input. This is the reason that `fetch()` is an asynchronous function, for
    example.'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个基本特性是它是单线程的：浏览器永远不会同时运行两个事件处理程序，也永远不会在事件处理程序运行时触发计时器，例如。对应用程序状态或文档的并发更新根本不可能，客户端程序员不需要考虑或甚至理解并发编程。一个推论是客户端
    JavaScript 函数不能运行太长时间；否则，它们将占用事件循环，并且 Web 浏览器将对用户输入无响应。这就是例如 `fetch()` 是异步函数的原因。
- en: 'Web browsers very carefully relax the single-thread requirement with the Worker
    class: instances of this class represent threads that run concurrently with the
    main thread and the event loop. Workers live in a self-contained execution environment
    with a completely independent global object and no access to the Window or Document
    objects. Workers can communicate with the main thread only through asynchronous
    message passing. This means that concurrent modifications of the DOM remain impossible,
    but it also means that you can write long-running functions that do not stall
    the event loop and hang the browser. Creating a new worker is not a heavyweight
    operation like opening a new browser window, but workers are not flyweight “fibers”
    either, and it does not make sense to create new workers to perform trivial operations.
    Complex web applications may find it useful to create tens of workers, but it
    is unlikely that an application with hundreds or thousands of workers would be
    practical.'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: Web 浏览器非常谨慎地通过 Worker 类放宽了单线程要求：这个类的实例代表与主线程和事件循环并发运行的线程。工作者生存在一个独立的执行环境中，具有完全独立的全局对象，没有访问
    Window 或 Document 对象的权限。工作者只能通过异步消息传递与主线程通信。这意味着 DOM 的并发修改仍然是不可能的，但也意味着你可以编写不会阻塞事件循环并使浏览器挂起的长时间运行函数。创建一个新的工作者不像打开一个新的浏览器窗口那样消耗资源，但工作者也不是轻量级的“纤程”，创建新的工作者来执行琐碎的操作是没有意义的。复杂的
    Web 应用程序可能会发现创建数十个工作者很有用，但是一个具有数百或数千个工作者的应用程序可能并不实用。
- en: Workers are useful when your application needs to perform computationally intensive
    tasks, such as image processing. Using a worker moves tasks like this off the
    main thread so that the browser does not become unresponsive. And workers also
    offer the possibility of dividing the work among multiple threads. But workers
    are also useful when you have to perform frequent moderately intensive computations.
    Suppose, for example, that you’re implementing a simple in-browser code editor,
    and want to include syntax highlighting. To get the highlighting right, you need
    to parse the code on every keystroke. But if you do that on the main thread, it
    is likely that the parsing code will prevent the event handlers that respond to
    the user’s key strokes from running promptly and the user’s typing experience
    will be sluggish.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序需要执行计算密集型任务时，工作者非常有用，比如图像处理。使用工作者将这样的任务移出主线程，以免浏览器变得无响应。而且工作者还提供了将工作分配给多个线程的可能性。但是当你需要执行频繁的中等强度计算时，工作者也非常有用。例如，假设你正在实现一个简单的浏览器内代码编辑器，并且想要包含语法高亮显示。为了正确高亮显示，你需要在每次按键时解析代码。但如果你在主线程上这样做，很可能解析代码会阻止响应用户按键的事件处理程序及时运行，用户的输入体验将会变得迟缓。
- en: 'As with any threading API, there are two parts to the Worker API. The first
    is the Worker object: this is what a worker looks like from the outside, to the
    thread that creates it. The second is the WorkerGlobalScope: this is the global
    object for a new worker, and it is what a worker thread looks like, on the inside,
    to itself.'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何线程 API 一样，Worker API 有两个部分。第一个是 Worker 对象：这是一个工作者从外部看起来的样子，对于创建它的线程来说。第二个是
    WorkerGlobalScope：这是一个新工作者的全局对象，对于工作者线程来说，它是内部的样子。
- en: The following sections cover Worker and WorkerGlobalScope and also explain the
    message-passing API that allows workers to communicate with the main thread and
    each other. The same communication API is used to exchange messages between a
    document and `<iframe>` elements contained in the document, and this is covered
    in the following sections as well.
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分涵盖了 Worker 和 WorkerGlobalScope，并解释了允许工作者与主线程和彼此通信的消息传递 API。相同的通信 API 也用于在文档和包含在文档中的`<iframe>`元素之间交换消息，这也在以下部分中进行了介绍。
- en: 15.13.1 Worker Objects
  id: totrans-1017
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.13.1 工作者对象
- en: 'To create a new worker, call the `Worker()` constructor, passing a URL that
    specifies the JavaScript code that the worker is to run:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的工作者，调用`Worker()`构造函数，传递一个指定要运行的 JavaScript 代码的 URL：
- en: '[PRE140]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: If you specify a relative URL, it is resolved relative to the URL of the document
    that contains the script that called the `Worker()` constructor. If you specify
    an absolute URL, it must have the same origin (same protocol, host, and port)
    as that containing document.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你指定一个相对 URL，它将相对于包含调用`Worker()`构造函数的脚本的文档的 URL 进行解析。如果你指定一个绝对 URL，它必须与包含文档的原点（相同的协议、主机和端口）相同。
- en: 'Once you have a Worker object, you can send data to it with `postMessage()`.
    The value you pass to `postMessage()` will be copied using the structured clone
    algorithm (see [“The Structured Clone Algorithm”](#structuredclone)), and the
    resulting copy will be delivered to the worker via a message event:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个 Worker 对象，你可以使用`postMessage()`向其发送数据。你传递给`postMessage()`的值将使用结构化克隆算法进行复制（参见[“结构化克隆算法”](#structuredclone)），并且生成的副本将通过消息事件传递给工作者：
- en: '[PRE141]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Here we’re just passing a single string message, but you can also use objects,
    arrays, typed arrays, Maps, Sets, and so on. You can receive messages from a worker
    by listening for “message” events on the Worker object:'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只是传递了一个单个字符串消息，但你也可以使用对象、数组、类型化数组、Map、Set 等等。你可以通过在 Worker 对象上监听“message”事件来接收来自工作者的消息：
- en: '[PRE142]'
  id: totrans-1024
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Like all event targets, Worker objects define the standard `addEventListener()`
    and `removeEventListener()` methods, and you can use these in place of the `onmessage`.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有事件目标一样，Worker 对象定义了标准的`addEventListener()`和`removeEventListener()`方法，你可以在这些方法中使用`onmessage`。
- en: In addition to `postMessage()`, Worker objects have just one other method, `terminate()`,
    which forces a worker thread to stop running.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`postMessage()`之外，Worker 对象只有另一个方法，`terminate()`，它可以强制停止一个工作者线程的运行。
- en: 15.13.2 The Global Object in Workers
  id: totrans-1027
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.13.2 工作者中的全局对象
- en: When you create a new worker with the `Worker()` constructor, you specify the
    URL of a file of JavaScript code. That code is executed in a new, pristine JavaScript
    execution environment, isolated from the script that created the worker. The global
    object for that new execution environment is a WorkerGlobalScope object. A WorkerGlobalScope
    is something more than the core JavaScript global object, but less than a full-blown
    client-side Window object.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `Worker()` 构造函数创建一个新的 worker 时，您需要指定一个 JavaScript 代码文件的 URL。该代码在一个新的、干净的
    JavaScript 执行环境中执行，与创建 worker 的脚本隔离。该新执行环境的全局对象是一个 WorkerGlobalScope 对象。WorkerGlobalScope
    不仅仅是核心 JavaScript 全局对象，但也不是完整的客户端 Window 对象。
- en: 'The WorkerGlobalScope object has a `postMessage()` method and an `onmessage`
    event handler property that are just like those of the Worker object but work
    in the opposite direction: calling `postMessage()` inside a worker generates a
    message event outside the worker, and messages sent from outside the worker are
    turned into events and delivered to the `onmessage` handler. Because the WorkerGlobalScope
    is the global object for a worker, `postMessage()` and `onmessage` look like a
    global function and global variable to worker code.'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: WorkerGlobalScope 对象具有一个 `postMessage()` 方法和一个 `onmessage` 事件处理程序属性，与 Worker
    对象的类似，但工作方向相反：在 worker 内部调用 `postMessage()` 会在 worker 外部生成一个消息事件，而从 worker 外部发送的消息会被转换为事件并传递给
    `onmessage` 处理程序。因为 WorkerGlobalScope 是 worker 的全局对象，对于 worker 代码来说，`postMessage()`
    和 `onmessage` 看起来像是全局函数和全局变量。
- en: If you pass an object as the second argument to the `Worker()` constructor,
    and if that object has a `name` property, then the value of that property becomes
    the value of the `name` property in the worker’s global object. A worker might
    include this name in any messages it prints with `console.warn()` or `console.error()`.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将对象作为 `Worker()` 构造函数的第二个参数传递，并且该对象具有一个 `name` 属性，则该属性的值将成为 worker 全局对象中 `name`
    属性的值。worker 可能会在使用 `console.warn()` 或 `console.error()` 打印的任何消息中包含此名称。
- en: The `close()` function allows a worker to terminate itself, and it is similar
    in effect to the `terminate()` method of a Worker object.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '`close()` 函数允许 worker 终止自身，其效果类似于 Worker 对象的 `terminate()` 方法。'
- en: 'Since WorkerGlobalScope is the global object for workers, it has all of the
    properties of the core JavaScript global object, such as the JSON object, the
    `isNaN()` function, and the `Date()` constructor. In addition, however, WorkerGlobalScope
    also has the following properties of the client-side Window object:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WorkerGlobalScope 是 worker 的全局对象，它具有核心 JavaScript 全局对象的所有属性，例如 JSON 对象、`isNaN()`
    函数和 `Date()` 构造函数。但是，WorkerGlobalScope 还具有客户端 Window 对象的以下属性：
- en: '`self` is a reference to the global object itself. WorkerGlobalScope is not
    a Window object and does not define a `window` property.'
  id: totrans-1033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self` 是全局对象本身的引用。WorkerGlobalScope 不是 Window 对象，也不定义 `window` 属性。'
- en: The timer methods `setTimeout()`, `clearTimeout()`, `setInterval()`, and `clearInterval()`.
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器方法 `setTimeout()`、`clearTimeout()`、`setInterval()` 和 `clearInterval()`。
- en: A `location` property that describes the URL that was passed to the `Worker()`
    constructor. This property refers to a Location object, just as the `location`
    property of a Window does. The Location object has properties `href`, `protocol`,
    `host`, `hostname`, `port`, `pathname`, `search`, and `hash`. In a worker, these
    properties are read-only, however.
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个描述传递给 `Worker()` 构造函数的 URL 的 `location` 属性。该属性引用一个 Location 对象，就像 Window 的
    `location` 属性一样。然而，在 worker 中，这些属性是只读的。
- en: A `navigator` property that refers to an object with properties like those of
    the Navigator object of a window. A worker’s Navigator object has the properties
    `appName`, `appVersion`, `platform`, `userAgent`, and `onLine`.
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `navigator` 属性，指向一个具有类似于窗口 Navigator 对象的属性的对象。worker 的 Navigator 对象具有 `appName`、`appVersion`、`platform`、`userAgent`
    和 `onLine` 属性。
- en: The usual event target methods `addEventListener()` and `removeEventListener()`.
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的事件目标方法 `addEventListener()` 和 `removeEventListener()`。
- en: Finally, the WorkerGlobalScope object includes important client-side JavaScript
    APIs including the Console object, the `fetch()` function, and the IndexedDB API.
    WorkerGlobalScope also includes the `Worker()` constructor, which means that worker
    threads can create their own workers.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，WorkerGlobalScope 对象包括重要的客户端 JavaScript API，包括 Console 对象、`fetch()` 函数和 IndexedDB
    API。WorkerGlobalScope 还包括 `Worker()` 构造函数，这意味着 worker 线程可以创建自己的 workers。
- en: 15.13.3 Importing Code into a Worker
  id: totrans-1039
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.13.3 将代码导入到 Worker 中
- en: 'Workers were defined in web browsers before JavaScript had a module system,
    so workers have a unique system for including additional code. WorkerGlobalScope
    defines `importScripts()` as a global function that all workers have access to:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 没有模块系统之前，Web 浏览器中定义了 workers，因此 workers 具有一个独特的包含额外代码的系统。WorkerGlobalScope
    将 `importScripts()` 定义为所有 workers 都可以访问的全局函数：
- en: '[PRE143]'
  id: totrans-1041
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`importScripts()` takes one or more URL arguments, each of which should refer
    to a file of JavaScript code. Relative URLs are resolved relative to the URL that
    was passed to the `Worker()` constructor (not relative to the containing document).
    `importScripts()` synchronously loads and executes these files one after the other,
    in the order in which they were specified. If loading a script causes a network
    error, or if executing throws an error of any sort, none of the subsequent scripts
    are loaded or executed. A script loaded with `importScripts()` can itself call
    `importScripts()` to load the files it depends on. Note, however, that `importScripts()`
    does not try to keep track of what scripts have already loaded and does nothing
    to prevent dependency cycles.'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '`importScripts()` 接受一个或多个 URL 参数，每个参数应该指向一个 JavaScript 代码文件。相对 URL 是相对于传递给
    `Worker()` 构造函数的 URL 解析的（而不是相对于包含文档）。`importScripts()` 同步加载并依次执行这些文件，按照指定的顺序。如果加载脚本导致网络错误，或者执行引发任何错误，那么后续的脚本都不会加载或执行。使用
    `importScripts()` 加载的脚本本身可以调用 `importScripts()` 来加载其依赖的文件。但请注意，`importScripts()`
    不会尝试跟踪已加载的脚本，并且不会阻止依赖循环。'
- en: '`importScripts()` is a synchronous function: it does not return until all of
    the scripts have loaded and executed. You can start using the scripts you loaded
    as soon as `importScripts()` returns: there is no need for a callback, event handler,
    `then()` method or `await`. Once you have internalized the asynchronous nature
    of client-side JavaScript, it feels strange to go back to simple, synchronous
    programming again. But that is the beauty of threads: you can use a blocking function
    call in a worker without blocking the event loop in the main thread, and without
    blocking the computations being concurrently performed in other workers.'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '`importScripts()` 是一个同步函数：直到所有脚本都加载并执行完毕后才会返回。一旦`importScripts()`返回，你就可以立即开始使用加载的脚本：不需要回调、事件处理程序、`then()`方法或`await`。一旦你内化了客户端
    JavaScript 的异步特性，再回到简单的同步编程会感到奇怪。但这就是线程的美妙之处：你可以在工作线程中使用阻塞函数调用，而不会阻塞主线程中的事件循环，也不会阻塞其他工作线程同时执行的计算。'
- en: 15.13.4 Worker Execution Model
  id: totrans-1044
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.13.4 工作线程执行模型
- en: Worker threads run their code (and all imported scripts or modules) synchronously
    from top to bottom, and then enter an asynchronous phase in which they respond
    to events and timers. If a worker registers a “message” event handler, it will
    never exit as long as there is a possibility that message events will still arrive.
    But if a worker doesn’t listen for messages, it will run until there are no further
    pending tasks (such as `fetch()` promises and timers) and all task-related callbacks
    have been called. Once all registered callbacks have been called, there is no
    way a worker can begin a new task, so it is safe for the thread to exit, which
    it will do automatically. A worker can also explicitly shut itself down by calling
    the global `close()` function. Note that there are no properties or methods on
    the Worker object that specify whether a worker thread is still running or not,
    so workers should not close themselves without somehow coordinating this with
    their parent thread.
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程从上到下同步运行其代码（以及所有导入的脚本或模块），然后进入一个异步阶段，响应事件和定时器。如果工作线程注册了“message”事件处理程序，只要仍有可能到达消息事件，它就永远不会退出。但如果工作线程不监听消息，它将一直运行，直到没有进一步的待处理任务（如`fetch()`承诺和定时器）并且所有与任务相关的回调都已调用。一旦所有注册的回调都被调用，工作线程就无法开始新任务，因此线程可以安全退出，它会自动执行。工作线程还可以通过调用全局的`close()`函数显式关闭自身。请注意，工作线程对象上没有指定工作线程是否仍在运行的属性或方法，因此工作线程不应在没有与父线程协调的情况下关闭自身。
- en: Errors in Workers
  id: totrans-1046
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作线程中的错误
- en: If an exception occurs in a worker and is not caught by any `catch` clause,
    then an “error” event is triggered on the global object of the worker. If this
    event is handled and the handler calls the `preventDefault()` method of the event
    object, the error propagation ends. Otherwise, the “error” event is fired on the
    Worker object. If `preventDefault()` is called there, then propagation ends. Otherwise,
    an error message is printed in the developer console and the onerror handler ([§15.1.7](#onerror))
    of the Window object is invoked.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 如果工作线程中发生异常并且没有被任何`catch`子句捕获，那么将在工作线程的全局对象上触发一个“error”事件。如果处理了此事件并且处理程序调用了事件对象的`preventDefault()`方法，则错误传播结束。否则，“error”事件将在
    Worker 对象上触发。如果在那里调用了`preventDefault()`，则传播结束。否则，将在开发者控制台中打印错误消息，并调用 Window 对象的
    onerror 处理程序（[§15.1.7](#onerror)）。
- en: '[PRE144]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Like windows, workers can register a handler to be invoked when a Promise is
    rejected and there is no `.catch()` function to handle it. Within a worker you
    can detect this by defining a `self.onunhandledrejection` function or by using
    `addEventListener()` to register a global handler for “unhandledrejection” events.
    The event object passed to this handler will have a `promise` property whose value
    is the Promise object that rejected and a `reason` property whose value is what
    would have been passed to a `.catch()` function.
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 与窗口类似，工作线程可以注册一个处理程序，在 Promise 被拒绝且没有`.catch()`函数处理时调用。在工作线程中，你可以通过定义一个`self.onunhandledrejection`函数或使用`addEventListener()`注册一个全局处理程序来检测这种情况。传递给此处理程序的事件对象将具有一个`promise`属性，其值是被拒绝的
    Promise 对象，以及一个`reason`属性，其值是将传递给`.catch()`函数的值。
- en: 15.13.5 postMessage(), MessagePorts, and MessageChannels
  id: totrans-1050
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.13.5 postMessage()、MessagePorts 和 MessageChannels
- en: 'The `postMessage()` method of the Worker object and the global `postMesage()`
    function defined inside a worker both work by invoking the `postMessage()` methods
    of a pair of MessagePort objects that are automatically created along with the
    worker. Client-side JavaScript can’t directly access these automatically created
    MessagePort objects, but it can create new pairs of connected ports with the `MessageChannel()`
    constructor:'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: Worker 对象的`postMessage()`方法和工作线程内部定义的全局`postMesage()`函数都通过调用一对自动与工作线程一起创建的 MessagePort
    对象的`postMessage()`方法来工作。客户端 JavaScript 无法直接访问这些自动创建的 MessagePort 对象，但可以使用`MessageChannel()`构造函数创建新的连接端口对：
- en: '[PRE145]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: A MessageChannel is an object with `port1` and `port2` properties that refer
    to a pair of connected MessagePort objects. A MessagePort is an object with a
    `postMessage()` method and an `onmessage` event handler property. When `postMessage()`
    is called on one port of a connected pair, a “message” event is fired on the other
    port in the pair. You can receive these “message” events by setting the `onmessage`
    property or by using `addEventListener()` to register a listener for “message”
    events.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: MessageChannel 是一个具有`port1`和`port2`属性的对象，这些属性指向一对连接的 MessagePort 对象。MessagePort
    是一个具有`postMessage()`方法和`onmessage`事件处理程序属性的对象。当在连接的一对端口上调用`postMessage()`时，另一端口将触发“message”事件。您可以通过设置`onmessage`属性或使用`addEventListener()`注册“message”事件的监听器来接收这些“message”事件。
- en: Messages sent to a port are queued until the `onmessage` property is defined
    or until the `start()` method is called on the port. This prevents messages sent
    by one end of the channel from being missed by the other end. If you use `addEventListener()`
    with a MessagePort, don’t forget to call `start()` or you may never see a message
    delivered.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到端口的消息将排队，直到定义了 `onmessage` 属性或直到在端口上调用了 `start()` 方法。这可以防止一个通道的一端发送的消息被另一端错过。如果您在
    MessagePort 上使用 `addEventListener()`，不要忘记调用 `start()`，否则您可能永远看不到消息被传递。
- en: 'All the `postMessage()` calls we’ve seen so far have taken a single message
    argument. But the method also accepts an optional second argument. This second
    argument is an array of items that are to be transferred to the other end of the
    channel instead of having a copy sent across the channel. Values that can be transferred
    instead of copied are MessagePorts and ArrayBuffers. (Some browsers also implement
    other transferable types, such as ImageBitmap and OffscreenCanvas. These are not
    universally supported, however, and are not covered in this book.) If the first
    argument to `postMessage()` includes a MessagePort (nested anywhere within the
    message object), then that MessagePort must also appear in the second argument.
    If you do this, then the MessagePort will become available to the other end of
    the channel and will immediately become nonfunctional on your end. Suppose you
    have created a worker and want to have two channels for communicating with it:
    one channel for ordinary data exchange and one channel for high-priority messages.
    In the main thread, you might create a MessageChannel, then call `postMessage()`
    on the worker to pass one of the MessagePorts to it:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有 `postMessage()` 调用都接受一个单一的消息参数。但该方法还接受一个可选的第二个参数。这个第二个参数是一个要传输到通道另一端的项目数组，而不是在通道上发送一个副本。可以传输而不是复制的值包括
    MessagePorts 和 ArrayBuffers。 （一些浏览器还实现了其他可传输类型，如 ImageBitmap 和 OffscreenCanvas。然而，并非所有浏览器都支持，本书不涵盖这些内容。）如果
    `postMessage()` 的第一个参数包含一个 MessagePort（在消息对象的任何地方嵌套），那么该 MessagePort 也必须出现在第二个参数中。如果这样做，那么
    MessagePort 将在通道的另一端变为可用，并且在您的端口上立即变为不可用。假设您创建了一个 worker 并希望有两个用于与其通信的通道：一个用于普通数据交换，一个用于高优先级消息。在主线程中，您可以创建一个
    MessageChannel，然后在 worker 上调用 `postMessage()` 以将其中一个 MessagePorts 传递给它：
- en: '[PRE146]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: MessageChannels are also useful if you create two workers and want to allow
    them to communicate directly with each other rather than requiring code on the
    main thread to relay messages between them.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建了两个 worker 并希望它们直接进行通信而不需要主线程上的代码来中继消息，则 MessageChannels 也非常有用。
- en: The other use of the second argument to `postMessage()` is to transfer ArrayBuffers
    between workers without having to copy them. This is an important performance
    enhancement for large ArrayBuffers like those used to hold image data. When an
    ArrayBuffer is transferred over a MessagePort, the ArrayBuffer becomes unusable
    in the original thread so that there is no possibility of concurrent access to
    its contents. If the first argument to `postMessage()` includes an ArrayBuffer,
    or any value (such as a typed array) that has an ArrayBuffer, then that buffer
    may appear as an array element in the second `postMessage()` argument. If it does
    appear, then it will be transferred without copying. If not, then the ArrayBuffer
    will be copied rather than transferred. [Example 15-14](#mandelbrotWorker.js)
    will demonstrate the use of this transfer technique with ArrayBuffers.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '`postMessage()` 的第二个参数的另一个用途是在 worker 之间传递 ArrayBuffers 而无需复制它们。对于像保存图像数据的大型
    ArrayBuffers 这样的情况，这是一个重要的性能增强。当一个 ArrayBuffer 被传输到一个 MessagePort 上时，该 ArrayBuffer
    在原始线程中变得不可用，因此不可能同时访问其内容。如果 `postMessage()` 的第一个参数包含一个 ArrayBuffer，或者包含一个具有 ArrayBuffer
    的任何值（例如一个 typed array），那么该缓冲区可能会出现在第二个 `postMessage()` 参数中作为一个数组元素。如果出现了，那么它将被传输而不是复制。如果没有出现，那么该
    ArrayBuffer 将被复制而不是传输。[示例 15-14](#mandelbrotWorker.js) 将演示如何使用这种传输技术与 ArrayBuffers。'
- en: 15.13.6 Cross-Origin Messaging with postMessage()
  id: totrans-1059
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.13.6 使用 postMessage() 进行跨源消息传递
- en: There is another use case for the `postMessage()` method in client-side JavaScript.
    It involves windows instead of workers, but there are enough similarities between
    the two cases that we will describe the `postMessage()` method of the Window object
    here.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端 JavaScript 中，`postMessage()` 方法还有另一个用例。它涉及窗口而不是 worker，但两种情况之间有足够的相似之处，我们将在这里描述
    Window 对象的 `postMessage()` 方法。
- en: When a document contains an `<iframe>` element, that element acts as an embedded
    but independent window. The Element object that represents the `<iframe>` has
    a `contentWindow` property that is the Window object for the embedded document.
    And for scripts running within that nested iframe, the `window.parent` property
    refers to the containing Window object. When two windows display documents with
    the same origin, then scripts in each of those windows have access to the contents
    of the other window. But when the documents have different origins, the browser’s
    same-origin policy prevents JavaScript in one window from accessing the content
    of another window.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档包含一个 `<iframe>` 元素时，该元素充当一个嵌入但独立的窗口。代表 `<iframe>` 的 Element 对象具有一个 `contentWindow`
    属性，该属性是嵌入文档的 Window 对象。对于在嵌套 iframe 中运行的脚本，`window.parent` 属性指的是包含的 Window 对象。当两个窗口显示具有相同源的文档时，那么每个窗口中的脚本都可以访问另一个窗口的内容。但是当文档具有不同的源时，浏览器的同源策略会阻止一个窗口中的
    JavaScript 访问另一个窗口的内容。
- en: For workers, `postMessage()` provides a safe way for two independent threads
    to communicate without sharing memory. For windows, `postMessage()` provides a
    controlled way for two independent origins to safely exchange messages. Even if
    the same-origin policy prevents your script from seeing the content of another
    window, you can still call `postMessage()` on that window, and doing so will cause
    a “message” event to be triggered on that window, where it can be seen by the
    event handlers in that window’s scripts.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 worker，`postMessage()`提供了两个独立线程之间进行通信而不共享内存的安全方式。对于窗口，`postMessage()`提供了两个独立来源之间安全交换消息的受控方式。即使同源策略阻止你的脚本查看另一个窗口的内容，你仍然可以在该窗口上调用`postMessage()`，这将导致该窗口上触发“message”事件，可以被该窗口脚本中的事件处理程序看到。
- en: The `postMessage()` method of a Window is a little different than the `postMessage()`
    method of a Worker, however. The first argument is still an arbitrary message
    that will be copied by the structured clone algorithm. But the optional second
    argument listing objects to be transferred instead of copied becomes an optional
    third argument. The `postMessage()` method of a window takes a string as its required
    second argument. This second argument should be an origin (a protocol, hostname,
    and optional port) that specifies who you expect to be receiving the message.
    If you pass the string “https://good.example.com” as the second argument, but
    the window you are posting the message to actually contains content from “https://malware.example.com,”
    then the message you posted will not be delivered. If you are willing to send
    your message to content from any origin, then you can pass the wildcard “*” as
    the second argument.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Window 的`postMessage()`方法与 Worker 的`postMessage()`方法有些不同。第一个参数仍然是将通过结构化克隆算法复制的任意消息。但是，列出要传输而不是复制的对象的可选第二个参数变成了可选的第三个参数。窗口的`postMessage()`方法将字符串作为其必需的第二个参数。这第二个参数应该是一个指定你期望接收消息的来源（协议、主机名和可选端口）的来源。如果你将字符串“https://good.example.com”作为第二个参数传递，但你要发送消息的窗口实际上包含来自“https://malware.example.com”的内容，那么你发送的消息将不会被传递。如果你愿意将消息发送给任何来源的内容，那么可以将通配符“*”作为第二个参数传递。
- en: JavaScript code running inside a window or `<iframe>` can receive messages posted
    to that window or frame by defining the `onmessage` property of that window or
    by calling `addEventListener()` for “message” events. As with workers, when you
    receive a “message” event for a window, the `data` property of the event object
    is the message that was sent. In addition, however, “message” events delivered
    to windows also define `source` and `origin` properties. The `source` property
    specifies the Window object that sent the event, and you can use `event.source.postMessage()`
    to send a reply. The `origin` property specifies the origin of the content in
    the source window. This is not something the sender of the message can forge,
    and when you receive a “message” event, you will typically want to verify that
    it is from an origin you expect.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口或`<iframe>`中运行的 JavaScript 代码可以通过定义该窗口的`onmessage`属性或调用`addEventListener()`来接收发送到该窗口或帧的消息。与
    worker 一样，当你接收到窗口的“message”事件时，事件对象的`data`属性就是发送的消息。此外，传递给窗口的“message”事件还定义了`source`和`origin`属性。`source`属性指定发送事件的
    Window 对象，你可以使用`event.source.postMessage()`来发送回复。`origin`属性指定源窗口中内容的来源。这不是消息发送者可以伪造的内容，当你接收到“message”事件时，通常会希望验证它来自你期望的来源。
- en: '15.14 Example: The Mandelbrot Set'
  id: totrans-1065
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.14 示例：曼德勃罗特集
- en: This chapter on client-side JavaScript culminates with a long example that demonstrates
    using workers and messaging to parallelize computationally intensive tasks. But
    it is written to be an engaging, real-world web application and also demonstrates
    a number of the other APIs demonstrated in this chapter, including history management;
    use of the ImageData class with a `<canvas>`; and the use of keyboard, pointer,
    and resize events. It also demonstrates important core JavaScript features, including
    generators and a sophisticated use of Promises.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章关于客户端 JavaScript 的内容以一个长篇示例告终，演示了如何使用 worker 和消息传递来并行化计算密集型任务。但它被写成一个引人入胜的、真实的
    Web 应用程序，还演示了本章中展示的其他 API，包括历史管理；使用带有`<canvas>`的 ImageData 类；以及键盘、指针和调整大小事件的使用。它还演示了重要的核心
    JavaScript 功能，包括生成器和对 Promise 的复杂使用。
- en: The example is a program for displaying and exploring the Mandelbrot set, a
    complex fractal that includes beautiful images like the one shown in [Figure 15-16](Images/#mandelbrot.png).
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例是一个用于显示和探索曼德勃罗特集的程序，这是一个包含美丽图像的复杂分形，如[图 15-16](Images/#mandelbrot.png)所示。
- en: '![js7e 1515](Images/js7e_1515.png)'
  id: totrans-1068
  prefs: []
  type: TYPE_IMG
  zh: '![js7e 1515](Images/js7e_1515.png)'
- en: Figure 15-16\. A portion of the Mandelbrot set
  id: totrans-1069
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-16\. 曼德勃罗特集的一部分
- en: 'The Mandelbrot set is defined as the set of points on the complex plane, which,
    when put through a repeated process of complex multiplication and addition, produce
    a value whose magnitude remains bounded. The contours of the set are surprisingly
    complex, and computing which points are members of the set and which are not is
    computationally intensive: to produce a 500×500 image of the Mandelbrot set, you
    must individually compute the membership of each of the 250,000 pixels in your
    image. And to verify that the value associated with each pixel remains bounded,
    you may have to repeat the process of complex multiplication 1,000 times or more.
    (More iterations give more sharply defined boundaries for the set; fewer iterations
    produce fuzzier boundaries.) With up to 250 million steps of complex arithmetic
    required to produce a high-quality image of the Mandelbrot set, you can understand
    why using workers is a valuable technique. [Example 15-14](#mandelbrotWorker.js)
    shows the worker code we will use. This file is relatively compact: it is just
    the raw computational muscle for the larger program. Two things are worth noting
    about it, however:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: Mandelbrot 集合被定义为复平面上的点集，当通过复数乘法和加法的重复过程产生一个值，其大小保持有界时。集合的轮廓非常复杂，计算哪些点是集合的成员，哪些不是，是计算密集型的：要生成一个
    500×500 的 Mandelbrot 集合图像，您必须分别计算图像中的 250,000 个像素中的每一个的成员资格。为了验证与每个像素关联的值保持有界，您可能需要重复进行复数乘法的过程
    1,000 次或更多。 （更多的迭代会产生更清晰定义的集合边界；更少的迭代会产生模糊的边界。）要生成一个高质量的 Mandelbrot 集合图像，需要进行高达
    2.5 亿步的复数运算，您可以理解为什么使用 worker 是一种有价值的技术。[示例 15-14](#mandelbrotWorker.js) 显示了我们将使用的
    worker 代码。这个文件相对紧凑：它只是更大程序的原始计算力量。但是，关于它有两件值得注意的事情：
- en: The worker creates an ImageData object to represent the rectangular grid of
    pixels for which it is computing Mandelbrot set membership. But instead of storing
    actual pixel values in the ImageData, it uses a custom-typed array to treat each
    pixel as a 32-bit integer. It stores the number of iterations required for each
    pixel in this array. If the magnitude of the complex number computed for each
    pixel becomes greater than four, then it is mathematically guaranteed to grow
    without bounds from then on, and we say it has “escaped.” So the value this worker
    returns for each pixel is the number of iterations before the value escaped. We
    tell the worker the maximum number of iterations it should try for each value,
    and pixels that reach this maximum number are considered to be in the set.
  id: totrans-1071
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Worker 创建一个 ImageData 对象来表示它正在计算 Mandelbrot 集合成员资格的像素的矩形网格。但是，它不是在 ImageData
    中存储实际的像素值，而是使用自定义类型的数组将每个像素视为 32 位整数。它在此数组中存储每个像素所需的迭代次数。如果为每个像素计算的复数的大小超过四，则从那时起它在数学上保证会无限增长，我们称之为“逃逸”。因此，该
    worker 为每个像素返回的值是逃逸前的迭代次数。我们告诉 worker 它应该为每个值尝试的最大迭代次数，并且达到此最大次数的像素被视为在集合中。
- en: The worker transfers the ArrayBuffer associated with the ImageData back to the
    main thread so the memory associated with it does not need to be copied.
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Worker 将与 ImageData 关联的 ArrayBuffer 传回主线程，因此不需要复制与之关联的内存。
- en: Example 15-14\. Worker code for computing regions of the Mandelbrot set
  id: totrans-1073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-14\. 计算 Mandelbrot 集合区域的 Worker 代码
- en: '[PRE147]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The Mandelbrot set viewer application that uses that worker code is shown in
    [Example 15-15](#mandelbrot.js). Now that you have nearly reached the end of this
    chapter, this long example is something of a capstone experience that brings together
    a number of important core and client-side JavaScript features and APIs. The code
    is thoroughly commented, and I encourage you to read it carefully.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该 worker 代码的 Mandelbrot 集合查看器应用程序显示在 [示例 15-15](#mandelbrot.js) 中。现在您几乎已经到达本章的末尾，这个长示例是一个汇总体验，汇集了许多重要的核心和客户端
    JavaScript 功能和 API。代码有详细的注释，我鼓励您仔细阅读。
- en: Example 15-15\. A web application for displaying and exploring the Mandelbrot
    set
  id: totrans-1076
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-15\. 用于显示和探索 Mandelbrot 集合的 Web 应用程序
- en: '[PRE148]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 15.15 Summary and Suggestions for Further Reading
  id: totrans-1078
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.15 总结和进一步阅读建议
- en: 'This long chapter has covered the fundamentals of client-side JavaScript programming:'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 这一长章节涵盖了客户端 JavaScript 编程的基础知识：
- en: How scripts and JavaScript modules are included in web pages and how and when
    they are executed.
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本和 JavaScript 模块如何包含在网页中以及它们何时以及如何执行。
- en: Client-side JavaScript’s asynchronous, event-driven programming model.
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 JavaScript 的异步、事件驱动的编程模型。
- en: The Document Object Model (DOM) that allows JavaScript code to inspect and modify
    the HTML content of the document it is embedded within. This DOM API is the heart
    of all client-side JavaScript programming.
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许 JavaScript 代码检查和修改其嵌入的文档的 HTML 内容的文档对象模型（DOM）。这个 DOM API 是所有客户端 JavaScript
    编程的核心。
- en: How JavaScript code can manipulate the CSS styles that are applied to content
    within the document.
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 代码如何操作应用于文档内容的 CSS 样式。
- en: How JavaScript code can obtain the coordinates of document elements in the browser
    window and within the document itself.
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 代码如何获取浏览器窗口中和文档内部的文档元素的坐标。
- en: How to create reusable UI “Web Components” with JavaScript, HTML, and CSS using
    the Custom Elements and Shadow DOM APIs.
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 JavaScript、HTML 和 CSS 利用自定义元素和影子 DOM API 创建可重用的 UI “Web 组件”。
- en: How to display and dynamically generate graphics with SVG and the HTML `<canvas>`
    element.
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 SVG 和 HTML `<canvas>` 元素显示和动态生成图形。
- en: How to add scripted sound effects (both recorded and synthesized) to your web
    pages.
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向您的网页添加脚本化的声音效果（录制和合成的）。
- en: How JavaScript can make the browser load new pages, go backward and forward
    in the user’s browsing history, and even add new entries to the browsing history.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 如何使浏览器加载新页面，在用户的浏览历史记录中前进和后退，甚至向浏览历史记录添加新条目。
- en: How JavaScript programs can exchange data with web servers using the HTTP and
    WebSocket protocols.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 程序如何使用 HTTP 和 WebSocket 协议与 Web 服务器交换数据。
- en: How JavaScript programs can store data in the user’s browser.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 程序如何在用户的浏览器中存储数据。
- en: How JavaScript programs can use worker threads to achieve a safe form of concurrency.
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 程序如何使用工作线程实现一种安全的并发形式。
- en: This has been the longest chapter of the book, by far. But it cannot come close
    to covering all the APIs available to web browsers. The web platform is sprawling
    and ever-evolving, and my goal for this chapter was to introduce the most important
    core APIs. With the knowledge you have from this book, you are well equipped to
    learn and use new APIs as you need them. But you can’t learn about a new API if
    you don’t know that it exists, so the short sections that follow end the chapter
    with a quick list of web platform features that you might want to investigate
    in the future.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书迄今为止最长的一章。但它远远不能涵盖 Web 浏览器可用的所有 API。Web 平台庞大且不断发展，我这一章的目标是介绍最重要的核心 API。有了本书中的知识，你已经具备了学习和使用新
    API 的能力。但如果你不知道某个新 API 的存在，就无法学习它，因此接下来的简短部分以一个快速列表结束本章，列出了未来可能想要调查的 Web 平台功能。
- en: 15.15.1 HTML and CSS
  id: totrans-1093
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.1 HTML 和 CSS
- en: 'The web is built upon three key technologies: HTML, CSS, and JavaScript, and
    knowledge of JavaScript can take you only so far as a web developer unless you
    also develop your expertise with HTML and CSS. It is important to know how to
    use JavaScript to manipulate HTML elements and CSS styles, but that knowledge
    is is much more useful if you also know which HTML elements and which CSS styles
    to use.'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: Web 是建立在三个关键技术上的：HTML、CSS 和 JavaScript，只有掌握 JavaScript 的知识，作为 Web 开发者，你的能力是有限的，除非你还提升自己在
    HTML 和 CSS 方面的专业知识。重要的是要知道如何使用 JavaScript 操纵 HTML 元素和 CSS 样式，但只有当你知道使用哪些 HTML
    元素和 CSS 样式时，这些知识才更有用。
- en: So before you start exploring more JavaScript APIs, I would encourage you to
    invest some time in mastering the other tools in a web developer’s toolkit. HTML
    form and input elements, for example, have sophisticated behavior that is important
    to understand, and the flexbox and grid layout modes in CSS are incredibly powerful.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始探索更多 JavaScript API 之前，我建议你花一些时间掌握 Web 开发者工具包中的其他工具。例如，HTML 表单和输入元素具有复杂的行为，很重要理解，而
    CSS 中的 flexbox 和 grid 布局模式非常强大。
- en: Two topics worth paying particular attention to in this area are accessibility
    (including ARIA attributes) and internationalization (including support for right-to-left
    writing directions).
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域值得特别关注的两个主题是可访问性（包括 ARIA 属性）和国际化（包括支持从右到左的书写方向）。
- en: 15.15.2 Performance
  id: totrans-1097
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.2 性能
- en: Once you have written a web application and released it to the world, the never-ending
    quest to make it fast begins. It is hard to optimize things that you can’t measure,
    however, so it is worth familiarizing yourself with the Performance APIs. The
    `performance` property of the window object is the main entry point to this API.
    It includes a high-resolution time source `performance.now()`, and methods `performance.mark()`
    and `performance.measure()` for marking critical points in your code and measuring
    the elapsed time between them. Calling these methods creates PerformanceEntry
    objects that you can access with `performance.getEntries()`. Browsers add their
    own PerformanceEntry objects any time the browser loads a new page or fetches
    a file over the network, and these automatically created PerformanceEntry objects
    include granular timing details of your application’s network performance. The
    related PerformanceObserver class allows you to specify a function to be invoked
    when new PerformanceEntry objects are created.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你编写了一个 Web 应用并发布到世界上，不断优化使其变得更快的任务就开始了。然而，优化你无法测量的东西是困难的，因此值得熟悉性能 API。window
    对象的`performance`属性是这个 API 的主要入口点。它包括一个高分辨率时间源`performance.now()`，以及用于标记代码中关键点和测量它们之间经过的时间的方法`performance.mark()`和`performance.measure()`。调用这些方法会创建
    PerformanceEntry 对象，你可以通过`performance.getEntries()`访问。浏览器在加载新页面或通过网络获取文件时会添加自己的
    PerformanceEntry 对象，这些自动创建的 PerformanceEntry 对象包含应用程序网络性能的细粒度计时详细信息。相关的 PerformanceObserver
    类允许你指定一个函数，在创建新的 PerformanceEntry 对象时调用。
- en: 15.15.3 Security
  id: totrans-1099
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.3 安全
- en: This chapter introduced the general idea of how to defend against cross-site
    scripting (XSS) security vulnerabilities in your websites, but we did not go into
    much detail. The topic of web security is an important one, and you may want to
    spend some time learning more about it. In addition to XSS, it is worth learning
    about the `Content-Security-Policy` HTTP header and understanding how CSP allows
    you to ask the web browser to restrict the capabilities it grants to JavaScript
    code. Understanding CORS (Cross-Origin Resource Sharing) is also important.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了如何防御网站中的跨站脚本（XSS）安全漏洞的一般思路，但没有详细展开。网络安全是一个重要的话题，你可能想花一些时间了解更多。除了 XSS 外，值得学习的还有`Content-Security-Policy`
    HTTP 头部，了解 CSP 如何让你要求网络浏览器限制它授予 JavaScript 代码的能力。理解跨域资源共享（CORS）也很重要。
- en: 15.15.4 WebAssembly
  id: totrans-1101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.4 WebAssembly
- en: WebAssembly (or “wasm”) is a low-level virtual machine bytecode format that
    is designed to integrate well with JavaScript interpreters in web browsers. There
    are compilers that allow you to compile C, C++, and Rust programs to WebAssembly
    bytecode and to run those programs in web browsers at close to native speed, without
    breaking the browser sandbox or security model. WebAssembly can export functions
    that can be called by JavaScript programs. A typical use case for WebAssembly
    would be to compile the standard C-language zlib compression library so that JavaScript
    code has access to high-speed compression and decompression algorithms. Learn
    more at *[*https://webassembly.org*](https://webassembly.org)*.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly（或“wasm”）是一种低级虚拟机字节码格式，旨在与 Web 浏览器中的 JavaScript 解释器很好地集成。有编译器可以让你将
    C、C++ 和 Rust 程序编译为 WebAssembly 字节码，并在 Web 浏览器中以接近本机速度运行这些程序，而不会破坏浏览器的沙箱或安全模型。WebAssembly
    可以导出函数，供 JavaScript 程序调用。WebAssembly 的一个典型用例是将标准的 C 语言 zlib 压缩库编译，以便 JavaScript
    代码可以访问高速压缩和解压缩算法。了解更多请访问[*https://webassembly.org*](https://webassembly.org)。
- en: 15.15.5 More Document and Window Features
  id: totrans-1103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.5 更多文档和窗口功能
- en: 'The Window and Document objects have a number of features that were not covered
    in this chapter:'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: Window和Document对象具有许多本章未涵盖的功能：
- en: The Window object defines `alert()`, `confirm()`, and `prompt()` methods that
    display simple modal dialogues to the user. These methods block the main thread.
    The `confirm()` method synchronously returns a boolean value, and `prompt()` synchronously
    returns a string of user input. These are not suitable for production use but
    can be useful for simple projects and prototypes.
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Window对象定义了`alert()`、`confirm()`和`prompt()`方法，用于向用户显示简单的模态对话框。这些方法会阻塞主线程。`confirm()`方法同步返回一个布尔值，而`prompt()`同步返回用户输入的字符串。这些方法不适合生产使用，但对于简单项目和原型设计可能会有用。
- en: The `navigator` and `screen` properties of the Window object were mentioned
    in passing at the start of this chapter, but the Navigator and Screen objects
    that they reference have some features that were not described here that you may
    find useful.
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Window对象的`navigator`和`screen`属性在本章开头简要提到过，但它们引用的Navigator和Screen对象具有一些这里未描述的功能，您可能会发现它们有用。
- en: The `requestFullscreen()` method of any Element object requests that that element
    (a `<video>` or `<canvas>` element, for example) be displayed in fullscreen mode.
    The `exitFullscreen()` method of the Document returns to normal display mode.
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何Element对象的`requestFullscreen()`方法请求该元素（例如`<video>`或`<canvas>`元素）以全屏模式显示。Document的`exitFullscreen()`方法返回正常显示模式。
- en: The `requestAnimationFrame()` method of the Window object takes a function as
    its argument and will execute that function when the browser is preparing to render
    the next frame. When you are making visual changes (especially repeated or animated
    ones), wrapping your code within a call to `requestAnimationFrame()` can help
    to ensure that the changes are rendered smoothly and in a way that is optimized
    by the browser.
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requestAnimationFrame()`方法是Window对象的一个方法，它接受一个函数作为参数，并在浏览器准备渲染下一帧时执行该函数。当您进行视觉变化（特别是重复或动画变化）时，将您的代码包装在`requestAnimationFrame()`调用中可以帮助确保变化平滑地呈现，并以浏览器优化的方式呈现。'
- en: If the user selects text within your document, you can obtain details of that
    selection with the Window method `getSelection()` and get the selected text with
    `getSelection().toString()`. In some browsers, `navigator.clipboard` is an object
    with an async API for reading and setting the content of the system clipboard
    to enable copy-and-paste interactions with applications outside of the browser.
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在您的文档中选择文本，您可以使用Window方法`getSelection()`获取该选择的详细信息，并使用`getSelection().toString()`获取所选文本。在某些浏览器中，`navigator.clipboard`是一个具有异步API的对象，用于读取和设置系统剪贴板的内容，以便与浏览器外的应用程序进行复制和粘贴交互。
- en: A little-known feature of web browsers is that HTML elements with a `contenteditable="true"`
    attribute allow their content to be edited. The `document.execCommand()` method
    enables rich-text editing features for editable content.
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web浏览器的一个鲜为人知的功能是具有`contenteditable="true"`属性的HTML元素允许编辑其内容。`document.execCommand()`方法为可编辑内容启用富文本编辑功能。
- en: A MutationObserver allows JavaScript to monitor changes to, or beneath, a specified
    element in the document. Create a MutationObserver with the `MutationObserver()`
    constructor, passing the callback function that should be called when changes
    are made. Then call the `observe()` method of the MutationObserver to specify
    which parts of which element are to be monitored.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MutationObserver允许JavaScript监视文档中指定���素的更改或下方的更改。使用`MutationObserver()`构造函数创建MutationObserver，传递应在进行更改时调用的回调函数。然后调用MutationObserver的`observe()`方法指定要监视的哪些元素的哪些部分。
- en: An IntersectionObserver allows JavaScript to determine which document elements
    are on the screen and which are close to being on the screen. It is particularly
    useful for applications that want to dynamically load content on demand as the
    user scrolls.
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntersectionObserver允许JavaScript确定哪些文档元素在屏幕上，哪些接近屏幕。对于希望根据用户滚动动态加载内容的应用程序，它特别有用。
- en: 15.15.6 Events
  id: totrans-1113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.6 事件
- en: 'The sheer number and diversity of events supported by the web platform can
    be daunting. This chapter has discussed a variety of event types, but here are
    some more that you may find useful:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: Web平台支持的事件数量和多样性令人生畏。本章讨论了各种事件类型，但以下是一些您可能会发现有用的其他事件：
- en: Browsers fire “online” and “offline” events at the Window object when the browser
    gains or loses an internet connection.
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当浏览器获得或失去互联网连接时，浏览器会在Window对象上触发“online”和“offline”事件。
- en: Browsers fire a “visiblitychange” event at the Document object when a document
    becomes visible or invisible (usually because a user has switched tabs). JavaScript
    can check `document.visibilityState` to determine whether its document is currently
    “visible” or “hidden.”
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当文档变得可见或不可见（通常是因为用户切换选项卡）时，浏览器会在Document对象上触发“visiblitychange”事件。JavaScript可以检查`document.visibilityState`以确定其文档当前是“可见”还是“隐藏”。
- en: Browsers support a complicated API to support drag-and-drop UIs and to support
    data exchange with applications outside the browser. This API involves a number
    of events, including “dragstart,” “dragover,” “dragend,” and “drop.” This API
    is tricky to use correctly but useful when you need it. It is an important API
    to know about if you want to enable users to drag files from their desktop into
    your web application.
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器支持复杂的API以支持拖放UI和与浏览器外的应用程序进行数据交换。该API涉及许多事件，包括“dragstart”、“dragover”、“dragend”和“drop”。正确使用此API可能有些棘手，但在需要时非常有用。如果您想要使用户能够从其桌面拖动文件到您的Web应用程序中，则了解此重要API是很重要的。
- en: The Pointer Lock API enables JavaScript to hide the mouse pointer and get raw
    mouse events as relative movement amounts rather than absolute positions on the
    screen. This is typically useful for games. Call `requestPointerLock()` on the
    element you want all mouse events directed to. After you do this, “mousemove”
    events delivered to that element will have `movementX` and `movementY` properties.
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针锁定 API 使 JavaScript 能够隐藏鼠标指针，并获取原始鼠标事件作为相对移动量，而不是屏幕上的绝对位置。这通常对游戏很有用。在您希望所有鼠标事件指向的元素上调用`requestPointerLock()`。这样做后，传递给该元素的“mousemove”事件将具有`movementX`和`movementY`属性。
- en: The Gamepad API adds support for game controllers. Use `navigator.getGamepads()`
    to get connected Gamepad objects, and listen for “gamepadconnected” events on
    the Window object to be notified when a new controller is plugged in. The Gamepad
    object defines an API for querying the current state of the buttons on the controller.
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏手柄 API 添加了对游戏手柄的支持。使用`navigator.getGamepads()`来获取连接的游戏手柄对象，并在 Window 对象上监听“gamepadconnected”事件，以便在插入新控制器时收到通知。游戏手柄对象定义了一个用于查询控制器按钮当前状态的
    API。
- en: 15.15.7 Progressive Web Apps and Service Workers
  id: totrans-1120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.7 渐进式网络应用和服务工作者
- en: 'The term *Progressive Web Apps*, or PWAs, is a buzzword that describes web
    applications that are built using a few key technologies. Careful documentation
    of these key technologies would require a book of its own, and I have not covered
    them in this chapter, but you should be aware of all of these APIs. It is worth
    noting that powerful modern APIs like these are typically designed to work only
    on secure HTTPS connections. Websites that are still using `http://` URLs will
    not be able to take advantage of these:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: '*渐进式网络应用*（Progressive Web Apps，PWAs）是一个流行词，用来描述使用一些关键技术构建的网络应用程序。对这些关键技术进行仔细的文档记录需要一本专门的书，我在本章中没有涵盖它们，但你应该了解所有这些
    API。值得注意的是，像这样强大的现代 API 通常只设计用于安全的 HTTPS 连接。仍在使用`http://`URL 的网站将无法利用这些：'
- en: A ServiceWorker is a kind of worker thread with the ability to intercept, inspect,
    and respond to network requests from the web application that it “services.” When
    a web application registers a service worker, that worker’s code becomes persistent
    in the browser’s local storage, and when the user visits the associated website
    again, the service worker is reactivated. Service workers can cache network responses
    (including files of JavaScript code), which means that web applications that use
    service workers can effectively install themselves onto the user’s computer for
    rapid startup and offline use. The *Service Worker Cookbook* at [*https://serviceworke.rs*](https://serviceworke.rs)
    is a valuable resource for learning about service workers and their related technologies.
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者是一种具有拦截、检查和响应来自其“服务”的网络应用程序的网络请求能力的��作者线程。当一个网络应用程序注册一个服务工作者时，该工作者的代码将持久保存在浏览器的本地存储中，当用户再次访问相关网站时，服务工作者将被重新激活。服务工作者可以缓存网络响应（包括
    JavaScript 代码文件），这意味着使用服务工作者的网络应用程序可以有效地安装到用户的计算机上，以实现快速启动和离线使用。[*Service Worker
    Cookbook*](https://serviceworke.rs) 是一个了解服务工作者及其相关技术的宝贵资源。
- en: The Cache API is designed for use by service workers (but is also available
    to regular JavaScript code outside of workers). It works with the Request and
    Response objects defined by the `fetch()` API and implements a cache of Request/Response
    pairs. The Cache API enables a service worker to cache the scripts and other assets
    of the web app it serves and can also help to enable offline use of the web app
    (which is particularly important for mobile devices).
  id: totrans-1123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存 API 设计用于服务工作者（但也可用于工作者之外的常规 JavaScript 代码）。它与`fetch()`API 定义的 Request 和 Response
    对象一起工作，并实现了 Request/Response 对的缓存。缓存 API 使服务工作者能够缓存其提供的网络应用程序的脚本和其他资产，并且还可以帮助实现网络应用程序的离线使用（这对移动设备尤为重要）。
- en: A Web Manifest is a JSON-formatted file that describes a web application including
    a name, a URL, and links to icons in various sizes. If your web app uses a service
    worker and includes a `<link rel="manifest">` tag that references a `.webmanifest`
    file, then browsers (particularly browsers on mobile devices) may give you the
    option to add an icon for the web app to your desktop or home screen.
  id: totrans-1124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 清单是一个 JSON 格式的文件，描述了一个网络应用程序，包括名称、URL 和各种尺寸的图标链接。如果您的网络应用程序使用服务工作者，并包含一个引用`.webmanifest`文件的`<link
    rel="manifest">`标签，则浏览器（尤其是移动设备上的浏览器）可能会给您添加一个图标的选项，以便将网络应用程序添加到您的桌面或主屏幕上。
- en: The Notifications API allows web apps to display notifications using the native
    OS notification system on both mobile and desktop devices. Notifications can include
    an image and text, and your code can receive an event if the user clicks on the
    notification. Using this API is complicated by the fact that you must first request
    the user’s permission to display notifications.
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知 API 允许网络应用程序在移动设备和桌面设备上使用本机操作系统通知系统显示通知。通知可以包括图像和文本，如果用户点击通知，您的代码可以接收到事件。使用此
    API 的复杂之处在于您必须首先请求用户的权限来显示通知。
- en: The Push API allows web applications that have a service worker (and that have
    the user’s permission) to subscribe to notifications from a server, and to display
    those notifications even when the application itself is not running. Push notifications
    are common on mobile devices, and the Push API brings web apps closer to feature
    parity with native apps on mobile.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送 API 允许具有服务工作者（并且获得用户许可）的网络应用程序订阅来自服务器的通知，并在应用程序本身未运行时显示这些通知。推送通知在移动设备上很常见，推送
    API 使网络应用程序更接近移动设备上本机应用程序的功能。
- en: 15.15.8 Mobile Device APIs
  id: totrans-1127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.8 移动设备 API
- en: There are a number of web APIs that are primarily useful for web apps running
    on mobile devices. (Unfortunately, a number of these APIs only work on Android
    devices and not iOS devices.)
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网络 API 主要适用于在移动设备上运行的网络应用程序。（不幸的是，其中一些 API 仅适用于 Android 设备，而不适用于 iOS 设备。）
- en: The Geolocation API allows JavaScript (with the user’s permission) to determine
    the user’s physical location. It is well supported on desktop and mobile devices,
    including iOS devices. Use `navigator.geolocation.getCurrentPosition()` to request
    the user’s current position and use `navigator.geolocation.watchPosition()` to
    register a callback to be called when the user’s position changes.
  id: totrans-1129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理位置 API 允许 JavaScript（在用户许可的情况下）确定用户的物理位置。它在桌面和移动设备上得到很好的支持，包括 iOS 设备。使用 `navigator.geolocation.getCurrentPosition()`
    请求用户当前位置，并使用 `navigator.geolocation.watchPosition()` 注册一个回调函数，当用户位置发生变化时调用该函数。
- en: The `navigator.vibrate()` method causes a mobile device (but not iOS) to vibrate.
    Often this is only allowed in response to a user gesture, but calling this method
    will allow your app to provide silent feedback that a gesture has been recognized.
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navigator.vibrate()` 方法会使移动设备（但不包括 iOS）震动。通常只允许在响应用户手势时使用，但调用此方法将允许您的应用程序提供无声反馈，表示已识别到手势。'
- en: The ScreenOrientation API enables a web application to query the current orientation
    of a mobile device screen and also to lock themselves to landscape or portrait
    orientation.
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScreenOrientation API 允许 Web 应用程序查询移动设备屏幕的当前方向，并锁定自身为横向或纵向方向。
- en: The “devicemotion” and “deviceorientation” events on the window object report
    accelerometer and magnetometer data for the device, enabling you to determine
    how the device is accelerating and how the user is orienting it in space. (These
    events do work on iOS.)
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口对象上的 “devicemotion” 和 “deviceorientation” 事件报告设备的加速计和磁力计数据，使您能够确定设备如何加速以及用户如何在空间中定位设备。（这些事件在
    iOS 上也有效。）
- en: The Sensor API is not yet widely supported beyond Chrome on Android devices,
    but it enables JavaScript access to the full suite of mobile device sensors, including
    accelerometer, gyroscope, magnetometer, and ambient light sensor. These sensors
    enable JavaScript to determine which direction a user is facing or to detect when
    the user shakes their phone, for example.
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sensor API 在 Chrome on Android 设备之外尚未得到广泛支持，但它使 JavaScript 能够访问完整套移动设备传感器，包括加速计、陀螺仪、磁力计和环境光传感器。这些传感器使
    JavaScript 能够确定用户面向的方向或检测用户何时摇动他们的手机，例如。
- en: 15.15.9 Binary APIs
  id: totrans-1134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.9 二进制 API
- en: Typed arrays, ArrayBuffers, and the DataView class (all covered in [§11.2](ch11.xhtml#typedarrays))
    enable JavaScript to work with binary data. As described earlier in this chapter,
    the `fetch()` API enables JavaScript programs to load binary data over the network.
    Another source of binary data is files from the user’s local filesystem. For security
    reasons, JavaScript can’t just read local files. But if the user selects a file
    for upload (using an `<input type="file>` form element) or uses drag-and-drop
    to drop a file into your web application, then JavaScript can access that file
    as a File object.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: Typed arrays、ArrayBuffers 和 DataView 类（在 [§11.2](ch11.xhtml#typedarrays) 中有介绍）使
    JavaScript 能够处理二进制数据。正如本章前面所述，`fetch()` API 使 JavaScript 程序能够通过网络加载二进制数据。另一个二进制数据的来源是用户本地文件系统中的文件。出于安全原因，JavaScript
    不能直接读取本地文件。但是如果用户选择上传文件（使用 `<input type="file>` 表单元素）或使用拖放将文件拖放到您的 Web 应用程序中，那么
    JavaScript 就可以访问该文件作为一个 File 对象。
- en: File is a subclass of Blob, and as such, it is an opaque representation of a
    chunk of data. You can use a FileReader class to asynchronously get the content
    of a file as an ArrayBuffer or string. (In some browsers, you can skip the FileReader
    and instead use the Promise-based `text()` and `arrayBuffer()` methods defined
    by the Blob class, or the `stream()` method for streaming access to the file contents.)
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: File 是 Blob 的一个子类，因此它是一个数据块的不透明表示。您可以使用 FileReader 类异步地将文件内容获取为 ArrayBuffer
    或字符串。（在某些浏览器中，您可以跳过FileReader，而是使用 Blob 类定义的基于 Promise 的 `text()` 和 `arrayBuffer()`
    方法，或者用于对文件内容进行流式访问的 `stream()` 方法。）
- en: When working with binary data, especially streaming binary data, you may need
    to decode bytes into text or encode text as bytes. The TextEncoder and TextDecoder
    classes help with this task.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理二进制数据，特别是流式二进制数据时，您可能需要将字节解码为文本或将文本编码为字节。TextEncoder 和 TextDecoder 类有助于完成这项任务。
- en: 15.15.10 Media APIs
  id: totrans-1138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.10 媒体 API
- en: The `navigator.mediaDevices.getUserMedia()` function allows JavaScript to request
    access to the user’s microphone and/or video camera. A successful request results
    in a MediaStream object. Video streams can be displayed in a `<video>` tag (by
    setting the `srcObject` property to the stream). Still frames of the video can
    be captured into an offscreen `<canvas>` with the canvas `drawImage()` function
    resulting in a relatively low-resolution photograph. Audio and video streams returned
    by `getUserMedia()` can be recorded and encoded to a Blob with a MediaRecorder
    object.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator.mediaDevices.getUserMedia()` 函数允许 JavaScript 请求访问用户的麦克风和/或摄像头。成功的请求会返回一个
    MediaStream 对象。视频流可以在 `<video>` 标签中显示（通过将 `srcObject` 属性设置为该流）。视频的静止帧可以通过在一个离屏
    `<canvas>` 中使用 canvas 的 `drawImage()` 函数捕获，从而得到一个相对低分辨率的照片。由 `getUserMedia()`
    返回的音频和视频流可以被记录并编码为一个 Blob 对象。'
- en: The more complex WebRTC API enables the transmission and reception of MediaStreams
    over the network, enabling peer-to-peer video conferencing, for example.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的 WebRTC API 允许在网络上传输和接收 MediaStreams，例如实现点对点视频会议。
- en: 15.15.11 Cryptography and Related APIs
  id: totrans-1141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.15.11 加密和相关 API
- en: The `crypto` property of the Window object exposes a `getRandomValues()` method
    for cryptographically secure pseudorandom numbers. Other methods for encryption,
    decryption, key generation, digital signatures, and so on are available through
    `crypto.subtle`. The name of this property is a warning to everyone who uses these
    methods that properly using cryptographic algorithms is difficult and that you
    should not use those methods unless you really know what you are doing. Also,
    the methods of `crypto.subtle` are only available to JavaScript code running within
    documents that were loaded over a secure HTTPS connection.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: Window 对象的 `crypto` 属性公开了一个用于生成密码安全伪随机数的 `getRandomValues()` 方法。通过 `crypto.subtle`
    还可以使用其他加密、解密、密钥生成、数字签名等方法。这个属性的名称是对所有使用这些方法的人的警告，即正确使用加密算法是困难的，除非你真正知道自己在做什么，否则不应该使用这些方法。此外，`crypto.subtle`
    的方法仅对通过安全的 HTTPS 连接加载的文档中运行的 JavaScript 代码可用。
- en: The Credential Management API and the Web Authentication API allow JavaScript
    to generate, store, and retrieve public key (and other types of) credentials and
    enables account creation and login without passwords. The JavaScript API consists
    primarily of the functions `navigator.credentials.create()` and `navigator.credentials.get()`,
    but substantial infrastructure is required on the server side to make these methods
    work. These APIs are not universally supported yet, but have the potential to
    revolutionize the way we log in to websites.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 凭据管理 API 和 Web 认证 API 允许 JavaScript 生成、存储和检索公钥（以及其他类型的）凭据，并实现无需密码的帐户创建和登录。JavaScript
    API 主要由函数 `navigator.credentials.create()` 和 `navigator.credentials.get()` 组成，但在服务器端需要大量基础设施来使这些方法工作。这些
    API 尚未得到普遍支持，但有潜力彻底改变我们登录网站的方式。
- en: The Payment Request API adds browser support for making credit card payments
    on the web. It allows users to store their payment details securely in the browser
    so that they don’t have to type their credit card number each time they make a
    purchase. Web applications that want to request a payment create a PaymentRequest
    object and call its `show()` method to display the request to the user.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 支付请求 API 为网页上的信用卡支付添加了浏览器支持。它允许用户在浏览器中安全存储他们的支付详细信息，这样他们每次购买时就不必输入信用卡号码。想要请求支付的网络应用程序会创建一个
    PaymentRequest 对象，并调用其 `show()` 方法来向用户显示请求。
- en: '^([1](ch15.xhtml#idm46198510985832-marker)) Previous editions of this book
    had an extensive reference section covering the JavaScript standard library and
    web APIs. It was removed in the seventh edition because MDN has made it obsolete:
    today, it is quicker to look something up on MDN than it is to flip through a
    book, and my former colleagues at MDN do a better job at keeping their online
    documentation up to date than this book ever could.'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.xhtml#idm46198510985832-marker)) 本书的早期版本包含了一个广泛的参考部分，涵盖了 JavaScript
    标准库和 Web API。第七版中将其删除，因为 MDN 已经使其过时：今天，在 MDN 上查找信息比翻书更快，而我在 MDN 的前同事比这本书更擅长保持在线文档的更新。
- en: ^([2](ch15.xhtml#idm46198510122904-marker)) Some sources, including the HTML
    specification, make a technical distinction between handlers and listeners, based
    on the way in which they are registered. In this book, we treat the two terms
    as synonyms.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.xhtml#idm46198510122904-marker)) 一些来源，包括 HTML 规范，根据它们的注册方式在处理程序和监听器之间做了技术区分。在本书中，我们将这两个术语视为同义词。
- en: '^([3](ch15.xhtml#idm46198510064168-marker)) If you have used the React framework
    to create client-side user interfaces, this may surprise you. React makes a number
    of minor changes to the client-side event model, and one of them is that in React,
    event handler property names are written in camelCase: `onClick`, `onMouseOver`,
    and so on. When working with the web platform natively, however, the event handler
    properties are written entirely in lowercase.'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.xhtml#idm46198510064168-marker)) 如果你使用 React 框架创建客户端用户界面，这可能会让你感到惊讶。React
    对客户端事件模型进行了一些微小的更改，其中之一是在 React 中，事件处理程序属性名称采用驼峰式写法：`onClick`、`onMouseOver` 等。然而，在原生的
    Web 平台上工作时，事件处理程序属性完全采用小写形式。
- en: ^([4](ch15.xhtml#idm46198505802920-marker)) The custom element specification
    allows subclassing of `<button>` and other specific element classes, but this
    is not supported in Safari and a different syntax is required to use a custom
    element that extends anything other than HTMLElement.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch15.xhtml#idm46198505802920-marker)) 自定义元素规范允许对 `<button>` 和其他特定元素类进行子类化，但
    Safari 不支持这一点，使用扩展除 HTMLElement 之外的自定义元素需要不同的语法。
