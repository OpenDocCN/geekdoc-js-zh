- en: Chapter 6\. Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。对象
- en: Objects are JavaScript’s most fundamental datatype, and you have already seen
    them many times in the chapters that precede this one. Because objects are so
    important to the JavaScript language, it is important that you understand how
    they work in detail, and this chapter provides that detail. It begins with a formal
    overview of objects, then dives into practical sections about creating objects
    and querying, setting, deleting, testing, and enumerating the properties of objects.
    These property-focused sections are followed by sections that explain how to extend,
    serialize, and define important methods on objects. Finally, the chapter concludes
    with a long section about new object literal syntax in ES6 and more recent versions
    of the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是 JavaScript 中最基本的数据类型，您在本章之前的章节中已经多次看到它们。因为对象对于 JavaScript 语言非常重要，所以您需要详细了解它们的工作原理，而本章提供了这些细节。它从对象的正式概述开始，然后深入到关于创��对象和查询、设置、删除、测试和枚举对象属性的实用部分。这些以属性为重点的部分之后是关于如何扩展、序列化和定义对象重要方法的部分。最后，本章以关于
    ES6 和更高版本语言中新对象字面量语法的长篇部分结束。
- en: 6.1 Introduction to Objects
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 对象简介
- en: 'An object is a composite value: it aggregates multiple values (primitive values
    or other objects) and allows you to store and retrieve those values by name. An
    object is an unordered collection of *properties*, each of which has a name and
    a value. Property names are usually strings (although, as we’ll see in [§6.10.3](#symbols-as-property-names),
    property names can also be Symbols), so we can say that objects map strings to
    values. This string-to-value mapping goes by various names—you are probably already
    familiar with the fundamental data structure under the name “hash,” “hashtable,”
    “dictionary,” or “associative array.” An object is more than a simple string-to-value
    map, however. In addition to maintaining its own set of properties, a JavaScript
    object also inherits the properties of another object, known as its “prototype.”
    The methods of an object are typically inherited properties, and this “prototypal
    inheritance” is a key feature of JavaScript.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一个复合值：它聚合了多个值（原始值或其他对象），并允许您通过名称存储和检索这些值。对象是一个无序的*属性*集合，每个属性都有一个名称和一个值。属性名称通常是字符串（尽管，正如我们将在[§6.10.3](#symbols-as-property-names)中看到的，属性名称也可以是符号），因此我们可以说对象将字符串映射到值。这种字符串到值的映射有各种名称——您可能已经熟悉了以“哈希”、“哈希表”、“字典”或“关联数组”命名的基本数据结构。然而，对象不仅仅是一个简单的字符串到值的映射。除了维护自己的一组属性外，JavaScript
    对象还继承另一个对象的属性，称为其“原型”。对象的方法通常是继承的属性，这种“原型继承”是 JavaScript 的一个关键特性。
- en: JavaScript objects are dynamic—properties can usually be added and deleted—but
    they can be used to simulate the static objects and “structs” of statically typed
    languages. They can also be used (by ignoring the value part of the string-to-value
    mapping) to represent sets of strings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象是动态的——属性通常可以添加和删除——但它们可以用来模拟静态类型语言的静态对象和“结构”。它们也可以被用来（通过忽略字符串到值映射的值部分）表示字符串集合。
- en: Any value in JavaScript that is not a string, a number, a Symbol, or `true`,
    `false`, `null`, or `undefined` is an object. And even though strings, numbers,
    and booleans are not objects, they can behave like immutable objects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在 JavaScript 中不是字符串、数字、符号、`true`、`false`、`null` 或 `undefined` 的值都是对象。即使字符串、数字和布尔值不是对象，它们也可以像不可变对象一样行事。
- en: Recall from [§3.8](ch03.xhtml#mutableandimmutable) that objects are *mutable*
    and manipulated by reference rather than by value. If the variable `x` refers
    to an object and the code `let y = x;` is executed, the variable `y` holds a reference
    to the same object, not a copy of that object. Any modifications made to the object
    through the variable `y` are also visible through the variable `x`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从[§3.8](ch03.xhtml#mutableandimmutable)中回想起，对象是*可变*的，通过引用而不是值来操作。如果变量 `x` 引用一个对象，并且执行代码
    `let y = x;`，那么变量 `y` 持有对同一对象的引用，而不是该对象的副本。通过变量 `y` 对对象进行的任何修改也会通过变量 `x` 可见。
- en: The most common things to do with objects are to create them and set, query,
    delete, test, and enumerate their properties. These fundamental operations are
    described in the opening sections of this chapter. The sections after that cover
    more advanced topics.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对象最常见的操作是创建它们并设置、查询、删除、测试和枚举它们的属性。这些基本操作在本章的开头部分进行了描述。之后的部分涵盖了更高级的主题。
- en: A *property* has a name and a value. A property name may be any string, including
    the empty string (or any Symbol), but no object may have two properties with the
    same name. The value may be any JavaScript value, or it may be a getter or setter
    function (or both). We’ll learn about getter and setter functions in [§6.10.6](#gettersandsetters).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*具有名称和值。属性名称可以是任何字符串，包括空字符串（或任何符号），但没有对象可以具有两个具有相同名称的属性。该值可以是任何 JavaScript
    值，或者它可以是一个 getter 或 setter 函数（或两者）。我们将在[§6.10.6](#gettersandsetters)中学习有关 getter
    和 setter 函数的内容。'
- en: It is sometimes important to be able to distinguish between properties defined
    directly on an object and those that are inherited from a prototype object. JavaScript
    uses the term *own property* to refer to non-inherited properties.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时重要的是能够区分直接在对象上定义的属性和从原型对象继承的属性。JavaScript 使用术语*自有属性*来指代非继承的属性。
- en: 'In addition to its name and value, each property has three *property attributes*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了名称和值之外，每个属性还有三个*属性属性*：
- en: The *writable* attribute specifies whether the value of the property can be
    set.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*writable* 属性指定属性的值是否可以被设置。'
- en: The *enumerable* attribute specifies whether the property name is returned by
    a `for/in` loop.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*enumerable* 属性指定属性名称是否由 `for/in` 循环返回。'
- en: The *configurable* attribute specifies whether the property can be deleted and
    whether its attributes can be altered.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*configurable* 属性指定属性是否可以被删除以及其属性是否可以被更改。'
- en: Many of JavaScript’s built-in objects have properties that are read-only, non-enumerable,
    or non-configurable. By default, however, all properties of the objects you create
    are writable, enumerable, and configurable. [§14.1](ch14.xhtml#propertydescriptors)
    explains techniques for specifying non-default property attribute values for your
    objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的许多内置对象具有只读、不可枚举或不可配置的属性。但是，默认情况下，您创建的对象的所有属性都是可写的、可枚举的和可配置的。[§14.1](ch14.xhtml#propertydescriptors)解释了指定对象的非默认属性属性值的技术。
- en: 6.2 Creating Objects
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 创建对象
- en: Objects can be created with object literals, with the `new` keyword, and with
    the `Object.create()` function. The subsections below describe each technique.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象字面量、`new`关键字和`Object.create()`函数可以创建对象。下面的小节描述了每种技术。
- en: 6.2.1 Object Literals
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.1 对象字面量
- en: 'The easiest way to create an object is to include an object literal in your
    JavaScript code. In its simplest form, an *object literal* is a comma-separated
    list of colon-separated name:value pairs, enclosed within curly braces. A property
    name is a JavaScript identifier or a string literal (the empty string is allowed).
    A property value is any JavaScript expression; the value of the expression (it
    may be a primitive value or an object value) becomes the value of the property.
    Here are some examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象的最简单方法是在JavaScript代码中包含一个对象字面量。在其最简单的形式中，*对象字面量*是一个逗号分隔的冒号分隔的名称:值对列表，包含在花括号中。属性名是JavaScript标识符或字符串字面量（允许空字符串）。属性值是任何JavaScript表达式；表达式的值（可以是原始值或对象值）成为属性的值。以下是一些示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A trailing comma following the last property in an object literal is legal,
    and some programming styles encourage the use of these trailing commas so you’re
    less likely to cause a syntax error if you add a new property at the end of the
    object literal at some later time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象字面量中最后一个属性后面加上逗号是合法的，一些编程风格鼓励使用这些尾随逗号，这样如果以后在对象字面量的末尾添加新属性，就不太可能导致语法错误。
- en: An object literal is an expression that creates and initializes a new and distinct
    object each time it is evaluated. The value of each property is evaluated each
    time the literal is evaluated. This means that a single object literal can create
    many new objects if it appears within the body of a loop or in a function that
    is called repeatedly, and that the property values of these objects may differ
    from each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量是一个表达式，每次评估时都会创建和初始化一个新的独立对象。每个属��的值在每次评估字面量时都会被评估。这意味着如果对象字面量出现在循环体内或重复调用的函数中，一个对象字面量可以创建许多新对象，并且这些对象的属性值可能彼此不同。
- en: The object literals shown here use simple syntax that has been legal since the
    earliest versions of JavaScript. Recent versions of the language have introduced
    a number of new object literal features, which are covered in [§6.10](#extended-object-literal-syntax).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的对象字面量使用自JavaScript最早版本以来就合法的简单语法。语言的最新版本引入了许多新的对象字面量特性，这些特性在[§6.10](#extended-object-literal-syntax)中有介绍。
- en: 6.2.2 Creating Objects with new
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.2 使用new创建对象
- en: 'The `new` operator creates and initializes a new object. The `new` keyword
    must be followed by a function invocation. A function used in this way is called
    a *constructor* and serves to initialize a newly created object. JavaScript includes
    constructors for its built-in types. For example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符创建并初始化一个新对象。`new`关键字必须跟随一个函数调用。以这种方式使用的函数称为*构造函数*，用于初始化新创建的对象。JavaScript包括其内置类型的构造函数。例如：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to these built-in constructors, it is common to define your own
    constructor functions to initialize newly created objects. Doing so is covered
    in [Chapter 9](ch09.xhtml#classes).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些内置构造函数，通常会定义自己的构造函数来初始化新创建的对象。这在[第9章](ch09.xhtml#classes)中有介绍。
- en: 6.2.3 Prototypes
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.3 原型
- en: Before we can cover the third object creation technique, we must pause for a
    moment to explain prototypes. Almost every JavaScript object has a second JavaScript
    object associated with it. This second object is known as a *prototype*, and the
    first object inherits properties from the prototype.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论第三种对象创建技术之前，我们必须停顿一下来解释原型。几乎每个JavaScript对象都有一个与之关联的第二个JavaScript对象。这第二个对象称为*原型*，第一个对象从原型继承属性。
- en: 'All objects created by object literals have the same prototype object, and
    we can refer to this prototype object in JavaScript code as `Object.prototype`.
    Objects created using the `new` keyword and a constructor invocation use the value
    of the `prototype` property of the constructor function as their prototype. So
    the object created by `new Object()` inherits from `Object.prototype`, just as
    the object created by `{}` does. Similarly, the object created by `new Array()`
    uses `Array.prototype` as its prototype, and the object created by `new Date()`
    uses `Date.prototype` as its prototype. This can be confusing when first learning
    JavaScript. Remember: almost all objects have a *prototype*, but only a relatively
    small number of objects have a `prototype` property. It is these objects with
    `prototype` properties that define the *prototypes* for all the other objects.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通过对象字面量创建的对象都有相同的原型对象，在JavaScript代码中我们可以将这个原型对象称为`Object.prototype`。使用`new`关键字和构造函数调用创建的对象使用构造函数的`prototype`属性的值作为它们的原型。因此，通过`new
    Object()`创建的对象继承自`Object.prototype`，就像通过`{}`创建的对象一样。类似地，通过`new Array()`创建的对象使用`Array.prototype`作为它们的原型，通过`new
    Date()`创建的对象使用`Date.prototype`作为它们的原型。初学JavaScript时可能会感到困惑。记住：几乎所有对象都有一个*原型*，但只有相对较少的对象有一个`prototype`属性。具有`prototype`属性的这些对象为所有其他对象定义了*原型*。
- en: '`Object.prototype` is one of the rare objects that has no prototype: it does
    not inherit any properties. Other prototype objects are normal objects that do
    have a prototype. Most built-in constructors (and most user-defined constructors)
    have a prototype that inherits from `Object.prototype`. For example, `Date.prototype`
    inherits properties from `Object.prototype`, so a Date object created by `new
    Date()` inherits properties from both `Date.prototype` and `Object.prototype`.
    This linked series of prototype objects is known as a *prototype chain*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype`是少数没有原型的对象之一：它不继承任何属性。其他原型对象是具有原型的普通对象。大多数内置构造函数（以及大多数用户定义的构造函数）具有从`Object.prototype`继承的原型。例如，`Date.prototype`从`Object.prototype`继承属性，因此通过`new
    Date()`创建的Date对象从`Date.prototype`和`Object.prototype`继承属性。这个链接的原型对象系列被称为*原型链*。'
- en: 'An explanation of how property inheritance works is in [§6.3.2](#inheritance).
    [Chapter 9](ch09.xhtml#classes) explains the connection between prototypes and
    constructors in more detail: it shows how to define new “classes” of objects by
    writing a constructor function and setting its `prototype` property to the prototype
    object to be used by the “instances” created with that constructor. And we’ll
    learn how to query (and even change) the prototype of an object in [§14.3](ch14.xhtml#prototypeattr).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如何工作属性继承的解释在[§6.3.2](#inheritance)中。[第9章](ch09.xhtml#classes)更详细地解释了原型和构造函数之间的关系：它展示了如何通过编写构造函数并将其`prototype`属性设置为由该构造函数创建的“实例”使用的原型对象来定义新的对象“类”。我们将学习如何在[§14.3](ch14.xhtml#prototypeattr)中查询（甚至更改）对象的原型。
- en: 6.2.4 Object.create()
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2.4 Object.create()
- en: '`Object.create()` creates a new object, using its first argument as the prototype
    of that object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.create()`创建一个新对象，使用其第一个参数作为该对象的原型：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can pass `null` to create a new object that does not have a prototype,
    but if you do this, the newly created object will not inherit anything, not even
    basic methods like `toString()` (which means it won’t work with the `+` operator
    either):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递`null`来创建一个没有原型的新对象，但如果这样做，新创建的对象将不会继承任何东西，甚至不会继承像`toString()`这样的基本方法（这意味着它也无法与`+`运算符一起使用）：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to create an ordinary empty object (like the object returned by
    `{}` or `new Object()`), pass `Object.prototype`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要创建一个普通的空对象（类似于`{}`或`new Object()`返回的对象），请传递`Object.prototype`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ability to create a new object with an arbitrary prototype is a powerful
    one, and we’ll use `Object.create()` in a number of places throughout this chapter.
    (`Object.create()` also takes an optional second argument that describes the properties
    of the new object. This second argument is an advanced feature covered in [§14.1](ch14.xhtml#propertydescriptors).)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有任意原型的新对象的能力是强大的，我们将在本章的许多地方使用`Object.create()`。（`Object.create()`还接受一个可选的第二个参数，描述新对象的属性。这个第二个参数是一个高级功能，涵盖在[§14.1](ch14.xhtml#propertydescriptors)中。）
- en: One use for `Object.create()` is when you want to guard against unintended (but
    nonmalicious) modification of an object by a library function that you don’t have
    control over. Instead of passing the object directly to the function, you can
    pass an object that inherits from it. If the function reads properties of that
    object, it will see the inherited values. If it sets properties, however, those
    writes will not affect the original object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Object.create()`的一个用途是当您想要防止通过您无法控制的库函数意外（但非恶意）修改对象时。您可以传递一个从中继承的对象而不是直接将对象传递给函数。如果函数读取该对象的属性，它将看到继承的值。但是，如果它设置属性，这些写入将不会影响原始对象。
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To understand why this works, you need to know how properties are queried and
    set in JavaScript. These are the topics of the next section.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这样做有效，您需要了解在JavaScript中如何查询和设置属性。这些是下一节的主题。
- en: 6.3 Querying and Setting Properties
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 查询和设置属性
- en: 'To obtain the value of a property, use the dot (`.`) or square bracket (`[]`)
    operators described in [§4.4](ch04.xhtml#propertyexprs). The lefthand side should
    be an expression whose value is an object. If using the dot operator, the righthand
    side must be a simple identifier that names the property. If using square brackets,
    the value within the brackets must be an expression that evaluates to a string
    that contains the desired property name:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取属性的值，请使用[§4.4](ch04.xhtml#propertyexprs)中描述的点号（`.`）或方括号（`[]`）运算符。左侧应该是一个值为对象的表达式。如果使用点运算符，则右侧必须是一个简单的标识符，用于命名属性。如果使用方括号，则括号内的值必须是一个求值为包含所需属性名称的字符串的表达式：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To create or set a property, use a dot or square brackets as you would to query
    the property, but put them on the lefthand side of an assignment expression:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建或设置属性，请像查询属性一样使用点号或方括号，但将它们放在赋值表达式的左侧：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When using square bracket notation, we’ve said that the expression inside the
    square brackets must evaluate to a string. A more precise statement is that the
    expression must evaluate to a string or a value that can be converted to a string
    or to a Symbol ([§6.10.3](#symbols-as-property-names)). In [Chapter 7](ch07.xhtml#arrays),
    for example, we’ll see that it is common to use numbers inside the square brackets.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用方括号表示法时，我们已经说过方括号内的表达式必须求值为字符串。更精确的说法是，表达式必须求值为字符串或可以转换为字符串或符号的值（[§6.10.3](#symbols-as-property-names)）。例如，在[第7章](ch07.xhtml#arrays)中，我们将看到在方括号内使用数字是常见的。
- en: 6.3.1 Objects As Associative Arrays
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.1 对象作为关联数组
- en: 'As explained in the preceding section, the following two JavaScript expressions
    have the same value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，以下两个JavaScript表达式具有相同的值：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first syntax, using the dot and an identifier, is like the syntax used to
    access a static field of a struct or object in C or Java. The second syntax, using
    square brackets and a string, looks like array access, but to an array indexed
    by strings rather than by numbers. This kind of array is known as an *associative
    array* (or hash or map or dictionary). JavaScript objects are associative arrays,
    and this section explains why that is important.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种语法，使用点和标识符，类似于在C或Java中访问结构体或对象的静态字段的语法。第二种语法，使用方括号和字符串，看起来像数组访问，但是是通过字符串而不是数字索引的数组。这种类型的数组被称为*关联数组*（或哈希或映射或字典）。JavaScript对象就是关联数组，本节解释了为什么这很重要。
- en: 'In C, C++, Java, and similar strongly typed languages, an object can have only
    a fixed number of properties, and the names of these properties must be defined
    in advance. Since JavaScript is a loosely typed language, this rule does not apply:
    a program can create any number of properties in any object. When you use the
    `.` operator to access a property of an object, however, the name of the property
    is expressed as an identifier. Identifiers must be typed literally into your JavaScript
    program; they are not a datatype, so they cannot be manipulated by the program.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在C、C++、Java等强类型语言中，一个对象只能拥有固定数量的属性，并且这些属性的名称必须事先定义。由于JavaScript是一种弱类型语言，这个规则不适用：程序可以在任何对象中创建任意数量的属性。然而，当你使用`.`运算符访问对象的属性时，属性的名称必须表示为标识符。标识符必须直接输入到你的JavaScript程序中；它们不是一种数据类型，因此不能被程序操作。
- en: 'On the other hand, when you access a property of an object with the `[]` array
    notation, the name of the property is expressed as a string. Strings are JavaScript
    datatypes, so they can be manipulated and created while a program is running.
    So, for example, you can write the following code in JavaScript:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你使用`[]`数组表示法访问对象的属性时，属性的名称表示为字符串。字符串是JavaScript数据类型，因此它们可以在程序运行时被操��和创建。因此，例如，你可以在JavaScript中编写以下代码：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code reads and concatenates the `address0`, `address1`, `address2`, and
    `address3` properties of the `customer` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码读取并连接`customer`对象的`address0`、`address1`、`address2`和`address3`属性。
- en: This brief example demonstrates the flexibility of using array notation to access
    properties of an object with string expressions. This code could be rewritten
    using the dot notation, but there are cases in which only the array notation will
    do. Suppose, for example, that you are writing a program that uses network resources
    to compute the current value of the user’s stock market investments. The program
    allows the user to type in the name of each stock they own as well as the number
    of shares of each stock. You might use an object named `portfolio` to hold this
    information. The object has one property for each stock. The name of the property
    is the name of the stock, and the property value is the number of shares of that
    stock. So, for example, if a user holds 50 shares of stock in IBM, the `portfolio.ibm`
    property has the value `50`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的示例展示了使用数组表示法访问对象属性时的灵活性。这段代码可以使用点表示法重写，但有些情况下只有数组表示法才能胜任。例如，假设你正在编写一个程序，该程序使用网络资源计算用户股票市场投资的当前价值。该程序允许用户输入他们拥有的每支股票的名称以及每支股票的股数。你可以使用一个名为`portfolio`的对象来保存这些信息。对象的每个属性都代表一支股票。属性的名称是股票的名称，属性值是该股票的股数。因此，例如，如果用户持有IBM的50股，`portfolio.ibm`属性的值为`50`。
- en: 'Part of this program might be a function for adding a new stock to the portfolio:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的一部分可能是一个用于向投资组合添加新股票的函数：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the user enters stock names at runtime, there is no way that you can know
    the property names ahead of time. Since you can’t know the property names when
    you write the program, there is no way you can use the `.` operator to access
    the properties of the `portfolio` object. You can use the `[]` operator, however,
    because it uses a string value (which is dynamic and can change at runtime) rather
    than an identifier (which is static and must be hardcoded in the program) to name
    the property.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户在运行时输入股票名称，所以你无法提前知道属性名称。因为在编写程序时你无法知道属性名称，所以无法使用`.`运算符访问`portfolio`对象的属性。然而，你可以使用`[]`运算符，因为它使用字符串值（动态的，可以在运行时更改）而不是标识符（静态的，必须在程序中硬编码）来命名属性。
- en: 'In [Chapter 5](ch05.xhtml#statements), we introduced the `for/in` loop (and
    we’ll see it again shortly, in [§6.6](#enumeratingprops)). The power of this JavaScript
    statement becomes clear when you consider its use with associative arrays. Here
    is how you would use it when computing the total value of a portfolio:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.xhtml#statements)中，我们介绍了`for/in`循环（我们很快会再次看到它，在[§6.6](#enumeratingprops)中）。当你考虑它与关联数组一起使用时，这个JavaScript语句的强大之处就显而易见了。下面是计算投资组合总价值时如何使用它的示例：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: JavaScript objects are commonly used as associative arrays as shown here, and
    it is important to understand how this works. In ES6 and later, however, the Map
    class described in [§11.1.2](ch11.xhtml#mapclass) is often a better choice than
    using a plain object.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象通常被用作关联数组，如下所示，了解这是如何工作的很重要。然而，在ES6及以后的版本中，描述在[§11.1.2](ch11.xhtml#mapclass)中的Map类通常比使用普通对象更好。
- en: 6.3.2 Inheritance
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.2 继承
- en: JavaScript objects have a set of “own properties,” and they also inherit a set
    of properties from their prototype object. To understand this, we must consider
    property access in more detail. The examples in this section use the `Object.create()`
    function to create objects with specified prototypes. We’ll see in [Chapter 9](ch09.xhtml#classes),
    however, that every time you create an instance of a class with `new`, you are
    creating an object that inherits properties from a prototype object.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象有一组“自有属性”，它们还从它们的原型对象继承了一组属性。要理解这一点，我们必须更详细地考虑属性访问。本节中的示例使用`Object.create()`函数创建具有指定原型的对象。然而，我们将在[第9章](ch09.xhtml#classes)中看到，每次使用`new`创建类的实例时，都会创建一个从原型对象继承属性的对象。
- en: 'Suppose you query the property `x` in the object `o`. If `o` does not have
    an own property with that name, the prototype object of `o`^([1](ch06.xhtml#idm46198551345848))
    is queried for the property `x`. If the prototype object does not have an own
    property by that name, but has a prototype itself, the query is performed on the
    prototype of the prototype. This continues until the property `x` is found or
    until an object with a `null` prototype is searched. As you can see, the `prototype`
    attribute of an object creates a chain or linked list from which properties are
    inherited:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您查询对象`o`中的属性`x`。如果`o`没有具有该名称的自有属性，则将查询`o`的原型对象^([1](ch06.xhtml#idm46198551345848))的属性`x`。如果原型对象没有具有该名称的自有属性，但具有自己的原型，则将在原型的原型上执行查询。这将继续，直到找到属性`x`或直到搜索具有`null`原型的对象。正如您所看到的，对象的`prototype`属性创建了一个链或链接列表，从中继承属性：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now suppose you assign to the property `x` of the object `o`. If `o` already
    has an own (non-inherited) property named `x`, then the assignment simply changes
    the value of this existing property. Otherwise, the assignment creates a new property
    named `x` on the object `o`. If `o` previously inherited the property `x`, that
    inherited property is now hidden by the newly created own property with the same
    name.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您对对象`o`的属性`x`进行赋值。如果`o`已经具有自己的（非继承的）名为`x`的属性，则赋值将简单地更改此现有属性的值。否则，赋值将在对象`o`上创建一个名为`x`的新属性。如果`o`先前继承了属性`x`，那么新创建的同名自有属性将隐藏该继承的属性。
- en: 'Property assignment examines the prototype chain only to determine whether
    the assignment is allowed. If `o` inherits a read-only property named `x`, for
    example, then the assignment is not allowed. (Details about when a property may
    be set are in [§6.3.3](#propertyaccesserrors).) If the assignment is allowed,
    however, it always creates or sets a property in the original object and never
    modifies objects in the prototype chain. The fact that inheritance occurs when
    querying properties but not when setting them is a key feature of JavaScript because
    it allows us to selectively override inherited properties:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 属性赋值仅检查原型链以确定是否允许赋值。例如，如果`o`继承了一个名为`x`的只读属性，则不允许赋值。（有关何时可以设置属性的详细信息，请参见[§6.3.3](#propertyaccesserrors)。）然而，如果允许赋值，它总是在原始对象中创建或设置属性，而不会修改原型链中的对象。查询属性时发生继承，但在设置属性时不会发生继承是JavaScript的一个关键特性，因为它允许我们有选择地覆盖继承的属性：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There is one exception to the rule that a property assignment either fails or
    creates or sets a property in the original object. If `o` inherits the property
    `x`, and that property is an accessor property with a setter method (see [§6.10.6](#gettersandsetters)),
    then that setter method is called rather than creating a new property `x` in `o`.
    Note, however, that the setter method is called on the object `o`, not on the
    prototype object that defines the property, so if the setter method defines any
    properties, it will do so on `o`, and it will again leave the prototype chain
    unmodified.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外情况，即属性赋值要么失败，要么在原始对象中创建或设置属性。如果`o`继承了属性`x`，并且该属性是一个具有setter方法的访问器属性（参见[§6.10.6](#gettersandsetters)），那么将调用该setter方法，而不是在`o`中创建新属性`x`。然而，请注意，setter方法是在对象`o`上调用的，而不是在定义属性的原型对象上调用的，因此如果setter方法定义了任何属性，它将在`o`上进行，而且它将再次不修改原型链。
- en: 6.3.3 Property Access Errors
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3.3 属性访问错误
- en: Property access expressions do not always return or set a value. This section
    explains the things that can go wrong when you query or set a property.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 属性访问表达式并不总是返回或设置一个值。本节解释了在查询或设置属性时可能出现的问题。
- en: 'It is not an error to query a property that does not exist. If the property
    `x` is not found as an own property or an inherited property of `o`, the property
    access expression `o.x` evaluates to `undefined`. Recall that our book object
    has a “sub-title” property, but not a “subtitle” property:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查询不存在的属性并不是错误的。如果在`o`的自有属性或继承属性中找不到属性`x`，则属性访问表达式`o.x`将求值为`undefined`。请记住，我们的书对象具有“子标题”属性，但没有“subtitle”属性：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It is an error, however, to attempt to query a property of an object that does
    not exist. The `null` and `undefined` values have no properties, and it is an
    error to query properties of these values. Continuing the preceding example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尝试查询不存在的对象的属性是错误的。`null`和`undefined`值没有属性，查询这些值的属性是错误的。继续前面的例子：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Property access expressions will fail if the lefthand side of the `.` is `null`
    or `undefined`. So when writing an expression like `book.author.surname`, you
    should be careful if you are not certain that `book` and `book.author` are actually
    defined. Here are two ways to guard against this kind of problem:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`.`的左侧是`null`或`undefined`，则属性访问表达式将失败。因此，在编写诸如`book.author.surname`的表达式时，如果不确定`book`和`book.author`是否已定义，应谨慎。以下是防止此类问题的两种方法：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To understand why this idiomatic expression works to prevent TypeError exceptions,
    you might want to review the short-circuiting behavior of the `&&` operator in
    [§4.10.1](ch04.xhtml#logicaland).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么这种成语表达式可以防止TypeError异常，您可能需要回顾一下`&&`运算符的短路行为，详情请参见[§4.10.1](ch04.xhtml#logicaland)。
- en: 'As described in [§4.4.1](ch04.xhtml#conditionalpropertyaccess), ES2020 supports
    conditional property access with `?.`, which allows us to rewrite the previous
    assignment expression as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如[§4.4.1](ch04.xhtml#conditionalpropertyaccess)中所述，ES2020支持使用`?.`进行条件属性访问，这使我们可以将先前的赋值表达式重写为：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Attempting to set a property on `null` or `undefined` also causes a TypeError.
    Attempts to set properties on other values do not always succeed, either: some
    properties are read-only and cannot be set, and some objects do not allow the
    addition of new properties. In strict mode ([§5.6.3](ch05.xhtml#strictmode)),
    a TypeError is thrown whenever an attempt to set a property fails. Outside of
    strict mode, these failures are usually silent.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 `null` 或 `undefined` 上设置属性也会导致 TypeError。在其他值上尝试设置属性也不总是成功：某些属性是只读的，无法设置，某些对象不允许添加新属性。在严格模式下（[§5.6.3](ch05.xhtml#strictmode)），每当尝试设置属性失败时都会抛出
    TypeError。在非严格模式下，这些失败通常是静默的。
- en: 'The rules that specify when a property assignment succeeds and when it fails
    are intuitive but difficult to express concisely. An attempt to set a property
    `p` of an object `o` fails in these circumstances:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 指定属性赋值何时成功何时失败的规则是直观的，但难以简洁表达。在以下情况下，尝试设置对象 `o` 的属性 `p` 失败：
- en: '`o` has an own property `p` that is read-only: it is not possible to set read-only
    properties.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o` 有一个自己的只读属性 `p`：无法设置只读属性。'
- en: '`o` has an inherited property `p` that is read-only: it is not possible to
    hide an inherited read-only property with an own property of the same name.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o` 具有一个继承的只读属性 `p`：无法通过具有相同名称的自有属性隐藏继承的只读属性。'
- en: '`o` does not have an own property `p`; `o` does not inherit a property `p`
    with a setter method, and `o`’s *extensible* attribute (see [§14.2](ch14.xhtml#extensibleattr))
    is `false`. Since `p` does not already exist in `o`, and if there is no setter
    method to call, then `p` must be added to `o`. But if `o` is not extensible, then
    no new properties can be defined on it.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o` 没有自己的属性 `p`；`o` 没有继承具有 setter 方法的属性 `p`，且 `o` 的 *可扩展* 属性（见 [§14.2](ch14.xhtml#extensibleattr)）为
    `false`。由于 `o` 中 `p` 不存在，并且没有 setter 方法可调用，因此必须将 `p` 添加到 `o` 中。但如果 `o` 不可扩展，则无法在其上定义新属性。'
- en: 6.4 Deleting Properties
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 删除属性
- en: 'The `delete` operator ([§4.13.4](ch04.xhtml#deleteoperator)) removes a property
    from an object. Its single operand should be a property access expression. Surprisingly,
    `delete` does not operate on the value of the property but on the property itself:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 运算符（[§4.13.4](ch04.xhtml#deleteoperator)）从对象中删除属性。其单个操作数应为属性访问表达式。令人惊讶的是，`delete`
    不是作用于属性的值，而是作用于属性本身：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `delete` operator only deletes own properties, not inherited ones. (To delete
    an inherited property, you must delete it from the prototype object in which it
    is defined. Doing this affects every object that inherits from that prototype.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 运算符仅删除自有属性，而不删除继承的属性。（要删除继承的属性，必须从定义该属性的原型对象中删除它。这会影响从该原型继承的每个对象。）'
- en: 'A `delete` expression evaluates to `true` if the delete succeeded or if the
    delete had no effect (such as deleting a nonexistent property). `delete` also
    evaluates to `true` when used (meaninglessly) with an expression that is not a
    property access expression:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 表达式在删除成功删除或删除无效（例如删除不存在的属性）时求值为 `true`。当与非属性访问表达式一起使用时，`delete` 也会求值为
    `true`（毫无意义地）：'
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`delete` does not remove properties that have a *configurable* attribute of
    `false`. Certain properties of built-in objects are non-configurable, as are properties
    of the global object created by variable declaration and function declaration.
    In strict mode, attempting to delete a non-configurable property causes a TypeError.
    In non-strict mode, `delete` simply evaluates to `false` in this case:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete` 不会删除具有 *可配置* 属性为 `false` 的属性。某些内置对象的属性是不可配置的，变量声明和函数声明创建的全局对象的属性也是如此。在严格模式下，尝试删除不可配置属性会导致
    TypeError。在非严格模式下，此情况下 `delete` 简单地求值为 `false`：'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When deleting configurable properties of the global object in non-strict mode,
    you can omit the reference to the global object and simply follow the `delete`
    operator with the property name:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格模式下删除全局对象的可配置属性时，可以省略对全局对象的引用，只需跟随 `delete` 运算符后面的属性名：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In strict mode, however, `delete` raises a SyntaxError if its operand is an
    unqualified identifier like `x`, and you have to be explicit about the property
    access:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在严格模式下，如果其操作数是像 `x` 这样的未限定标识符，`delete` 会引发 SyntaxError，并且您必须明确指定属性访问：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 6.5 Testing Properties
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.5 测试属性
- en: JavaScript objects can be thought of as sets of properties, and it is often
    useful to be able to test for membership in the set—to check whether an object
    has a property with a given name. You can do this with the `in` operator, with
    the `hasOwnProperty()` and `propertyIsEnumerable()` methods, or simply by querying
    the property. The examples shown here all use strings as property names, but they
    also work with Symbols ([§6.10.3](#symbols-as-property-names)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象可以被视为属性集合，通常有必要能够测试是否属于该集合——检查对象是否具有给定名称的属性。您可以使用 `in` 运算符、`hasOwnProperty()`
    和 `propertyIsEnumerable()` 方法，或者简单地查询属性来实现此目的。这里显示的示例都使用字符串作为属性名称，但它们也适用于符号（[§6.10.3](#symbols-as-property-names)）。
- en: 'The `in` operator expects a property name on its left side and an object on
    its right. It returns `true` if the object has an own property or an inherited
    property by that name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 运算符在其左侧期望一个属性名，在其右侧期望一个对象。如果对象具有该名称的自有属性或继承属性，则返回 `true`：'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `hasOwnProperty()` method of an object tests whether that object has an
    own property with the given name. It returns `false` for inherited properties:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的 `hasOwnProperty()` 方法测试该对象是否具有给定名称的自有属性。对于继承属性，它返回 `false`：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `propertyIsEnumerable()` refines the `hasOwnProperty()` test. It returns
    `true` only if the named property is an own property and its *enumerable* attribute
    is `true`. Certain built-in properties are not enumerable. Properties created
    by normal JavaScript code are enumerable unless you’ve used one of the techniques
    shown in [§14.1](ch14.xhtml#propertydescriptors) to make them non-enumerable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`propertyIsEnumerable()` 优化了 `hasOwnProperty()` 测试。只有在命名属性是自有属性且其*可枚举*属性为 `true`
    时才返回 `true`。某些内置属性是不可枚举的。通过正常的 JavaScript 代码创建的属性是可枚举的，除非你使用了 [§14.1](ch14.xhtml#propertydescriptors)
    中展示的技术之一使它们变为不可枚举。'
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Instead of using the `in` operator, it is often sufficient to simply query
    the property and use `!==` to make sure it is not undefined:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不必使用 `in` 运算符，通常只需查询属性并使用 `!==` 来确保它不是未定义的：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There is one thing the `in` operator can do that the simple property access
    technique shown here cannot do. `in` can distinguish between properties that do
    not exist and properties that exist but have been set to `undefined`. Consider
    this code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 运算符可以做到这里展示的简单属性访问技术无法做到的一件事。`in` 可以区分不存在的属性和已设置为 `undefined` 的属性。考虑以下代码：'
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 6.6 Enumerating Properties
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.6 枚举属性
- en: Instead of testing for the existence of individual properties, we sometimes
    want to iterate through or obtain a list of all the properties of an object. There
    are a few different ways to do this.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不想测试单个属性的存在，而是想遍历或获���对象的所有属性列表。有几种不同的方法可以做到这一点。
- en: 'The `for/in` loop was covered in [§5.4.5](ch05.xhtml#forinloop). It runs the
    body of the loop once for each enumerable property (own or inherited) of the specified
    object, assigning the name of the property to the loop variable. Built-in methods
    that objects inherit are not enumerable, but the properties that your code adds
    to objects are enumerable by default. For example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/in` 循环在 [§5.4.5](ch05.xhtml#forinloop) 中有介绍。它会为指定对象的每个可枚举属性（自有或继承的）执行一次循环体，将属性的名称赋给循环变量。对象继承的内置方法是不可枚举的，但你的代码添加到对象的属性默认是可枚举的。例如：'
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To guard against enumerating inherited properties with `for/in`, you can add
    an explicit check inside the loop body:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止使用 `for/in` 枚举继承属性，你可以在循环体内添加一个显式检查：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As an alternative to using a `for/in` loop, it is often easier to get an array
    of property names for an object and then loop through that array with a `for/of`
    loop. There are four functions you can use to get an array of property names:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用 `for/in` 循环的替代方案，通常更容易获得对象的属性名称数组，然后使用 `for/of` 循环遍历该数组。有四个函数可以用来获取属性名称数组：
- en: '`Object.keys()` returns an array of the names of the enumerable own properties
    of an object. It does not include non-enumerable properties, inherited properties,
    or properties whose name is a Symbol (see [§6.10.3](#symbols-as-property-names)).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.keys()` 返回一个对象的可枚举自有属性名称的数组。它不包括不可枚举属性、继承属性或名称为 Symbol 的属性（参见 [§6.10.3](#symbols-as-property-names)）。'
- en: '`Object.getOwnPropertyNames()` works like `Object.keys()` but returns an array
    of the names of non-enumerable own properties as well, as long as their names
    are strings.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertyNames()` 的工作方式类似于 `Object.keys()`，但会返回一个非枚举自有属性名称的数组，只要它们的名称是字符串。'
- en: '`Object.getOwnPropertySymbols()` returns own properties whose names are Symbols,
    whether or not they are enumerable.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols()` 返回那些名称为 Symbol 的自有属性，无论它们是否可枚举。'
- en: '`Reflect.ownKeys()` returns all own property names, both enumerable and non-enumerable,
    and both string and Symbol. (See [§14.6](ch14.xhtml#reflectapi).)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys()` 返回所有自有属性名称，包括可枚举和不可枚举的，以及字符串和 Symbol。 (参见 [§14.6](ch14.xhtml#reflectapi).)'
- en: There are examples of the use of `Object.keys()` with a `for/of` loop in [§6.7](#extending-objects).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [§6.7](#extending-objects) 中有关于使用 `Object.keys()` 与 `for/of` 循环的示例。
- en: 6.6.1 Property Enumeration Order
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6.1 属性枚举顺序
- en: 'ES6 formally defines the order in which the own properties of an object are
    enumerated. `Object.keys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`,
    `Reflect.ownKeys()`, and related methods such as `JSON.stringify()` all list properties
    in the following order, subject to their own additional constraints about whether
    they list non-enumerable properties or properties whose names are strings or Symbols:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 正式定义了对象自有属性枚举的顺序。`Object.keys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`、`Reflect.ownKeys()`
    和相关方法如 `JSON.stringify()` 都按照以下顺序列出属性，受其自身关于是否列出非枚举属性或属性名称为字符串或 Symbol 的额外约束：
- en: String properties whose names are non-negative integers are listed first, in
    numeric order from smallest to largest. This rule means that arrays and array-like
    objects will have their properties enumerated in order.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称为非负整数的字符串属性首先按数字顺序从小到大列出。这个规则意味着数组和类数组对象的属性将按顺序枚举。
- en: After all properties that look like array indexes are listed, all remaining
    properties with string names are listed (including properties that look like negative
    numbers or floating-point numbers). These properties are listed in the order in
    which they were added to the object. For properties defined in an object literal,
    this order is the same order they appear in the literal.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出所有看起来像数组索引的属性后，所有剩余的具有字符串名称的属性也会被列出（包括看起来像负数或浮点数的属性）。这些属性按照它们添加到对象的顺序列出。对于对象字面量中定义的属性，这个顺序与它们在字面量中出现的顺序相同。
- en: Finally, the properties whose names are Symbol objects are listed in the order
    in which they were added to the object.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，那些名称为 Symbol 对象的属性按照它们添加到对象的顺序列出。
- en: The enumeration order for the `for/in` loop is not as tightly specified as it
    is for these enumeration functions, but implementations typically enumerate own
    properties in the order just described, then travel up the prototype chain enumerating
    properties in the same order for each prototype object. Note, however, that a
    property will not be enumerated if a property by that same name has already been
    enumerated, or even if a non-enumerable property by the same name has already
    been considered.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`for/in` 循环的枚举顺序并没有像这些枚举函数那样严格规定，但通常的实现会按照刚才描述的顺序枚举自有属性，然后沿着原型链向上遍历，对每个原型对象按照相同的顺序枚举属性。然而，请注意，如果同名属性已经被枚举过，或者即使同名的不可枚举属性已经被考虑过，该属性将不会被枚举。'
- en: 6.7 Extending Objects
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.7 扩展对象
- en: 'A common operation in JavaScript programs is needing to copy the properties
    of one object to another object. It is easy to do that with code like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 程序中的一个常见操作是需要将一个对象的属性复制到另一个对象中。可以使用以下代码轻松实现这一操作：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But because this is a common operation, various JavaScript frameworks have defined
    utility functions, often named `extend()`, to perform this copying operation.
    Finally, in ES6, this ability comes to the core JavaScript language in the form
    of `Object.assign()`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于这是一个常见的操作，各种 JavaScript 框架已经定义了实用函数，通常命名为 `extend()`，来执行这种复制操作。最后，在 ES6 中，这种能力以
    `Object.assign()` 的形式进入了核心 JavaScript 语言。
- en: '`Object.assign()` expects two or more objects as its arguments. It modifies
    and returns the first argument, which is the target object, but does not alter
    the second or any subsequent arguments, which are the source objects. For each
    source object, it copies the enumerable own properties of that object (including
    those whose names are Symbols) into the target object. It processes the source
    objects in argument list order so that properties in the first source object override
    properties by the same name in the target object and properties in the second
    source object (if there is one) override properties with the same name in the
    first source object.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()` 期望两个或更多对象作为其参数。它修改并返回第一个参数，即目标对象，但不会改变第二个或任何后续参数，即源对象。对于每个源对象，它将该对象的可枚举自有属性（包括那些名称为
    Symbols 的属性）复制到目标对象中。它按照参数列表顺序处理源对象，因此第一个源对象中的属性将覆盖目标对象中同名的属性，第二个源对象中的属性（如果有的话）将覆盖第一个源对象中同名的属性。'
- en: '`Object.assign()` copies properties with ordinary property get and set operations,
    so if a source object has a getter method or the target object has a setter method,
    they will be invoked during the copy, but they will not themselves be copied.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()` 使用普通的属性获取和设置操作来复制属性，因此如果源对象具有 getter 方法或目标对象具有 setter 方法，则它们将在复制过程中被调用，但它们本身不会被复制。'
- en: 'One reason to assign properties from one object into another is when you have
    an object that defines default values for many properties and you want to copy
    those default properties into another object if a property by that name does not
    already exist in that object. Using `Object.assign()` naively will not do what
    you want:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个对象的属性分配到另一个对象中的一个原因是，当你有一个对象定义了许多属性的默认值，并且希望将这些默认属性复制到另一个对象中，如果该对象中不存在同名属性。简单地使用
    `Object.assign()` 不会达到你想要的效果：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Instead, what you can do is to create a new object, copy the defaults into
    it, and then override those defaults with the properties in `o`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可���创建一个新对象，将默认值复制到其中，然后用 `o` 中的属性覆盖这些默认值：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ll see in [§6.10.4](#object-spread-operator) that you can also express this
    object copy-and-override operation using the `...` spread operator like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [§6.10.4](#object-spread-operator) 中看到，您还可以使用 `...` 展开运算符来表达这种对象复制和覆盖操作，就像这样：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We could also avoid the overhead of the extra object creation and copying by
    writing a version of `Object.assign()` that copies properties only if they are
    missing:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过编写一个只在属性缺失时才复制属性的版本的 `Object.assign()` 来避免额外的对象创建和复制开销：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It is straightforward to write other property manipulation utilities like this
    `merge()` function. A `restrict()` function could delete properties of an object
    if they do not appear in another template object, for example. Or a `subtract()`
    function could remove all of the properties of one object from another object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 编写其他类似这个 `merge()` 函数的属性操作实用程序是很简单的。例如，`restrict()` 函数可以删除对象的属性，如果这些属性在另一个模板对象中不存在。或者
    `subtract()` 函数可以从另一个对象中删除所有属性。
- en: 6.8 Serializing Objects
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.8 序列化对象
- en: 'Object *serialization* is the process of converting an object’s state to a
    string from which it can later be restored. The functions `JSON.stringify()` and
    `JSON.parse()` serialize and restore JavaScript objects. These functions use the
    JSON data interchange format. JSON stands for “JavaScript Object Notation,” and
    its syntax is very similar to that of JavaScript object and array literals:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对象*序列化*是将对象状态转换为一个字符串的过程，以便以后可以恢复该对象。函数 `JSON.stringify()` 和 `JSON.parse()`
    可以序列化和恢复 JavaScript 对象。这些函数使用 JSON 数据交换格式。JSON 代表“JavaScript 对象表示法”，其语法与 JavaScript
    对象和数组文字非常相似：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: JSON syntax is a *subset* of JavaScript syntax, and it cannot represent all
    JavaScript values. Objects, arrays, strings, finite numbers, `true`, `false`,
    and `null` are supported and can be serialized and restored. `NaN`, `Infinity`,
    and `-Infinity` are serialized to `null`. Date objects are serialized to ISO-formatted
    date strings (see the `Date.toJSON()` function), but `JSON.parse()` leaves these
    in string form and does not restore the original Date object. Function, RegExp,
    and Error objects and the `undefined` value cannot be serialized or restored.
    `JSON.stringify()` serializes only the enumerable own properties of an object.
    If a property value cannot be serialized, that property is simply omitted from
    the stringified output. Both `JSON.stringify()` and `JSON.parse()` accept optional
    second arguments that can be used to customize the serialization and/or restoration
    process by specifying a list of properties to be serialized, for example, or by
    converting certain values during the serialization or stringification process.
    Complete documentation for these functions is in [§11.6](ch11.xhtml#jsonapi).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JSON语法是JavaScript语法的*子集*，它不能表示所有JavaScript值。支持并可以序列化和还原的有对象、数组、字符串、有限数字、`true`、`false`和`null`。`NaN`、`Infinity`和`-Infinity`被序列化为`null`。Date对象被序列化为ISO格式的日期字符串（参见`Date.toJSON()`函数），但`JSON.parse()`将它们保留为字符串形式，不会还原原始的Date对象。Function、RegExp和Error对象以及`undefined`值不能被序列化或还原。`JSON.stringify()`只序列化对象的可枚举自有属性。如果属性值无法序列化，则该属性将简单地从字符串化输出中省略。`JSON.stringify()`和`JSON.parse()`都接受可选的第二个参数，用于通过指定要序列化的属性列表来自定义序列化和/或还原过程，例如，在序列化或字符串化过程中转换某些值。这些函数的完整文档在[§11.6](ch11.xhtml#jsonapi)中。
- en: 6.9 Object Methods
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.9 对象方法
- en: As discussed earlier, all JavaScript objects (except those explicitly created
    without a prototype) inherit properties from `Object.prototype`. These inherited
    properties are primarily methods, and because they are universally available,
    they are of particular interest to JavaScript programmers. We’ve already seen
    the `hasOwnProperty()` and `propertyIsEnumerable()` methods, for example. (And
    we’ve also already covered quite a few static functions defined on the `Object`
    constructor, such as `Object.create()` and `Object.keys()`.) This section explains
    a handful of universal object methods that are defined on `Object.prototype`,
    but which are intended to be replaced by other, more specialized implementations.
    In the sections that follow, we show examples of defining these methods on a single
    object. In [Chapter 9](ch09.xhtml#classes), you’ll learn how to define these methods
    more generally for an entire class of objects.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，所有JavaScript对象（除了明确创建时没有原型的对象）都从`Object.prototype`继承属性。这些继承的属性主要是方法，因为它们是普遍可用的，所以它们对JavaScript程序员特别感兴趣。例如，我们已经看到了`hasOwnProperty()`和`propertyIsEnumerable()`方法。（我们也已经涵盖了`Object`构造函数上定义的许多静态函数，比如`Object.create()`和`Object.keys()`。）本节解释了一些定义在`Object.prototype`上的通用对象方法，但是这些方法旨在被其他更专门的实现所取代。在���下来的章节中，我们将展示在单个对象上定义这些方法的示例。在[第9章](ch09.xhtml#classes)中，您将学习如何为整个对象类更普遍地定义这些方法。
- en: 6.9.1 The toString() Method
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9.1 toString() 方法
- en: The `toString()` method takes no arguments; it returns a string that somehow
    represents the value of the object on which it is invoked. JavaScript invokes
    this method of an object whenever it needs to convert the object to a string.
    This occurs, for example, when you use the `+` operator to concatenate a string
    with an object or when you pass an object to a method that expects a string.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString()` 方法不接受任何参数；它返回一个表示调用它的对象的值的字符串。JavaScript在需要将对象转换为字符串时会调用这个方法。例如，当你使用`+`运算符将字符串与对象连接在一起，或者当你将对象传递给期望字符串的方法时，就会发生这种情况。'
- en: 'The default `toString()` method is not very informative (though it is useful
    for determining the class of an object, as we will see in [§14.4.3](ch14.xhtml#tostringtag)).
    For example, the following line of code simply evaluates to the string “[object
    Object]”:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`toString()`方法并不是很有信息量（尽管它对于确定对象的类很有用，正如我们将在[§14.4.3](ch14.xhtml#tostringtag)中看到的）。例如，以下代码行简单地评估为字符串“[object
    Object]”：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Because this default method does not display much useful information, many
    classes define their own versions of `toString()`. For example, when an array
    is converted to a string, you obtain a list of the array elements, themselves
    each converted to a string, and when a function is converted to a string, you
    obtain the source code for the function. You might define your own `toString()`
    method like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个默认方法并不显示太多有用信息，许多类定义了它们自己的`toString()`版本。例如，当数组转换为字符串时，你会得到一个数组元素列表，它们各自被转换为字符串，当函数转换为字符串时，你会得到函数的源代码。你可以像这样定义自己的`toString()`方法：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 6.9.2 The toLocaleString() Method
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9.2 toLocaleString() 方法
- en: 'In addition to the basic `toString()` method, objects all have a `toLocaleString()`.
    The purpose of this method is to return a localized string representation of the
    object. The default `toLocaleString()` method defined by Object doesn’t do any
    localization itself: it simply calls `toString()` and returns that value. The
    Date and Number classes define customized versions of `toLocaleString()` that
    attempt to format numbers, dates, and times according to local conventions. Array
    defines a `toLocaleString()` method that works like `toString()` except that it
    formats array elements by calling their `toLocaleString()` methods instead of
    their `toString()` methods. You might do the same thing with a `point` object
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的`toString()`方法外，所有对象都有一个`toLocaleString()`方法。这个方法的目的是返回对象的本地化字符串表示。Object定义的默认`toLocaleString()`方法不进行任何本地化：它只是调用`toString()`并返回该值。Date和Number类定义了定制版本的`toLocaleString()`，试图根据本地惯例格式化数字、日期和时间。Array定义了一个`toLocaleString()`方法，工作方式类似于`toString()`，只是通过调用它们的`toLocaleString()`方法而不是`toString()`方法来格式化数组元素。你可以像这样处理`point`对象：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The internationalization classes documented in [§11.7](ch11.xhtml#intlapi) can
    be useful when implementing a `toLocaleString()` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `toLocaleString()` 方法时，[§11.7](ch11.xhtml#intlapi) 中记录的国际化类可能会很有用。
- en: 6.9.3 The valueOf() Method
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9.3 valueOf() 方法
- en: 'The `valueOf()` method is much like the `toString()` method, but it is called
    when JavaScript needs to convert an object to some primitive type other than a
    string—typically, a number. JavaScript calls this method automatically if an object
    is used in a context where a primitive value is required. The default `valueOf()`
    method does nothing interesting, but some of the built-in classes define their
    own `valueOf()` method. The Date class defines `valueOf()` to convert dates to
    numbers, and this allows Date objects to be chronologically compared with `<`
    and `>`. You could do something similar with a point object, defining a `valueOf()`
    method that returns the distance from the origin to the point:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`valueOf()` 方法类似于 `toString()` 方法，但当 JavaScript 需要将对象转换为除字符串以外的某种原始类型时（通常是数字），就会调用它。如果对象在需要原始值的上下文中使用，JavaScript
    会自动调用这个方法。默认的 `valueOf()` 方法没有什么有趣的功能，但一些内置类定义了自己的 `valueOf()` 方法。Date 类定义了 `valueOf()`
    方法来将日期转换为数字，这允许使用 `<` 和 `>` 来对日期对象进行比较。你可以通过定义一个 `valueOf()` 方法来实现类似的功能，返回从原点到点的距离：'
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 6.9.4 The toJSON() Method
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9.4 toJSON() 方法
- en: '`Object.prototype` does not actually define a `toJSON()` method, but the `JSON.stringify()`
    method (see [§6.8](#serializingobjects)) looks for a `toJSON()` method on any
    object it is asked to serialize. If this method exists on the object to be serialized,
    it is invoked, and the return value is serialized, instead of the original object.
    The Date class ([§11.4](ch11.xhtml#datesandtimes)) defines a `toJSON()` method
    that returns a serializable string representation of the date. We could do the
    same for our Point object like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.prototype` 实际上并没有定义 `toJSON()` 方法，但 `JSON.stringify()` 方法（参见 [§6.8](#serializingobjects)）会在要序列化的任何对象上查找
    `toJSON()` 方法。如果这个方法存在于要序列化的对象上，它就会被调用，返回值会被序列化，而不是原始对象。Date 类（[§11.4](ch11.xhtml#datesandtimes)）定义了一个
    `toJSON()` 方法，返回日期的可序列化字符串表示。我们可以为我们的 Point 对象做同样的事情：'
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 6.10 Extended Object Literal Syntax
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.10 扩展对象字面量语法
- en: Recent versions of JavaScript have extended the syntax for object literals in
    a number of useful ways. The following subsections explain these extensions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的最新版本在对象字面量的语法上以多种有用的方式进行了扩展。以下小节解释了这些扩展。
- en: 6.10.1 Shorthand Properties
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10.1 简写属性
- en: 'Suppose you have values stored in variables `x` and `y` and want to create
    an object with properties named `x` and `y` that hold those values. With basic
    object literal syntax, you’d end up repeating each identifier twice:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有存储在变量 `x` 和 `y` 中的值，并且想要创建一个具有名为 `x` 和 `y` 的属性的对象，其中包含这些值。使用基本对象字面量语法，你将重复每个标识符两次：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In ES6 and later, you can drop the colon and one copy of the identifier and
    end up with much simpler code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 及更高版本中，你可以省略冒号和一个标识符的副本，从而得到更简洁的代码：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 6.10.2 Computed Property Names
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10.2 计算属性名
- en: 'Sometimes you need to create an object with a specific property, but the name
    of that property is not a compile-time constant that you can type literally in
    your source code. Instead, the property name you need is stored in a variable
    or is the return value of a function that you invoke. You can’t use a basic object
    literal for this kind of property. Instead, you have to create an object and then
    add the desired properties as an extra step:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要创建一个具有特定属性的对象，但该属性的名称不是你可以在源代码中直接输入的编译时常量。相反，你需要的属性名称存储在一个变量中，或者是一个你调用的函数的返回值。你不能使用基本对象字面量来定义这种属性。相反，你必须先创建一个对象，然后作为额外步骤添加所需的属性：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is much simpler to set up an object like this with an ES6 feature known
    as *computed properties* that lets you take the square brackets from the preceding
    code and move them directly into the object literal:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ES6 功能中称为*计算属性*的功能，可以更简单地设置一个对象，直接将前面代码中的方括号移到对象字面量中：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With this new syntax, the square brackets delimit an arbitrary JavaScript expression.
    That expression is evaluated, and the resulting value (converted to a string,
    if necessary) is used as the property name.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的语法，方括号限定了任意的 JavaScript 表达式。该表达式被评估，结果值（如有必要，转换为字符串）被用作属性名。
- en: One situation where you might want to use computed properties is when you have
    a library of JavaScript code that expects to be passed objects with a particular
    set of properties, and the names of those properties are defined as constants
    in that library. If you are writing code to create the objects that will be passed
    to that library, you could hardcode the property names, but you’d risk bugs if
    you type the property name wrong anywhere, and you’d risk version mismatch issues
    if a new version of the library changes the required property names. Instead,
    you might find that it makes your code more robust to use computed property syntax
    with the property name constants defined by the library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个情况下你可能想使用计算属性的地方是当你有一个 JavaScript 代码库，该库期望传递具有特定属性集的对象，并且这些属性的名称在该库中被定义为常量。如果你正在编写代码来创建将传递给该库的对象，你可以硬编码属性名称，但如果在任何地方输入属性名称错误，就会出现错误，如果库的新版本更改了所需的属性名称，就会出现版本不匹配的问题。相反，你可能会发现使用由库定义的属性名常量与计算属性语法使你的代码更加健壮。
- en: 6.10.3 Symbols as Property Names
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10.3 符号作为属性名
- en: 'The computed property syntax enables one other very important object literal
    feature. In ES6 and later, property names can be strings or symbols. If you assign
    a symbol to a variable or constant, then you can use that symbol as a property
    name using the computed property syntax:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性语法还启用了另一个非常重要的对象字面量特性。在 ES6 及更高版本中，属性名称可以是字符串或符号。如果将符号分配给变量或常量，那么可以使用计算属性语法将该符号作为属性名：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As explained in [§3.6](ch03.xhtml#symbols), Symbols are opaque values. You
    can’t do anything with them other than use them as property names. Every Symbol
    is different from every other Symbol, however, which means that Symbols are good
    for creating unique property names. Create a new Symbol by calling the `Symbol()`
    factory function. (Symbols are primitive values, not objects, so `Symbol()` is
    not a constructor function that you invoke with `new`.) The value returned by
    `Symbol()` is not equal to any other Symbol or other value. You can pass a string
    to `Symbol()`, and this string is used when your Symbol is converted to a string.
    But this is a debugging aid only: two Symbols created with the same string argument
    are still different from one another.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如[§3.6](ch03.xhtml#symbols)中所解释的，符号是不透明的值。你不能对它们做任何操作，只能将它们用作属性名称。然而，每个符号都与其他任何符号都不同，这意味着符号非常适合创建唯一的属性名称。通过调用`Symbol()`工厂函数创建一个新符号。（符号是原始值，不是对象，因此`Symbol()`不是一个你使用`new`调用的构造函数。）`Symbol()`返回的值不等于任何其他符号或其他值。你可以向`Symbol()`传递一个字符串，当你的符号���换为字符串时，将使用该字符串。但这仅用于调试：使用相同字符串参数创建的两个符号仍然彼此不同。
- en: The point of Symbols is not security, but to define a safe extension mechanism
    for JavaScript objects. If you get an object from third-party code that you do
    not control and need to add some of your own properties to that object but want
    to be sure that your properties will not conflict with any properties that may
    already exist on the object, you can safely use Symbols as your property names.
    If you do this, you can also be confident that the third-party code will not accidentally
    alter your symbolically named properties. (That third-party code could, of course,
    use `Object.getOwnPropertySymbols()` to discover the Symbols you’re using and
    could then alter or delete your properties. This is why Symbols are not a security
    mechanism.)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的作用不是安全性，而是为 JavaScript 对象定义一个安全的扩展机制。如果你从你无法控制的第三方代码中获取一个对象，并且需要向该对象添加一些你自己的属性，但又希望确保你的属性不会与对象上可能已经存在的任何属性发生冲突，那么你可以安全地使用符号作为你的属性名称。如果你这样做，你还可以确信第三方代码不会意外地更改你的以符号命名的属性。（当然，该第三方代码可以使用`Object.getOwnPropertySymbols()`来发现你正在使用的符号，并可能更改或删除你的属性。这就是为什么符号不是一种安全机制。）
- en: 6.10.4 Spread Operator
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10.4 展开运算符
- en: 'In ES2018 and later, you can copy the properties of an existing object into
    a new object using the “spread operator” `...` inside an object literal:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES2018 及更高版本中，你可以使用“展开运算符”`...`将现有对象的属性复制到一个新对象中，写在对象字面量内部：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this code, the properties of the `position` and `dimensions` objects are
    “spread out” into the `rect` object literal as if they had been written literally
    inside those curly braces. Note that this `...` syntax is often called a spread
    operator but is not a true JavaScript operator in any sense. Instead, it is a
    special-case syntax available only within object literals. (Three dots are used
    for other purposes in other JavaScript contexts, but object literals are the only
    context where the three dots cause this kind of interpolation of one object into
    another one.)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`position`和`dimensions`对象的属性被“展开”到`rect`对象字面量中，就好像它们被直接写在那些花括号内一样。请注意，这种`...`语法通常被称为展开运算符，但在任何情况下都不是真正的
    JavaScript 运算符。相反，它是仅在对象字面量内部可用的特殊语法。 （在其他 JavaScript 上下文中，三个点用于其他目的，但对象字面量是唯一的上下文，其中这三个点会导致一个对象插入到另一个对象中。）
- en: 'If the object that is spread and the object it is being spread into both have
    a property with the same name, then the value of that property will be the one
    that comes last:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被展开的对象和被展开到的对象都有同名属性，则该属性的值将是最后一个出现的值：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Also note that the spread operator only spreads the own properties of an object,
    not any inherited ones:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，展开运算符只展开对象的自有属性，而不包括任何继承的属性：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, it is worth noting that, although the spread operator is just three
    little dots in your code, it can represent a substantial amount of work to the
    JavaScript interpreter. If an object has *n* properties, the process of spreading
    those properties into another object is likely to be an *O(n)* operation. This
    means that if you find yourself using `...` within a loop or recursive function
    as a way to accumulate data into one large object, you may be writing an inefficient
    *O(n²)* algorithm that will not scale well as *n* gets larger.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，尽管展开运算符在你的代码中只是三个小点，但它可能代表 JavaScript 解释器大量的工作。如果一个对象有*n*个属性，将这些属性展开到另一个对象中的过程可能是一个*O(n)*的操作。这意味着如果你发现自己在循环或递归函数中使用`...`来将数据累积到一个大对象中，你可能正在编写一个效率低下的*O(n²)*算法，随着*n*的增大，它的性能将不会很好。
- en: 6.10.5 Shorthand Methods
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10.5 简写方法
- en: 'When a function is defined as a property of an object, we call that function
    a *method* (we’ll have a lot more to say about methods in Chapters [8](ch08.xhtml#functions)
    and [9](ch09.xhtml#classes)). Prior to ES6, you would define a method in an object
    literal using a function definition expression just as you would define any other
    property of an object:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数被定义为对象的属性时，我们称该函数为*方法*（我们将在第[8](ch08.xhtml#functions)章和第[9](ch09.xhtml#classes)章中详细讨论方法）。在
    ES6 之前，你可以使用函数定义表达式在对象字面量中定义一个方法，就像你定义对象的任何其他属性一样：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In ES6, however, the object literal syntax (and also the class definition syntax
    we’ll see in [Chapter 9](ch09.xhtml#classes)) has been extended to allow a shortcut
    where the `function` keyword and the colon are omitted, resulting in code like
    this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 ES6 中，对象字面量语法（以及我们将在[第9章](ch09.xhtml#classes)中看到的类定义语法）已经扩展，允许一种快捷方式，其中省略了`function`关键字和冒号，导致代码如下：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Both forms of the code are equivalent: both add a property named `area` to
    the object literal, and both set the value of that property to the specified function.
    The shorthand syntax makes it clearer that `area()` is a method and not a data
    property like `side`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 两种形式的代码是等价的：都向对象字面量添加了一个名为`area`的属性，并将该属性的值设置为指定的函数。简写语法使得`area()`是一个方法，而不是像`side`那样的数据属性。
- en: 'When you write a method using this shorthand syntax, the property name can
    take any of the forms that are legal in an object literal: in addition to a regular
    JavaScript identifier like the name `area` above, you can also use string literals
    and computed property names, which can include Symbol property names:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种简写语法编写方法时，属性名称可以采用对象字面量中合法的任何形式：除了像上面的`area`名称一样的常规JavaScript标识符外，还可以使用字符串文字和计算属性名称，其中可以包括Symbol属性名称：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using a Symbol as a method name is not as strange as it seems. In order to make
    an object iterable (so it can be used with a `for/of` loop), you must define a
    method with the symbolic name `Symbol.iterator`, and there are examples of doing
    exactly that in [Chapter 12](ch12.xhtml#itergene).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用符号作为方法名并不像看起来那么奇怪。为了使对象可迭代（以便与`for/of`循环一起使用），必须定义一个具有符号名称`Symbol.iterator`的方法，[第12章](ch12.xhtml#itergene)中有这样做的示例。
- en: 6.10.6 Property Getters and Setters
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.10.6 属性的getter和setter
- en: 'All of the object properties we’ve discussed so far in this chapter have been
    *data properties* with a name and an ordinary value. JavaScript also supports
    *accessor properties*, which do not have a single value but instead have one or
    two accessor methods: a *getter* and/or a *setter*.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中讨论的所有对象属性都是具有名称和普通值的*数据属性*。JavaScript还支持*访问器属性*，它们没有单个值，而是具有一个或两个访问器方��：一个*getter*和/或一个*setter*。
- en: When a program queries the value of an accessor property, JavaScript invokes
    the getter method (passing no arguments). The return value of this method becomes
    the value of the property access expression. When a program sets the value of
    an accessor property, JavaScript invokes the setter method, passing the value
    of the righthand side of the assignment. This method is responsible for “setting,”
    in some sense, the property value. The return value of the setter method is ignored.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序查询访问器属性的值时，JavaScript会调用getter方法（不传递任何参数）。此方法的返回值成为属性访问表达式的值。当程序设置访问器属性的值时，JavaScript会调用setter方法，传递赋值右侧的值。该方法负责在某种意义上“设置”属性值。setter方法的返回值将被忽略。
- en: If a property has both a getter and a setter method, it is a read/write property.
    If it has only a getter method, it is a read-only property. And if it has only
    a setter method, it is a write-only property (something that is not possible with
    data properties), and attempts to read it always evaluate to `undefined`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个属性同时具有getter和setter方法，则它是一个读/写属性。如果它只有getter方法，则它是一个只读属性。如果它只有setter方法，则它是一个只写属性（这是使用数据属性不可能实现的），并且尝试读取它的值总是评估为`undefined`。
- en: 'Accessor properties can be defined with an extension to the object literal
    syntax (unlike the other ES6 extensions we’ve seen here, getters and setters were
    introduced in ES5):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器属性可以使用对象字面量语法的扩展来定义（与我们在这里看到的其他ES6扩展不同，getter和setter是在ES5中引入的）：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Accessor properties are defined as one or two methods whose name is the same
    as the property name. These look like ordinary methods defined using the ES6 shorthand
    except that getter and setter definitions are prefixed with `get` or `set`. (In
    ES6, you can also use computed property names when defining getters and setters.
    Simply replace the property name after `get` or `set` with an expression in square
    brackets.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器属性被定义为一个或两个方法，其名称与属性名称相同。它们看起来像使用ES6简写定义的普通方法，只是getter和setter定义前缀为`get`或`set`。（在ES6中，当定义getter和setter时，也可以使用计算属性名称。只需在`get`或`set`后用方括号中的表达式替换属性名称。）
- en: 'The accessor methods defined above simply get and set the value of a data property,
    and there is no reason to prefer the accessor property over the data property.
    But as a more interesting example, consider the following object that represents
    a 2D Cartesian point. It has ordinary data properties to represent the *x* and
    *y* coordinates of the point, and it has accessor properties that give the equivalent
    polar coordinates of the point:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上面定义的访问器方法只是获取和设置数据属性的值，并没有理由优先使用访问器属性而不是数据属性。但作为一个更有趣的例子，考虑以下表示2D笛卡尔点的对象。它具有普通数据属性来表示点的*x*和*y*坐标，并且具有访问器属性来给出点的等效极坐标：
- en: '[PRE53]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note the use of the keyword `this` in the getters and setter in this example.
    JavaScript invokes these functions as methods of the object on which they are
    defined, which means that within the body of the function, `this` refers to the
    point object `p`. So the getter method for the `r` property can refer to the `x`
    and `y` properties as `this.x` and `this.y`. Methods and the `this` keyword are
    covered in more detail in [§8.2.2](ch08.xhtml#methodinvocation).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在这个例子中，关键字`this`在getter和setter中的使用。JavaScript将这些函数作为定义它们的对象的方法调用，这意味着在函数体内，`this`指的是点对象`p`。因此，`r`属性的getter方法可以将`x`和`y`属性称为`this.x`和`this.y`。更详细地讨论方法和`this`关键字在[§8.2.2](ch08.xhtml#methodinvocation)中有介绍。
- en: 'Accessor properties are inherited, just as data properties are, so you can
    use the object `p` defined above as a prototype for other points. You can give
    the new objects their own `x` and `y` properties, and they’ll inherit the `r`
    and `theta` properties:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器属性是继承的，就像数据属性一样，因此可以将上面定义的对象`p`用作其他点的原型。您可以为新对象提供它们自己的`x`和`y`属性，并且它们将继承`r`和`theta`属性：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The code above uses accessor properties to define an API that provides two
    representations (Cartesian coordinates and polar coordinates) of a single set
    of data. Other reasons to use accessor properties include sanity checking of property
    writes and returning different values on each property read:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用访问器属性来定义一个API，提供单组数据的两种表示（笛卡尔坐标和极坐标）。使用访问器属性的其他原因包括对属性写入进行检查和在每次属性读取时返回不同的值：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, here is one more example that uses a getter method to implement a
    property with “magical” behavior:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是另一个示例，使用getter方法实现具有“神奇”行为的属性：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 6.11 Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.11 总结
- en: 'This chapter has documented JavaScript objects in great detail, covering topics
    that include:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细记录了JavaScript对象，涵盖的主题包括：
- en: Basic object terminology, including the meaning of terms like *enumerable* and
    *own property*.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本对象术语，包括诸如*可枚举*和*自有属性*等术语的含义。
- en: Object literal syntax, including the many new features in ES6 and later.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象字面量语法，包括 ES6 及以后版本中的许多新特性。
- en: How to read, write, delete, enumerate, and check for the presence of the properties
    of an object.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何读取、写入、删除、枚举和检查对象的属性是否存在。
- en: How prototype-based inheritance works in JavaScript and how to create an object
    that inherits from another object with `Object.create()`.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中基于原型的继承是如何工作的，以及如何使用`Object.create()`创建一个继承自另一个对象的对象。
- en: How to copy properties from one object into another with `Object.assign()`.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`Object.assign()`将一个对象的属性复制到另一个对象中。
- en: All JavaScript values that are not primitive values are objects. This includes
    both arrays and functions, which are the topics of the next two chapters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非原始值的 JavaScript 值都是对象。这包括数组和函数，它们是接下来两章的主题。
- en: ^([1](ch06.xhtml#idm46198551345848-marker)) Remember; almost all objects have
    a prototype but most do not have a property named `prototype`. JavaScript inheritance
    works even if you can’t access the prototype object directly. But see [§14.3](ch14.xhtml#prototypeattr)
    if you want to learn how to do that.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#idm46198551345848-marker)) 记住；几乎所有对象都有一个原型，但大多数对象没有名为`prototype`的属性。即使无法直接访问原型对象，JavaScript
    继承仍然有效。但如果想学习如何做到这一点，请参见[§14.3](ch14.xhtml#prototypeattr)。
