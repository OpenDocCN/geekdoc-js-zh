- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: REGULAR EXPRESSIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Programming tools and techniques survive and spread in a chaotic, evolutionary
    way. It’s not always the best or most brilliant ones that win, but rather the
    ones that function well enough within the right niche or that happen to be integrated
    with another successful piece of technology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程工具和技术以一种混乱的进化方式生存和传播。并不是最佳或最聪明的工具获胜，而是那些在正确的细分市场中足够有效或恰好与其他成功技术整合的工具。
- en: In this chapter, I will discuss one such tool, *regular expressions*. Regular
    expressions are a way to describe patterns in string data. They form a small,
    separate language that is part of JavaScript and many other languages and systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论这样一个工具，*正则表达式*。正则表达式是一种描述字符串数据模式的方法。它们形成了一种小而独立的语言，属于JavaScript以及许多其他语言和系统。
- en: Regular expressions are both terribly awkward and extremely useful. Their syntax
    is cryptic and the programming interface JavaScript provides for them is clumsy.
    But they are a powerful tool for inspecting and processing strings. Properly understanding
    regular expressions will make you a more effective programmer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式既十分笨拙又极其有用。它们的语法晦涩，而JavaScript为它们提供的编程接口又笨重。但它们是检查和处理字符串的强大工具。正确理解正则表达式将使你成为更有效的程序员。
- en: Creating a Regular Expression
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建正则表达式
- en: A regular expression is a type of object. It can be either constructed with
    the RegExp constructor or written as a literal value by enclosing a pattern in
    forward slash (/) characters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种对象。它可以通过RegExp构造函数构造，或通过用正斜杠（/）字符括起模式来作为文字值书写。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both of those regular expression objects represent the same pattern: an *a*
    character followed by a *b* followed by a *c*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个正则表达式对象表示相同的模式：一个*a*字符后跟一个*b*，再后跟一个*c*。
- en: When using the RegExp constructor, the pattern is written as a normal string,
    so the usual rules apply for backslashes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RegExp构造函数时，模式被写成普通字符串，因此反斜杠的通常规则适用。
- en: The second notation, where the pattern appears between slash characters, treats
    backslashes somewhat differently. First, since a forward slash ends the pattern,
    we need to put a backslash before any forward slash that we want to be *part*
    of the pattern. In addition, backslashes that aren’t part of special character
    codes (like \n) will be *preserved*, rather than ignored as they are in strings,
    and change the meaning of the pattern. Some characters, such as question marks
    and plus signs, have special meanings in regular expressions and must be preceded
    by a backslash if they are meant to represent the character itself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种记法中，模式出现在斜杠字符之间，对反斜杠的处理方式有所不同。首先，由于正斜杠结束了模式，我们需要在任何希望成为*模式一部分*的正斜杠前加上反斜杠。此外，反斜杠如果不是特殊字符代码的一部分（如\n），将会被*保留*，而不是像在字符串中那样被忽略，并且会改变模式的含义。一些字符，比如问号和加号，在正则表达式中具有特殊含义，如果它们表示的是字符本身，必须在前面加上反斜杠。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Testing for Matches
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配测试
- en: Regular expression objects have a number of methods. The simplest one is test.
    If you pass it a string, it will return a Boolean telling you whether the string
    contains a match of the pattern in the expression.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象有许多方法。最简单的方法是test。如果你传递给它一个字符串，它将返回一个布尔值，告诉你该字符串是否包含模式的匹配。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A regular expression consisting of only nonspecial characters simply represents
    that sequence of characters. If *abc* occurs anywhere in the string we are testing
    against (not just at the start), test will return true.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仅由非特殊字符组成的正则表达式简单地表示该字符序列。如果*abc*出现在我们测试的字符串中的任何位置（不仅仅是在开始处），测试将返回true。
- en: Sets of Characters
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符集
- en: Finding out whether a string contains *abc* could just as well be done with
    a call to indexOf. Regular expressions are useful because they allow us to describe
    more complicated patterns.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个字符串是否包含*abc*也可以通过调用indexOf来完成。正则表达式之所以有用，是因为它们允许我们描述更复杂的模式。
- en: Say we want to match any number. In a regular expression, putting a set of characters
    between square brackets makes that part of the expression match any of the characters
    between the brackets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想匹配任何数字。在正则表达式中，将一组字符放在方括号之间，使得该部分表达式匹配方括号中的任何字符。
- en: 'Both of the following expressions match all strings that contain a digit:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个表达式匹配所有包含数字的字符串：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Within square brackets, a hyphen (-) between two characters can be used to indicate
    a range of characters, where the ordering is determined by the character’s Unicode
    number. Characters 0 to 9 sit right next to each other in this ordering (codes
    48 to 57), so [0-9] covers all of them and matches any digit.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号内，两个字符之间的连字符（-）可以用来表示字符范围，其顺序由字符的 Unicode 编号决定。字符 0 到 9 在这个排序中彼此相邻（编码 48
    到 57），因此 [0-9] 包含了所有数字，并且匹配任何数字。
- en: 'A number of common character groups have their own built-in shortcuts. Digits
    are one of them: \d means the same thing as [0-9].'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的字符组有其自己的内置快捷方式。数字就是其中之一：\d 的含义与 [0-9] 相同。
- en: '| \d | Any digit character |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| \d | 任何数字字符 |'
- en: '| \w | An alphanumeric character (“word character”) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| \w | 一个字母数字字符（“单词字符”）|'
- en: '| \s | Any whitespace character (space, tab, newline, and similar) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| \s | 任何空白字符（空格、制表符、换行符等） |'
- en: '| \D | A character that is *not* a digit |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| \D | 一个*不是*数字的字符 |'
- en: '| \W | A nonalphanumeric character |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| \W | 一个非字母数字字符 |'
- en: '| \S | A nonwhitespace character |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| \S | 一个非空白字符 |'
- en: '| . | Any character except for newline |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| . | 除换行符外的任何字符 |'
- en: 'You could match a date and time format like 01-30-2003 15:20 with the following
    expression:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下表达式匹配日期和时间格式，如 01-30-2003 15:20：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That regular expression looks completely awful, doesn’t it? Half of it is backslashes,
    producing a background noise that makes it hard to spot the actual pattern expressed.
    We’ll see a slightly improved version of this expression later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那个正则表达式看起来完全糟糕，不是吗？其中一半是反斜杠，产生的背景噪声使得实际表达的模式很难被识别。稍后我们会看到这个表达式的稍微改进版本。
- en: These backslash codes can also be used inside square brackets. For example,
    [\d.] means any digit or a period character. The period itself, between square
    brackets, loses its special meaning. The same goes for other special characters,
    such as the plus sign (+).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反斜杠代码也可以在方括号内使用。例如，[\d.] 表示任何数字或句点字符。句点本身在方括号中失去了特殊含义。其他特殊字符也是如此，例如加号（+）。
- en: To *invert* a set of characters—that is, to express that you want to match any
    character *except* the ones in the set—you can write a caret (^) character after
    the opening bracket.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要*反转*一组字符——即表达你想匹配任何*除了*该组中的字符外的字符——可以在开括号后写一个插入符号（^）。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: International Characters
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 国际字符
- en: Because of JavaScript’s initial simplistic implementation and the fact that
    this simplistic approach was later set in stone as standard behavior, Java-Script’s
    regular expressions are rather dumb about characters that do not appear in the
    English language. For example, as far as JavaScript’s regular expressions are
    concerned, a “word character” is only one of the 26 characters in the Latin alphabet
    (uppercase or lowercase), decimal digits, and, for some reason, the underscore
    character. Things like *é* or *β*, which most definitely are word characters,
    will not match \w (and *will* match uppercase \W, the nonword category).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 最初的简单实现以及这种简单方法后来被视为标准行为，JavaScript 的正则表达式在处理不出现在英语中的字符时显得相当愚蠢。例如，在
    JavaScript 的正则表达式看来，“单词字符”仅是拉丁字母表中的 26 个字符（大小写皆可）、十进制数字，以及出于某种原因的下划线字符。像 *é* 或
    *β* 这样的字符，虽然绝对是单词字符，却不会匹配 \w（而且会匹配大写的 \W，即非单词类别）。
- en: By a strange historical accident, \s (whitespace) does not have this problem
    and matches all characters that the Unicode standard considers whitespace, including
    things like the nonbreaking space and the Mongolian vowel separator.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个奇怪的历史偶然，\s（空白符）没有这个问题，它匹配 Unicode 标准认为的所有空白字符，包括不换行空格和蒙古元音分隔符等。
- en: It is possible to use \p in a regular expression to match all characters to
    which the Unicode standard assigns a given property. This allows us to match things
    like letters in a more cosmopolitan way. However, again due to compatibility with
    the original language standards, those are recognized only when you put a u character
    (for Unicode) after the regular expression.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中可以使用 \p 来匹配 Unicode 标准赋予特定属性的所有字符。这使我们能够以更广泛的方式匹配字母。然而，由于与原始语言标准的兼容性，只有在正则表达式后面加上
    u 字符（表示 Unicode）时，这些字符才能被识别。
- en: '| \p{L} | Any letter |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| \p{L} | 任何字母 |'
- en: '| \p{N} | Any numeric character |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| \p{N} | 任何数字字符 |'
- en: '| \p{P} | Any punctuation character |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| \p{P} | 任何标点符号字符 |'
- en: '| \P{L} | Any nonletter (uppercase P inverts) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| \P{L} | 任何非字母（大写 P 表示反转） |'
- en: '| \p{Script=Hangul} | Any character from the given script (see [Chapter 5](ch05.xhtml#ch05))
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| \p{Script=Hangul} | 给定脚本中的任何字符（参见 [第 5 章](ch05.xhtml#ch05)） |'
- en: Using \w for text processing that may need to handle non-English text (or even
    English text with borrowed words like *cliché*) is a liability, since it won’t
    treat characters like *é* as letters. Though they tend to be a bit more verbose,
    \p property groups are more robust.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 \w 进行文本处理，可能需要处理非英语文本（甚至包含借用词如 *cliché* 的英语文本）是一种风险，因为它不会将像 *é* 这样的字符视为字母。尽管它们通常更冗长，但
    \p 属性组更加稳健。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On the other hand, if you are matching numbers in order to do something with
    them, you often do want \d for digits, since converting arbitrary numeric characters
    into a JavaScript number is not something that a function like Number can do for
    you.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你是为了对数字执行某些操作而匹配数字，通常确实需要 \d 来匹配数字，因为将任意数字字符转换为 JavaScript 数字并不是像 Number
    这样的函数能为你做到的。
- en: Repeating Parts of a Pattern
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复模式的部分
- en: We now know how to match a single digit. What if we want to match a whole number—a
    sequence of one or more digits?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何匹配单个数字。如果我们想匹配一个完整的数字——一个或多个数字的序列呢？
- en: When you put a plus sign (+) after something in a regular expression, it indicates
    that the element may be repeated more than once. Thus, /\d+/ matches one or more
    digit characters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在正则表达式中在某个内容后加上加号 (+) 时，表示该元素可以重复多次。因此，/\d+/ 匹配一个或多个数字字符。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The star (*) has a similar meaning but also allows the pattern to match zero
    times. Something with a star after it never prevents a pattern from matching—it’ll
    just match zero instances if it can’t find any suitable text to match.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 星号 (*) 的含义类似，但也允许模式零次匹配。后面带有星号的内容不会阻止模式匹配——如果找不到任何合适的文本匹配，它只会匹配零个实例。
- en: 'A question mark (?) makes a part of a pattern *optional*, meaning it may occur
    zero times or one time. In the following example, the *u* character is allowed
    to occur, but the pattern also matches when it is missing:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 问号 (?) 使模式的部分 *可选*，意味着它可以出现零次或一次。在下面的示例中，*u* 字符可以出现，但当它缺失时，模式仍然匹配：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To indicate that a pattern should occur a precise number of times, use braces.
    Putting {4} after an element, for example, requires it to occur exactly four times.
    It is also possible to specify a range this way: {2,4} means the element must
    occur at least twice and at most four times.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示模式应该出现的精确次数，可以使用大括号。在元素后面加上 {4}，例如，要求它恰好出现四次。也可以通过这种方式指定范围：{2,4} 意味着元素必须至少出现两次，最多四次。
- en: Here is another version of the date and time pattern that allows both single-
    and double-digit days, months, and hours. It is also slightly easier to decipher.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是日期和时间模式的另一个版本，允许单个和双个数字的天、月和小时。它也略微更易于解读。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can also specify open-ended ranges when using braces by omitting the number
    after the comma. For example, {5,} means five or more times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大括号时，可以通过省略逗号后的数字来指定开放范围。例如，{5,} 意味着五次或更多次。
- en: Grouping Subexpressions
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子表达式分组
- en: To use an operator like * or + on more than one element at a time, you must
    use parentheses. A part of a regular expression that is enclosed in parentheses
    counts as a single element as far as the operators following it are concerned.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个元素上同时使用 * 或 + 这样的运算符，必须使用括号。被括号包围的正则表达式的一部分在后续运算符的考虑下算作一个单一元素。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first and second + characters apply only to the second o in boo and hoo,
    respectively. The third + applies to the whole group (hoo+), matching one or more
    sequences like that.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第二个 + 字符仅适用于 boo 和 hoo 中的第二个 o。第三个 + 适用于整个组 (hoo+)，匹配一个或多个这样的序列。
- en: The i at the end of the expression in the example makes this regular expression
    case insensitive, allowing it to match the uppercase *B* in the input string,
    even though the pattern is itself all lowercase.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中表达式末尾的 i 使该正则表达式对大小写不敏感，即使模式本身全部为小写，也允许匹配输入字符串中的大写 *B*。
- en: Matches and Groups
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配和分组
- en: The test method is the absolute simplest way to match a regular expression.
    It tells you only whether it matched and nothing else. Regular expressions also
    have an exec (execute) method that will return null if no match was found and
    return an object with information about the match otherwise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 测试方法是匹配正则表达式的最简单方式。它只告诉你是否匹配，而没有其他信息。正则表达式还有一个 exec（执行）方法，如果未找到匹配项，则返回 null，否则返回一个包含匹配信息的对象。
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: An object returned from exec has an index property that tells us *where* in
    the string the successful match begins. Other than that, the object looks like
    (and in fact is) an array of strings, whose first element is the string that was
    matched. In the previous example, this is the sequence of digits that we were
    looking for.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从exec返回的对象有一个index属性，告诉我们*匹配*在字符串中开始的位置。除此之外，该对象看起来（实际上也是）是一个字符串数组，其中第一个元素是匹配的字符串。在前面的例子中，这就是我们要寻找的数字序列。
- en: String values have a match method that behaves similarly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值有一个match方法，其行为类似。
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the regular expression contains subexpressions grouped with parentheses,
    the text that matched those groups will also show up in the array. The whole match
    is always the first element. The next element is the part matched by the first
    group (the one whose opening parenthesis comes first in the expression), then
    the second group, and so on.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当正则表达式包含用括号分组的子表达式时，匹配这些组的文本也会出现在数组中。整个匹配总是第一个元素。下一个元素是第一个组（即开括号在表达式中最先出现的那个）的匹配部分，然后是第二组，以此类推。
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When a group does not end up being matched at all (for example, when followed
    by a question mark), its position in the output array will hold undefined. When
    a group is matched multiple times (for example, when followed by a +), only the
    last match ends up in the array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个组根本没有被匹配时（例如，后面跟着问号），其在输出数组中的位置将是undefined。当一个组被多次匹配时（例如，后面跟着+），只有最后一次匹配会出现在数组中。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you want to use parentheses purely for grouping, without having them show
    up in the array of matches, you can put ?: after the opening parenthesis.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想单纯将括号用于分组，而不希望它们出现在匹配的数组中，可以在开括号后加上?:。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Groups can be useful for extracting parts of a string. If we don’t just want
    to verify whether a string contains a date but also extract it and construct an
    object that represents it, we can wrap parentheses around the digit patterns and
    directly pick the date out of the result of exec.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 组对于提取字符串的一部分是很有用的。如果我们不仅想验证一个字符串是否包含日期，还想提取它并构建一个表示它的对象，我们可以在数字模式周围加上括号，并直接从exec的结果中提取日期。
- en: But first we’ll take a brief detour to discuss the built-in way to represent
    date and time values in JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先我们将简要讨论JavaScript中表示日期和时间值的内置方法。
- en: The Date Class
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期类
- en: JavaScript has a standard Date class for representing dates, or rather, points
    in time. If you simply create a date object using new, you get the current date
    and time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一个标准的日期类用于表示日期，或者更准确地说，表示时间点。如果你仅仅使用new创建一个日期对象，你将获得当前的日期和时间。
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also create an object for a specific time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为特定时间创建一个对象。
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: JavaScript uses a convention where month numbers start at zero (so December
    is 11), yet day numbers start at one. This is confusing and silly. Be careful.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript使用一种约定，即月份编号从零开始（所以12月是11），而日期编号从一开始。这让人感到困惑和愚蠢。请小心。
- en: The last four arguments (hours, minutes, seconds, and milliseconds) are optional
    and taken to be zero when not given.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后四个参数（小时、分钟、秒和毫秒）是可选的，未给定时默认为零。
- en: Timestamps are stored as the number of milliseconds since the start of 1970,
    in the UTC time zone. This follows a convention set by “Unix time,” which was
    invented around that time. You can use negative numbers for times before 1970\.
    The getTime method on a date object returns this number. It is big, as you can
    imagine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳以自1970年开始的毫秒数存储，使用UTC时区。这遵循了“Unix时间”设定的约定，该约定大约在那个时候被发明。对于1970年之前的时间，可以使用负数。日期对象上的getTime方法返回这个数字。它的数值很大，可以想象。
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you give the Date constructor a single argument, that argument is treated
    as such a millisecond count. You can get the current millisecond count by creating
    a new Date object and calling getTime on it or by calling the Date.now function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给Date构造函数一个单一的参数，那么该参数会被视为这样的毫秒计数。你可以通过创建一个新的Date对象并调用getTime来获取当前的毫秒计数，或者通过调用Date.now函数。
- en: Date objects provide methods such as getFullYear, getMonth, getDate, getHours,
    getMinutes, and getSeconds to extract their components. Besides getFullYear there’s
    also getYear, which gives you the year minus 1900 (such as 98 or 125) and is mostly
    useless.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 日期对象提供了getFullYear、getMonth、getDate、getHours、getMinutes和getSeconds等方法来提取它们的组成部分。除了getFullYear外，还有getYear，它返回的是年份减去1900（如98或125），这个方法大多无用。
- en: Putting parentheses around the parts of the expression that we are interested
    in, we can now create a date object from a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将感兴趣的表达式部分用括号括起来后，我们现在可以从字符串创建日期对象。
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The underscore (_) binding is ignored and used only to skip the full match element
    in the array returned by exec.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线(_)绑定被忽略，仅用于跳过exec返回的数组中的完整匹配元素。
- en: Boundaries and Look-Ahead
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界和前瞻
- en: Unfortunately, getDate will also happily extract a date from the string “100-1
    -30000”. A match may happen anywhere in the string, so in this case, it’ll just
    start at the second character and end at the second-to-last character.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，getDate也会愉快地从字符串“100-1 -30000”中提取日期。匹配可以发生在字符串的任何地方，因此在这种情况下，它会从第二个字符开始，到倒数第二个字符结束。
- en: If we want to enforce that the match must span the whole string, we can add
    the markers ^ and $. The caret matches the start of the input string, whereas
    the dollar sign matches the end. Thus /^\d+$/ matches a string consisting entirely
    of one or more digits, /^!/ matches any string that starts with an exclamation
    mark, and /x^/ does not match any string (there cannot be an x before the start
    of the string).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要强制匹配必须覆盖整个字符串，可以添加标记^和$。插入符号匹配输入字符串的开头，而美元符号匹配结尾。因此，/^\d+$/匹配一个完全由一个或多个数字组成的字符串，/^!/匹配任何以感叹号开头的字符串，而/x^/则不匹配任何字符串（字符串开头不能有x）。
- en: There is also a \b marker that matches *word boundaries*, positions that have
    a word character on one side and a nonword character on the other. Unfortunately,
    these use the same simplistic concept of word characters as \w and are therefore
    not very reliable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个\b标记，匹配*单词边界*，即一侧是单词字符而另一侧是非单词字符的位置。不幸的是，这些标记与\w使用相同的简单概念，因此并不可靠。
- en: Note that these boundary markers don’t match any actual characters. They just
    enforce that a given condition holds at the place where it appears in the pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些边界标记并不匹配任何实际字符。它们只是确保在出现位置满足特定条件。
- en: '*Look-ahead* tests do something similar. They provide a pattern and will make
    the match fail if the input doesn’t match that pattern, but don’t actually move
    the match position forward. They are written between (?= and ).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*前瞻*测试做了类似的事情。它们提供一个模式，如果输入不匹配该模式，则使匹配失败，但实际上并不向前移动匹配位置。它们是在(?=和)之间编写的。'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The e in the first example is necessary to match, but is not part of the matched
    string. The (?! ) notation expresses a *negative* look-ahead. This matches only
    if the pattern in the parentheses *doesn’t* match, causing the second example
    to match only a characters that don’t have a space after them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例中的e是匹配所必需的，但不是匹配字符串的一部分。(?! )符号表示*负向*前瞻。只有在括号内的模式*不*匹配时，它才会匹配，从而导致第二个示例只匹配后面没有空格的字符。
- en: Choice Patterns
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择模式
- en: Say we want to know whether a piece of text contains not only a number but a
    number followed by one of the words *pig*, *cow*, or *chicken*, or any of their
    plural forms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想知道一段文本是否不仅包含一个数字，还包含一个数字后面跟着单词*pig*、*cow*或*chicken*，或者它们的复数形式。
- en: 'We could write three regular expressions and test them in turn, but there is
    a nicer way. The pipe character (|) denotes a choice between the pattern to its
    left and the pattern to its right. We can use it in expressions like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写三个正则表达式并依次测试，但有一种更好的方法。管道字符（|）表示其左侧模式和右侧模式之间的选择。我们可以在这样的表达式中使用它：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Parentheses can be used to limit the part of the pattern to which the pipe operator
    applies, and you can put multiple such operators next to each other to express
    a choice between more than two alternatives.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用括号来限制管道操作符适用的模式部分，你可以将多个这样的操作符并排放置，以表达两种以上选项之间的选择。
- en: The Mechanics of Matching
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配机制
- en: Conceptually, when you use exec or test, the regular expression engine looks
    for a match in your string by trying to match the expression first from the start
    of the string, then from the second character, and so on until it finds a match
    or reaches the end of the string. It’ll either return the first match that can
    be found or fail to find any match at all.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，当你使用exec或test时，正则表达式引擎会通过尝试首先从字符串的开头开始匹配表达式，然后从第二个字符开始，依此类推，直到找到匹配项或到达字符串的末尾。它将返回找到的第一个匹配项，或者根本找不到任何匹配。
- en: 'To do the actual matching, the engine treats a regular expression something
    like a flow diagram. This is the diagram for the livestock expression in the previous
    example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行实际的匹配，引擎将正则表达式视作一个流程图。这是前一个示例中牲畜表达式的图示：
- en: '![Image](../images/f0150-01.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0150-01.jpg)'
- en: If we can find a path from the left side of the diagram to the right side, our
    expression matches. We keep a current position in the string, and every time we
    move through a box, we verify that the part of the string after our current position
    matches that box.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够找到一条从图左侧到右侧的路径，我们的表达式就匹配。我们在字符串中保持一个当前位置，每当我们穿过一个框时，我们会验证当前位置之后的字符串部分是否与该框匹配。
- en: Backtracking
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回溯
- en: 'The regular expression /^([01]+b|[\da-f]+h|\d+)$/ matches either a binary number
    followed by a b, a hexadecimal number (that is, base 16, with the letters a to
    f standing for the digits 10 to 15) followed by an h, or a regular decimal number
    with no suffix character. This is the corresponding diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式 /^([01]+b|[\da-f]+h|\d+)$/ 可以匹配一个后面跟着 b 的二进制数字、一个后面跟着 h 的十六进制数字（即基数 16，字母
    a 到 f 表示数字 10 到 15），或者一个没有后缀字符的常规十进制数字。这是相应的图示：
- en: '![Image](../images/f0150-02.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0150-02.jpg)'
- en: When matching this expression, the top (binary) branch will often be entered
    even though the input does not actually contain a binary number. When matching
    the string “103”, for example, it becomes clear only at the 3 that we are in the
    wrong branch. The string *does* match the expression, just not the branch we are
    currently in.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配这个表达式时，顶部的（二进制）分支通常会被进入，即使输入实际上并不包含二进制数字。例如，在匹配字符串“103”时，只有在字符 3 处才明确我们在错误的分支中。该字符串*确实*匹配表达式，只是我们当前所在的分支不匹配。
- en: So the matcher *backtracks*. When entering a branch, it remembers its current
    position (in this case, at the start of the string, just past the first boundary
    box in the diagram) so that it can go back and try another branch if the current
    one does not work out. For the string “103”, after encountering the 3 character,
    the matcher starts trying the branch for hexadecimal numbers, which fails again
    because there is no h after the number. It then tries the decimal number branch.
    This one fits, and a match is reported after all.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，匹配器*回溯*。进入一个分支时，它会记住当前的位置（在这种情况下，位于字符串的开始，刚好在图中的第一个边界框后面），以便在当前分支不成功时可以返回并尝试另一个分支。对于字符串“103”，在遇到字符
    3 后，匹配器开始尝试十六进制数字的分支，但由于数字后没有 h，因此再次失败。接着它尝试十进制数字的分支。这个分支匹配成功，最终报告了匹配结果。
- en: The matcher stops as soon as it finds a full match. This means that if multiple
    branches could potentially match a string, only the first one (ordered by where
    the branches appear in the regular expression) is used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器在找到完整匹配后立即停止。这意味着如果多个分支可能匹配一个字符串，只有第一个（按分支在正则表达式中出现的顺序）会被使用。
- en: Backtracking also happens for repetition operators like + and *. If you match
    /^.*x/ against “abcxe”, the .* part will first try to consume the whole string.
    The engine will then realize that it needs an x to match the pattern. Since there
    is no x past the end of the string, the star operator tries to match one character
    less. But the matcher doesn’t find an x after abcx either, so it backtracks again,
    matching the star operator to just abc. *Now* it finds an x where it needs it
    and reports a successful match from positions 0 to 4.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回溯也发生在重复操作符如 + 和 * 上。如果你用 /^.*x/ 来匹配“abcxe”，.* 部分会首先尝试消耗整个字符串。引擎会意识到它需要一个 x
    来匹配模式。由于在字符串末尾没有 x，星号操作符会尝试少匹配一个字符。但是匹配器在 abcx 后也没有找到 x，因此它再次回溯，将星号操作符匹配为仅 abc。*此时*
    它找到了一个 x，并报告从位置 0 到 4 的成功匹配。
- en: It is possible to write regular expressions that will do a *lot* of backtracking.
    This problem occurs when a pattern can match a piece of input in many different
    ways. For example, if we get confused while writing a binary-number regular expression,
    we might accidentally write something like /([01]+)+b/.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写会进行*大量*回溯的正则表达式。当一个模式可以以多种不同方式匹配输入的一部分时，就会出现这个问题。例如，如果在编写二进制数字正则表达式时感到困惑，可能会不小心写出类似
    /([01]+)+b/ 的东西。
- en: '![Image](../images/f0151-01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0151-01.jpg)'
- en: If that tries to match some long series of zeros and ones with no trailing *b*
    character, the matcher first goes through the inner loop until it runs out of
    digits. Then it notices there is no *b*, so it backtracks one position, goes through
    the outer loop once, and gives up again, trying to backtrack out of the inner
    loop once more. It will continue to try every possible route through these two
    loops. This means the amount of work *doubles* with each additional character.
    For even just a few dozen characters, the resulting match will take practically
    forever.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它试图匹配一些长长的零和一系列，没有尾随的 *b* 字符，匹配器首先会遍历内部循环，直到耗尽数字。然后它注意到没有 *b*，所以它向后退一个位置，再次经过外部循环一次，然后再次放弃，试图再次从内部循环中回退。它将继续尝试通过这两个循环的每一种可能路径。这意味着每增加一个字符，工作量*翻倍*。即使只是几十个字符，最终的匹配将几乎需要永远。
- en: The replace Method
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换方法
- en: String values have a replace method that can be used to replace part of the
    string with another string.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串值具有一个可以用来将字符串的一部分替换为另一个字符串的 replace 方法。
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first argument can also be a regular expression, in which case the first
    match of the regular expression is replaced. When a g option (for *global*) is
    added after the regular expression, *all* matches in the string will be replaced,
    not just the first.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数也可以是一个正则表达式，在这种情况下，正则表达式的第一次匹配将被替换。当在正则表达式后添加 g 选项（表示*全局*）时，字符串中的*所有*匹配项都会被替换，而不仅仅是第一个。
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The real power of using regular expressions with replace comes from the fact
    that we can refer to matched groups in the replacement string. For example, say
    we have a big string containing the names of people, one name per line, in the
    format Lastname, Firstname. If we want to swap these names and remove the comma
    to get a Firstname Lastname format, we can use the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式与 replace 结合的真正强大之处在于我们可以在替换字符串中引用匹配的组。例如，假设我们有一个包含人名的大字符串，每行一个名字，格式为
    Lastname, Firstname。如果我们想交换这些名字并移除逗号以获得 Firstname Lastname 格式，我们可以使用以下代码：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The $1 and $2 in the replacement string refer to the parenthesized groups in
    the pattern. $1 is replaced by the text that matched against the first group,
    $2 by the second, and so on, up to $9. The whole match can be referred to with
    $&.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 替换字符串中的 $1 和 $2 引用模式中的括号组。$1 被替换为与第一个组匹配的文本，$2 被替换为第二个，依此类推，直到 $9。整个匹配可以通过 $&
    引用。
- en: It is possible to pass a function—rather than a string—as the second argument
    to replace. For each replacement, the function will be called with the matched
    groups (as well as the whole match) as arguments, and its return value will be
    inserted into the new string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将一个函数而不是字符串作为第二个参数传递给 replace。对于每一个替换，函数将被调用，并传入匹配的组（以及整个匹配项）作为参数，其返回值将插入到新字符串中。
- en: 'Here’s an example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code takes a string, finds all occurrences of a number followed by an alphanumeric
    word, and returns a string that has one less of every such quantity.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码获取一个字符串，查找所有后跟一个字母数字单词的数字出现次数，并返回一个每个数量少一个的字符串。
- en: The (\d+) group ends up as the amount argument to the function, and the (\p{L}+)
    group gets bound to unit. The function converts amount to a number—which always
    works, since it matched \d+ earlier—and makes some adjustments in case there is
    only one or zero left.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: (\d+) 组最终作为函数的数量参数，(\p{L}+) 组绑定到单位。函数将数量转换为数字——这总是有效的，因为它之前匹配了 \d+——并进行一些调整，以防只有一个或零个剩余。
- en: Greed
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 贪婪
- en: 'We can use replace to write a function that removes all comments from a piece
    of JavaScript code. Here is a first attempt:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 replace 来编写一个函数，从一段 JavaScript 代码中移除所有注释。这是第一次尝试：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The part before the | operator matches two slash characters followed by any
    number of non-newline characters. The part for multiline comments is more involved.
    We use [^] (any character that is not in the empty set of characters) as a way
    to match any character. We cannot just use a period here because block comments
    can continue on a new line, and the period character does not match newline characters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| 操作符前面的部分匹配两个斜杠字符后跟任意数量的非换行字符。多行注释的部分更复杂。我们使用 [^]（不在空字符集中的任何字符）作为匹配任意字符的方式。我们不能在这里简单地使用一个句点，因为块注释可能会在新行上继续，而句点字符无法匹配换行字符。'
- en: But the output for the last line appears to have gone wrong. Why?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是最后一行的输出似乎出错了。为什么？
- en: The [^]* part of the expression, as I described in the section on backtracking,
    will first match as much as it can. If that causes the next part of the pattern
    to fail, the matcher moves back one character and tries again from there. In the
    example, the matcher first tries to match the whole rest of the string and then
    moves back from there. It will find an occurrence of */ after going back four
    characters and match that. This is not what we wanted—the intention was to match
    a single comment, not to go all the way to the end of the code and find the end
    of the last block comment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的 [^]* 部分，如我在回溯部分所述，首先会匹配尽可能多的内容。如果这导致模式的下一部分失败，匹配器会回退一个字符并从那里重新尝试。在这个例子中，匹配器首先尝试匹配字符串的其余部分，然后从那里回退。它会在回退四个字符后找到一个
    */ 的出现，并进行匹配。这并不是我们想要的——我们的意图是匹配单个注释，而不是一直到代码的末尾去找到最后一个块注释的结束。
- en: Because of this behavior, we say the repetition operators (+, *, ?, and {})
    are *greedy*, meaning they match as much as they can and backtrack from there.
    If you put a question mark after them (+?, *?, ??, {}?), they become nongreedy
    and start by matching as little as possible, matching more only when the remaining
    pattern does not fit the smaller match.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为这种行为，我们称重复运算符（+，*，?，和 {}）为*贪婪的*，意思是它们尽可能多地匹配，然后从那里回溯。如果在它们后面加上问号（+?，*?，??，{}?），它们就会变成非贪婪的，并尽量匹配尽可能少的内容，只有在剩余模式不适合较小匹配时才会匹配更多。
- en: And that is exactly what we want in this case. By having the star match the
    smallest stretch of characters that brings us to a */, we consume one block comment
    and nothing more.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 而这正是我们在这种情况下想要的。通过让星号匹配最小的字符范围，使我们到达一个 */，我们消耗了一个块注释，而没有更多。
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A lot of bugs in regular expression programs can be traced to unintentionally
    using a greedy operator where a nongreedy one would work better. When using a
    repetition operator, prefer the nongreedy variant.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式程序中的许多错误可以追溯到无意中使用了贪婪运算符，而非贪婪运算符会更好。当使用重复运算符时，优先选择非贪婪变体。
- en: Dynamically Creating RegExp Objects
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态创建 RegExp 对象
- en: In some cases, you may not know the exact pattern you need to match against
    when you are writing your code. Say you want to test for the user’s name in a
    piece of text. You can build up a string and use the RegExp constructor on that.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当你编写代码时，可能不知道需要匹配的确切模式。比如说，你想在一段文本中测试用户的名字。你可以构建一个字符串，并在此基础上使用 RegExp
    构造函数。
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When creating the \s part of the string, we have to use two backslashes because
    we are writing them in a normal string, not a slash-enclosed regular expression.
    The second argument to the RegExp constructor contains the options for the regular
    expression—in this case, “gi” for global and case insensitive.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建字符串的 \s 部分时，我们必须使用两个反斜杠，因为我们是在正常字符串中编写它们，而不是在斜杠封闭的正则表达式中。RegExp 构造函数的第二个参数包含正则表达式的选项——在这种情况下，“gi”表示全局匹配和不区分大小写。
- en: But what if the name is “dea+hl[]rd” because our user is a nerdy teenager? That
    would result in a nonsensical regular expression that won’t actually match the
    user’s name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果名字是 “dea+hl[]rd”，因为我们的用户是一个书呆子青少年呢？这会导致一个毫无意义的正则表达式，实际上无法匹配用户的名字。
- en: To work around this, we can add backslashes before any character that has a
    special meaning.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在任何具有特殊含义的字符前添加反斜杠。
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The search Method
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: search 方法
- en: While the indexOf method on strings cannot be called with a regular expression,
    there is another method, search, that does expect a regular expression. Like indexOf,
    it returns the first index on which the expression was found, or -1 when it wasn’t
    found.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串的 indexOf 方法不能用正则表达式调用，但还有另一种方法 search，它确实需要一个正则表达式。像 indexOf 一样，它返回表达式找到的第一个索引，或者在未找到时返回
    -1。
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unfortunately, there is no way to indicate that the match should start at a
    given offset (like we can with the second argument to indexOf), which would often
    be useful.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有办法指示匹配应从给定偏移量开始（就像我们可以用 indexOf 的第二个参数一样），这在很多情况下会非常有用。
- en: The lastIndex Property
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lastIndex 属性
- en: The exec method similarly does not provide a convenient way to start searching
    from a given position in the string. But it does provide an *in*convenient way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: exec 方法同样没有提供从给定位置开始搜索的方便方式。但它提供了一种*不*方便的方式。
- en: Regular expression objects have properties. One such property is source, which
    contains the string that expression was created from. Another property is lastIndex,
    which controls, in some limited circumstances, where the next match will start.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式对象有属性。其中一个属性是source，它包含创建该表达式时使用的字符串。另一个属性是lastIndex，它在某些有限情况下控制下一个匹配的起始位置。
- en: Those circumstances are that the regular expression must have the global (g)
    or sticky (y) option enabled, and the match must happen through the exec method.
    Again, a less confusing solution would have been to just allow an extra argument
    to be passed to exec, but confusion is an essential feature of JavaScript’s regular
    expression interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有限情况是正则表达式必须启用全局(g)或粘性(y)选项，并且匹配必须通过exec方法发生。再说一次，较少混淆的解决方案是允许将额外参数传递给exec，但混淆是JavaScript正则表达式接口的一个基本特征。
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If the match was successful, the call to exec automatically updates the lastIndex
    property to point after the match. If no match was found, lastIndex is set back
    to 0, which is also the value it has in a newly constructed regular expression
    object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配成功，对exec的调用会自动更新lastIndex属性，使其指向匹配之后的位置。如果没有找到匹配，lastIndex会被重置为0，这也是新构建的正则表达式对象的初始值。
- en: The difference between the global and the sticky options is that when sticky
    is enabled, the match will succeed only if it starts directly at lastIndex, whereas
    with global, it will search ahead for a position where a match can start.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 全局选项和粘性选项之间的区别在于，当启用粘性时，匹配只会在lastIndex直接开始时成功，而全局匹配则会向前搜索可以开始匹配的位置。
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When using a shared regular expression value for multiple exec calls, these
    automatic updates to the lastIndex property can cause problems. Your regular expression
    might be accidentally starting at an index left over from a previous call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在对多个exec调用使用共享的正则表达式值时，这些对lastIndex属性的自动更新可能会引发问题。你的正则表达式可能会意外地从上一次调用留下的索引开始。
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Another interesting effect of the global option is that it changes the way the
    match method on strings works. When called with a global expression, instead of
    returning an array similar to that returned by exec, match will find *all* matches
    of the pattern in the string and return an array containing the matched strings.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 全局选项的另一个有趣效果是它改变了字符串上match方法的工作方式。当使用全局表达式调用时，match不会返回与exec返回的数组类似的结果，而是会找到字符串中模式的*所有*匹配，并返回一个包含匹配字符串的数组。
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So be cautious with global regular expressions. The cases where they are necessary—calls
    to replace and places where you want to explicitly use lastIndex—are typically
    the only situations where you want to use them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请谨慎使用全局正则表达式。它们必要的情况——调用replace和希望显式使用lastIndex的地方——通常是你想使用它们的唯一情况。
- en: A common thing to do is to find all the matches of a regular expression in a
    string. We can do this by using the matchAll method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是查找字符串中正则表达式的所有匹配。我们可以通过使用matchAll方法来实现。
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method returns an array of match arrays. The regular expression given to
    matchAll *must* have g enabled.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个匹配数组的数组。传递给matchAll的正则表达式*必须*启用g选项。
- en: Parsing an INI File
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析INI文件
- en: 'To conclude the chapter, we’ll look at a problem that calls for regular expressions.
    Imagine we are writing a program to automatically collect information about our
    enemies from the internet. (We will not actually write that program here, just
    the part that reads the configuration file. Sorry.) The configuration file looks
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这一章，我们将看一个需要正则表达式的问题。假设我们正在编写一个程序，以自动从互联网上收集有关我们敌人的信息。（我们在这里不会实际编写那个程序，只是读取配置文件的部分。抱歉。）配置文件看起来像这样：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The exact rules for this format—which is a widely used file format, usually
    called an *INI* file—are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式的确切规则——它是一种广泛使用的文件格式，通常称为*INI*文件——如下所示：
- en: Blank lines and lines starting with semicolons are ignored.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空行和以分号开头的行会被忽略。
- en: Lines wrapped in [ and ] start a new section.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用[和]包裹的行开始一个新节。
- en: Lines containing an alphanumeric identifier followed by an = character add a
    setting to the current section.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含字母数字标识符后跟=字符的行会为当前节添加一个设置。
- en: Anything else is invalid.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他任何情况都是无效的。
- en: Our task is to convert a string like this into an object whose properties hold
    strings for settings written before the first section header and subobjects for
    sections, with those subobjects holding the section’s settings.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是将像这样的字符串转换为一个对象，该对象的属性包含在第一个节标题之前写的设置字符串，而子对象则用于节，其中这些子对象包含该节的设置。
- en: Since the format has to be processed line by line, splitting up the file into
    separate lines is a good start. We saw the split method in [Chapter 4](ch04.xhtml#ch04).
    Some operating systems, however, use not just a newline character to separate
    lines but a carriage return character followed by a newline (”\r\n”). Given that
    the split method also allows a regular expression as its argument, we can use
    a regular expression like /\r?\n/ to split in a way that allows both ”\n” and
    “\r\n” between lines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于格式必须逐行处理，将文件拆分成单独的行是一个良好的开始。我们在[第 4 章](ch04.xhtml#ch04)中看到了 split 方法。然而，一些操作系统不仅使用换行符来分隔行，还使用回车符后跟换行符（“\r\n”）。考虑到
    split 方法也允许使用正则表达式作为参数，我们可以使用像 `/\r?\n/` 这样的正则表达式，以便在行之间支持“\n”和“\r\n”。
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code goes over the file’s lines and builds up an object. Properties at the
    top are stored directly into that object, whereas properties found in sections
    are stored in a separate section object. The section binding points at the object
    for the current section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遍历文件的行并构建一个对象。顶部的属性直接存储到该对象中，而在节中找到的属性则存储在单独的节对象中。节绑定指向当前节的对象。
- en: There are two kinds of significant lines—section headers or property lines.
    When a line is a regular property, it is stored in the current section. When it
    is a section header, a new section object is created, and section is set to point
    at it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种重要的行——节标题或属性行。当一行是常规属性时，它存储在当前节中。当它是节标题时，会创建一个新的节对象，并将节设置为指向它。
- en: Note the recurring use of ^ and $ to make sure the expression matches the whole
    line, not just part of it. Leaving these out results in code that mostly works
    but behaves strangely for some input, which can be a difficult bug to track down.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 ^ 和 $ 的重复使用，以确保表达式匹配整行，而不仅仅是部分内容。省略这些将导致代码在大多数情况下工作，但对于某些输入表现得很奇怪，这可能是一个难以追踪的错误。
- en: The pattern if (match = *string*.match(...)) makes use of the fact that the
    value of an assignment expression (=) is the assigned value. You often aren’t
    sure that your call to match will succeed, so you can access the resulting object
    only inside an if statement that tests for this. To not break the pleasant chain
    of else if forms, we assign the result of the match to a binding and immediately
    use that assignment as the test for the if statement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模式 `if (match = *string*.match(...))` 利用赋值表达式（=）的值是被赋值的事实。你通常不能确定你的 match 调用是否会成功，因此你只能在测试此的
    if 语句内部访问结果对象。为了不打破愉快的 else if 形式的链，我们将匹配结果分配给一个绑定，并立即将该赋值作为 if 语句的测试。
- en: If a line is not a section header or a property, the function checks whether
    it is a comment or an empty line using the expression /^\s*(;|$)/ to match lines
    that contain either only whitespace, or whitespace followed by a semicolon (making
    the rest of the line a comment). When a line doesn’t match any of the expected
    forms, the function throws an exception.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一行不是节标题或属性，函数会使用表达式 `/^\s*(;|$)/` 检查它是否是注释或空行，以匹配仅包含空白或空白后跟分号的行（使该行的其余部分成为注释）。当一行不匹配任何预期形式时，函数会抛出异常。
- en: Code Units and Characters
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码单元和字符
- en: Another design mistake that’s been standardized in JavaScript regular expressions
    is that by default, operators like . or ? work on code units (as discussed in
    [Chapter 5](ch05.xhtml#ch05)), not actual characters. This means characters that
    are composed of two code units behave strangely.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 正则表达式中，一个被标准化的设计错误是，默认情况下，像 . 或 ? 这样的运算符是作用于代码单元（如[第 5 章](ch05.xhtml#ch05)所讨论），而不是实际字符。这意味着由两个代码单元组成的字符表现得很奇怪。
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The problem is that the ![Image](../images/apple.jpg) in the first line is treated
    as two code units, and {3} is applied only to the second unit. Similarly, the
    dot matches a single code unit, not the two that make up the rose emoji.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，第一行中的 ![Image](../images/apple.jpg) 被视为两个代码单元，而 {3} 仅应用于第二个单元。类似地，点只匹配单个代码单元，而不是组成玫瑰表情的两个代码单元。
- en: You must add the u (Unicode) option to your regular expression to make it treat
    such characters properly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在正则表达式中添加 u（Unicode）选项，以使其正确处理此类字符。
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Regular expressions are objects that represent patterns in strings. They use
    their own language to express these patterns.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是表示字符串中模式的对象。它们使用自己的语言来表达这些模式。
- en: '| /abc/ | A sequence of characters |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| /abc/ | 一串字符 |'
- en: '| /[abc]/ | Any character from a set of characters |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| /[abc]/ | 字符集中的任意字符 |'
- en: '| /[^abc]/ | Any character *not* in a set of characters |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| /[^abc]/ | 不在字符集中的任意字符 |'
- en: '| /[0-9]/ | Any character in a range of characters |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| /[0-9]/ | 范围内的任意字符 |'
- en: '| /x+/ | One or more occurrences of the pattern x |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| /x+/ | x模式的一个或多个出现 |'
- en: '| /x+?/ | One or more occurrences, nongreedy |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| /x+?/ | 一个或多个出现，非贪婪 |'
- en: '| /x*/ | Zero or more occurrences |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| /x*/ | 零个或多个出现 |'
- en: '| /x?/ | Zero or one occurrence |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| /x?/ | 零个或一个出现 |'
- en: '| /x{2,4}/ | Two to four occurrences |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| /x{2,4}/ | 两到四个出现 |'
- en: '| /(abc)/ | A group |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| /(abc)/ | 一个分组 |'
- en: '| /a&#124;b&#124;c/ | Any one of several patterns |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| /a&#124;b&#124;c/ | 几个模式中的任意一个 |'
- en: '| /\d/ | Any digit character |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| /\d/ | 任意数字字符 |'
- en: '| /\w/ | An alphanumeric character (“word character”) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| /\w/ | 一个字母数字字符（“单词字符”） |'
- en: '| /\s/ | Any whitespace character |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| /\s/ | 任意空白字符 |'
- en: '| /./ | Any character except newlines |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| /./ | 除换行符外的任意字符 |'
- en: '| /\p{L}/u | Any letter character |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| /\p{L}/u | 任意字母字符 |'
- en: '| /^/ | Start of input |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| /^/ | 输入的开始 |'
- en: '| /$/ | End of input |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| /$/ | 输入的结束 |'
- en: '| /(?=a)/ | A look-ahead test |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| /(?=a)/ | 前瞻测试 |'
- en: A regular expression has a method test to test whether a given string matches
    it. It also has a method exec that, when a match is found, returns an array containing
    all matched groups. Such an array has an index property that indicates where the
    match started.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式有一个 test 方法用于测试给定字符串是否与其匹配。还有一个 exec 方法，当找到匹配时返回一个包含所有匹配组的数组。这样的数组有一个 index
    属性，指示匹配开始的位置。
- en: Strings have a match method to match them against a regular expression and a
    search method to search for one, returning only the starting position of the match.
    Their replace method can replace matches of a pattern with a replacement string
    or function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串具有一个匹配方法，可以将其与正则表达式进行匹配，还有一个搜索方法用于查找匹配，只返回匹配的起始位置。它们的替换方法可以将模式的匹配替换为一个替换字符串或函数。
- en: Regular expressions can have options, which are written after the closing slash.
    The i option makes the match case insensitive. The g option makes the expression
    *global*, which, among other things, causes the replace method to replace all
    instances instead of just the first. The y option makes an expression sticky,
    which means that it will not search ahead and skip part of the string when looking
    for a match. The u option turns on Unicode mode, which enables \p syntax and fixes
    a number of problems around the handling of characters that take up two code units.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以有选项，这些选项在关闭斜杠后书写。i 选项使匹配不区分大小写。g 选项使表达式*全局*，这意味着替换方法将替换所有实例，而不仅仅是第一个。y
    选项使表达式具有粘性，这意味着在寻找匹配时不会向前搜索并跳过字符串的一部分。u 选项启用 Unicode 模式，允许使用 \p 语法，并修复了一些关于处理占用两个代码单元的字符的问题。
- en: Regular expressions are a sharp tool with an awkward handle. They simplify some
    tasks tremendously but can quickly become unmanageable when applied to complex
    problems. Part of knowing how to use them is resisting the urge to try to shoehorn
    things into them that they cannot cleanly express.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个锐利的工具，使用起来却有些笨拙。它们极大地简化了一些任务，但在应用于复杂问题时，很快就会变得难以管理。了解如何使用它们的一部分是抵制将无法清晰表达的内容强行塞入其中的冲动。
- en: Exercises
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: It is almost unavoidable that, in the course of working on these exercises,
    you will get confused and frustrated by some regular expression’s inexplicable
    behavior. Sometimes it helps to enter your expression into an online tool like
    *[https://www.debuggex.com](https://www.debuggex.com)* to see whether its visualization
    corresponds to what you intended and to experiment with the way it responds to
    various input strings.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这些练习时，你几乎无法避免会对某些正则表达式的莫名行为感到困惑和沮丧。有时候，将你的表达式输入到一个像 *[https://www.debuggex.com](https://www.debuggex.com)*
    的在线工具中，可以帮助你查看其可视化效果是否与你的意图一致，并尝试它对各种输入字符串的响应。
- en: '*Regexp Golf*'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*正则表达式高尔夫*'
- en: '*Code golf* is a term used for the game of trying to express a particular program
    in as few characters as possible. Similarly, *regexp golf* is the practice of
    writing as tiny a regular expression as possible to match a given pattern and
    *only* that pattern.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码高尔夫* 是一个术语，用于描述尽可能少字符表达特定程序的游戏。同样，*正则表达式高尔夫* 是一种实践，旨在写出尽可能小的正则表达式以匹配给定模式，并且*仅*匹配该模式。'
- en: For each of the following items, write a regular expression to test whether
    the given pattern occurs in a string. The regular expression should match only
    strings containing the pattern. When your expression works, see whether you can
    make it any smaller.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每一项，写一个正则表达式来测试给定模式是否出现在字符串中。正则表达式应该只匹配包含该模式的字符串。当你的表达式工作时，看看能否让它更小。
- en: '*car* and *cat*'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*车* 和 *猫*'
- en: '*pop* and *prop*'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*流行* 和 *道具*'
- en: '*ferret*, *ferry*, and *ferrari*'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*雪貂*、*渡船*和 *法拉利*'
- en: Any word ending in *ious*
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何以 *ious* 结尾的单词
- en: A whitespace character followed by a period, comma, colon, or semicolon
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个空白字符后跟一个句号、逗号、冒号或分号
- en: A word longer than six letters
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个超过六个字母的单词
- en: A word without the letter *e* (or *E*)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个不包含字母 *e*（或 *E*）的单词
- en: Refer to the table in the chapter summary for help. Test each solution with
    a few test strings.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 参考章节总结中的表格以获得帮助。用几个测试字符串测试每个解决方案。
- en: '*Quoting Style*'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*引号风格*'
- en: Imagine you have written a story and used single quotation marks throughout
    to mark pieces of dialogue. Now you want to replace all the dialogue quotes with
    double quotes, while keeping the single quotes used in contractions like *aren’t*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你写了一篇故事，并且在整个故事中使用单引号来标记对话的片段。现在你想将所有对话的引号替换为双引号，同时保留在缩写中使用的单引号，比如 *aren’t*。
- en: Think of a pattern that distinguishes these two kinds of quote usage and craft
    a call to the replace method that does the proper replacement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 想出一个模式来区分这两种引号的用法，并编写一个调用替换方法的代码来进行正确的替换。
- en: '*Numbers Again*'
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*数字再谈*'
- en: Write an expression that matches only JavaScript-style numbers. It must support
    an optional minus *or* plus sign in front of the number, the decimal dot, and
    exponent notation—5e-3 or 1E10—again with an optional sign in front of the exponent.
    Also note that it is not necessary for there to be digits in front of or after
    the dot, but the number cannot be a dot alone. That is, .5 and 5. are valid JavaScript
    numbers, but a lone dot isn’t.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 写一个只匹配 JavaScript 风格数字的表达式。它必须支持在数字前的可选负号 *或* 正号，十进制点，以及指数表示法——5e-3 或 1E10——同样在指数前也有可选符号。另外，请注意，点前后不需要有数字，但数字不能仅仅是一个点。也就是说，.5
    和 5. 是有效的 JavaScript 数字，但一个孤立的点不是。
- en: '*Write code that is easy to delete, not easy to extend.*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*编写易于删除的代码，而不是易于扩展的代码。*'
- en: —Tef, *programming is terrible*
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: —Tef，*编程是可怕的*
- en: '![Image](../images/f0162-01.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0162-01.jpg)'
