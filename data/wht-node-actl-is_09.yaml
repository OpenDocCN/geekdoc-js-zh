- en: Buffer Fragmentation and Challenges
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¼“å†²åŒºç¢ç‰‡åŒ–å’ŒæŒ‘æˆ˜
- en: åŸæ–‡ï¼š[https://www.thenodebook.com/buffers/fragmentation-and-challenges](https://www.thenodebook.com/buffers/fragmentation-and-challenges)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://www.thenodebook.com/buffers/fragmentation-and-challenges](https://www.thenodebook.com/buffers/fragmentation-and-challenges)
- en: âš ï¸Warning
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸è­¦å‘Š
- en: You've received an early-access to this chapter. Your feedback is invaluable,
    so please share your thoughts in the comment section at the bottom or in [GitHub
    discussions](https://github.com/ishtms/nodebook).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å·²ç»æå‰è·å¾—äº†è¿™ä¸€ç« èŠ‚çš„å†…å®¹ã€‚ä½ çš„åé¦ˆéå¸¸å®è´µï¼Œè¯·åœ¨ä¸‹é¢çš„è¯„è®ºéƒ¨åˆ†æˆ–[GitHubè®¨è®º](https://github.com/ishtms/nodebook)ä¸­åˆ†äº«ä½ çš„æƒ³æ³•ã€‚
- en: Alright, we've covered a lot of ground. You now have a solid mental model of
    what a `Buffer` is, where it lives in memory, and the critical distinction between
    a view and a copy. You've seen the raw power of zero-copy operations and the leaks
    they can cause if you're not careful. We've talked about the internal buffer pool
    and how Node.js cleverly optimizes small, frequent allocations to avoid the performance
    penalty of constant system calls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œæˆ‘ä»¬å·²ç»è¦†ç›–äº†å¾ˆå¤šå†…å®¹ã€‚ä½ ç°åœ¨å¯¹`Buffer`æœ‰ä¸€ä¸ªç¨³å›ºçš„å¿ƒç†æ¨¡å‹ï¼ŒçŸ¥é“å®ƒåœ¨å†…å­˜ä¸­çš„ä½ç½®ï¼Œä»¥åŠè§†å›¾å’Œå‰¯æœ¬ä¹‹é—´çš„å…³é”®åŒºåˆ«ã€‚ä½ çœ‹åˆ°äº†é›¶æ‹·è´æ“ä½œçš„åŸå§‹åŠ›é‡ï¼Œä»¥åŠå¦‚æœä½ ä¸å°å¿ƒå¯èƒ½ä¼šé€ æˆçš„æ³„æ¼ã€‚æˆ‘ä»¬è®¨è®ºäº†å†…éƒ¨ç¼“å†²æ± ä»¥åŠNode.jså¦‚ä½•å·§å¦™åœ°ä¼˜åŒ–å°è€Œé¢‘ç¹çš„åˆ†é…ï¼Œä»¥é¿å…é¢‘ç¹ç³»ç»Ÿè°ƒç”¨å¸¦æ¥çš„æ€§èƒ½æƒ©ç½šã€‚
- en: 'This chapter is where it all comes together. We''re going to dive deep into
    a classic, low-level problem that most JavaScript developers never have to think
    about: **memory fragmentation**. It''s an issue that feels abstract until it crashes
    your production server, even when your monitoring dashboards swear you have plenty
    of RAM available. We''ll dissect what it is, why it happens, and how Node''s memory
    architecture both helps and sometimes hinders the situation.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ˜¯æ‰€æœ‰å†…å®¹æ±‡èšçš„åœ°æ–¹ã€‚æˆ‘ä»¬å°†æ·±å…¥æ¢è®¨ä¸€ä¸ªç»å…¸ä¸”ä½çº§çš„é—®é¢˜ï¼Œå¤§å¤šæ•°JavaScriptå¼€å‘è€…ä»æœªéœ€è¦è€ƒè™‘ï¼š**å†…å­˜ç¢ç‰‡åŒ–**ã€‚è¿™æ˜¯ä¸€ä¸ªæ„Ÿè§‰æŠ½è±¡çš„é—®é¢˜ï¼Œç›´åˆ°å®ƒè®©ä½ çš„ç”Ÿäº§æœåŠ¡å™¨å´©æºƒï¼Œå³ä½¿ä½ çš„ç›‘æ§ä»ªè¡¨æ¿æ˜¾ç¤ºä½ æœ‰è¶³å¤Ÿçš„RAMå¯ç”¨ã€‚æˆ‘ä»¬å°†å‰–æå®ƒæ˜¯å¦‚ä½•å‘ç”Ÿçš„ï¼Œä¸ºä»€ä¹ˆä¼šå‘ç”Ÿï¼Œä»¥åŠNodeçš„å†…å­˜æ¶æ„å¦‚ä½•æ—¢å¸®åŠ©åˆæœ‰æ—¶é˜»ç¢è¿™ç§æƒ…å†µã€‚
- en: Then, we're shifting gears. The second, larger part of this chapter is dedicated
    to a bunch of comprehensive code challenges. This chapter is about taking everything
    we've discussed - from byte-level interpretation and endianness to the view-vs-copy
    trade-off and buffer pooling - and applying it to solve real-world problems. You'll
    build a binary protocol parser, profile memory usage to see the leaks for yourself,
    implement a stateful stream processor, and even construct your own application-level
    buffer pool.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å°†è½¬æ¢æ–¹å‘ã€‚æœ¬ç« çš„ç¬¬äºŒéƒ¨åˆ†ï¼Œæ›´å¤§çš„éƒ¨åˆ†ï¼Œè‡´åŠ›äºä¸€ç³»åˆ—ç»¼åˆæ€§çš„ä»£ç æŒ‘æˆ˜ã€‚æœ¬ç« æ˜¯å…³äºå°†æˆ‘ä»¬è®¨è®ºçš„æ‰€æœ‰å†…å®¹â€”â€”ä»å­—èŠ‚çº§è§£é‡Šå’Œå­—èŠ‚åºåˆ°è§†å›¾ä¸å‰¯æœ¬çš„æƒè¡¡ä»¥åŠç¼“å†²æ± â€”â€”åº”ç”¨åˆ°è§£å†³ç°å®ä¸–ç•Œçš„é—®é¢˜ã€‚ä½ å°†æ„å»ºä¸€ä¸ªäºŒè¿›åˆ¶åè®®è§£æå™¨ï¼Œåˆ†æå†…å­˜ä½¿ç”¨æƒ…å†µä»¥äº²è‡ªæŸ¥çœ‹æ³„æ¼ï¼Œå®ç°ä¸€ä¸ªæœ‰çŠ¶æ€çš„æµå¤„ç†å™¨ï¼Œç”šè‡³æ„å»ºä½ è‡ªå·±çš„åº”ç”¨çº§ç¼“å†²æ± ã€‚
- en: I'm not giving you the answers here. Reading is one thing; doing is another.
    By the end of this chapter, you won't just *know* about Buffers. You'll have the
    experience to prove you can wield them effectively, safely, and efficiently in
    a high-performance production environment, not just in Node.js but any other language
    that is thrown at you.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸ä¼šåœ¨è¿™é‡Œç»™ä½ ç­”æ¡ˆã€‚é˜…è¯»æ˜¯ä¸€å›äº‹ï¼›åšæ˜¯å¦ä¸€å›äº‹ã€‚åˆ°æœ¬ç« ç»“æŸæ—¶ï¼Œä½ ä¸ä»…ä¼š*çŸ¥é“*å…³äºç¼“å†²åŒºçš„å†…å®¹ã€‚ä½ å°†æ‹¥æœ‰è¯æ˜ä½ å¯ä»¥åœ¨é«˜æ€§èƒ½ç”Ÿäº§ç¯å¢ƒä¸­æœ‰æ•ˆã€å®‰å…¨ã€é«˜æ•ˆåœ°ä½¿ç”¨å®ƒä»¬çš„ç»éªŒï¼Œè€Œä¸ä»…ä»…æ˜¯Node.jsï¼Œè¿˜åŒ…æ‹¬ä»»ä½•å…¶ä»–æŠ›ç»™ä½ çš„è¯­è¨€ã€‚
- en: Memory Fragmentation
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å†…å­˜ç¢ç‰‡åŒ–
- en: ğŸ’¡Tip
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡æç¤º
- en: 'Want to dive deeper into memory fundamentals? Check out my blog post on [Memory:
    The Stack & Heap](https://www.ishtms.com/blog/basic-system-concepts/memory-stack-heap),
    where I cover everything from how RAM and virtual memory work, to stack frames
    and heap allocation, cache performance, common memory issues (leaks, dangling
    pointers, fragmentation), and why different languages choose different memory
    management strategies.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è¦æ·±å…¥äº†è§£å†…å­˜åŸºç¡€çŸ¥è¯†ï¼Ÿè¯·æŸ¥çœ‹æˆ‘çš„åšå®¢æ–‡ç« [å†…å­˜ï¼šæ ˆå’Œå †](https://www.ishtms.com/blog/basic-system-concepts/memory-stack-heap)ï¼Œå…¶ä¸­æˆ‘æ¶µç›–äº†ä»RAMå’Œè™šæ‹Ÿå†…å­˜çš„å·¥ä½œåŸç†ï¼Œåˆ°æ ˆå¸§å’Œå †åˆ†é…ï¼Œç¼“å­˜æ€§èƒ½ï¼Œå¸¸è§çš„å†…å­˜é—®é¢˜ï¼ˆæ³„æ¼ã€æ‚¬å‚æŒ‡é’ˆã€ç¢ç‰‡åŒ–ï¼‰ï¼Œä»¥åŠä¸ºä»€ä¹ˆä¸åŒçš„è¯­è¨€é€‰æ‹©ä¸åŒçš„å†…å­˜ç®¡ç†ç­–ç•¥ã€‚
- en: 'Memory fragmentation is one of the silent killers of long-running applications.
    The core concept is simple: your application''s memory becomes broken up into
    many small, non-contiguous chunks over time. The total amount of free memory might
    be large, but if it''s scattered in thousands of tiny pieces, it''s useless for
    satisfying a large allocation request. You can have 100MB of free RAM available
    to your process, but if you ask for a single 1MB buffer, the request can fail
    because there isn''t a single, unbroken 1MB block of free memory anywhere.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: å†…å­˜ç¢ç‰‡åŒ–æ˜¯é•¿æœŸè¿è¡Œåº”ç”¨ç¨‹åºçš„éšå½¢æ€æ‰‹ä¹‹ä¸€ã€‚å…¶æ ¸å¿ƒæ¦‚å¿µå¾ˆç®€å•ï¼šéšç€æ—¶é—´çš„æ¨ç§»ï¼Œä½ çš„åº”ç”¨ç¨‹åºçš„å†…å­˜è¢«åˆ†å‰²æˆè®¸å¤šå°è€Œåˆ†æ•£çš„å—ã€‚å°½ç®¡å¯ç”¨å†…å­˜æ€»é‡å¯èƒ½å¾ˆå¤§ï¼Œä½†å¦‚æœå®ƒè¢«åˆ†æ•£æˆæˆåƒä¸Šä¸‡çš„å¾®å°éƒ¨åˆ†ï¼Œå®ƒå¯¹äºæ»¡è¶³å¤§å‹åˆ†é…è¯·æ±‚å°±æ¯«æ— ç”¨å¤„ã€‚ä½ å¯èƒ½æœ‰ä¸€ä¸ª
    100MB çš„å¯ç”¨ RAM ä¾›ä½ çš„è¿›ç¨‹ä½¿ç”¨ï¼Œä½†å¦‚æœè¯·æ±‚ä¸€ä¸ªå•ç‹¬çš„ 1MB ç¼“å†²åŒºï¼Œè¯·æ±‚å¯èƒ½ä¼šå¤±è´¥ï¼Œå› ä¸ºæ²¡æœ‰ä¸€å—è¿ç»­çš„ 1MB å¯ç”¨å†…å­˜ã€‚
- en: To really get this, we have to talk about how the operating system gives memory
    to your Node.js process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è¦çœŸæ­£ç†è§£è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¿…é¡»è°ˆè°ˆæ“ä½œç³»ç»Ÿæ˜¯å¦‚ä½•å°†å†…å­˜åˆ†é…ç»™ Node.js è¿›ç¨‹çš„ã€‚
- en: Virtual vs. Physical Memory
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è™šæ‹Ÿå†…å­˜ä¸ç‰©ç†å†…å­˜
- en: Your Node.js process doesn't directly interact with your computer's physical
    RAM sticks. Instead, it operates within a **virtual address space**. This is a
    massive, contiguous address range that the operating system provides to every
    process. On a 64-bit system, this address space is huge - theoretically 16 exabytes.
    It's a clean, linear abstraction. When your code asks for memory, the OS finds
    a free chunk within this virtual address space and gives it to your process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„ Node.js è¿›ç¨‹å¹¶ä¸ç›´æ¥ä¸ä½ çš„è®¡ç®—æœºçš„ç‰©ç† RAM æ¡äº¤äº’ã€‚ç›¸åï¼Œå®ƒåœ¨ä¸€ä¸ª **è™šæ‹Ÿåœ°å€ç©ºé—´** å†…è¿è¡Œã€‚è¿™æ˜¯æ“ä½œç³»ç»Ÿä¸ºæ¯ä¸ªè¿›ç¨‹æä¾›çš„åºå¤§ã€è¿ç»­çš„åœ°å€èŒƒå›´ã€‚åœ¨
    64 ä½ç³»ç»Ÿä¸Šï¼Œè¿™ä¸ªåœ°å€ç©ºé—´éå¸¸å·¨å¤§â€”â€”ç†è®ºä¸Š 16 å…†å­—èŠ‚ã€‚è¿™æ˜¯ä¸€ä¸ªå¹²å‡€ã€çº¿æ€§çš„æŠ½è±¡ã€‚å½“ä½ çš„ä»£ç è¯·æ±‚å†…å­˜æ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šåœ¨è¿™ä¸ªè™šæ‹Ÿåœ°å€ç©ºé—´ä¸­æ‰¾åˆ°ä¸€ä¸ªç©ºé—²å—å¹¶å°†å…¶åˆ†é…ç»™ä½ çš„è¿›ç¨‹ã€‚
- en: Behind the scenes, the Memory Management Unit (MMU), a piece of hardware in
    your CPU, works with the OS to map these virtual addresses to actual physical
    addresses in RAM. This mapping happens in chunks called **pages**, which are typically
    4KB in size. This system is what allows for magic like swapping memory to disk
    and preventing processes from stomping on each other's memory.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¹•åï¼Œå†…å­˜ç®¡ç†å•å…ƒ (MMU)ï¼Œè¿™æ˜¯ä½  CPU ä¸­çš„ä¸€å—ç¡¬ä»¶ï¼Œä¸æ“ä½œç³»ç»Ÿåˆä½œå°†è¿™äº›è™šæ‹Ÿåœ°å€æ˜ å°„åˆ° RAM ä¸­çš„å®é™…ç‰©ç†åœ°å€ã€‚è¿™ç§æ˜ å°„å‘ç”Ÿåœ¨ç§°ä¸º **é¡µ**
    çš„å—ä¸­ï¼Œé€šå¸¸å¤§å°ä¸º 4KBã€‚è¿™ä¸ªç³»ç»Ÿå…è®¸åƒå°†å†…å­˜äº¤æ¢åˆ°ç£ç›˜ä¸Šå’Œé˜²æ­¢è¿›ç¨‹ç›¸äº’å¹²æ‰°è¿™æ ·çš„é­”æ³•ã€‚
- en: The important takeaway here is that when Node.js allocates a large buffer, it's
    asking the OS for a contiguous block of *virtual* memory. The OS then has the
    job of finding enough free *physical* memory pages to back that virtual allocation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œçš„é‡è¦å¯ç¤ºæ˜¯ï¼Œå½“ Node.js åˆ†é…ä¸€ä¸ªå¤§ç¼“å†²åŒºæ—¶ï¼Œå®ƒæ˜¯åœ¨å‘æ“ä½œç³»ç»Ÿè¯·æ±‚ä¸€ä¸ªè¿ç»­çš„ *è™šæ‹Ÿ* å†…å­˜å—ã€‚ç„¶åæ“ä½œç³»ç»Ÿæœ‰è´£ä»»æ‰¾åˆ°è¶³å¤Ÿçš„ç©ºé—² *ç‰©ç†*
    å†…å­˜é¡µæ¥æ”¯æŒè¿™ä¸ªè™šæ‹Ÿåˆ†é…ã€‚
- en: The Allocator's Dilemma
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: åˆ†é…å™¨çš„å›°å¢ƒ
- en: When you call `Buffer.alloc(65536)` to get a 64KB buffer for a file read, Node.js
    bypasses its internal 8KB pool. It needs to get this memory from the system. It
    does this via system calls like `mmap` on Linux/macOS or `VirtualAlloc` on Windows.
    The system's memory allocator (like `glibc`'s `malloc` on Linux) finds a suitable
    64KB block in your process's virtual address space and maps it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ è°ƒç”¨ `Buffer.alloc(65536)` æ¥è·å–ä¸€ä¸ªç”¨äºæ–‡ä»¶è¯»å–çš„ 64KB ç¼“å†²åŒºæ—¶ï¼ŒNode.js ä¼šç»•è¿‡å…¶å†…éƒ¨çš„ 8KB æ± ã€‚å®ƒéœ€è¦ä»ç³»ç»Ÿä¸­è·å–è¿™äº›å†…å­˜ã€‚å®ƒé€šè¿‡ç³»ç»Ÿè°ƒç”¨å¦‚
    Linux/macOS ä¸Šçš„ `mmap` æˆ– Windows ä¸Šçš„ `VirtualAlloc` æ¥å®ç°ã€‚ç³»ç»Ÿçš„å†…å­˜åˆ†é…å™¨ï¼ˆå¦‚ Linux ä¸Šçš„ `glibc`
    çš„ `malloc`ï¼‰åœ¨ä½ çš„è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„ 64KB å—å¹¶å°†å…¶æ˜ å°„ã€‚
- en: Now, your code processes the file, and eventually, that 64KB buffer is no longer
    referenced. The V8 garbage collector reclaims the JavaScript handle, and Node's
    C++ layer is notified to free the underlying memory. It calls `munmap` or `free`,
    returning that 64KB block to the system allocator.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä½ çš„ä»£ç å¤„ç†æ–‡ä»¶ï¼Œæœ€ç»ˆé‚£ä¸ª 64KB ç¼“å†²åŒºä¸å†è¢«å¼•ç”¨ã€‚V8 åƒåœ¾æ”¶é›†å™¨å›æ”¶äº† JavaScript å¤„ç†å™¨ï¼ŒNode çš„ C++ å±‚è¢«é€šçŸ¥é‡Šæ”¾åº•å±‚å†…å­˜ã€‚å®ƒè°ƒç”¨
    `munmap` æˆ– `free`ï¼Œå°†é‚£ä¸ª 64KB å—è¿”å›ç»™ç³»ç»Ÿåˆ†é…å™¨ã€‚
- en: The problem starts when your application does this thousands of times with buffers
    of varying sizes. This constant allocation and deallocation, especially with different
    sizes, is what chews up your memory space. It's like taking a whole sheet of paper,
    cutting out a 5-inch square, then a 2-inch square, then putting the 5-inch square
    back, then cutting out a 3-inch square. After a while, the paper is full of holes.
    You might have enough total paper left, but you can't cut out a new 6-inch square.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜å§‹äºä½ çš„åº”ç”¨ç¨‹åºå¤šæ¬¡ä½¿ç”¨ä¸åŒå¤§å°çš„ç¼“å†²åŒºè¿›è¡Œè¿™ç§æ“ä½œã€‚è¿™ç§æŒç»­çš„åˆ†é…å’Œé‡Šæ”¾ï¼Œå°¤å…¶æ˜¯ä¸åŒå¤§å°çš„ï¼Œæ¶ˆè€—äº†ä½ çš„å†…å­˜ç©ºé—´ã€‚è¿™å°±åƒæ‹¿ä¸€å¼ æ•´å¼ çº¸ï¼Œå‰ªä¸‹ä¸€ä¸ª 5
    è‹±å¯¸çš„æ­£æ–¹å½¢ï¼Œç„¶åæ˜¯ä¸€ä¸ª 2 è‹±å¯¸çš„æ­£æ–¹å½¢ï¼Œç„¶åæŠŠ 5 è‹±å¯¸çš„æ­£æ–¹å½¢æ”¾å›å»ï¼Œç„¶åå‰ªä¸‹ä¸€ä¸ª 3 è‹±å¯¸çš„æ­£æ–¹å½¢ã€‚è¿‡äº†ä¸€ä¼šå„¿ï¼Œçº¸ä¸Šæ»¡æ˜¯æ´ã€‚ä½ å¯èƒ½è¿˜æœ‰è¶³å¤Ÿçš„æ€»çº¸å¼ ï¼Œä½†ä½ æ— æ³•å‰ªå‡ºä¸€ä¸ªæ–°çš„
    6 è‹±å¯¸æ­£æ–¹å½¢ã€‚
- en: 'This leads to two types of fragmentation: **External Fragmentation** and **Internal
    Fragmentation.**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¼è‡´äº†ä¸¤ç§ç±»å‹çš„ç¢ç‰‡åŒ–ï¼š**å¤–éƒ¨ç¢ç‰‡åŒ–**å’Œ**å†…éƒ¨ç¢ç‰‡åŒ–**ã€‚
- en: '**External Fragmentation** is the scenario we''ve been describing. There is
    enough total free memory, but it''s divided into many non-contiguous blocks (holes).
    A new allocation request fails because no single hole is large enough. This is
    the primary concern for applications that allocate and free many large, non-pooled
    buffers.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å¤–éƒ¨ç¢ç‰‡åŒ–**æ˜¯æˆ‘ä»¬ä¸€ç›´åœ¨æè¿°çš„æƒ…å†µã€‚æ€»ç©ºé—²å†…å­˜è¶³å¤Ÿï¼Œä½†å®ƒè¢«åˆ†å‰²æˆè®¸å¤šéè¿ç»­çš„å—ï¼ˆç©ºæ´ï¼‰ã€‚æ–°çš„åˆ†é…è¯·æ±‚å¤±è´¥ï¼Œå› ä¸ºæ²¡æœ‰è¶³å¤Ÿå¤§çš„å•ä¸ªç©ºæ´æ¥æ»¡è¶³è¯·æ±‚ã€‚è¿™æ˜¯å¯¹åˆ†é…å’Œé‡Šæ”¾è®¸å¤šå¤§å‹ã€éæ± åŒ–ç¼“å†²åŒºçš„åº”ç”¨ç¨‹åºçš„ä¸»è¦å…³æ³¨ç‚¹ã€‚'
- en: '**Internal Fragmentation** is a more subtle problem. It happens when memory
    is allocated in fixed-size chunks, and an allocation request is satisfied by a
    chunk larger than the request. For example, if an allocator only deals in blocks
    of 32, 64, and 128 bytes, and you request 33 bytes, it will give you a 64-byte
    block. The remaining 31 bytes are wasted. They are allocated but unused - a hole
    *inside* your allocated block. Node''s internal 8KB buffer pool is a perfect example
    of a system that can cause internal fragmentation. If it satisfies hundreds of
    10-byte requests from its 8KB slab, a significant portion of that slab might be
    "wasted" in the gaps between allocations. However, this is a conscious trade-off
    made to prevent external fragmentation and reduce system call overhead, and it''s
    generally a very effective one.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å†…éƒ¨ç¢ç‰‡åŒ–**æ˜¯ä¸€ä¸ªæ›´å¾®å¦™çš„é—®é¢˜ã€‚å®ƒå‘ç”Ÿåœ¨å†…å­˜ä»¥å›ºå®šå¤§å°çš„å—åˆ†é…æ—¶ï¼Œä¸”ä¸€ä¸ªåˆ†é…è¯·æ±‚è¢«ä¸€ä¸ªæ¯”è¯·æ±‚æ›´å¤§çš„å—æ»¡è¶³ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªåˆ†é…å™¨åªå¤„ç†32ã€64å’Œ128å­—èŠ‚çš„å—ï¼Œè€Œä½ è¯·æ±‚33å­—èŠ‚ï¼Œå®ƒå°†ç»™ä½ ä¸€ä¸ª64å­—èŠ‚çš„å—ã€‚å‰©ä½™çš„31å­—èŠ‚è¢«æµªè´¹äº†ã€‚å®ƒä»¬è¢«åˆ†é…äº†ä½†æœªä½¿ç”¨â€”â€”è¿™æ˜¯ä½ åˆ†é…å—å†…éƒ¨çš„ä¸€ä¸ªç©ºæ´ã€‚Nodeçš„å†…éƒ¨8KBç¼“å†²æ± æ˜¯è¿™æ ·ä¸€ä¸ªå¯ä»¥å¯¼è‡´å†…éƒ¨ç¢ç‰‡åŒ–çš„ç³»ç»Ÿçš„å®Œç¾ä¾‹å­ã€‚å¦‚æœå®ƒä»å…¶8KBçš„slabä¸­æ»¡è¶³æ•°ç™¾ä¸ª10å­—èŠ‚çš„è¯·æ±‚ï¼Œé‚£ä¹ˆè¯¥slabçš„å¾ˆå¤§ä¸€éƒ¨åˆ†å¯èƒ½ä¼šåœ¨åˆ†é…ä¹‹é—´çš„é—´éš™ä¸­è¢«â€œæµªè´¹â€ã€‚ç„¶è€Œï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢å¤–éƒ¨ç¢ç‰‡åŒ–å’Œå‡å°‘ç³»ç»Ÿè°ƒç”¨å¼€é”€è€Œåšå‡ºçš„æœ‰æ„è¯†çš„æƒè¡¡ï¼Œå¹¶ä¸”é€šå¸¸æ˜¯éå¸¸æœ‰æ•ˆçš„ã€‚'
- en: Initial State
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åˆå§‹çŠ¶æ€
- en: Your process has a large, clean region of free virtual memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„è¿›ç¨‹æœ‰ä¸€ä¸ªå¤§å‹çš„å¹²å‡€åŒºåŸŸç©ºé—²è™šæ‹Ÿå†…å­˜ã€‚
- en: Node.js Runtime & V8 HeapF R E E M E M O R Y
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Node.jsè¿è¡Œæ—¶ & V8å †F R E E M E M O R Y
- en: Allocate a 1MB buffer for an image upload (bufA)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºå›¾åƒä¸Šä¼ åˆ†é…ä¸€ä¸ª1MBçš„ç¼“å†²åŒºï¼ˆbufAï¼‰
- en: RuntimebufA (1MB)F R E E
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œæ—¶bufA (1MB)F R E E
- en: Allocate a 512KB buffer for a video chunk (bufB)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºè§†é¢‘å—åˆ†é…ä¸€ä¸ª512KBçš„ç¼“å†²åŒºï¼ˆbufBï¼‰
- en: RuntimebufA (1MB)bufB (512KB)F R E E
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œæ—¶ç¼“å†²åŒºA (1MB)bufB (512KB)F R E E
- en: The image processing is done. Free bufA.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒå¤„ç†å·²å®Œæˆã€‚é‡Šæ”¾bufAã€‚
- en: RuntimeF R E E (1MB)bufB (512KB)F R E ELook at the memory now.We've created
    a 1MB **hole**. The total free memory is large, but it's split into two non-contiguous
    chunks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œæ—¶F R E E (1MB)bufB (512KB)F R E EæŸ¥çœ‹ç°åœ¨çš„å†…å­˜ã€‚æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª1MBçš„**ç©ºæ´**ã€‚æ€»ç©ºé—²å†…å­˜å¾ˆå¤§ï¼Œä½†å®ƒè¢«åˆ†å‰²æˆä¸¤ä¸ªéè¿ç»­çš„å—ã€‚
- en: '**A new request comes in, needing a 1.2MB buffer for a database dump.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¸€ä¸ªæ–°çš„è¯·æ±‚åˆ°æ¥ï¼Œéœ€è¦ä¸€ä¸ª1.2MBçš„ç¼“å†²åŒºæ¥æ‰§è¡Œæ•°æ®åº“è½¬å‚¨ã€‚**'
- en: The allocation fails. Even though you have well over 1.2MB of total free memory,
    there is no single block large enough to satisfy the request. This is external
    fragmentation in action. In a real server running for days, this process repeats
    thousands of times, leaving the memory space looking like Swiss cheese. Eventually,
    a critical allocation fails, and your application crashes with an `ENOMEM` (Out
    of Memory) error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ†é…å¤±è´¥ã€‚å°½ç®¡ä½ æœ‰è¶…è¿‡1.2MBçš„æ€»ç©ºé—²å†…å­˜ï¼Œä½†æ²¡æœ‰è¶³å¤Ÿå¤§çš„å•ä¸ªå—æ¥æ»¡è¶³è¯·æ±‚ã€‚è¿™æ˜¯å¤–éƒ¨ç¢ç‰‡åŒ–çš„å®é™…è¡¨ç°ã€‚åœ¨ä¸€ä¸ªè¿è¡Œæ•°å¤©çš„çœŸå®æœåŠ¡å™¨ä¸Šï¼Œè¿™ä¸ªè¿‡ç¨‹ä¼šé‡å¤æ•°åƒæ¬¡ï¼Œä½¿å†…å­˜ç©ºé—´çœ‹èµ·æ¥åƒç‘å£«å¥¶é…ªã€‚æœ€ç»ˆï¼Œä¸€ä¸ªå…³é”®çš„åˆ†é…å¤±è´¥ï¼Œä½ çš„åº”ç”¨ç¨‹åºä¼šå› `ENOMEM`ï¼ˆå†…å­˜ä¸è¶³ï¼‰é”™è¯¯è€Œå´©æºƒã€‚
- en: What can I do... ?
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æˆ‘èƒ½åšä»€ä¹ˆ...ï¼Ÿ
- en: The risk of fragmentation emerges when you work with buffers that are too large
    for the pool (larger than 4KB by default). If your application allocates and frees
    many large buffers of varying sizes, it's acting like a chaotic memory client.
    This churn is what gradually chops up the free memory available to your Node.js
    process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ å¤„ç†æ¯”æ± å¤§çš„ç¼“å†²åŒºï¼ˆé»˜è®¤æƒ…å†µä¸‹å¤§äº4KBï¼‰æ—¶ï¼Œç¢ç‰‡åŒ–çš„é£é™©å°±ä¼šå‡ºç°ã€‚å¦‚æœä½ çš„åº”ç”¨ç¨‹åºåˆ†é…å’Œé‡Šæ”¾äº†è®¸å¤šå¤§å°ä¸ä¸€çš„å¤§å‹ç¼“å†²åŒºï¼Œå®ƒå°±åƒä¸€ä¸ªæ··ä¹±çš„å†…å­˜å®¢æˆ·ç«¯ã€‚è¿™ç§ç¢ç‰‡æ˜¯é€æ¸åˆ†å‰²ä½ Node.jsè¿›ç¨‹å¯ç”¨ç©ºé—²å†…å­˜çš„åŸå› ã€‚
- en: So, how do you fight this? You can't change how the OS allocator works, but
    you can change how your application *behaves*. The key is to reduce memory churn.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œä½ å¦‚ä½•åº”å¯¹è¿™ä¸ªé—®é¢˜ï¼Ÿä½ ä¸èƒ½æ”¹å˜æ“ä½œç³»ç»Ÿåˆ†é…å™¨çš„å·¥ä½œæ–¹å¼ï¼Œä½†ä½ å¯ä»¥é€šè¿‡æ”¹å˜ä½ çš„åº”ç”¨ç¨‹åº*è¡Œä¸º*æ¥æ”¹å˜å®ƒã€‚å…³é”®æ˜¯å‡å°‘å†…å­˜ç¢ç‰‡ã€‚
- en: Buffer Reuse
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ç¼“å†²åŒºé‡ç”¨
- en: This is the single most powerful technique for reducing allocation churn. Instead
    of allocating a new buffer for every task, you allocate a single, larger buffer
    upfront and reuse it. This is especially critical in hot paths of your code, like
    inside a network `data` event handler or a tight loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å‡å°‘åˆ†é… churn çš„æœ€å¼ºå¤§æŠ€æœ¯ã€‚ä¸æ˜¯ä¸ºæ¯ä¸ªä»»åŠ¡åˆ†é…ä¸€ä¸ªæ–°çš„ç¼“å†²åŒºï¼Œè€Œæ˜¯é¢„å…ˆåˆ†é…ä¸€ä¸ªå•ä¸€ã€æ›´å¤§çš„ç¼“å†²åŒºå¹¶é‡å¤ä½¿ç”¨å®ƒã€‚è¿™åœ¨ä»£ç çš„çƒ­è·¯å¾„ä¸­å°¤ä¸ºé‡è¦ï¼Œæ¯”å¦‚åœ¨ç½‘ç»œçš„
    `data` äº‹ä»¶å¤„ç†ç¨‹åºå†…éƒ¨æˆ–ä¸€ä¸ªç´§å¯†çš„å¾ªç¯ä¸­ã€‚
- en: Let's imagine a server that processes incoming TCP packets. Each packet needs
    to be framed with a 4-byte length header.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æƒ³è±¡ä¸€ä¸ªå¤„ç†ä¼ å…¥ TCP æ•°æ®åŒ…çš„æœåŠ¡å™¨ã€‚æ¯ä¸ªæ•°æ®åŒ…éƒ½éœ€è¦ç”¨ 4 å­—èŠ‚é•¿åº¦å¤´è¿›è¡Œå°è£…ã€‚
- en: '**The Bad, High-Churn Approach**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¸è‰¯ã€é«˜ churn æ–¹æ³•**'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this server handles 10,000 packets per second, that's 20,000 buffer allocations
    per second (though Node's small-buffer pool may optimize some of these). The garbage
    collector will be working overtime, and the memory allocator will be struggling
    to keep up, leading to potential fragmentation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¿™ä¸ªæœåŠ¡å™¨æ¯ç§’å¤„ç† 10,000 ä¸ªæ•°æ®åŒ…ï¼Œé‚£ä¹ˆæ¯ç§’å°†æœ‰ 20,000 ä¸ªç¼“å†²åŒºåˆ†é…ï¼ˆå°½ç®¡ Node çš„å°ç¼“å†²æ± å¯èƒ½ä¼šä¼˜åŒ–å…¶ä¸­ä¸€äº›ï¼‰ã€‚åƒåœ¾æ”¶é›†å™¨å°†è¶…è´Ÿè·å·¥ä½œï¼Œå†…å­˜åˆ†é…å™¨å°†åŠªåŠ›è·Ÿä¸Šï¼Œå¯¼è‡´æ½œåœ¨çš„ç¢ç‰‡åŒ–ã€‚
- en: '**A Better, Reusable Approach**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ›´å¥½çš„ã€å¯é‡ç”¨æ–¹æ³•**'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this version, we've eliminated the large backing-memory allocations (from
    two per packet to zero per packet). While we do create a small Buffer wrapper
    object for the view, we've removed the expensive memory allocation and copying
    that `Buffer.concat` performs. The performance difference is significant.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬æ¶ˆé™¤äº†å¤§åç«¯å†…å­˜åˆ†é…ï¼ˆä»æ¯ä¸ªæ•°æ®åŒ…ä¸¤ä¸ªå‡å°‘åˆ°é›¶ï¼‰ã€‚è™½ç„¶æˆ‘ä»¬ç¡®å®ä¸ºè§†å›¾åˆ›å»ºäº†ä¸€ä¸ªå°çš„ Buffer åŒ…è£…å¯¹è±¡ï¼Œä½†æˆ‘ä»¬å·²ç»ç§»é™¤äº† `Buffer.concat`
    æ‰§è¡Œçš„æ˜‚è´µå†…å­˜åˆ†é…å’Œå¤åˆ¶ã€‚æ€§èƒ½å·®å¼‚æ˜¯æ˜¾è‘—çš„ã€‚
- en: '**Shared Memory Hazard**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**å…±äº«å†…å­˜é£é™©**'
- en: The optimization above has a **serious issue** that can cause data corruption
    if not handled correctly. The `framedPacketView` created by `subarray()` shares
    the underlying memory with `reusableBuffer`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°ä¼˜åŒ–æœ‰ä¸€ä¸ª**ä¸¥é‡é—®é¢˜**ï¼Œå¦‚æœä¸æ­£ç¡®å¤„ç†ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ•°æ®æŸåã€‚ç”± `subarray()` åˆ›å»ºçš„ `framedPacketView` ä¸ `reusableBuffer`
    å…±äº«åº•å±‚å†…å­˜ã€‚
- en: '**If `sendToNextService` is asyync** (which is typical for network operations,
    queuing systems, or pipelines), and you immediately handle the next packet, you''ll
    **overwrite the buffer contents while the previous consumer is still reading it**.
    This causes silent data corruption.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**å¦‚æœ `sendToNextService` æ˜¯å¼‚æ­¥çš„**ï¼ˆè¿™å¯¹äºç½‘ç»œæ“ä½œã€æ’é˜Ÿç³»ç»Ÿæˆ–ç®¡é“æ¥è¯´æ˜¯å…¸å‹çš„ï¼‰ï¼Œå¹¶ä¸”ä½ ç«‹å³å¤„ç†ä¸‹ä¸€ä¸ªæ•°æ®åŒ…ï¼Œä½ å°†åœ¨**å‰ä¸€ä¸ªæ¶ˆè´¹è€…ä»åœ¨è¯»å–æ—¶è¦†ç›–ç¼“å†²åŒºå†…å®¹**ã€‚è¿™ä¼šå¯¼è‡´æ•°æ®æŸåã€‚'
- en: This approach is only safe when the consumer uses the data synchronously before
    the function returns (rare), or you coordinate buffer lifetimes carefully.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åªæœ‰å½“æ¶ˆè´¹è€…åœ¨å‡½æ•°è¿”å›ä¹‹å‰åŒæ­¥ä½¿ç”¨æ•°æ®ï¼ˆå¾ˆå°‘è§ï¼‰ï¼Œæˆ–è€…ä½ ä»”ç»†åè°ƒç¼“å†²åŒºç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œè¿™ç§æ–¹æ³•æ‰æ˜¯å®‰å…¨çš„ã€‚
- en: '**Safer Alternative? A Buffer Pool**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆï¼Ÿç¼“å†²æ± **'
- en: 'For asynchronous consumers, use a ring buffer pool with multiple buffers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºå¼‚æ­¥æ¶ˆè´¹è€…ï¼Œä½¿ç”¨å…·æœ‰å¤šä¸ªç¼“å†²åŒºçš„ç¯å½¢ç¼“å†²æ± ï¼š
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The pool gives each in-flight packet its own distinct backing buffer, preventing
    overwrites as long as `POOL_SIZE` is large enough to accommodate your maximum
    concurrent operations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: æ± ä¸ºæ¯ä¸ªåœ¨é€”æ•°æ®åŒ…æä¾›å…¶è‡ªå·±çš„ç‹¬ç«‹åç«¯ç¼“å†²åŒºï¼Œåªè¦ `POOL_SIZE` è¶³å¤Ÿå¤§ä»¥å®¹çº³ä½ çš„æœ€å¤§å¹¶å‘æ“ä½œï¼Œå°±å¯ä»¥é˜²æ­¢è¦†ç›–ã€‚
- en: So, in case (you probably won't) ever run into the issue, how would you decide
    when to Use which approach -
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œåœ¨ï¼ˆä½ å¾ˆå¯èƒ½ä¸ä¼šï¼‰é‡åˆ°é—®é¢˜çš„å‰æä¸‹ï¼Œä½ å°†å¦‚ä½•å†³å®šä½•æ—¶ä½¿ç”¨å“ªç§æ–¹æ³• -
- en: '**Single reusable buffer** only if consumers are truly synchronous (very rare)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å•ä¸€å¯é‡ç”¨ç¼“å†²åŒº**ä»…å½“æ¶ˆè´¹è€…çœŸæ­£åŒæ­¥æ—¶ï¼ˆéå¸¸ç½•è§ï¼‰'
- en: '**Buffer pool** for asynchronous consumers with bounded concurrency'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç¼“å†²æ± **ç”¨äºå…·æœ‰æœ‰é™å¹¶å‘æ€§çš„å¼‚æ­¥æ¶ˆè´¹è€…'
- en: '**Copy to new buffer** if you can''t bound in-flight work, copy the data to
    a new buffer at send time (e.g., `Buffer.from(framedPacketView)`) - this costs
    an allocation per packet but is simple and safe'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ— æ³•é™åˆ¶åœ¨é€”å·¥ä½œï¼Œè¯·**å¤åˆ¶åˆ°æ–°ç¼“å†²åŒº**ï¼ˆä¾‹å¦‚ï¼Œ`Buffer.from(framedPacketView)`ï¼‰- è¿™ä¼šä¸ºæ¯ä¸ªæ•°æ®åŒ…åˆ†é…ä¸€æ¬¡ï¼Œä½†ç®€å•ä¸”å®‰å…¨ã€‚
- en: ğŸ“ŒImportant
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ“Œé‡è¦
- en: Node.js has an internal buffer pool for small allocations, so tiny buffers may
    already benefit from some optimization. You still pay CPU cost to copy bytes with
    `chunk.copy()` - you're trading allocation cost for CPU copy cost (usually worth
    it in GC-sensitive hot paths)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js æœ‰ä¸€ä¸ªç”¨äºå°åˆ†é…çš„å†…éƒ¨ç¼“å†²æ± ï¼Œå› æ­¤å¾®å°çš„ç¼“å†²åŒºå¯èƒ½å·²ç»ä»æŸäº›ä¼˜åŒ–ä¸­å—ç›Šã€‚ä½ ä»ç„¶éœ€è¦ä¸º `chunk.copy()` å¤åˆ¶å­—èŠ‚æ”¯ä»˜ CPU
    æˆæœ¬ - ä½ æ˜¯åœ¨äº¤æ¢åˆ†é…æˆæœ¬å’Œ CPU å¤åˆ¶æˆæœ¬ï¼ˆé€šå¸¸åœ¨ GC æ•æ„Ÿçš„çƒ­è·¯å¾„ä¸­æ˜¯å€¼å¾—çš„ï¼‰ã€‚
- en: The key takaway is - buffer reuse can dramatically improve performance, but
    shared memory requires careful lifetime management to avoid corruption.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®çš„æ”¶è·æ˜¯ - ç¼“å†²åŒºé‡ç”¨å¯ä»¥æ˜¾è‘—æé«˜æ€§èƒ½ï¼Œä½†å…±äº«å†…å­˜éœ€è¦ä»”ç»†çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ä»¥é¿å…æŸåã€‚
- en: Understanding fragmentation is about seeing `Buffer.alloc()` not as a cheap
    operation, but as a request that has a real cost, a cost that accumulates over
    the lifetime of a server. By consciously designing your application to reduce
    this churn through reuse and pooling, you can build systems that are not just
    fast, but stable and resilient enough to run for months or years without issue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ç†è§£ç¢ç‰‡åŒ–æ˜¯å°†`Buffer.alloc()`ä¸ä»…ä»…è§†ä¸ºä¸€ä¸ªä¾¿å®œçš„æ“ä½œï¼Œè€Œè§†ä¸ºä¸€ä¸ªå…·æœ‰å®é™…æˆæœ¬ã€åœ¨æœåŠ¡å™¨ç”Ÿå‘½å‘¨æœŸå†…ç´¯ç§¯æˆæœ¬çš„æ“ä½œã€‚é€šè¿‡æœ‰æ„è¯†åœ°è®¾è®¡ä½ çš„åº”ç”¨ç¨‹åºä»¥é€šè¿‡é‡ç”¨å’Œæ± åŒ–æ¥å‡å°‘è¿™ç§
    churnï¼Œä½ å¯ä»¥æ„å»ºä¸ä»…é€Ÿåº¦å¿«ï¼Œè€Œä¸”ç¨³å®šã€æœ‰å¼¹æ€§çš„ç³»ç»Ÿï¼Œå¯ä»¥åœ¨æ•°æœˆæˆ–æ•°å¹´å†…æ— é—®é¢˜åœ°è¿è¡Œã€‚
- en: Code Challenges
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä»£ç æŒ‘æˆ˜
- en: Theory is important, but there's no substitute for getting your hands dirty.
    I've created the challenges below to take the concepts from the previous chapters
    and force you to apply them in a practical context. Each challenge builds on the
    last, increasing in complexity and trying to be pretty close to the real-world
    problems you'll face when working with binary data in Node.js.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ç†è®ºå¾ˆé‡è¦ï¼Œä½†æ²¡æœ‰ä»€ä¹ˆèƒ½æ›¿ä»£äº²è‡ªåŠ¨æ‰‹ã€‚æˆ‘å·²ç»åˆ›å»ºäº†ä»¥ä¸‹æŒ‘æˆ˜ï¼Œä»¥ä¾¿å°†å‰å‡ ç« çš„æ¦‚å¿µåº”ç”¨åˆ°å®é™…ç¯å¢ƒä¸­ã€‚æ¯ä¸ªæŒ‘æˆ˜éƒ½å»ºç«‹åœ¨ä¸Šä¸€ä¸ªæŒ‘æˆ˜çš„åŸºç¡€ä¸Šï¼Œå¤æ‚æ€§å¢åŠ ï¼Œå¹¶è¯•å›¾å°½å¯èƒ½æ¥è¿‘ä½ åœ¨ä½¿ç”¨Node.jså¤„ç†äºŒè¿›åˆ¶æ•°æ®æ—¶å¯èƒ½é‡åˆ°çš„çœŸå®ä¸–ç•Œé—®é¢˜ã€‚
- en: I am not providing the solutions. The goal is for you to build them. Struggle
    with the code. Consult the Node.js documentation. The insights you gain from building
    a working solution yourself are worth far more than anything you can get from
    copy-pasting an answer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¸ä¼šæä¾›è§£å†³æ–¹æ¡ˆã€‚ç›®æ ‡æ˜¯è®©ä½ è‡ªå·±æ„å»ºå®ƒä»¬ã€‚ä¸ä»£ç æ–—äº‰ã€‚æŸ¥é˜…Node.jsæ–‡æ¡£ã€‚ä½ è‡ªå·±æ„å»ºä¸€ä¸ªæœ‰æ•ˆè§£å†³æ–¹æ¡ˆæ‰€è·å¾—çš„è§è§£æ¯”ä»å¤åˆ¶ç²˜è´´ç­”æ¡ˆä¸­è·å¾—çš„ä¸œè¥¿è¦å®è´µå¾—å¤šã€‚
- en: Let's begin.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å¼€å§‹ã€‚
- en: 'Challenge #1'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'æŒ‘æˆ˜ #1'
- en: 'Imagine you''re working on an IoT project. A fleet of sensors sends data packets
    over TCP to your Node.js server. The protocol is simple and fixed-size. Every
    packet is exactly 24 bytes long and has the following structure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡ä½ æ­£åœ¨åšä¸€ä¸ªç‰©è”ç½‘é¡¹ç›®ã€‚ä¸€ç»„ä¼ æ„Ÿå™¨é€šè¿‡TCPå°†æ•°æ®åŒ…å‘é€åˆ°ä½ çš„Node.jsæœåŠ¡å™¨ã€‚è¯¥åè®®ç®€å•ä¸”å›ºå®šå¤§å°ã€‚æ¯ä¸ªæ•°æ®åŒ…æ­£å¥½24å­—èŠ‚é•¿ï¼Œå…·æœ‰ä»¥ä¸‹ç»“æ„ï¼š
- en: '| Offset (Bytes) | Length (Bytes) | Data Type | Description |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| åç§»é‡ï¼ˆå­—èŠ‚ï¼‰ | é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰ | æ•°æ®ç±»å‹ | æè¿° |'
- en: '| --- | --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0-3 | 4 | `UInt32BE` | Sensor ID |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 0-3 | 4 | `UInt32BE` | ä¼ æ„Ÿå™¨ID |'
- en: '| 4-11 | 8 | `Float64BE` | Timestamp (Unix epoch, ms) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 4-11 | 8 | `Float64BE` | æ—¶é—´æˆ³ï¼ˆUnixçºªå…ƒï¼Œæ¯«ç§’ï¼‰ |'
- en: '| 12-13 | 2 | `UInt16BE` | Sensor Type Code |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 12-13 | 2 | `UInt16BE` | ä¼ æ„Ÿå™¨ç±»å‹ä»£ç  |'
- en: '| 14 | 1 | `UInt8` | Status Flags (a bitmask) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 1 | `UInt8` | çŠ¶æ€æ ‡å¿—ï¼ˆä½æ©ç ï¼‰|'
- en: '| 15 | 1 | `Int8` | Temperature (Â°C) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 1 | `Int8` | æ¸©åº¦ï¼ˆÂ°Cï¼‰ |'
- en: '| 16-19 | 4 | `Float32BE` | Humidity (%) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 16-19 | 4 | `Float32BE` | æ¹¿åº¦ï¼ˆ%ï¼‰ |'
- en: '| 20-23 | 4 | `Float32BE` | Pressure (kPa) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 20-23 | 4 | `Float32BE` | å‹åŠ›ï¼ˆkPaï¼‰ |'
- en: Your Task
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ä½ çš„ä»»åŠ¡
- en: Write a Node.js function called `parseSensorData` that accepts a 24-byte `Buffer`
    as input. The function should parse the buffer according to the specification
    above and return a JavaScript object with the decoded values.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªåä¸º`parseSensorData`çš„Node.jså‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ª24å­—èŠ‚çš„`Buffer`ä½œä¸ºè¾“å…¥ã€‚è¯¥å‡½æ•°åº”æ ¹æ®ä¸Šè¿°è§„èŒƒè§£æç¼“å†²åŒºï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å«è§£ç å€¼çš„JavaScriptå¯¹è±¡ã€‚
- en: Use this sample `Buffer` to test your function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æ­¤ç¤ºä¾‹`Buffer`æ¥æµ‹è¯•æ‚¨çš„å‡½æ•°ã€‚
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**The Goal**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®æ ‡**'
- en: 'Your `parseSensorData(samplePacket)` function should return an object that
    looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„`parseSensorData(samplePacket)`å‡½æ•°åº”è¯¥è¿”å›ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„å¯¹è±¡ï¼š
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: â„¹ï¸Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: Floating point precsion might cause slight variations in the last decimal places,
    which is normal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: æµ®ç‚¹ç²¾åº¦å¯èƒ½åœ¨æœ€åå‡ ä½å°æ•°ä¸Šé€ æˆè½»å¾®çš„å˜åŒ–ï¼Œè¿™æ˜¯æ­£å¸¸çš„ã€‚
- en: '**Things to Consider**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**éœ€è¦è€ƒè™‘çš„äº‹é¡¹**'
- en: Which `Buffer` methods will you need for each field? The method names are very
    descriptive.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ éœ€è¦å“ªäº›`Buffer`æ–¹æ³•æ¥å¤„ç†æ¯ä¸ªå­—æ®µï¼Ÿæ–¹æ³•åéå¸¸å…·æœ‰æè¿°æ€§ã€‚
- en: Pay close attention to the data types (`UInt`, `Int`, `Float64`/`Double`, `Float32`/`Float`)
    and the endianness (`BE` - Big Endian).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¯·å¯†åˆ‡å…³æ³¨æ•°æ®ç±»å‹ï¼ˆ`UInt`ã€`Int`ã€`Float64`/`Double`ã€`Float32`/`Float`ï¼‰å’Œå­—èŠ‚åºï¼ˆ`BE` - å¤§ç«¯ï¼‰ã€‚
- en: The offset for each read is critical. This is a fixed-size protocol, so the
    offsets are constant.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯æ¬¡è¯»å–çš„åç§»é‡è‡³å…³é‡è¦ã€‚è¿™æ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„åè®®ï¼Œå› æ­¤åç§»é‡æ˜¯å›ºå®šçš„ã€‚
- en: Good practice dictates you should validate the input buffer's length before
    attempting to parse it.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è‰¯å¥½çš„å®è·µè§„å®šï¼Œåœ¨å°è¯•è§£æä¹‹å‰ï¼Œä½ åº”è¯¥éªŒè¯è¾“å…¥ç¼“å†²åŒºçš„é•¿åº¦ã€‚
- en: 'Challenge #2'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'æŒ‘æˆ˜ #2'
- en: We've talked at length about the memory retention issue where a small `Buffer`
    view can hold a massive parent buffer hostage. It's time to prove it to yourself
    with code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»è¯¦ç»†è®¨è®ºäº†å†…å­˜ä¿ç•™é—®é¢˜ï¼Œå…¶ä¸­ä¸€ä¸ªå°å‹çš„`Buffer`è§†å›¾å¯ä»¥æ§åˆ¶ä¸€ä¸ªåºå¤§çš„çˆ¶ç¼“å†²åŒºã€‚ç°åœ¨æ˜¯æ—¶å€™ç”¨ä»£ç æ¥è¯æ˜è¿™ä¸€ç‚¹äº†ã€‚
- en: Your Task
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ä½ çš„ä»»åŠ¡
- en: 'Write a Node.js program that demonstrates and quantifies this memory leak.
    The script should perform two separate tests:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªNode.jsç¨‹åºæ¥æ¼”ç¤ºå’Œé‡åŒ–è¿™ç§å†…å­˜æ³„æ¼ã€‚è¯¥è„šæœ¬åº”æ‰§è¡Œä¸¤ä¸ªå•ç‹¬çš„æµ‹è¯•ï¼š
- en: '**The "View" Test**'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**â€œè§†å›¾â€æµ‹è¯•**'
- en: Allocate a single, large `Buffer` (e.g., 50MB).
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ†é…ä¸€ä¸ªå•ä¸ªã€å¤§`Buffer`ï¼ˆä¾‹å¦‚ï¼Œ50MBï¼‰ã€‚
- en: In a loop, create a large number of small *views* (e.g., 100,000 views of 16
    bytes each) from this large buffer using `buf.slice()` or `buf.subarray()` (preferred).
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å¾ªç¯ä¸­ï¼Œä½¿ç”¨`buf.slice()`æˆ–`buf.subarray()`ï¼ˆé¦–é€‰ï¼‰ä»è¿™ä¸ªå¤§ç¼“å†²åŒºåˆ›å»ºå¤§é‡å°çš„*è§†å›¾*ï¼ˆä¾‹å¦‚ï¼Œæ¯ä¸ª16å­—èŠ‚çš„100,000ä¸ªè§†å›¾ï¼‰ã€‚
- en: Store these views in an array so they are not garbage collected.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†è¿™äº›è§†å›¾å­˜å‚¨åœ¨æ•°ç»„ä¸­ï¼Œä»¥ä¾¿å®ƒä»¬ä¸ä¼šè¢«åƒåœ¾å›æ”¶ã€‚
- en: After the loop, log the memory usage using `process.memoryUsage()`. Pay close
    attention to the `external` property.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¾ªç¯ç»“æŸåï¼Œä½¿ç”¨`process.memoryUsage()`è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µã€‚è¯·å¯†åˆ‡å…³æ³¨`external`å±æ€§ã€‚
- en: '**The "Copy" Test**'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"Copy"æµ‹è¯•**'
- en: Allocate a single, large `Buffer` of the same size (50MB).
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ†é…ä¸€ä¸ªå¤§å°ç›¸åŒçš„å•ä¸ªã€å¤§`Buffer`ï¼ˆä¾‹å¦‚ï¼Œ50MBï¼‰ã€‚
- en: In a loop, create a large number of small *copies* (e.g., 100,000 copies of
    16 bytes each).
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å¾ªç¯ä¸­ï¼Œåˆ›å»ºå¤§é‡å°çš„*å‰¯æœ¬*ï¼ˆä¾‹å¦‚ï¼Œæ¯ä¸ª16å­—èŠ‚çš„100,000ä¸ªå‰¯æœ¬ï¼‰ã€‚
- en: Store these copies in an array.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†è¿™äº›å‰¯æœ¬å­˜å‚¨åœ¨æ•°ç»„ä¸­ã€‚
- en: After the loop, ensure the original large buffer is eligible for garbage collection
    and, if possible, invoke the GC.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¾ªç¯ç»“æŸåï¼Œç¡®ä¿åŸå§‹å¤§ç¼“å†²åŒºé€‚ç”¨äºåƒåœ¾å›æ”¶ï¼Œå¦‚æœå¯èƒ½ï¼Œè°ƒç”¨GCã€‚
- en: Log the memory usage again.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å†æ¬¡è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µã€‚
- en: '**The Goal**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®æ ‡**'
- en: Your script's output should show a dramatic difference in the `external` memory
    reported by `process.memoryUsage()` between the two tests. The "View" test's external
    memory should be slightly over 50MB, while the "Copy" test's external memory should
    be much smaller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨çš„è„šæœ¬è¾“å‡ºåº”æ˜¾ç¤ºä¸¤æ¬¡æµ‹è¯•ä¸­`process.memoryUsage()`æŠ¥å‘Šçš„`external`å†…å­˜å­˜åœ¨æ˜¾è‘—å·®å¼‚ã€‚ "View"æµ‹è¯•çš„å¤–éƒ¨å†…å­˜åº”ç•¥è¶…è¿‡50MBï¼Œè€Œ"Copy"æµ‹è¯•çš„å¤–éƒ¨å†…å­˜åº”å°å¾—å¤šã€‚
- en: '**Things to Consider**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**éœ€è¦è€ƒè™‘çš„äº‹é¡¹**'
- en: You'll need to run your script with the `--expose-gc` flag to be able to call
    `global.gc()`. This makes the results much more deterministic.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ‚¨éœ€è¦ä½¿ç”¨`--expose-gc`æ ‡å¿—è¿è¡Œæ‚¨çš„è„šæœ¬ï¼Œä»¥ä¾¿èƒ½å¤Ÿè°ƒç”¨`global.gc()`ã€‚è¿™ä½¿å¾—ç»“æœæ›´åŠ ç¡®å®šã€‚
- en: Why is the `external` value in `process.memoryUsage()` the most important metric
    for this experiment? What do `rss` and `heapUsed` represent?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆ`process.memoryUsage()`ä¸­çš„`external`å€¼æ˜¯è¿™ä¸ªå®éªŒæœ€é‡è¦çš„æŒ‡æ ‡ï¼Ÿ`rss`å’Œ`heapUsed`ä»£è¡¨ä»€ä¹ˆï¼Ÿ
- en: The total size of the copies is `100,000 * 16 bytes = 1.6MB`. Your result for
    the copy test should be in this ballpark.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¤åˆ¶çš„æ€»å¤§å°ä¸º`100,000 * 16å­—èŠ‚ = 1.6MB`ã€‚æ‚¨çš„å¤åˆ¶æµ‹è¯•ç»“æœåº”è¯¥åœ¨è¿™ä¸ªèŒƒå›´å†…ã€‚
- en: A helper function to format the byte counts into KB/MB will make your output
    much easier to read.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªå°†å­—èŠ‚æ•°æ ¼å¼åŒ–ä¸ºKB/MBçš„è¾…åŠ©å‡½æ•°å°†ä½¿æ‚¨çš„è¾“å‡ºæ›´å®¹æ˜“é˜…è¯»ã€‚
- en: 'Challenge #3'
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æŒ‘æˆ˜#3
- en: 'Your fixed-protocol from Challenge #1 was a success, but now you need to handle
    a more complex, variable-length protocol. This is common in network applications.
    You''ll be parsing a stream of messages formatted using a Type-Length-Value (TLV)
    encoding.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: æ‚¨åœ¨æŒ‘æˆ˜#1ä¸­ä½¿ç”¨çš„å›ºå®šåè®®æ˜¯æˆåŠŸçš„ï¼Œä½†ç°åœ¨æ‚¨éœ€è¦å¤„ç†ä¸€ä¸ªæ›´å¤æ‚ã€å¯å˜é•¿åº¦çš„åè®®ã€‚è¿™åœ¨ç½‘ç»œåº”ç”¨ä¸­å¾ˆå¸¸è§ã€‚æ‚¨å°†è§£æä½¿ç”¨ç±»å‹-é•¿åº¦-å€¼ï¼ˆTLVï¼‰ç¼–ç æ ¼å¼åŒ–çš„æ¶ˆæ¯æµã€‚
- en: The problem is, you're reading from a TCP stream. Data can arrive in arbitrary
    chunks. A single `data` event might contain multiple TLV messages, or just a partial
    message. Your parser needs to be stateful - it must hold onto partial data and
    wait for the rest of the message to arrive in the next chunk.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜åœ¨äºï¼Œæ‚¨æ­£åœ¨ä»TCPæµä¸­è¯»å–ã€‚æ•°æ®å¯ä»¥ä»¥ä»»æ„å—çš„å½¢å¼åˆ°è¾¾ã€‚å•ä¸ª`data`äº‹ä»¶å¯èƒ½åŒ…å«å¤šä¸ªTLVæ¶ˆæ¯ï¼Œæˆ–è€…åªæ˜¯ä¸€ä¸ªéƒ¨åˆ†æ¶ˆæ¯ã€‚æ‚¨çš„è§£æå™¨éœ€è¦æ˜¯çŠ¶æ€çš„
    - å®ƒå¿…é¡»ä¿ç•™éƒ¨åˆ†æ•°æ®å¹¶ç­‰å¾…ä¸‹ä¸€å—ä¸­åˆ°è¾¾çš„å…¶ä½™æ¶ˆæ¯ã€‚
- en: The Protocol Specification
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: åè®®è§„èŒƒ
- en: Each TLV message has a 3-byte header followed by a variable-length value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªTLVæ¶ˆæ¯éƒ½æœ‰ä¸€ä¸ª3å­—èŠ‚çš„å¤´éƒ¨ï¼Œåé¢è·Ÿç€ä¸€ä¸ªå¯å˜é•¿åº¦çš„å€¼ã€‚
- en: '| Offset (Bytes) | Length (Bytes) | Data Type | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| åç§»ï¼ˆå­—èŠ‚ï¼‰ | é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰ | æ•°æ®ç±»å‹ | æè¿° |'
- en: '| --- | --- | --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 1 | `UInt8` | Message **T**ype (a number from 1-255) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | `UInt8` | æ¶ˆæ¯**T**ypeï¼ˆ1-255ä¹‹é—´çš„æ•°å­—ï¼‰ |'
- en: '| 1-2 | 2 | `UInt16BE` | **L**ength of the value part in bytes (0-65535) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 1-2 | 2 | `UInt16BE` | å€¼éƒ¨åˆ†çš„é•¿åº¦ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼Œ0-65535ï¼‰ |'
- en: '| 3 to 3+L | L | `Buffer` | The **V**alue (payload) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 3åˆ°3+L | L | `Buffer` | **V**alueï¼ˆæœ‰æ•ˆè´Ÿè½½ï¼‰ |'
- en: '**Your Task**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä½ çš„ä»»åŠ¡**'
- en: â„¹ï¸Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: The [next chapter of **NodeBook** covers Streams](https://thenodebook.com/streams/intro-to-streams).
    If you haven't worked with Streams in Node or don't feel comfortable with them,
    feel free to skip this challenge. If you do want to continue, please read the
    Streams chapter before attempting the challenge. The introductory Streams chapter
    will be published before the challenges go live.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[NodeBookçš„ä¸‹ä¸€ç« æ¶µç›–äº†æµ](https://thenodebook.com/streams/intro-to-streams)ã€‚å¦‚æœæ‚¨è¿˜æ²¡æœ‰åœ¨Nodeä¸­ä½¿ç”¨æµæˆ–è€…å¯¹å®ƒä»¬ä¸ç†Ÿæ‚‰ï¼Œè¯·éšæ„è·³è¿‡è¿™ä¸ªæŒ‘æˆ˜ã€‚å¦‚æœæ‚¨æƒ³ç»§ç»­ï¼Œè¯·åœ¨å°è¯•æŒ‘æˆ˜ä¹‹å‰é˜…è¯»æµçš„ç« èŠ‚ã€‚ç®€ä»‹æ€§æµçš„ç« èŠ‚å°†åœ¨æŒ‘æˆ˜ä¸Šçº¿ä¹‹å‰å‘å¸ƒã€‚'
- en: 'Create a `TlvParser` class that extends `stream.Transform`. This class will
    be the core of your solution. It needs to:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªæ‰©å±•`stream.Transform`çš„`TlvParser`ç±»ã€‚è¿™ä¸ªç±»å°†æ˜¯ä½ çš„è§£å†³æ–¹æ¡ˆçš„æ ¸å¿ƒã€‚å®ƒéœ€è¦ï¼š
- en: Maintain an internal buffer for incomplete message chunks.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ç»´æŠ¤ä¸€ä¸ªç”¨äºä¸å®Œæ•´æ¶ˆæ¯å—çš„å†…éƒ¨ç¼“å†²åŒºã€‚
- en: In its `_transform` method, append incoming data to the internal buffer.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åœ¨å…¶`_transform`æ–¹æ³•ä¸­ï¼Œå°†ä¼ å…¥çš„æ•°æ®è¿½åŠ åˆ°å†…éƒ¨ç¼“å†²åŒºã€‚
- en: Continuously try to parse complete TLV messages from its internal buffer.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä¸æ–­å°è¯•ä»å…¶å†…éƒ¨ç¼“å†²åŒºä¸­è§£æå®Œæ•´çš„TLVæ¶ˆæ¯ã€‚
- en: If a full message is parsed, it should `push` a JavaScript object `{ type, value
    }` downstream. The `value` should be a *copy* of the payload buffer.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å¦‚æœä¸€æ¡å®Œæ•´çš„æ¶ˆæ¯è¢«è§£æï¼Œå®ƒåº”è¯¥å°†ä¸€ä¸ªJavaScriptå¯¹è±¡`{ type, value }`æ¨é€åˆ°ä¸‹æ¸¸ã€‚`value`åº”è¯¥æ˜¯æœ‰æ•ˆè½½è·ç¼“å†²åŒºçš„å‰¯æœ¬ã€‚
- en: The remaining unparsed data must be kept in the internal buffer for the next
    chunk.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å‰©ä½™æœªè§£æçš„æ•°æ®å¿…é¡»ä¿ç•™åœ¨å†…éƒ¨ç¼“å†²åŒºä¸­ï¼Œä»¥ä¾›ä¸‹ä¸€ä¸ªæ•°æ®å—ä½¿ç”¨ã€‚
- en: '**Sample Data Stream**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç¤ºä¾‹æ•°æ®æµ**'
- en: The data will arrive in chunks. Here's an example sequence -
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®å°†ä»¥å—çš„å½¢å¼åˆ°è¾¾ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªç¤ºä¾‹åºåˆ— -
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**The Goal**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®æ ‡**'
- en: When you pipe these chunks through an instance of your `TlvParser`, it should
    emit two `data` events, producing these objects in order -
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ å°†è¿™äº›æ•°æ®å—é€šè¿‡ä½ çš„`TlvParser`å®ä¾‹æ—¶ï¼Œå®ƒåº”è¯¥å‘å‡ºä¸¤ä¸ª`data`äº‹ä»¶ï¼ŒæŒ‰é¡ºåºäº§ç”Ÿè¿™äº›å¯¹è±¡ -
- en: '`{ type: 1, value: <Buffer 68 65 6c 6c 6f> }` (value is "hello")'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{ type: 1, value: <Buffer 68 65 6c 6c 6f> }`ï¼ˆå€¼æ˜¯"hello"ï¼‰'
- en: '`{ type: 2, value: <Buffer 67 6f 6f 64 62 79 65 21> }` (value is "goodbye!")'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{ type: 2, value: <Buffer 67 6f 6f 64 62 79 65 21> }`ï¼ˆå€¼æ˜¯"goodbye!"ï¼‰'
- en: '**Things to Consider**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**éœ€è¦è€ƒè™‘çš„äº‹é¡¹**'
- en: How will you manage your internal buffer? `Buffer.concat` will be your best
    friend.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ å°†å¦‚ä½•ç®¡ç†ä½ çš„å†…éƒ¨ç¼“å†²åŒºï¼Ÿ`Buffer.concat`å°†æ˜¯ä½ çš„æœ€ä½³æœ‹å‹ã€‚
- en: Your parsing loop needs to check if you have enough data for a header (3 bytes),
    then read the length, and then check if you have enough data for the full value.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½ çš„è§£æå¾ªç¯éœ€è¦æ£€æŸ¥ä½ æ˜¯å¦æœ‰äº†è¶³å¤Ÿçš„æ•°æ®æ¥è¯»å–å¤´éƒ¨ï¼ˆ3ä¸ªå­—èŠ‚ï¼‰ï¼Œç„¶åè¯»å–é•¿åº¦ï¼Œç„¶åæ£€æŸ¥ä½ æ˜¯å¦æœ‰äº†è¶³å¤Ÿçš„æ•°æ®æ¥è¯»å–å®Œæ•´çš„å€¼ã€‚
- en: Once a message is successfully parsed, how do you remove it from your internal
    buffer so you can parse the next one? `buf.subarray()` is the tool for this.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ä¸€æ¡æ¶ˆæ¯æˆåŠŸè§£æï¼Œä½ å¦‚ä½•ä»å†…éƒ¨ç¼“å†²åŒºä¸­ç§»é™¤å®ƒä»¥ä¾¿è§£æä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Ÿ`buf.subarray()`æ˜¯è¿™ä¸ªå·¥å…·ã€‚
- en: Why is it important for the parser to emit a *copy* of the value buffer, not
    a view into its internal buffer? Think about what happens to the internal buffer
    over time.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆè§£æå™¨è¾“å‡ºå€¼ç¼“å†²åŒºçš„å‰¯æœ¬è€Œä¸æ˜¯å…¶å†…éƒ¨ç¼“å†²åŒºçš„è§†å›¾å¾ˆé‡è¦ï¼Ÿæƒ³æƒ³éšç€æ—¶é—´çš„æ¨ç§»å†…éƒ¨ç¼“å†²åŒºä¼šå‘ç”Ÿä»€ä¹ˆã€‚
- en: 'Challenge #4'
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æŒ‘æˆ˜#4
- en: Your video processing service is suffering from memory fragmentation. It constantly
    allocates and frees large (64KB) buffers, and after running for a few days, it
    crashes with out-of-memory errors. You've decided to implement a custom, application-level
    buffer pool to mitigate this churn.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„è§†é¢‘å¤„ç†æœåŠ¡æ­£é­å—å†…å­˜ç¢ç‰‡åŒ–ã€‚å®ƒä¸æ–­åˆ†é…å’Œé‡Šæ”¾å¤§ï¼ˆ64KBï¼‰çš„ç¼“å†²åŒºï¼Œè¿è¡Œå‡ å¤©åï¼Œç”±äºå†…å­˜ä¸è¶³é”™è¯¯è€Œå´©æºƒã€‚ä½ å·²ç»å†³å®šå®ç°ä¸€ä¸ªè‡ªå®šä¹‰çš„åº”ç”¨çº§ç¼“å†²æ± æ¥å‡è½»è¿™ç§ç¢ç‰‡åŒ–ã€‚
- en: Your Task
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ä½ çš„ä»»åŠ¡
- en: Create a `BufferPool` class. This class should be designed to manage a fixed
    number of pre-allocated buffers of a specific size.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ª`BufferPool`ç±»ã€‚è¿™ä¸ªç±»åº”è¯¥è¢«è®¾è®¡ç”¨æ¥ç®¡ç†ä¸€å®šæ•°é‡çš„é¢„åˆ†é…çš„ç‰¹å®šå¤§å°çš„ç¼“å†²åŒºã€‚
- en: The class must have the following features -
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªç±»å¿…é¡»å…·æœ‰ä»¥ä¸‹åŠŸèƒ½ -
- en: '**Constructor `(bufferSize, poolSize)`:**'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**æ„é€ å‡½æ•°`(bufferSize, poolSize)`**ï¼š'
- en: Takes the size of each buffer (e.g., 65536) and the number of buffers to keep
    in the pool (e.g., 100).
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¥æ”¶æ¯ä¸ªç¼“å†²åŒºçš„å¤§å°ï¼ˆä¾‹å¦‚ï¼Œ65536ï¼‰å’Œæ± ä¸­è¦ä¿ç•™çš„ç¼“å†²åŒºæ•°é‡ï¼ˆä¾‹å¦‚ï¼Œ100ï¼‰ã€‚
- en: It should pre-allocate all these buffers and store them, perhaps in an array.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥é¢„å…ˆåˆ†é…æ‰€æœ‰è¿™äº›ç¼“å†²åŒºå¹¶å°†å®ƒä»¬å­˜å‚¨èµ·æ¥ï¼Œå¯èƒ½åœ¨ä¸€ä¸ªæ•°ç»„ä¸­ã€‚
- en: '**Method `get()`:**'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**æ–¹æ³•`get()`**ï¼š'
- en: If the pool has an available buffer, it should return one.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ± æœ‰å¯ç”¨çš„ç¼“å†²åŒºï¼Œå®ƒåº”è¯¥è¿”å›ä¸€ä¸ªã€‚
- en: If the pool is empty, it should log a warning and allocate a new, temporary
    buffer of the correct size. This prevents the application from crashing but signals
    that the pool might be too small.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæ± ä¸ºç©ºï¼Œå®ƒåº”è¯¥è®°å½•ä¸€ä¸ªè­¦å‘Šå¹¶åˆ†é…ä¸€ä¸ªæ­£ç¡®å¤§å°çš„æ–°çš„ä¸´æ—¶ç¼“å†²åŒºã€‚è¿™å¯ä»¥é˜²æ­¢åº”ç”¨ç¨‹åºå´©æºƒï¼Œä½†åŒæ—¶ä¹Ÿè¡¨æ˜æ± å¯èƒ½å¤ªå°ã€‚
- en: It should return a `Buffer`.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥è¿”å›ä¸€ä¸ª`Buffer`ã€‚
- en: '**Method `release(buffer)`:**'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**æ–¹æ³•`release(buffer)`**ï¼š'
- en: Takes a buffer that was previously acquired from the pool.
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¥æ”¶ä»æ± ä¸­ä¹‹å‰è·å–çš„ç¼“å†²åŒºã€‚
- en: Returns the buffer to the pool, making it available for the next `get()` call.
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†ç¼“å†²åŒºè¿”å›åˆ°æ± ä¸­ï¼Œä½¿å…¶å¯¹ä¸‹ä¸€ä¸ª`get()`è°ƒç”¨å¯ç”¨ã€‚
- en: It should have a check to prevent the pool from growing beyond its initial size
    (i.e., don't add buffers that weren't originally from the pool or extra ones created
    when the pool was empty).
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒåº”è¯¥æœ‰ä¸€ä¸ªæ£€æŸ¥æ¥é˜²æ­¢æ± çš„å¤§å°è¶…è¿‡å…¶åˆå§‹å¤§å°ï¼ˆå³ï¼Œä¸è¦æ·»åŠ åŸæœ¬ä¸åœ¨æ± ä¸­çš„ç¼“å†²åŒºæˆ–å½“æ± ä¸ºç©ºæ—¶åˆ›å»ºçš„é¢å¤–ç¼“å†²åŒºï¼‰ã€‚
- en: '**Property `used`:**'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å±æ€§`used`**ï¼š'
- en: A getter that returns the number of buffers currently checked out from the pool.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªè¿”å›å½“å‰ä»æ± ä¸­å€Ÿå‡ºçš„ç¼“å†²åŒºæ•°é‡çš„getterã€‚
- en: '**The Goal**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®æ ‡**'
- en: 'Write the `BufferPool` class and then write a small simulation to test it.
    The simulation should:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™`BufferPool`ç±»ï¼Œç„¶åç¼–å†™ä¸€ä¸ªå°å‹æ¨¡æ‹Ÿæ¥æµ‹è¯•å®ƒã€‚æ¨¡æ‹Ÿåº”è¯¥ï¼š
- en: Create a pool.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªæ± ã€‚
- en: Get several buffers from it, checking the `used` count.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä»ä¸­è·å–å‡ ä¸ªç¼“å†²åŒºï¼Œæ£€æŸ¥`used`è®¡æ•°ã€‚
- en: Release those buffers back to the pool.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å°†è¿™äº›ç¼“å†²åŒºé‡Šæ”¾å›æ± ä¸­ã€‚
- en: Test the "pool empty" condition by trying to get more buffers than the pool
    size.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€šè¿‡å°è¯•è·å–æ¯”æ± å¤§å°æ›´å¤šçš„ç¼“å†²åŒºæ¥æµ‹è¯•â€œæ± ä¸ºç©ºâ€çš„æ¡ä»¶ã€‚
- en: Test the `release` logic for an "extra" buffer that was created when the pool
    was empty.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: æµ‹è¯•å½“æ± ä¸ºç©ºæ—¶åˆ›å»ºçš„â€œé¢å¤–â€ç¼“å†²åŒºçš„`release`é€»è¾‘ã€‚
- en: '**Things to Consider**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**éœ€è¦è€ƒè™‘çš„äº‹é¡¹**'
- en: What's the best data structure to hold the available buffers? An array with
    `push()` and `pop()` is simple and efficient.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€å¥½çš„æ•°æ®ç»“æ„æ¥ä¿å­˜å¯ç”¨ç¼“å†²åŒºæ˜¯ä»€ä¹ˆï¼Ÿä¸€ä¸ªå…·æœ‰`push()`å’Œ`pop()`æ“ä½œçš„æ•°ç»„æ—¢ç®€å•åˆé«˜æ•ˆã€‚
- en: How can you be sure a buffer being released is valid? You could add checks for
    its size or even tag the buffers in some way, though that's more advanced. For
    this challenge, a size check is sufficient.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚ä½•ç¡®ä¿é‡Šæ”¾çš„ç¼“å†²åŒºæ˜¯æœ‰æ•ˆçš„ï¼Ÿä½ å¯ä»¥æ·»åŠ å¯¹å…¶å¤§å°çš„æ£€æŸ¥ï¼Œç”šè‡³ä»¥æŸç§æ–¹å¼æ ‡è®°ç¼“å†²åŒºï¼Œå°½ç®¡è¿™æ›´é«˜çº§ã€‚å¯¹äºè¿™ä¸ªæŒ‘æˆ˜ï¼Œå¤§å°æ£€æŸ¥å°±è¶³å¤Ÿäº†ã€‚
- en: In a real-world multi-threaded application (using worker threads), how would
    you need to change this class to make it thread-safe? (This is a thought experiment;
    you don't need to implement it for this challenge).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä¸€ä¸ªç°å®ä¸–ç•Œçš„å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºï¼ˆä½¿ç”¨å·¥ä½œçº¿ç¨‹ï¼‰ä¸­ï¼Œä½ éœ€è¦å¦‚ä½•æ›´æ”¹è¿™ä¸ªç±»ä»¥ä½¿å…¶çº¿ç¨‹å®‰å…¨ï¼Ÿï¼ˆè¿™æ˜¯ä¸€ä¸ªæ€æƒ³å®éªŒï¼›ä½ ä¸éœ€è¦ä¸ºè¿™ä¸ªæŒ‘æˆ˜å®ç°å®ƒï¼‰ã€‚
- en: The `try...finally` block is your best friend when using this pool to ensure
    buffers are always released, even if errors occur.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“ä½¿ç”¨æ­¤æ± æ—¶ï¼Œ`try...finally`å—æ˜¯ä½ çš„å¥½æœ‹å‹ï¼Œå¯ä»¥ç¡®ä¿å³ä½¿åœ¨å‘ç”Ÿé”™è¯¯çš„æƒ…å†µä¸‹ä¹Ÿèƒ½å§‹ç»ˆé‡Šæ”¾ç¼“å†²åŒºã€‚
- en: 'Challenge #5'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: æŒ‘æˆ˜#5
- en: You are interfacing with a legacy piece of hardware that uses a bizarre binary
    format. It mixes Big-Endian and Little-Endian byte orders within the same data
    packet. The `Buffer`'s standard `read*BE()` and `read*LE()` methods are great,
    but for maximum clarity and safety, you've decided to use a `DataView`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ­£åœ¨ä¸ä¸€ä¸ªä½¿ç”¨å¥‡æ€ªäºŒè¿›åˆ¶æ ¼å¼çš„æ—§ç¡¬ä»¶æ¥å£ã€‚å®ƒåœ¨åŒä¸€æ•°æ®åŒ…ä¸­æ··åˆäº†å¤§ç«¯å’Œå°ç«¯å­—èŠ‚é¡ºåºã€‚`Buffer`çš„æ ‡å‡†`read*BE()`å’Œ`read*LE()`æ–¹æ³•å¾ˆæ£’ï¼Œä½†ä¸ºäº†æœ€å¤§é™åº¦çš„æ¸…æ™°åº¦å’Œå®‰å…¨æ€§ï¼Œä½ å†³å®šä½¿ç”¨`DataView`ã€‚
- en: '**The Protocol Specification**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**åè®®è§„èŒƒ**'
- en: The packet is 16 bytes long.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®åŒ…é•¿åº¦ä¸º16å­—èŠ‚ã€‚
- en: '| Offset (Bytes) | Length (Bytes) | Data Type | Endianness | Description |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| åç§»é‡ï¼ˆå­—èŠ‚ï¼‰ | é•¿åº¦ï¼ˆå­—èŠ‚ï¼‰ | æ•°æ®ç±»å‹ | é¡ºåº | æè¿° |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0-1 | 2 | `UInt16` | **Big** | Packet Magic Number (must be `0xCAFE`) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0-1 | 2 | `UInt16` | **Big** | æ•°æ®åŒ…é­”æ•°ï¼ˆå¿…é¡»æ˜¯`0xCAFE`ï¼‰ |'
- en: '| 2-5 | 4 | `Int32` | **Little** | Device ID |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 2-5 | 4 | `Int32` | **Little** | è®¾å¤‡ID |'
- en: '| 6-9 | 4 | `Float32` | **Big** | Voltage Reading |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 6-9 | 4 | `Float32` | **Big** | ç”µå‹è¯»æ•° |'
- en: '| 10 | 1 | `UInt8` | N/A | Status Code |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 1 | `UInt8` | N/A | çŠ¶æ€ç  |'
- en: '| 11 | 1 | `UInt8` | N/A | Checksum |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 1 | `UInt8` | N/A | æ ¡éªŒå’Œ |'
- en: '| 12-15 | 4 | `UInt32` | **Little** | Uptime in seconds |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 12-15 | 4 | `UInt32` | **Little** | è¿è¡Œæ—¶é—´ï¼ˆç§’ï¼‰ |'
- en: Your Task
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ä½ çš„ä»»åŠ¡
- en: Write a function `parseLegacyPacket(buffer)` that takes a 16-byte `Buffer`.
    Inside this function, you must create a `DataView` over the buffer's underlying
    `ArrayBuffer`. Use the `DataView` methods (`getUint16`, `getInt32`, `getFloat32`,
    etc.) to parse the packet according to the specification. Remember that `DataView`
    methods take an optional final boolean argument to specify endianness (`true`
    for little-endian, `false` for big-endian).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªå‡½æ•°`parseLegacyPacket(buffer)`ï¼Œå®ƒæ¥å—ä¸€ä¸ª16å­—èŠ‚çš„`Buffer`ã€‚åœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨ï¼Œä½ å¿…é¡»åˆ›å»ºä¸€ä¸ªè¦†ç›–ç¼“å†²åŒºåº•å±‚`ArrayBuffer`çš„`DataView`ã€‚ä½¿ç”¨`DataView`æ–¹æ³•ï¼ˆ`getUint16`ã€`getInt32`ã€`getFloat32`ç­‰ï¼‰æ ¹æ®è§„èŒƒè§£ææ•°æ®åŒ…ã€‚è®°ä½ï¼Œ`DataView`æ–¹æ³•æ¥å—ä¸€ä¸ªå¯é€‰çš„å¸ƒå°”å‚æ•°æ¥æŒ‡å®šé¡ºåºï¼ˆ`true`ä¸ºå°ç«¯ï¼Œ`false`ä¸ºå¤§ç«¯ï¼‰ã€‚
- en: '**Sample Data**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ ·æœ¬æ•°æ®**'
- en: '[PRE6]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**The Goal**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®æ ‡**'
- en: 'Your `parseLegacyPacket(legacyPacket)` function should return an object that
    looks like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ çš„`parseLegacyPacket(legacyPacket)`å‡½æ•°åº”è¯¥è¿”å›ä¸€ä¸ªçœ‹èµ·æ¥åƒè¿™æ ·çš„å¯¹è±¡ï¼š
- en: '[PRE7]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Things to Considr**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**éœ€è¦è€ƒè™‘çš„äº‹é¡¹**'
- en: How do you get the underlying `ArrayBuffer` from a `Buffer` to create a `DataView`?
    Every `Buffer` instance has a `.buffer` property.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚ä½•ä»ä¸€ä¸ª`Buffer`è·å–åº•å±‚çš„`ArrayBuffer`ä»¥åˆ›å»º`DataView`ï¼Ÿæ¯ä¸ª`Buffer`å®ä¾‹éƒ½æœ‰ä¸€ä¸ª`.buffer`å±æ€§ã€‚
- en: Be careful with the `byteOffset`. The `DataView` needs to be created with the
    correct offset if the `Buffer` is a slice of a larger `ArrayBuffer`. For this
    challenge, you can assume the buffer is not a slice, but it's good to be aware
    of the `buf.byteOffset` property.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ³¨æ„`byteOffset`ã€‚å¦‚æœ`Buffer`æ˜¯æ›´å¤§çš„`ArrayBuffer`çš„åˆ‡ç‰‡ï¼Œ`DataView`éœ€è¦ä½¿ç”¨æ­£ç¡®çš„åç§»é‡æ¥åˆ›å»ºã€‚å¯¹äºè¿™ä¸ªæŒ‘æˆ˜ï¼Œä½ å¯ä»¥å‡è®¾ç¼“å†²åŒºä¸æ˜¯åˆ‡ç‰‡ï¼Œä½†äº†è§£`buf.byteOffset`å±æ€§æ˜¯å¥½çš„ã€‚
- en: The third argument to `DataView` methods is the endianness flag. `false` (or
    omitted) is Big-Endian. `true` is Little-Endian. You will need to use both.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataView` æ–¹æ³•çš„ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯å­—èŠ‚åºæ ‡å¿—ã€‚`false`ï¼ˆæˆ–çœç•¥ï¼‰æ˜¯å¤§ç«¯å­—èŠ‚åºã€‚`true` æ˜¯å°ç«¯å­—èŠ‚åºã€‚ä½ éœ€è¦ä½¿ç”¨ä¸¤è€…ã€‚'
- en: This is a great exercise in careful, methodical parsing where every single byte
    and its interpretation matters.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ç»ƒä¹ ï¼Œéœ€è¦ä»”ç»†ã€æœ‰ç³»ç»Ÿåœ°è§£æï¼Œå› ä¸ºæ¯ä¸ªå­—èŠ‚åŠå…¶è§£é‡Šéƒ½å¾ˆé‡è¦ã€‚
- en: 'Challenge #6 (Advanced)'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'æŒ‘æˆ˜ #6ï¼ˆé«˜çº§ï¼‰'
- en: ğŸ“ŒImportant
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ“Œé‡è¦
- en: This is an advanced, optional challenge. If you havenâ€™t worked with Node.js
    worker threads, shared memory, or `Atomics` before, feel free to skip it for now.
    Come back after youâ€™ve read those chapters in the book. I'll add a link in the
    future chapters as a reminder for you to finish this challenge.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªé«˜çº§çš„ã€å¯é€‰çš„æŒ‘æˆ˜ã€‚å¦‚æœä½ ä¹‹å‰æ²¡æœ‰ä½¿ç”¨è¿‡ Node.js å·¥ä½œçº¿ç¨‹ã€å…±äº«å†…å­˜æˆ– `Atomics`ï¼Œç°åœ¨å¯ä»¥è·³è¿‡è¿™ä¸ªæŒ‘æˆ˜ã€‚åœ¨é˜…è¯»å®Œä¹¦ä¸­çš„ç›¸å…³ç« èŠ‚åå›æ¥ã€‚æˆ‘å°†åœ¨æœªæ¥çš„ç« èŠ‚ä¸­æ·»åŠ ä¸€ä¸ªé“¾æ¥ï¼Œä½œä¸ºæé†’ä½ å®Œæˆè¿™ä¸ªæŒ‘æˆ˜ã€‚
- en: You have a performance-critical application where multiple worker threads need
    to increment a shared counter. Passing messages back and forth to the main thread
    for every increment would be too slow due to serialization overhead. You need
    a way for all threads to access and modify the same piece of memory directly and
    safely.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æœ‰ä¸€ä¸ªæ€§èƒ½å…³é”®çš„åº”ç”¨ç¨‹åºï¼Œå…¶ä¸­å¤šä¸ªå·¥ä½œçº¿ç¨‹éœ€è¦å¢åŠ ä¸€ä¸ªå…±äº«è®¡æ•°å™¨ã€‚ç”±äºåºåˆ—åŒ–å¼€é”€ï¼Œæ¯æ¬¡å¢åŠ éƒ½éœ€è¦åœ¨ä¸»çº¿ç¨‹ä¹‹é—´ä¼ é€’æ¶ˆæ¯å°†ä¼šå¤ªæ…¢ã€‚ä½ éœ€è¦ä¸€ç§æ–¹å¼è®©æ‰€æœ‰çº¿ç¨‹å¯ä»¥ç›´æ¥ä¸”å®‰å…¨åœ°è®¿é—®å’Œä¿®æ”¹åŒä¸€å—å†…å­˜ã€‚
- en: Your Task
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ä½ çš„ä»»åŠ¡
- en: Write a script that demonstrates a thread-safe counter using a `SharedArrayBuffer`
    and `Atomics`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ç¼–å†™ä¸€ä¸ªè„šæœ¬ï¼Œæ¼”ç¤ºä½¿ç”¨ `SharedArrayBuffer` å’Œ `Atomics` å®ç°çš„çº¿ç¨‹å®‰å…¨è®¡æ•°å™¨ã€‚
- en: '**Main Script (`main.js`)**'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ä¸»è„šæœ¬ (`main.js`)**'
- en: Create a `SharedArrayBuffer` large enough to hold one 32-bit integer (4 bytes).
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸€ä¸ªè¶³å¤Ÿå¤§çš„ `SharedArrayBuffer` æ¥å­˜å‚¨ä¸€ä¸ª32ä½æ•´æ•°ï¼ˆ4å­—èŠ‚ï¼‰ã€‚
- en: Create an `Int32Array` view over it.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å…¶ä¸Šåˆ›å»ºä¸€ä¸ª `Int32Array` è§†å›¾ã€‚
- en: Initialize the counter at that memory location to 0.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†è®¡æ•°å™¨åˆå§‹åŒ–ä¸ºè¯¥å†…å­˜ä½ç½®çš„0ã€‚
- en: Create two `Worker` threads, passing the `SharedArrayBuffer` to each of them.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸¤ä¸ª `Worker` çº¿ç¨‹ï¼Œå¹¶å°† `SharedArrayBuffer` ä¼ é€’ç»™æ¯ä¸ªçº¿ç¨‹ã€‚
- en: Each worker will increment the counter a large number of times (e.g., 1 million).
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå·¥ä½œçº¿ç¨‹å°†å¤šæ¬¡å¢åŠ è®¡æ•°å™¨ï¼ˆä¾‹å¦‚ï¼Œ1ç™¾ä¸‡æ¬¡ï¼‰ã€‚
- en: Wait for both workers to signal that they are finished.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç­‰å¾…ä¸¤ä¸ªå·¥ä½œçº¿ç¨‹éƒ½å‘å‡ºå®Œæˆä¿¡å·ã€‚
- en: Read the final value from the `SharedArrayBuffer` using `Atomics.load()` and
    print it. The final value should be the sum of all increments (e.g., 2 million).
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ `Atomics.load()` ä» `SharedArrayBuffer` ä¸­è¯»å–æœ€ç»ˆå€¼å¹¶æ‰“å°å‡ºæ¥ã€‚æœ€ç»ˆå€¼åº”è¯¥æ˜¯æ‰€æœ‰å¢åŠ çš„æ€»å’Œï¼ˆä¾‹å¦‚ï¼Œ200ä¸‡ï¼‰ã€‚
- en: '**Worker Script (`worker.js`)**'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**å·¥ä½œè„šæœ¬ (`worker.js`)**'
- en: Receive the `SharedArrayBuffer` via a message.
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: é€šè¿‡æ¶ˆæ¯æ¥æ”¶ `SharedArrayBuffer`ã€‚
- en: Create its own `Int32Array` view over the shared buffer.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨å…±äº«ç¼“å†²åŒºä¸Šåˆ›å»ºè‡ªå·±çš„ `Int32Array` è§†å›¾ã€‚
- en: In a tight loop, increment the shared counter using `Atomics.add()`. This is
    the key to thread safety.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨ä¸€ä¸ªç´§å¯†çš„å¾ªç¯ä¸­ï¼Œä½¿ç”¨ `Atomics.add()` å¢åŠ å…±äº«è®¡æ•°å™¨ã€‚è¿™æ˜¯çº¿ç¨‹å®‰å…¨çš„å…³é”®ã€‚
- en: When the loop is done, send a 'done' message back to the main thread.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“å¾ªç¯å®Œæˆåï¼Œå‘ä¸»çº¿ç¨‹å‘é€ä¸€ä¸ª 'done' æ¶ˆæ¯ã€‚
- en: '**The Goal**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç›®æ ‡**'
- en: 'The final output on the main thread should be `Final counter value: 2000000`.
    If you were to use a non-atomic operation like `view[0]++`, you would likely get
    a final value less than 2 million due to race conditions, where one worker''s
    read-modify-write cycle overwrites another''s.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'ä¸»çº¿ç¨‹ä¸Šçš„æœ€ç»ˆè¾“å‡ºåº”è¯¥æ˜¯ `Final counter value: 2000000`ã€‚å¦‚æœä½ ä½¿ç”¨éåŸå­æ“ä½œå¦‚ `view[0]++`ï¼Œç”±äºç«äº‰æ¡ä»¶ï¼Œä½ å¯èƒ½ä¼šå¾—åˆ°å°äº200ä¸‡çš„æœ€ç»ˆå€¼ï¼Œå…¶ä¸­ä¸€ä¸ªå·¥ä½œçº¿ç¨‹çš„è¯»å–-ä¿®æ”¹-å†™å…¥å‘¨æœŸä¼šè¦†ç›–å¦ä¸€ä¸ªçš„ã€‚'
- en: '**Things to Consider**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**éœ€è¦è€ƒè™‘çš„äº‹é¡¹**'
- en: This is the only challenge that requires two separate files.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å”¯ä¸€éœ€è¦ä¸¤ä¸ªå•ç‹¬æ–‡ä»¶çš„æŒ‘æˆ˜ã€‚
- en: '`SharedArrayBuffer` is the core component that allows memory to be visible
    across threads.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedArrayBuffer` æ˜¯å…è®¸å†…å­˜è·¨çº¿ç¨‹å¯è§çš„æ ¸å¿ƒç»„ä»¶ã€‚'
- en: Why is `Atomics.add(view, 0, 1)` required instead of `view[0]++`? Research what
    a "race condition" is in the context of a read-modify-write operation.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆéœ€è¦ `Atomics.add(view, 0, 1)` è€Œä¸æ˜¯ `view[0]++`ï¼Ÿç ”ç©¶åœ¨è¯»å–-ä¿®æ”¹-å†™å…¥æ“ä½œä¸Šä¸‹æ–‡ä¸­â€œç«äº‰æ¡ä»¶â€æ˜¯ä»€ä¹ˆã€‚
- en: How does the main thread know when both workers are finished? You can use Promises
    to wait for the 'done' message from each worker. `Promise.all` is a good tool
    for this.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸»çº¿ç¨‹å¦‚ä½•çŸ¥é“ä¸¤ä¸ªå·¥ä½œçº¿ç¨‹éƒ½å·²å®Œæˆï¼Ÿä½ å¯ä»¥ä½¿ç”¨ Promises ç­‰å¾…æ¯ä¸ªå·¥ä½œçº¿ç¨‹çš„ 'done' æ¶ˆæ¯ã€‚`Promise.all` æ˜¯è¿™ä¸ªä»»åŠ¡çš„ç†æƒ³å·¥å…·ã€‚
- en: This demonstrates the absolute lowest-level and highest-performance way to share
    state between threads in Node.js, built directly on the memory primitives we've
    been studying.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™å±•ç¤ºäº†åœ¨ Node.js ä¸­åœ¨çº¿ç¨‹ä¹‹é—´å…±äº«çŠ¶æ€çš„ç»å¯¹æœ€ä½çº§å’Œæœ€é«˜æ€§èƒ½çš„æ–¹æ³•ï¼Œè¿™æ˜¯ç›´æ¥å»ºç«‹åœ¨æˆ‘ä»¬æ‰€ç ”ç©¶çš„å†…å­˜åŸè¯­ä¹‹ä¸Šçš„ã€‚
