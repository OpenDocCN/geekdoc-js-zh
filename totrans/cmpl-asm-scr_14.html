<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 12
Visitor Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chapter 12
Visitor Pattern</h1>
<blockquote>原文：<a href="https://keleshev.com/compiling-to-assembly-from-scratch/12-visitor-pattern">https://keleshev.com/compiling-to-assembly-from-scratch/12-visitor-pattern</a></blockquote>




<header>

<a href="./#table-of-contents">Compiling to Assembly from Scratch</a>
<br/>by <a href="/">Vladimir Keleshev</a>
</header>
<p> </p>
<p>We are about to add more passes to our compiler: type checking, and code generation for dynamic typing. What we could do is extend the AST interface with new methods, one for each pass. It can look something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"/><span class="kw">interface</span> AST {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"/>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"/>  <span class="fu">emitDynamic</span>(<span class="dt">env</span><span class="op">:</span> Environment)<span class="op">:</span> <span class="kw">void</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"/>  <span class="fu">typeCheck</span>(<span class="dt">env</span><span class="op">:</span> TypeEnvironment)<span class="op">:</span> Type<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"/>  <span class="fu">equal</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"/>}</span></code></pre></div>
<p>And this is perfectly fine. However, this way, code for each pass is intertwined with code for every other pass. In other words, code is grouped by an AST node and not by a pass.</p>
<p>Using the <em>visitor pattern</em> we can group the code for each pass together under a separate class. The visitor pattern allows us to decouple our passes from AST by using indirection. Instead of having a method <em>per pass, per AST node</em> we add a single method <em>per AST node</em> called <code>visit</code> that delegates the action to a class that implements the <em>visitor interface</em>. The <em>visitor interface</em> has one method per AST node: <code>visitAssert</code>, <code>visitLength</code>, <code>visitNumber</code>, etc.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"/><span class="kw">interface</span> AST {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"/>  visit<span class="op">&lt;</span>T<span class="op">&gt;</span>(<span class="dt">v</span><span class="op">:</span> Visitor<span class="op">&lt;</span>T<span class="op">&gt;</span>)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"/>  <span class="fu">equal</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"/>}</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"/></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"/><span class="kw">interface</span> Visitor<span class="op">&lt;</span>T<span class="op">&gt;</span> {</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitAssert</span>(<span class="dt">node</span><span class="op">:</span> Assert)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitLength</span>(<span class="dt">node</span><span class="op">:</span> Length)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitNumber</span>(<span class="dt">node</span><span class="op">:</span> <span class="bu">Number</span>)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitBoolean</span>(<span class="dt">node</span><span class="op">:</span> <span class="bu">Boolean</span>)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitNot</span>(<span class="dt">node</span><span class="op">:</span> Not)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitEqual</span>(<span class="dt">node</span><span class="op">:</span> Equal)<span class="op">:</span> T<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"/>  …</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"/>}</span></code></pre></div>
<p>Each AST node implements the new <code>AST</code> interface by calling the corresponding visitor method. For example, <code>Assert</code> calls <code>visitAssert</code>, <code>Length</code> calls <code>visitLength</code>, etc.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"/><span class="kw">class</span> Assert <span class="kw">implements</span> AST {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"/>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">condition</span><span class="op">:</span> AST) {}</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"/></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"/>  visit<span class="op">&lt;</span>T<span class="op">&gt;</span>(<span class="dt">v</span><span class="op">:</span> Visitor<span class="op">&lt;</span>T<span class="op">&gt;</span>) {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"/>    <span class="cf">return</span> v<span class="op">.</span><span class="fu">visitAssert</span>(<span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"/>  }</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"/></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"/>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean {…}</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"/>}</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"/></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"/><span class="kw">class</span> Length <span class="kw">implements</span> AST {</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"/>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">array</span><span class="op">:</span> AST) {}</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"/></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"/>  visit<span class="op">&lt;</span>T<span class="op">&gt;</span>(<span class="dt">v</span><span class="op">:</span> Visitor<span class="op">&lt;</span>T<span class="op">&gt;</span>) {</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"/>    <span class="cf">return</span> v<span class="op">.</span><span class="fu">visitLength</span>(<span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"/>  }</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"/></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"/>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean {…}</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"/>}</span></code></pre></div>
<p>The visitor interface <code>Visitor&lt;T&gt;</code> is generic. That means it can be used to implement passes that return different things. For example, <code>Visitor&lt;AST&gt;</code> produces an <code>AST</code> node, <code>Visitor&lt;void&gt;</code> can emit code as a side-effect.</p>
<p>Let’s convert our existing code generation pass into a visitor. Since our existing <code>emit</code> method returned <code class="sourceCode javascript"><span class="kw">void</span></code>, our new visitor will implement <code>Visitor&lt;void&gt;</code>. Instead of having a separate <code>Environment</code> class, we make the visitor constructor take all the environment parameters. In a way, the visitor becomes the environment.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"/><span class="kw">class</span> CodeGenerator <span class="kw">implements</span> Visitor<span class="op">&lt;</span><span class="kw">void</span><span class="op">&gt;</span> {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"/>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">locals</span><span class="op">:</span> <span class="bu">Map</span><span class="op">&lt;</span>string<span class="op">,</span> number<span class="op">&gt;,</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"/>              <span class="kw">public</span> <span class="dt">nextLocalOffset</span><span class="op">:</span> number) {}</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"/></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitAssert</span>(<span class="dt">node</span><span class="op">:</span> Assert) {</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"/>    node<span class="op">.</span><span class="at">condition</span><span class="op">.</span><span class="fu">visit</span>(<span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  cmp r0, #1`</span>)<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  moveq r0, #'.'`</span>)<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  movne r0, #'F'`</span>)<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  bl putchar`</span>)<span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"/>  }</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"/></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitLength</span>(<span class="dt">node</span><span class="op">:</span> Length) {</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"/>    node<span class="op">.</span><span class="at">array</span><span class="op">.</span><span class="fu">visit</span>(<span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  ldr r0, [r0, #0]`</span>)<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"/>  }</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"/></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"/>  …</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"/>}</span></code></pre></div>
<p>We copy the body of each method, like <code>Assert.emit</code> and <code>Length.emit</code> into the visitor methods, like <code>visitAssert</code> and <code>visitLength</code>.</p>
<p>In <code>emit</code> methods we used to call <code>emit</code> recursively for inner nodes, like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"/>  <span class="fu">emit</span>(env<span class="op">:</span> Environment)<span class="op">:</span> <span class="kw">void</span> {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"/>    <span class="kw">this</span><span class="op">.</span><span class="at">array</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  ldr r0, [r0, #0]`</span>)<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"/>  }</span></code></pre></div>
<p>Now, instead, we call the <code>visit</code> method on them.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"/>  <span class="fu">visitLength</span>(node<span class="op">:</span> Length) {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"/>    node<span class="op">.</span><span class="at">array</span><span class="op">.</span><span class="fu">visit</span>(<span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"/>    <span class="fu">emit</span>(<span class="vs">`  ldr r0, [r0, #0]`</span>)<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"/>  }</span></code></pre></div>
<p>Previously <code class="sourceCode javascript"><span class="kw">this</span></code> referred to the AST node, but now the node is passed as the parameter called <code>node</code>. Now, <code class="sourceCode javascript"><span class="kw">this</span></code> refers to the visitor itself, which we pass instead of the <code>env</code> parameter.</p>
<p>In rare places where we created a new environment, we create a new visitor instead with the updated environment. Here’s an example from <code>visitFunction</code>.</p>
<p>Before:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"/>    <span class="kw">let</span> env <span class="op">=</span> <span class="kw">new</span> <span class="fu">Environment</span>(locals<span class="op">,</span> <span class="op">-</span><span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"/>    <span class="kw">this</span><span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">emit</span>(env)<span class="op">;</span></span></code></pre></div>
<p>After:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"/>    <span class="kw">let</span> visitor <span class="op">=</span> <span class="kw">new</span> <span class="fu">CodeGenerator</span>(locals<span class="op">,</span> <span class="op">-</span><span class="dv">20</span>)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"/>    node<span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">visit</span>(visitor)<span class="op">;</span></span></code></pre></div>
<p>As you can see, converting from an AST-based pass to a visitor-based pass is a purely mechanical transformation. New passes that we will introduce will also be based on the visitor pattern.</p>
<!--- print layout

> **Note:**
>
> If you are using a functional programming language you might notice that the visitor pattern corresponds to pattern matching.

-->
<center><a href="./13-static-type-checking-and-inference">Next: Chapter 13. Static Type Checking and Inference</a></center>


  <hr class="fleuron"/>
    
</body>
</html>