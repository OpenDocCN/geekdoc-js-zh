<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Transform & Duplex Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Transform & Duplex Streams</h1>
<blockquote>原文：<a href="https://www.thenodebook.com/streams/transform-streams">https://www.thenodebook.com/streams/transform-streams</a></blockquote><p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> streams produce data. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> streams consume it. But sometimes you need both, or you need a stream where the two directions aren't related, or you need transformation between input and output.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams are both readable and writable at the same time, with <strong class="font-bold">two independent sides</strong> operating in parallel. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams are a specialized version of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> where the writable side feeds into the readable side through a transformation function. The distinction between these two types affects how you build data processing pipelines.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Both stream types work differently. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams have independent sides. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams, which are more common in application code, connect the writable input to the readable output through a transformation function. We'll implement several custom <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams to show the patterns, then cover when to choose <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> versus <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>.</p>
<h2 id="duplex-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Duplex Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams come first. They're the foundation that makes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams make sense. A <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream is simultaneously readable and writable. You can call both <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> on the same object. You can attach both <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'data'</code> listeners and pass chunks to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>. The stream has all the properties and events of both <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The critical detail: the <strong class="font-bold">readable side</strong> and the <strong class="font-bold">writable side</strong> are <strong class="font-bold">independent</strong>. Data you write to a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream doesn't automatically appear on the readable side. The two sides are separate channels that happen to exist on the same object. Think of it like a phone line  -  you can speak into it and listen through it, but what you say doesn't echo back to you. The two directions are independent.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This independence exists because <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams model bidirectional communication channels. The canonical example is a TCP socket. When you have a socket connection, you can send data to the remote endpoint by writing to the socket, and you can receive data from the remote endpoint by reading from it. The data you send isn't the data you receive  -  they're two separate streams of communication happening simultaneously over the same connection.</p>
<p class="text-base leading-relaxed mb-4 font-normal">At the class level, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams have a specific structure. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.Duplex</code> class extends <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code>, but it also implements the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> interface. Internally, it maintains separate state for the readable side (<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_readableState</code>) and the writable side (<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writableState</code>). When you implement a custom <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream, you provide both <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> methods.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A minimal Duplex stream implementation:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Duplex } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> MinimalDuplex</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Duplex</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // produce data for readable side</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"readable data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // consume data on writable side</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Received:"</span><span style="color:#E1E4E8">, chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> method is called when the readable side needs data. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method is called when something writes to the writable side. These two methods don't interact. They're completely independent.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Using this stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> duplex</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> MinimalDuplex</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">duplex.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Read:"</span><span style="color:#E1E4E8">, chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">duplex.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"written data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">duplex.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you run this, you'll see "Received: written data" from the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> side and "Read: readable data" from the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> side. They're not connected. You're not transforming "written data" into "readable data"  -  they're two separate flows.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">allowHalfOpen</code> option is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>-specific and changes how the stream handles ending. When you create a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream, you can set <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">allowHalfOpen: false</code> to change what happens when one side ends.</p>
<p class="text-base leading-relaxed mb-4 font-normal">By default, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">allowHalfOpen</code> is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>. This means the readable side can end while the writable side is still open, and vice versa. You can finish writing and call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> on the writable side, but the readable side continues to produce data. Or the readable side can <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push(null)</code> to signal EOF, but you can still write to the writable side.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Network sockets work this way. When a TCP connection is <strong class="font-bold">half-closed</strong>, one endpoint has finished sending but can still receive. The connection isn't fully closed until both sides have finished.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you set <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">allowHalfOpen: false</code>, the stream enforces that when either side ends, the other side ends too. If the readable side pushes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>, the writable side is automatically ended. If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> on the writable side, the readable side automatically pushes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> duplex</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Duplex</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  allowHalfOpen: </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">  read</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">    // readable implementation</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#B392F0">  write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // writable implementation</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">allowHalfOpen: false</code>, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">duplex.end()</code> causes the readable side to end immediately. Use this when modeling something that doesn't support half-open states, like request-response protocols where the stream should close completely when either direction finishes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The real-world use cases for raw <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams are mostly about I/O primitives. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">net.Socket</code> class from Node's networking module is a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream. When you create a TCP socket, you get a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>. The writable side sends data over the network. The readable side receives data from the network. The two sides are independent because you're communicating with a remote endpoint  -  what you send isn't what you receive.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another example is a subprocess's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stdin</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stdout</code>. When you spawn a child process, its <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stdin</code> is writable (you send data to the process) and its <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stdout</code> is readable (you receive data from the process). These are modeled as a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream where the two sides communicate with the external process, not with each other.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Application code rarely implements <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams from scratch. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams are more common for data transformation. But first, a slightly more realistic <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> example:</p>
<p class="text-base leading-relaxed mb-4 font-normal">This <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream maintains an in-memory buffer. Data written to it is stored in an internal array, and data read from it comes from that array:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> BufferedDuplex</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Duplex</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">shift</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now the two sides interact through shared state (the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.buffer</code> array). When you write, chunks are added to the buffer. When the readable side needs data, chunks are pulled from the buffer. This is a basic queue implementation using a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Even though there's shared state, the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> methods don't call each other. They just access the same data structure. The stream's internal machinery handles calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> when the readable side needs data and calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> when something writes to the writable side.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Using a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> to implement a queue or buffer works, but it's not the primary use case. Most often, if you're building something that transforms or processes data in a pipeline, you want a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream, not a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One more detail about <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams: error handling works differently because of the two independent sides. Because a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> has two independent sides, an error on one side doesn't automatically propagate to the other. If an error occurs in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'error'</code> event, but the readable side continues operating unless you explicitly destroy it. Similarly, an error in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> doesn't stop the writable side.</p>
<p class="text-base leading-relaxed mb-4 font-normal">However, when you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> stream, both sides are destroyed. This is the correct behavior  -  destroying the stream means the entire resource is being shut down, not just one direction.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">duplex.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Fatal error"</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#6A737D">// Both readable and writable sides are now destroyed</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This matters when you're handling cleanup or cancellation. If you're using a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> to model a network connection, and the connection drops, you destroy the stream, which shuts down both sending and receiving.</p>
<h2 id="transform-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Transform Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams are what most developers reach for when building data processors. A <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream is a specialized <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> where the writable input is connected to the readable output through a transformation function. Data flows in one side, gets processed, and flows out the other side.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Unlike raw <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams where the two sides are independent, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams create a <strong class="font-bold">causal relationship</strong> between them. What you write to the writable side directly affects what comes out of the readable side. You're not just implementing two separate channels  -  you're implementing a function that takes input chunks and produces output chunks.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The most common examples of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams in Node.js's standard library are compression and encryption. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">zlib.createGzip()</code> function returns a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream. You write uncompressed data to it, and you read compressed data from it. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">crypto.createCipheriv()</code> function returns a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream. You write plaintext to it, and you read ciphertext from it. The transformation happens inside the stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> class differs from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> in a few key ways. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> extends <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>, so it has all the properties and methods of a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>. But instead of implementing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>, you implement a different method: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> method has this signature:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback)</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">It receives a <strong class="font-bold">chunk</strong> from the writable side, processes it, and pushes zero or more output chunks to the readable side. When it's done processing, it invokes the <strong class="font-bold">callback</strong> to signal that it's ready for the next chunk.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A simple <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> that converts text to uppercase:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Transform } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> UppercaseTransform</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> upper</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(upper);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> method receives a chunk (which is a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> by default), converts it to a string, uppercases it, pushes the result to the readable side using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push()</code>, and then calls the callback to indicate the transformation is complete.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Using this stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> upper</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> UppercaseTransform</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">upper.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">upper.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"hello"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">upper.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"world"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">upper.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Output: "HELLO" and "WORLD". Each chunk you write is transformed and emerges on the readable side.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>'s <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> method is already implemented for you, unlike <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>. You don't override it. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> base class handles pulling data from an internal buffer that's populated by your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> method. Similarly, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>'s <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method is implemented to call your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> method. You only implement the <strong class="font-bold">transformation logic</strong>  -  the stream plumbing is handled by the base class.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This makes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams simpler to implement than raw <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams. You focus on "what do I do with this chunk" instead of "how do I manage two independent sides."</p>
<p class="text-base leading-relaxed mb-4 font-normal">The callback parameter in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> does two things. It signals that you're done processing the current chunk, and it allows you to report errors.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If an error occurs during transformation, you pass it to the callback:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> result</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">stringify</span><span style="color:#E1E4E8">(result));</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If you pass an error to the callback, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'error'</code> event and stops processing. Any buffered data is discarded, and the stream enters an <strong class="font-bold">errored state</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push()</code> multiple times in a single <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> call. This is called a <strong class="font-bold">one-to-many transformation</strong>. For every input chunk, you produce multiple output chunks.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> splits input into individual lines:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> LineSplitter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(line </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If you write <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">"hello\nworld\n"</code>, the transform pushes two chunks: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">"hello\n"</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">"world\n"</code>. One input chunk becomes multiple output chunks.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also push nothing. If your transformation decides to drop a chunk (filter it out), you just call the callback without pushing:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> text</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">text.</span><span style="color:#B392F0">startsWith</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"#"</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#B392F0">  callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform filters out chunks that start with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">"#"</code>. Some chunks pass through, others are dropped.</p>
<p class="text-base leading-relaxed mb-4 font-normal">What about <strong class="font-bold">many-to-one transformations</strong>, where you need to accumulate multiple input chunks before producing output? This is common when parsing structured data that might be split across chunk boundaries. You use instance state to buffer incomplete data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> accumulates chunks until it sees a delimiter, then emits the accumulated data:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> DelimiterParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">delimiter</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.delimiter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> delimiter;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> parts</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.delimiter);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> parts.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// last part is incomplete</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> part</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> parts) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(part);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform maintains a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.buffer</code> that accumulates incoming data. Each time <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> is called, it appends the new chunk to the buffer, splits on the delimiter, and pushes complete parts. The last part (which might be incomplete) is kept in the buffer for the next call.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is a fundamental pattern in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams: <strong class="font-bold">maintaining state</strong> across calls to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> to handle data structures that span multiple chunks. This is <strong class="font-bold">stateful transformation</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The above implementation has a problem. When the stream ends, any leftover data in the buffer is lost. The stream finishes without emitting that final incomplete chunk. This is where <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> comes in.</p>
<h2 id="the-_flush-method" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The _flush() Method</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams have a second method you can implement: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>. This method is called after all input chunks have been processed (after <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> is called on the writable side) but before the readable side pushes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> to signal EOF. It's your opportunity to emit any remaining data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> signature is:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_flush</span><span style="color:#E1E4E8">(callback)</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">It receives only a callback, no chunk. You can call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push()</code> to emit final data, and then you call the callback to signal that flushing is complete.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The delimiter parser with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> added:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> DelimiterParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">delimiter</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.delimiter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> delimiter;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> parts</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.delimiter);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> parts.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> part</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> parts) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(part);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now when the stream ends, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> is called. If there's leftover data in the buffer, it's pushed as the final chunk. Then the callback is invoked, and the stream pushes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> to signal EOF on the readable side.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Without <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>, data that doesn't end with a delimiter is lost. With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>, it's emitted as the final chunk. Parsers, decoders, and any <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> that accumulates state need this.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> callback works the same way as the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> callback. If an error occurs, you pass it to the callback:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_flush</span><span style="color:#E1E4E8">(callback) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> parsed</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parseBuffer</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(parsed);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If you pass an error to the callback, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'error'</code> event instead of ending cleanly.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One more detail about <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>: it's <strong class="font-bold">optional</strong>. If you don't implement it, the stream just ends without a final processing step. Transforms that don't accumulate state (like the uppercase transform) don't need this. Each chunk is independent, so there's nothing to flush when the stream ends.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But for any transform that buffers across chunks  -  parsers, decoders, aggregators  -  you must implement <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> to avoid losing data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A more complete example: parsing <strong class="font-bold">NDJSON</strong> (newline-delimited JSON) where each line is a separate JSON document.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> NDJSONParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">().</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">          const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(line);</span></span>
<span class="line"><span style="color:#79B8FF">          this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">          return</span><span style="color:#B392F0"> callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">().</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer);</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#B392F0">        callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">        callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform operates in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, which means it pushes JavaScript objects instead of buffers. Each line is parsed as JSON, and the resulting object is pushed to the readable side. If a line is incomplete at the end of a chunk, it's buffered until the next chunk arrives. When the stream ends, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> parses any remaining buffered line.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">JSON.parse()</code> throws, we pass the error to the callback. This stops the stream and emits an error event. We use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">return callback(err)</code> to exit early  -  we don't want to continue processing after an error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern (buffer across chunks, split on delimiter, parse complete units, flush remaining data) appears in most <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams for structured data.</p>
<h2 id="implementing-custom-transform-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Implementing Custom Transform Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Now that you understand the mechanics, we'll implement several <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams. These cover <strong class="font-bold">filtering</strong>, <strong class="font-bold">mapping</strong>, <strong class="font-bold">splitting</strong>, <strong class="font-bold">joining</strong>, and <strong class="font-bold">stateful parsing</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Filter transforms</strong> pass through chunks that meet a condition and drop chunks that don't. This transform filters out empty lines:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> NonEmptyLines</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> text</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (text.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">().</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Simple. If the chunk (after trimming whitespace) has content, push it. Otherwise, skip it. The callback is always invoked to signal completion, even when we don't push.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Map transforms</strong> convert each input chunk to a different output chunk, typically in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>. This transform takes JSON objects and extracts specific fields:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> FieldExtractor</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fields</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.fields </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fields;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> extracted</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> field</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.fields) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (obj[field] </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">        extracted[field] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> obj[field];</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(extracted);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each input object is mapped to a new object with only the specified fields. One object in, one object out. This is a <strong class="font-bold">one-to-one transform</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Split transforms</strong> break input into smaller pieces. We've seen a line splitter, but here's a byte-level splitter that breaks a stream into fixed-size chunks:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> ChunkSplitter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunkSize</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.chunkSize </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> chunkSize;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">alloc</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">concat</span><span style="color:#E1E4E8">([</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer, chunk]);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.chunkSize) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> piece</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.chunkSize);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.chunkSize);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(piece);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform accumulates incoming data in a buffer. When the buffer reaches <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">chunkSize</code>, it slices off a chunk and pushes it. The loop continues until there's less than <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">chunkSize</code> left in the buffer. When the stream ends, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> emits any remaining data as a final partial chunk.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Join transforms</strong> combine multiple input chunks into a single output chunk. This transform accumulates objects into an array and emits the array when a certain count is reached:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> BatchAccumulator</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">batchSize</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batchSize </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> batchSize;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batch.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.batchSize) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is a <strong class="font-bold">many-to-one transform</strong>. It accumulates <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">batchSize</code> objects, then pushes the array. If the stream ends with a partial batch, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> emits it.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Stateful parsing transforms</strong> maintain state across chunks to parse structured data. We've seen delimiter parsing, but here's a more complex example: a parser for <strong class="font-bold">length-prefixed binary messages</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In a length-prefixed protocol, each message starts with a 4-byte length field (a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uint32</code>) indicating how many bytes follow. To parse this, we need to read the length, then read that many bytes, then repeat.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> LengthPrefixedParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">alloc</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.expectedLength </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">concat</span><span style="color:#E1E4E8">([</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer, chunk]);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.expectedLength </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.expectedLength </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">readUInt32BE</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.expectedLength) {</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> message</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.expectedLength);</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.expectedLength);</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.expectedLength </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(message);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform uses a <strong class="font-bold">state machine</strong>. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">expectedLength</code> variable tracks whether we're waiting to read a length header or waiting to read the message body. The loop reads as many complete messages as possible from the buffer, pushing each one, and then calls the callback.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's no <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code> here. If the stream ends with incomplete data (a partial length header or a partial message body), that data is lost. Whether this is correct depends on your protocol. Some protocols treat partial data at EOF as an error. Others emit a final incomplete message or emit an error in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Most transforms you implement will be variations of these patterns.</p>
<h2 id="the-chunking-boundary-problem" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The Chunking Boundary Problem</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Data structures that span chunk boundaries cause problems in nearly every <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> implementation. This is the source of many subtle bugs in streaming code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you're processing a stream of bytes or text, the chunks you receive are <strong class="font-bold">arbitrary</strong>. The stream doesn't know or care about the structure of your data. If you're parsing JSON objects separated by newlines, a newline might appear in the middle of a chunk, or it might fall exactly on a chunk boundary, or a JSON object might be split across two chunks.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can't assume that each chunk is a complete unit. You have to handle <strong class="font-bold">partial data</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">We've seen this in the delimiter parser and the length-prefixed parser. <strong class="font-bold">Buffering</strong> solves this. You maintain an internal buffer (often a string or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code>) that accumulates incoming data. You process complete units from the buffer and leave incomplete units for the next call.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The pattern in abstract form:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> Parser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> unit;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> ((unit </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">extractCompleteUnit</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer))) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> unit.remainder;</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(unit.data);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">      // handle remaining data</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  extractCompleteUnit</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">buffer</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // return { data, remainder } or null</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">extractCompleteUnit()</code> method tries to parse one complete unit from the buffer. If it succeeds, it returns the parsed data and the remaining buffer. If there's not enough data to parse a complete unit, it returns null. The loop continues extracting units until the buffer is empty or incomplete.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern handles arbitrary chunk boundaries correctly. It doesn't matter where the chunks split - the parser accumulates data until it has a complete unit, parses it, and continues.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Concrete example: parsing CSV rows from a stream. A CSV file is lines separated by newlines, and each line is fields separated by commas. A line might be split across chunks, and a field might contain a newline if it's quoted.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A simplified CSV parser (without handling quoted fields):</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> SimpleCSVParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> fields</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(fields);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> fields</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(fields);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This handles line boundaries correctly. If a line is split across chunks, the partial line is buffered until the newline arrives in a subsequent chunk.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But this doesn't handle quoted fields. If a field is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">"hello\nworld"</code>, the newline inside the quotes shouldn't split the line. Handling this correctly requires a more complex state machine that tracks whether we're inside quotes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Proper <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> implementations must account for the possibility that data structures span chunks. Buffering and state machines are the tools you use to handle this.</p>
<h2 id="push-behavior-and-backpressure-in-transforms" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Push Behavior and Backpressure in Transforms</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push()</code> in a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> is more subtle than it appears, because <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push</code> is the interface to the readable side, and it respects <strong class="font-bold">backpressure</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push(chunk)</code>, the chunk is added to the readable side's internal buffer. If the buffer is below its <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>. If the buffer is at or above <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, signaling backpressure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can check this return value in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> transformed</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">transformData</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> canContinue</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(transformed);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">canContinue) {</span></span>
<span class="line"><span style="color:#6A737D">    // readable side is full, but we have to process this chunk</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The return value of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push</code> in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> doesn't usually affect your logic. You still have to call the callback. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream handles backpressure for you by not calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> again until the readable side drains. You don't need to implement pause/resume logic yourself.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is different from implementing a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> stream, where you check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push</code>'s return value and stop calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> if it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. In a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>, the base class handles this. You just implement the transformation logic.</p>
<p class="text-base leading-relaxed mb-4 font-normal">However, if you're pushing multiple chunks in a single <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> call (a one-to-many transform), you might want to check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push</code>'s return value and stop pushing if backpressure is signaled:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> parts</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">splitIntoParts</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> part</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> parts) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> canContinue</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(part);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">canContinue) {</span></span>
<span class="line"><span style="color:#6A737D">      // readable side is full, buffer the rest</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.bufferedParts </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> parts.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(parts.</span><span style="color:#B392F0">indexOf</span><span style="color:#E1E4E8">(part) </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">      break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">But this adds complexity. Most of the time, you just push all your output chunks and let the stream's buffering handle the backpressure. The readable side's buffer will grow until it hits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, at which point the stream stops calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> until the buffer drains.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This automatic backpressure handling makes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams much easier to work with than raw <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams. You don't have to coordinate the two sides manually  -  the base class does it for you.</p>
<h2 id="passthrough" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">PassThrough</h2>
<p class="text-base leading-relaxed mb-4 font-normal">There's a built-in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream that does nothing: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.PassThrough</code>. It's a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> where <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> just pushes the input chunk unchanged.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { PassThrough } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> passthrough</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> PassThrough</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Use cases: observing or intercepting data without modifying it.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One use case is adding event listeners. You can insert a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code> into a pipeline and attach <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'data'</code> listeners to it to observe the data flowing through without affecting the pipeline:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> passthrough</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> PassThrough</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">passthrough.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Passing through:"</span><span style="color:#E1E4E8">, chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"bytes"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, passthrough, destination);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Another use case is implementing a <strong class="font-bold">tee</strong> or <strong class="font-bold">broadcast</strong> pattern, where you split a stream to multiple destinations. You can pipe a stream to multiple <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code>s, and each <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code> can be piped to a different destination.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code> is also useful in testing. You can create a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code>, write test data to it, and then read from it to verify that your stream processing logic works correctly.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Implementing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code> yourself:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> MyPassThrough</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">, chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">callback(null, chunk)</code> is a shorthand for pushing the chunk and then calling the callback. It's equivalent to:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#B392F0">callback</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern of passing the chunk to the callback is common when you want to push exactly one chunk per input chunk.</p>
<h2 id="transform-vs-duplex-when-to-use-each" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Transform vs Duplex - When to Use Each</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've covered both <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams. The choice between them matters for API design.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams fit data pipelines where input chunks become output chunks. The output depends on the input. Compression, encryption, parsing, formatting, filtering, and mapping all work this way.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams model bidirectional communication channels where the readable and writable sides are independent. Network sockets, IPC channels, proxy connections, and bidirectional message passing all work this way.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Does what you write affect what you read? If yes, use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>. If no, use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Application-level code mostly uses <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> streams appear at the system level: networking and IPC modules that model channels rather than transformations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Concrete examples:</p>
<p class="text-base leading-relaxed mb-4 font-normal">A <strong class="font-bold">Transform</strong> that compresses data:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createGzip } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "zlib"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> gzip</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createGzip</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">input.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(gzip).</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(output);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">What you write to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">gzip</code> (uncompressed data) directly determines what you read from it (compressed data). It's a transformation.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A <strong class="font-bold">Duplex</strong> that represents a TCP socket:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { connect } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "net"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> socket</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> connect</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">3000</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"localhost"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">socket.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"request"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">socket.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"response:"</span><span style="color:#E1E4E8">, chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">What you write to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">socket</code> (your request) doesn't produce the data you read from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">socket</code> (the server's response). They're independent. It's a channel.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's a subtle case where you might implement a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> instead of a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>: when you need to model something that has independent input and output, but the two sides share state. For example, a stream that encrypts outgoing data and decrypts incoming data using the same encryption key. The two sides are independent (encrypting A doesn't produce decrypted B), but they share configuration.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In practice, you'd probably implement this as two separate <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams (one for encryption, one for decryption) rather than a single <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>, because it's cleaner and more composable. But it's technically a valid <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> use case.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The rule of thumb: if you're building something that fits naturally into a pipeline with other transforms, make it a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>. If you're building something that sits at the edge of your system, communicating with external entities, make it a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code>.</p>
<h2 id="real-world-transform-examples" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Real-World Transform Examples</h2>
<p class="text-base leading-relaxed mb-4 font-normal">A few <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams you might actually use in production:</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">1) JSON Line Stringifier</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">This transform takes JavaScript objects and outputs newline-delimited JSON:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> JSONLineStringifier</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, writableObjectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> json</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">stringify</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(json </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableObjectMode: true</code> setting here: the writable side accepts objects, but the readable side emits strings (or buffers). You can mix modes  -  writable in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, readable in byte mode, or vice versa.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">2) Line Counter</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">This transform counts lines and emits a summary object at the end:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> LineCounter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, readableObjectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.lineCount </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.byteCount </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.byteCount </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">).</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.lineCount </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> lines;</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">      lines: </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.lineCount,</span></span>
<span class="line"><span style="color:#E1E4E8">      bytes: </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.byteCount,</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform doesn't push anything during <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code>, just accumulates statistics. In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>, it pushes a single summary object. This is a valid pattern - transforms don't have to produce output for every input chunk.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">3) Rate Limiter</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">This transform delays chunks to enforce a maximum throughput:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> RateLimiter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">bytesPerSecond</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.bytesPerSecond </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> bytesPerSecond;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> bytesPerSecond;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.lastRefill </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Date.</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_refillTokens</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> wait</span><span style="color:#F97583"> =</span></span>
<span class="line"><span style="color:#E1E4E8">      Math.</span><span style="color:#B392F0">max</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, chunk.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.tokens) </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.bytesPerSecond;</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">    setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">max</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }, wait </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 1000</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _refillTokens</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> now</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Date.</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> elapsed</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> (now </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.lastRefill) </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 1000</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.bytesPerSecond,</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> elapsed </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.bytesPerSecond</span></span>
<span class="line"><span style="color:#E1E4E8">    );</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.lastRefill </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> now;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform uses a token bucket to rate-limit throughput. If there aren't enough tokens for the current chunk, it delays the callback until enough time has passed. This is a useful pattern for throttling data flow to match downstream capacity.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">4) Deduplicator</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">This transform in objectMode removes duplicate objects based on a key:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> Deduplicator</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">keyField</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.keyField </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> keyField;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.seen </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Set</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> key</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> obj[</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.keyField];</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.seen.</span><span style="color:#B392F0">has</span><span style="color:#E1E4E8">(key)) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.seen.</span><span style="color:#B392F0">add</span><span style="color:#E1E4E8">(key);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This maintains a set of keys it's seen. If an object's key is new, it's pushed. Otherwise, it's dropped. This is a stateful filter transform.</p>
<p class="text-base leading-relaxed mb-4 font-normal">These examples show the versatility of Transform streams. They can aggregate, filter, format, throttle, deduplicate, and more. Any operation that takes a stream of chunks and produces a stream of chunks is a candidate for a Transform.</p>
<h2 id="error-handling-and-cleanup" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Error Handling and Cleanup</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Transform streams inherit error handling from both Readable and Writable. If an error occurs in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>, you pass it to the callback, and the stream emits an 'error' event.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> result</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">process</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(result);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.process()</code> throws, the error is caught and passed to the callback. The stream emits 'error', and processing stops.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also use async functions for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">async </span><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> result</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">processAsync</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(result);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Or omit the callback and return a promise:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">async </span><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(chunk, encoding) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> result</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">processAsync</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(result);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If the promise rejects, Node.js treats it as an error and invokes the callback with the rejection reason.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For cleanup, you can implement <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_destroy()</code>, which is called when the stream is destroyed:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_destroy</span><span style="color:#E1E4E8">(err, callback) {</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">cleanup</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">  callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful if your transform allocates resources (file handles, database connections, timers) that need to be released when the stream is destroyed.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Always attach an 'error' listener to Transform streams you create or use:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">transform.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Transform error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Without an error listener, an error will crash your process.</p>
<h2 id="objectmode-considerations-for-transforms" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">ObjectMode Considerations for Transforms</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've mentioned objectMode several times. With Transform streams, you can mix modes between the writable and readable sides.</p>
<p class="text-base leading-relaxed mb-4 font-normal">By default, both sides are in byte mode. But you can set:</p>
<ul class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:disc;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableObjectMode: true</code> - writable side accepts objects, readable side emits buffers/strings</li>
<li class="ml-2 font-normal" style="display:list-item"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readableObjectMode: true</code> - writable side accepts buffers/strings, readable side emits objects</li>
<li class="ml-2 font-normal" style="display:list-item"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode: true</code> - both sides in objectMode</li>
</ul>
<p class="text-base leading-relaxed mb-4 font-normal">Example: a Transform that parses JSON from bytes to objects:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> JSONParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, readableObjectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The writable side is in byte mode (accepts buffers), the readable side is in objectMode (emits objects).</p>
<p class="text-base leading-relaxed mb-4 font-normal">Conversely, a Transform that stringifies objects to JSON:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> JSONStringifier</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, writableObjectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> json</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">stringify</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(json);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The writable side is in objectMode (accepts objects), the readable side is in byte mode (emits strings/buffers).</p>
<p class="text-base leading-relaxed mb-4 font-normal">This flexibility lets you build pipelines that seamlessly transition between byte streams and object streams. You can have a byte stream that reads from a file, a Transform that parses bytes into objects, a Transform that processes objects, and another Transform that serializes objects back to bytes before writing to a destination.</p>
<h2 id="simplified-transform-creation" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Simplified Transform Creation</h2>
<p class="text-base leading-relaxed mb-4 font-normal">For simple transforms, you don't have to create a class. You can pass options with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">transform</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">flush</code> functions inline:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Transform } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> uppercase</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#B392F0">  transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is convenient for one-off transforms. You pass a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">transform</code> function and optionally a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">flush</code> function in the options object. Node.js creates the Transform and calls your functions as <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_flush()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.pipeline()</code> with transform functions directly:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">  source,</span></span>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#F97583"> function*</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">  destination</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This async generator becomes a Transform. Each <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">yield</code> pushes a chunk. This is even more concise for simple transforms and fits naturally with async iteration.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For complex stateful transforms, use a class. For simple one-off transforms in a pipeline, use inline options or a generator.</p>
<h2 id="performance-considerations" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Performance Considerations</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> streams add a layer of abstraction, which has a performance cost. Every chunk passes through the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>'s internal machinery  -  buffering, event emission, callback invocation. For high-throughput applications, this overhead can matter.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you're processing millions of small chunks per second, the overhead of creating <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> instances and invoking <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> for each chunk might be measurable. In such cases, consider <strong class="font-bold">batching</strong>. Instead of processing one object at a time, process arrays of objects. This reduces the number of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> invocations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For example, instead of:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> stream) {</span></span>
<span class="line"><span style="color:#B392F0">  process</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Batch with:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> batch</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> batchedStream) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> batch) {</span></span>
<span class="line"><span style="color:#B392F0">    process</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">BatchAccumulator</code> transform we implemented earlier does this.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another performance consideration is buffer copying. If your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer.concat()</code> repeatedly to accumulate data, you're allocating and copying buffers on every chunk. For large data volumes, this is slow. Consider using a more efficient data structure, like a linked list of buffers or a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">BufferList</code> from the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'bl'</code> npm package.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For transforms that don't need to accumulate state, make sure you're not accidentally buffering. If your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_transform()</code> immediately pushes each chunk, the transform is efficient. If it accumulates chunks in an array or buffer before pushing, you're adding memory pressure and latency.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Measure performance before optimizing. Use Node.js's built-in profiler or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">clinic.js</code> to identify bottlenecks. Many transforms are fast enough already, but high-throughput pipelines need attention to these details.</p>
<h2 id="testing-custom-transforms" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Testing Custom Transforms</h2>
<p class="text-base leading-relaxed mb-4 font-normal">When you implement a custom <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>, you need to test it. Here are patterns for testing transforms reliably.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Test by writing and reading:</strong></p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Readable, Writable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> input</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Readable.</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">([</span><span style="color:#9ECBFF">"hello"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"world"</span><span style="color:#E1E4E8">]);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> output</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> collector</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#B392F0">  write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    output.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(input, myTransform, collector);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">assert.</span><span style="color:#B392F0">deepEqual</span><span style="color:#E1E4E8">(output, [</span><span style="color:#9ECBFF">"HELLO"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"WORLD"</span><span style="color:#E1E4E8">]);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">You create a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> source with known data, pipe it through your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>, collect the output in a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code>, and assert the result.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Test edge cases:</strong> empty input, single chunks, many small chunks, large chunks, incomplete data at EOF, and invalid data. Write a test for each scenario.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Test backpressure:</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">Create a slow <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> destination and verify that the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> respects backpressure:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> slow</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#B392F0">  write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    setTimeout</span><span style="color:#E1E4E8">(callback, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> start</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Date.</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(fastSource, myTransform, slow);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> elapsed</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Date.</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> start;</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">assert</span><span style="color:#E1E4E8">(elapsed </span><span style="color:#F97583">&gt;</span><span style="color:#E1E4E8"> expectedMinimum);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> doesn't respect backpressure, it will finish much faster than expected because it's not waiting for the slow destination.</p>    
</body>
</html>