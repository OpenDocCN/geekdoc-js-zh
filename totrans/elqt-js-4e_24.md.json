["```js\n[{\"title\": \"Unituning\",\n  \"presenter\": \"Jamal\",\n  \"summary\": \"Modifying your cycle for extra style\",\n  \"comments\": []}]\n```", "```js\nconsole.log(\"/talks/\" + encodeURIComponent(\"How to Idle\"));\n// â†’ /talks/How%20to%20Idle\n```", "```js\nPUT /talks/How%20to%20Idle HTTP/1.1\nContent-Type: application/json\nContent-Length: 92\n\n{\"presenter\": \"Maureen\",\n \"summary\": \"Standing still on a unicycle\"}\n```", "```js\nPOST /talks/Unituning/comments HTTP/1.1\nContent-Type: application/json\nContent-Length: 72\n\n{\"author\": \"Iman\",\n \"message\": \"Will you talk about raising a cycle?\"}\n```", "```js\nGET /talks HTTP/1.1\nIf-None-Match: \"4\"\nPrefer: wait=90\n\n(time passes)\n\nHTTP/1.1 200 OK\nContent-Type: application/json\nETag: \"5\"\nContent-Length: 295\n\n--snip--\n```", "```js\nexport class Router {\n  constructor() {\n    this.routes = [];\n  }\n add(method, url, handler) {\n    this.routes.push({method, url, handler});\n  }\n  async resolve(request, context) {\n    let {pathname} = new URL(request.url, \"http://d\");\n    for (let {method, url, handler} of this.routes) {\n      let match = url.exec(pathname);\n      if (!match || request.method != method) continue;\n      let parts = match.slice(1).map(decodeURIComponent);\n      return handler(context, ...parts, request);\n    }\n  }\n}\n```", "```js\nimport {createServer} from \"node:http\";\nimport serveStatic from \"serve-static\";\n\nfunction notFound(request, response) {\n  response.writeHead(404, \"Not found\");\n  response.end(\"<h1>Not found</h1>\");\n}\nclass SkillShareServer {\n  constructor(talks) {\n    this.talks = talks;\n    this.version = 0;\n    this.waiting = [];\n\n    let fileServer = serveStatic(\"./public\");\n    this.server = createServer((request, response) => {\n      serveFromRouter(this, request, response, () => {\n        fileServer(request, response,\n                   () => notFound(request, response));\n      });\n    });\n  }\n  start(port) {\n    this.server.listen(port);\n  }\n  stop() {\n    this.server.close();\n  }\n}\n```", "```js\nimport {Router} from \"./router.mjs\";\n\nconst router = new Router();\nconst defaultHeaders = {\"Content-Type\": \"text/plain\"};\n\nasync function serveFromRouter(server, request,\n                               response, next) {\n  let resolved = await router.resolve(request, server)\n    .catch(error => {\n      if (error.status != null) return error;\n      return {body: String(err), status: 500};\n    });\n  if (!resolved) return next();\n  let {body, status = 200, headers = defaultHeaders} =\n    await resolved; \n response.writeHead(status, headers);\n  response.end(body);\n}\n```", "```js\nconst talkPath = /^\\/talks\\/([^\\/]+)$/;\n\nrouter.add(\"GET\", talkPath, async (server, title) => {\n  if (Object.hasOwn(server.talks, title)) {\n    return {body: JSON.stringify(server.talks[title]),\n            headers: {\"Content-Type\": \"application/json\"}};\n  } else {\n    return {status: 404, body: `No talk '${title}' found`};\n  }\n});\n```", "```js\nrouter.add(\"DELETE\", talkPath, async (server, title) => {\n  if (Object.hasOwn(server.talks, title)) {\n    delete server.talks[title];\n    server.updated();\n  }\n  return {status: 204};\n});\n```", "```js\nimport {json as readJSON} from \"node:stream/consumers\";\n\nrouter.add(\"PUT\", talkPath,\n           async (server, title, request) => {\n  let talk = await readJSON(request);\n  if (!talk ||\n      typeof talk.presenter != \"string\" ||\n      typeof talk.summary != \"string\") {\n    return {status: 400, body: \"Bad talk data\"};\n  }\n  server.talks[title] = {\n    title,\n    presenter: talk.presenter,\n    summary: talk.summary,\n    comments: []\n  };\n  server.updated();\n  return {status: 204};\n});\n```", "```js\nrouter.add(\"POST\", /^\\/talks\\/([^\\/]+)\\/comments$/,\n           async (server, title, request) => {\n  let comment = await readJSON(request);\n  if (!comment ||\n      typeof comment.author != \"string\" ||\n      typeof comment.message != \"string\") {\n    return {status: 400, body: \"Bad comment data\"};\n  } else if (Object.hasOwn(server.talks, title)) {\n    server.talks[title].comments.push(comment);\n    server.updated();\n    return {status: 204};\n  } else {\n    return {status: 404, body: `No talk '${title}' found`};\n  }\n});\n```", "```js\nSkillShareServer.prototype.talkResponse = function() {\n  let talks = Object.keys(this.talks)\n    .map(title => this.talks[title]);\n  return {\n    body: JSON.stringify(talks),\n    headers: {\"Content-Type\": \"application/json\",\n              \"ETag\": `\"${this.version}\"`,\n              \"Cache-Control\": \"no-store\"}\n  };\n};\n```", "```js\nrouter.add(\"GET\", /^\\/talks$/, async (server, request) => {\n  let tag = /\"(.*)\"/.exec(request.headers[\"if-none-match\"]);\n  let wait = /\\bwait=(\\d+)/.exec(request.headers[\"prefer\"]);\n  if (!tag || tag[1] != server.version) {\n    return server.talkResponse();\n  } else if (!wait) {\n    return {status: 304};\n  } else {\n    return server.waitForChanges(Number(wait[1]));\n  }\n});\n```", "```js\nSkillShareServer.prototype.waitForChanges = function(time) {\n  return new Promise(resolve => {\n    this.waiting.push(resolve);\n    setTimeout(() => {\n      if (!this.waiting.includes(resolve)) return;\n      this.waiting = this.waiting.filter(r => r != resolve);\n resolve({status: 304});\n    }, time * 1000);\n  });\n};\n```", "```js\nSkillShareServer.prototype.updated = function() {\n  this.version++;\n  let response = this.talkResponse();\n  this.waiting.forEach(resolve => resolve(response));\n  this.waiting = [];\n};\n```", "```js\nnew SkillShareServer({}).start(8000);\n```", "```js\n<!doctype html>\n<meta charset=\"utf-8\">\n<title>Skill Sharing</title>\n<link rel=\"stylesheet\" href=\"skillsharing.css\">\n\n<h1>Skill Sharing</h1>\n\n<script src=\"skillsharing_client.js\"></script>\n```", "```js\nfunction handleAction(state, action) {\n  if (action.type == \"setUser\") {\n    localStorage.setItem(\"userName\", action.user);\n    return {...state, user: action.user};\n  } else if (action.type == \"setTalks\") {\n    return {...state, talks: action.talks};\n  } else if (action.type == \"newTalk\") {\n    fetchOK(talkURL(action.title), {\n      method: \"PUT\",\n      headers: {\"Content-Type\": \"application/json\"},\n      body: JSON.stringify({\n        presenter: state.user,\n        summary: action.summary\n      })\n    }).catch(reportError);\n  } else if (action.type == \"deleteTalk\") {\n    fetchOK(talkURL(action.talk), {method: \"DELETE\"})\n      .catch(reportError);\n  } else if (action.type == \"newComment\") {\n    fetchOK(talkURL(action.talk) + \"/comments\", {\n      method: \"POST\",\n      headers: {\"Content-Type\": \"application/json\"},\n      body: JSON.stringify({\n        author: state.user,\n        message: action.message\n      })\n    }).catch(reportError);\n  }\n  return state;\n}\n```", "```js\nfunction fetchOK(url, options) {\n  return fetch(url, options).then(response => {\n    if (response.status < 400) return response;\n    else throw new Error(response.statusText);\n  });\n}\n```", "```js\nfunction talkURL(title) {\n  return \"talks/\" + encodeURIComponent(title);\n}\n```", "```js\nfunction reportError(error) {\n  alert(String(error));\n}\n```", "```js\nfunction renderUserField(name, dispatch) {\n  return elt(\"label\", {}, \"Your name: \", elt(\"input\", {\n    type: \"text\",\n    value: name,\n    onchange(event) {\n      dispatch({type: \"setUser\", user: event.target.value});\n    }\n  }));\n}\n```", "```js\nfunction renderTalk(talk, dispatch) {\n  return elt(\n    \"section\", {className: \"talk\"},\n    elt(\"h2\", null, talk.title, \" \", elt(\"button\", {\n      type: \"button\",\n      onclick() {\n        dispatch({type: \"deleteTalk\", talk: talk.title});\n      }\n    }, \"Delete\")),\n    elt(\"div\", null, \"by \",\n        elt(\"strong\", null, talk.presenter)),\n    elt(\"p\", null, talk.summary),\n    ...talk.comments.map(renderComment),\n    elt(\"form\", {\n      onsubmit(event) {\n        event.preventDefault();\n        let form = event.target;\n        dispatch({type: \"newComment\",\n                  talk: talk.title,\n                  message: form.elements.comment.value});\n        form.reset();\n      }\n    }, elt(\"input\", {type: \"text\", name: \"comment\"}), \" \",\n       elt(\"button\", {type: \"submit\"}, \"Add comment\")));\n}\n```", "```js\nfunction renderComment(comment) {\n  return elt(\"p\", {className: \"comment\"},\n             elt(\"strong\", null, comment.author),\n             \": \", comment.message);\n}\n```", "```js\nfunction renderTalkForm(dispatch) {\n  let title = elt(\"input\", {type: \"text\"});\n  let summary = elt(\"input\", {type: \"text\"});\n  return elt(\"form\", {\n    onsubmit(event) {\n      event.preventDefault();\n      dispatch({type: \"newTalk\",\n                title: title.value,\n                summary: summary.value});\n      event.target.reset();\n    }\n  }, elt(\"h3\", null, \"Submit a Talk\"),\n     elt(\"label\", null, \"Title: \", title),\n     elt(\"label\", null, \"Summary: \", summary),\n     elt(\"button\", {type: \"submit\"}, \"Submit\"));\n}\n```", "```js\nasync function pollTalks(update) {\n  let tag = undefined;\n  for (;;) {\n    let response;\n    try {\n      response = await fetchOK(\"/talks\", {\n        headers: tag && {\"If-None-Match\": tag,\n                         \"Prefer\": \"wait=90\"}\n      });\n    } catch (e) {\n      console.log(\"Request failed: \" + e);\n      await new Promise(resolve => setTimeout(resolve, 500));\n      continue;\n    }\n    if (response.status == 304) continue;\n    tag = response.headers.get(\"ETag\");\n    update(await response.json());\n  }\n}\n```", "```js\nclass SkillShareApp {\n  constructor(state, dispatch) {\n    this.dispatch = dispatch;\n    this.talkDOM = elt(\"div\", {className: \"talks\"});\n    this.dom = elt(\"div\", null,\n                   renderUserField(state.user, dispatch),\n                   this.talkDOM,\n                   renderTalkForm(dispatch));\n    this.syncState(state);\n  }\n\n  syncState(state) {\n    if (state.talks != this.talks) {\n      this.talkDOM.textContent = \"\";\n      for (let talk of state.talks) {\n        this.talkDOM.appendChild(\n          renderTalk(talk, this.dispatch));\n      }\n      this.talks = state.talks;\n    }\n  }\n}\n```", "```js\nfunction runApp() {\n  let user = localStorage.getItem(\"userName\") || \"Anon\";\n  let state, app;\n  function dispatch(action) {\n    state = handleAction(state, action);\n app.syncState(state);\n  }\n\n  pollTalks(talks => {\n    if (!app) {\n      state = {user, talks};\n      app = new SkillShareApp(state, dispatch);\n      document.body.appendChild(app.dom);\n    } else {\n      dispatch({type: \"setTalks\", talks});\n    }\n  }).catch(reportError);\n}\n\nrunApp();\n```"]