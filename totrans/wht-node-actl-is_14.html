<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Modern Async Pipelines & Error Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Modern Async Pipelines & Error Handling</h1>
<blockquote>原文：<a href="https://www.thenodebook.com/streams/modern-pipelines-error-handling">https://www.thenodebook.com/streams/modern-pipelines-error-handling</a></blockquote><p class="text-base leading-relaxed mb-4 font-normal">You know how individual streams work now - <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> producing data, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> consuming it, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> processing it in between. Each stream type has its own buffering, its own backpressure mechanism, its own event lifecycle. In real applications, you rarely work with streams in isolation. You're connecting them together, creating <strong class="font-bold">pipelines</strong> where data flows from source through multiple transformation stages to a final destination.</p>
<p class="text-base leading-relaxed mb-4 font-normal">And this is where things get tricky. The concept's fine - piping data from one stream to another is straightforward enough - but actually doing it correctly? That's where the headaches start. Because when you connect streams, you're dealing with <strong class="font-bold">multiple error sources</strong>, <strong class="font-bold">multiple backpressure signals</strong>, and <strong class="font-bold">multiple resource cleanup scenarios</strong>. If any stream in your pipeline fails, what happens to the others? If backpressure occurs midway through, does it propagate correctly? When the pipeline completes, are all resources cleaned up properly?</p>
<p class="text-base leading-relaxed mb-4 font-normal">This chapter is about answering those questions. We're going to examine the original <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> method and understand both why it exists and why it's insufficient for production code. Then we'll dive deep into <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.pipeline()</code>, which is the modern, recommended approach for composing stream pipelines with proper error handling and cleanup. After that, we'll explore error handling patterns specific to streaming - because errors in pipelines behave differently from errors in synchronous code. We'll look at using async iteration as an alternative pipeline approach, and finally we'll cover advanced composition patterns for building reusable, flexible pipeline segments.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This chapter covers how to connect streams correctly - with proper error propagation, resource cleanup, and backpressure handling across all stages.</p>
<h2 id="the-pipe-method" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The pipe() Method</h2>
<p class="text-base leading-relaxed mb-4 font-normal">You've already learned how <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> works from the Readable and Writable chapters. As a quick recap: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> connects a Readable stream to a Writable, automatically handling backpressure by calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code> when the Writable emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>. We covered this pattern extensively in the Writable Streams chapter when discussing backpressure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The method returns the destination stream, allowing you to chain pipes:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(transform1).</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(transform2).</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(writable);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This creates a four-stage pipeline: readable -&gt; transform1 -&gt; transform2 -&gt; writable. Data flows through each stage sequentially, with <strong class="font-bold">backpressure propagating backward</strong> from the writable destination all the way to the readable source—a pattern we explored in detail in the Writable Streams chapter. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable</code> signals backpressure, the entire chain pauses; when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable</code> emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>, the resume signal propagates forward.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A concrete example—compressing a log file:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createGzip } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "zlib"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"app.log"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">  .</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">createGzip</span><span style="color:#E1E4E8">())</span></span>
<span class="line"><span style="color:#E1E4E8">  .</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"app.log.gz"</span><span style="color:#E1E4E8">));</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Three streams, two <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> calls. The file reader produces chunks, the gzip transform compresses them, and the file writer saves the compressed data. Memory usage stays bounded because each stage respects backpressure signals.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> has a problem: <strong class="font-bold">error handling</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's what happens when an error occurs in a piped stream. The stream that encounters the error emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event. But that error <strong class="font-bold">does not propagate</strong> to other streams in the pipeline. You already know from the Readable and Writable chapters that each stream needs its own error handler, or the error will crash your process. But in pipelines, this becomes especially painful.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> reader</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> transform</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createGzip</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> writer</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.gz"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">reader.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(transform).</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(writer);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">reader.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Reader error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">transform.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Transform error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Writer error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">You need three separate error handlers. Miss one and your process crashes. It's tedious, error-prone, and honestly kind of ridiculous for something that should be straightforward.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But it gets worse. When an error occurs in the middle of a pipeline, the other streams <strong class="font-bold">don't automatically stop</strong>. Suppose the transform throws an error while processing a chunk. The transform emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> and stops processing. But the reader keeps reading and trying to write to the transform, which is now in an errored state. The writer is waiting for data that will never come, and it might never emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> because the pipeline never completes cleanly.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You end up with <strong class="font-bold">dangling resources</strong>. File handles that aren't closed. Network connections that aren't cleaned up. Memory buffers that aren't released. The pipeline is in a partially-failed state, and cleaning it up requires manually calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on each stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">reader.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  reader.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  transform.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  writer.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">transform.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  reader.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  transform.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  writer.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  reader.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  transform.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  writer.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is verbose, repetitive, and fragile. If you add a new stream to the pipeline, you have to update all the error handlers to destroy the new stream too.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's another limitation of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>: you can't easily tell when the entire pipeline has completed. The readable emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> when it's done reading. The writable emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> when it's done writing. But which one do you listen to? And what if you have multiple transforms in the middle? Each transform emits its own <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> event. The final destination emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>. You have to track the <strong class="font-bold">right event on the right stream</strong>, which depends on the pipeline's structure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For simple two-stream scenarios, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> works fine. But for real production pipelines with multiple stages and proper error handling requirements, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> is insufficient. This is why <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.pipeline()</code> was introduced.</p>
<h2 id="the-unpipe-method" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The unpipe() Method</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Worth covering <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe()</code> before pipeline() - though you'll rarely use it. This method disconnects a piped stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> writer</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> writable</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(writer);</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">// Later, disconnect</span></span>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">unpipe</span><span style="color:#E1E4E8">(writer);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe()</code>, the readable stops sending data to the specified writable. If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe()</code> without arguments, it disconnects from all destinations:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">unpipe</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Why would you use this? Mainly for dynamic routing scenarios where you want to redirect a stream's output based on runtime conditions. For example, you might be reading from a socket and initially piping to a file, but then decide to pipe to a different destination based on incoming data:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">socket.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">shouldRedirect</span><span style="color:#E1E4E8">(chunk)) {</span></span>
<span class="line"><span style="color:#E1E4E8">    socket.</span><span style="color:#B392F0">unpipe</span><span style="color:#E1E4E8">(fileWriter);</span></span>
<span class="line"><span style="color:#E1E4E8">    socket.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(differentWriter);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">But in practice? I've almost never needed <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe()</code>. Most pipelines are static - you define the flow at setup time and let it run to completion. Dynamic routing is better handled with higher-level abstractions, like routing streams or conditional transforms.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The main thing to know about <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe()</code> is that it exists, and that when you unpipe a stream, the destination does not automatically end. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe()</code> is called, it removes the destination's listeners from the source stream. The source stream's flowing mode state depends on whether any consumers remain attached - if all pipe destinations are removed and there are no <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event listeners, the stream switches back to paused mode. If other consumers exist (other piped destinations or data listeners), the source continues emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events. If you want the destination to close, you need to call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> on it manually.</p>
<h2 id="streampipeline" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">stream.pipeline()</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.pipeline()</code> is the modern approach to composing streams. This function was added to Node.js specifically to address the error handling and cleanup problems with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>. Here's the basic usage:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(readable, transform, writable, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline succeeded"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Instead of chaining <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> calls, you pass all your streams as arguments to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, followed by a callback that's invoked when the pipeline completes or errors. That's the signature:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(stream1, stream2, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">, streamN, callback)</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> does three things that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> doesn't:</p>
<ol class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:decimal;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Automatic error propagation</strong>: If any stream in the pipeline emits an error, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> stops the pipeline and invokes the callback with that error. You don't need separate error handlers on each stream.</p>
</li>
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Automatic cleanup</strong>: When an error occurs (or when the pipeline completes), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on all streams in the pipeline. File handles get closed, buffers freed, connections torn down.</p>
</li>
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Single completion callback</strong>: One callback for everything.</p>
</li>
</ol>
<p class="text-base leading-relaxed mb-4 font-normal">Let's see what this looks like in practice:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createGzip } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "zlib"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">  createGzip</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#B392F0">  createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.gz"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">      console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Compression failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Compression succeeded"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If any of these streams errors - the file read fails, the gzip encounters corrupt data, the file write hits a disk-full error - the callback is invoked with the error, and all three streams are destroyed. If everything succeeds, the callback is invoked with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">err</code> as <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">undefined</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is simpler than the equivalent <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> code with manual error handling. No separate error listeners, no manual destroy calls, no tracking which stream to listen to for completion.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's also a promise-based version of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> in the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream/promises</code> module:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createGzip } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "zlib"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">    createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#B392F0">    createGzip</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#B392F0">    createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.gz"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Compression succeeded"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Compression failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The promise-based version returns a promise that resolves when the pipeline completes or rejects when any stream errors. This fits naturally with async/await code. You wrap the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> call in a try/catch, and errors are handled like any other promise rejection.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is the <strong class="font-bold">recommended pattern</strong> for modern Node.js code. Use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream/promises</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">async/await</code> for clean, readable pipeline composition.</p>
<h2 id="how-pipeline-works-internally" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">How pipeline() Works Internally</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Understanding the internals helps you reason about behavior and debug issues. When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline(s1, s2, s3, callback)</code>, the function essentially:</p>
<ol class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:decimal;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal">Connects streams using the same <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> mechanics you learned in earlier chapters—the same automatic backpressure handling we covered in the Writable Streams chapter</p>
</li>
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal">Attaches error listeners to all streams for coordinated error handling</p>
</li>
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal">Calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on all streams when any error occurs or when completion happens</p>
</li>
<li class="ml-2 font-normal" style="display:list-item">
<p class="text-base leading-relaxed mb-4 font-normal">Invokes the callback once with either an error or undefined</p>
</li>
</ol>
<p class="text-base leading-relaxed mb-4 font-normal">The key difference from manual <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> is the <strong class="font-bold">error coordination and automatic cleanup</strong>. You get the same backpressure handling (which we covered extensively in the Writable Streams chapter), but with production-grade error management.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's a highly simplified conceptual model showing the basic behavior. <strong class="font-bold">Important</strong>: This is a pedagogical simplification to illustrate the concept, not the actual implementation. The real Node.js <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> implementation (based on the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pump</code> library) is significantly more sophisticated and handles many edge cases not shown here - including async iterables, generators, complex error scenarios, once-only callback guarantees, and proper stream type detection:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> simplifiedPipeline</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">...</span><span style="color:#FFAB70">args</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> callback</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> args.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> streams</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> args;</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">  // Connect streams with pipe()</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> streams.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    streams[i].</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(streams[i </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">]);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">  // Track completion</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> lastStream</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> streams[streams.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">  lastStream.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"finish"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    destroyAll</span><span style="color:#E1E4E8">(streams);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">  // Handle errors</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> stream</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> streams) {</span></span>
<span class="line"><span style="color:#E1E4E8">    stream.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      destroyAll</span><span style="color:#E1E4E8">(streams);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> destroyAll</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">streams</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> stream</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> streams) {</span></span>
<span class="line"><span style="color:#E1E4E8">    stream.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is a conceptual model to help you understand the behavior - the real <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> implementation in Node.js is more sophisticated with its own stream connection logic and comprehensive edge case handling (once-only callback invocation, destroyed stream handling, complex error scenarios, etc.). Think of this as "what it does" rather than "how it does it."</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> handles an edge case you should know about: a stream emitting an error after it's already been destroyed. This can happen with async operations in custom streams where an error occurs after the stream has nominally completed. The real <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> implementation ensures the callback is only invoked once, even if multiple streams error simultaneously.</p>
<h2 id="using-pipeline-with-transform-functions" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Using pipeline() with Transform Functions</h2>
<p class="text-base leading-relaxed mb-4 font-normal">You don't even need <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream instances - you can pass <strong class="font-bold">async generator functions</strong>, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> will treat them as transforms.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#F97583"> function*</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#B392F0">  createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.txt"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The async generator in the middle is automatically converted to a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> stream. For each chunk from the source, the generator transforms it (in this case, uppercases it) and yields the result. The yielded values become chunks in the output stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This works well for simple transformations. Instead of creating a custom <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> class, you write a generator function inline. It reads like a loop: <strong class="font-bold">for each input chunk, produce an output chunk.</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also use regular async functions that return async iterables:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> uppercase</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">  uppercase,</span></span>
<span class="line"><span style="color:#B392F0">  createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.txt"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This works because <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> recognizes async iterables and automatically wraps them in Transform streams internally.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can even chain multiple generator transforms:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"log.txt"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#F97583"> function*</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#E1E4E8">      buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">        yield</span><span style="color:#E1E4E8"> line </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (buffer) </span><span style="color:#F97583">yield</span><span style="color:#E1E4E8"> buffer;</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#F97583"> function*</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">line.</span><span style="color:#B392F0">startsWith</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"#"</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#F97583">        yield</span><span style="color:#E1E4E8"> line;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  },</span></span>
<span class="line"><span style="color:#B392F0">  createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"filtered.txt"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The first generator converts buffers to strings and splits them into lines, handling chunk boundaries with a buffer. The second filters out lines starting with "#". Each generator is a pipeline stage, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> handles the plumbing.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is the recommended way to build stream pipelines in modern Node.js. For simple transformations, use inline generators. For complex stateful transforms, create a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> class. Mix and match as needed.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Important note about generator functions</strong>: Only values produced with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">yield</code> are sent to the output stream. If a generator uses <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">return</code> to produce a final value, that value is <strong class="font-bold">not</strong> yielded to the pipeline - it's only accessible to code directly consuming the generator. In pipeline transforms, always use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">yield</code> for output chunks.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Quick aside: if you're coming from Python, this is like itertools but actually built into the language. End digression.</p>
<h2 id="error-handling-in-stream-pipelines" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Error Handling in Stream Pipelines</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Error handling gets tricky with pipelines because they introduce error scenarios that don't exist in single-stream code. You already know from the Readable and Writable chapters that streams emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> events for various failures (file not found, disk full, network dropped, etc.).</p>
<p class="text-base leading-relaxed mb-4 font-normal">In pipelines, these errors can come from <strong class="font-bold">multiple sources simultaneously</strong>:</p>
<ul class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:disc;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item">The <strong class="font-bold">source stream</strong> might fail to read (file doesn't exist, permission denied, network dropped)</li>
<li class="ml-2 font-normal" style="display:list-item">A <strong class="font-bold">transform stream</strong> might encounter invalid data (parse error, validation failure)</li>
<li class="ml-2 font-normal" style="display:list-item">The <strong class="font-bold">destination stream</strong> might fail to write (disk full, broken pipe, remote endpoint closed)</li>
</ul>
<p class="text-base leading-relaxed mb-4 font-normal">Each of these errors manifests as an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event on the stream that encountered it. With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>, you'd have to handle each separately. With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, all errors are caught and passed to your callback or promise rejection.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When an error occurs midway through a pipeline, what happens to partial data? Suppose you're reading 100MB file, transforming it, and writing the result. At 50MB, the transform encounters corrupt data and errors. What happened to the first 50MB?</p>
<p class="text-base leading-relaxed mb-4 font-normal">The answer depends on the destination stream's behavior. If it's writing to a file, the file now contains 50MB of <strong class="font-bold">partial output</strong>. The file exists, but it's incomplete and possibly invalid. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> <strong class="font-bold">doesn't roll back</strong> partial writes - it can't. The data is already written to the underlying resource.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This means you need to handle partial data in your application logic. One pattern is to write to a temporary file and rename it to the final name only on success:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { rename, unlink } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> tempFile</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> "output.tmp"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> finalFile</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> "output.dat"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, </span><span style="color:#B392F0">createWriteStream</span><span style="color:#E1E4E8">(tempFile));</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> rename</span><span style="color:#E1E4E8">(tempFile, finalFile);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> unlink</span><span style="color:#E1E4E8">(tempFile); </span><span style="color:#6A737D">// Clean up partial file</span></span>
<span class="line"><span style="color:#F97583">  throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If the pipeline succeeds, the temp file is renamed to the final name. If it fails, the temp file is deleted. This ensures that either the complete output exists or nothing exists - no partial files.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another pattern is to use transactions when writing to a database. Write all rows within a transaction, and commit only if the pipeline completes successfully:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> tx</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> db.</span><span style="color:#B392F0">beginTransaction</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">    source,</span></span>
<span class="line"><span style="color:#E1E4E8">    transform,</span></span>
<span class="line"><span style="color:#F97583">    new</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#E1E4E8">(tx)</span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#E1E4E8"> tx.</span><span style="color:#B392F0">commit</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#E1E4E8"> tx.</span><span style="color:#B392F0">rollback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> only handles <strong class="font-bold">stream-level cleanup</strong> - calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on streams. It doesn't handle <strong class="font-bold">domain-level cleanup</strong> (deleting partial files, rolling back transactions). <strong class="font-bold">That's your responsibility.</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">Error propagation is where this gets interesting. When a stream in a pipeline errors, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> immediately calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on all other streams. This causes each stream to emit a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> event, and any pending operations are canceled. This is correct - if one stage fails, the entire pipeline should stop.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But what if you want to handle errors from different streams differently? For example, if the source fails, you want to log "read error," but if the destination fails, you want to log "write error." With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, you only get one error in the callback - the first error that occurred.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you need to distinguish between error sources, you can check the error object's properties or use error wrapping in your custom streams:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> SourceStream</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> err</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Read failed"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    err.code </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> "ERR_SOURCE_READ"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(source, transform, destination, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#E1E4E8"> err.code </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> "ERR_SOURCE_READ"</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Source read error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Other error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">By tagging errors with a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">code</code> property, you can distinguish them in the error handler.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another pattern is using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.finished()</code> to detect when a specific stream completes or errors, even within a larger pipeline:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline, finished } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> transform</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createSomeTransform</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">finished</span><span style="color:#E1E4E8">(transform, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Transform specifically failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(source, transform, destination, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Overall pipeline failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> utility attaches listeners to a stream and invokes a callback when the stream ends, errors, or is destroyed. This lets you monitor individual streams within a pipeline.</p>
<h2 id="streamfinished" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">stream.finished()</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.finished()</code> deserves a closer look.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> function takes a stream and a callback, and invokes the callback when the stream completes (either successfully or with an error):</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { finished } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">finished</span><span style="color:#E1E4E8">(someStream, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream errored:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream finished successfully"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">What does "finished" mean? For a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code>, it means the stream has ended (pushed <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> or destroyed). For a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code>, it means the stream has finished writing and emitted <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> (or been destroyed). For a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Duplex</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>, it means both sides have completed.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is safer than attaching listeners to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> directly, because <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> also listens for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy</code> events, and handles the complex logic of determining whether the stream truly completed.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's also a promise-based version:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { finished } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> finished</span><span style="color:#E1E4E8">(someStream);</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream finished"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream errored:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The promise resolves when the stream completes successfully or rejects if the stream errors.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Note on event listeners</strong>: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.finished()</code> intentionally leaves dangling event listeners (particularly <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>) after the callback is invoked or the promise settles. This design choice allows <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> to catch unexpected error events from incorrect stream implementations, preventing crashes. For most use cases with short-lived streams, this is not a concern as the streams will be garbage collected. However, for memory-sensitive applications or long-lived streams, you can use the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cleanup</code> option to remove these listeners automatically:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { finished } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> finished</span><span style="color:#E1E4E8">(someStream, { cleanup: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> }); </span><span style="color:#6A737D">// Removes listeners after completion</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Why use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> instead of just listening for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>? Because streams can end in multiple ways. A stream might emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> naturally, or it might be destroyed due to an error, or it might be destroyed explicitly via <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code>. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> utility handles all these cases and gives you a single callback or promise that represents "this stream is done, one way or another."</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful when you need to know when a specific stream in a complex pipeline has completed, even if the overall pipeline is still running. For example, if you're piping a source to multiple destinations (a tee or broadcast pattern), you can use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finished()</code> to know when each destination has consumed all its data:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest1</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output1.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest2</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output2.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(dest1);</span></span>
<span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(dest2);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">all</span><span style="color:#E1E4E8">([</span></span>
<span class="line"><span style="color:#B392F0">  finished</span><span style="color:#E1E4E8">(dest1),</span></span>
<span class="line"><span style="color:#B392F0">  finished</span><span style="color:#E1E4E8">(dest2),</span></span>
<span class="line"><span style="color:#E1E4E8">]);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Both destinations finished"</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This waits for both destinations to finish writing before proceeding.</p>
<h2 id="error-recovery-in-pipelines" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Error Recovery in Pipelines</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Not all errors are fatal - some deserve a retry. Some errors are <strong class="font-bold">transient</strong> and can be retried. Others indicate a fundamental problem and require the pipeline to fail.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For example, if you're reading from a network source and the connection drops, that might be transient. Retrying the connection could succeed. But if you're reading a file and get <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">EACCES</code> (permission denied), retrying won't help - the file's permissions won't magically change.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The first step is <strong class="font-bold">categorizing errors</strong>. Is this an <em class="italic">operational error</em> (expected failure condition) or a <em class="italic">programmer error</em> (bug in the code)? Is it transient or permanent?</p>
<p class="text-base leading-relaxed mb-4 font-normal">For transient errors, you can implement retry logic around the pipeline:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> pipelineWithRetry</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">maxRetries</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> attempt </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; attempt </span><span style="color:#F97583">&lt;=</span><span style="color:#E1E4E8"> maxRetries; attempt</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">source</span><span style="color:#E1E4E8">(), transform, destination);</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// Success</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#B392F0">isTransientError</span><span style="color:#E1E4E8">(err) </span><span style="color:#F97583">&amp;&amp;</span><span style="color:#E1E4E8"> attempt </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> maxRetries) {</span></span>
<span class="line"><span style="color:#E1E4E8">        console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Attempt ${</span><span style="color:#E1E4E8">attempt</span><span style="color:#F97583"> +</span><span style="color:#79B8FF"> 1</span><span style="color:#9ECBFF">} failed, retrying...`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        await</span><span style="color:#B392F0"> delay</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1000</span><span style="color:#F97583"> *</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">pow</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, attempt)); </span><span style="color:#6A737D">// Exponential backoff</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        throw</span><span style="color:#E1E4E8"> err; </span><span style="color:#6A737D">// Give up</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> isTransientError</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> err.code </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> "ECONNRESET"</span><span style="color:#F97583"> ||</span><span style="color:#E1E4E8"> err.code </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> "ETIMEDOUT"</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// Network errors</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This function attempts the pipeline up to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">maxRetries</code> times. If a transient error occurs, it waits (with exponential backoff) and retries. If a non-transient error occurs, or if all retries are exhausted, it throws the error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Note that the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">source()</code> is a function that creates a new source stream. You can't reuse a stream after it's errored and been destroyed. Each retry needs fresh stream instances.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another recovery pattern is fallback. If one data source fails, try an alternative source:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(primarySource, transform, destination);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">warn</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Primary source failed, trying fallback"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(fallbackSource, transform, destination);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful for redundant data sources, like trying a CDN first and falling back to an origin server if the CDN is unavailable.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For destination failures, you might want to retry writes to a different location:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, primaryDest);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">warn</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Primary destination failed, trying backup"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">source</span><span style="color:#E1E4E8">(), transform, backupDest);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Again, note that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">source()</code> is a function creating a new source. After the first pipeline fails, the original source is destroyed, so you need a new one for the retry.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold">key principle</strong>: decide upfront which errors are recoverable and implement your retry or fallback logic <strong class="font-bold">at the pipeline level</strong>, not at the individual stream level. Streams don't know about your application's retry policy - you have to coordinate it externally.</p>
<h2 id="partial-data-concerns" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Partial Data Concerns</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Partial data needs attention because it's easy to get wrong. When a pipeline fails midway through, any data already written to the destination remains there. The pipeline doesn't automatically clean it up.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is a problem for <strong class="font-bold">data integrity</strong>. If you're writing a database export and the pipeline fails at 60%, you have a 60%-complete file. If you later retry and succeed, you might end up with duplicate data (the first 60% twice) or you might overwrite the partial file with a complete one, depending on how you open the output file.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here are <strong class="font-bold">strategies for handling this</strong>:</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">1. Write to a temporary location and atomic rename</strong></p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> temp</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> "output.tmp"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> final</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> "output.dat"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, </span><span style="color:#B392F0">createWriteStream</span><span style="color:#E1E4E8">(temp));</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> rename</span><span style="color:#E1E4E8">(temp, final);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> unlink</span><span style="color:#E1E4E8">(temp).</span><span style="color:#B392F0">catch</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {}); </span><span style="color:#6A737D">// Clean up, ignore errors</span></span>
<span class="line"><span style="color:#F97583">  throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is the <strong class="font-bold">safest pattern</strong> for file outputs. The final file only exists if the pipeline completed successfully.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">2. Use append mode and idempotent operations</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">If your output supports appending (like log files), and your operations are idempotent (writing the same data twice is harmless), you can just retry from the beginning and append:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, </span><span style="color:#B392F0">createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.log"</span><span style="color:#E1E4E8">, { flags: </span><span style="color:#9ECBFF">"a"</span><span style="color:#E1E4E8"> }));</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If the pipeline fails and you retry, the second attempt appends more data. If you have duplicate detection downstream, this is fine.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">3. Use transactional destinations</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">Databases, message queues, and some cloud storage systems support transactions. Write within a transaction and commit only on success:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> tx</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> db.</span><span style="color:#B392F0">beginTransaction</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, </span><span style="color:#F97583">new</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#E1E4E8">(tx));</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#E1E4E8"> tx.</span><span style="color:#B392F0">commit</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#E1E4E8"> tx.</span><span style="color:#B392F0">rollback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The destination doesn't persist any data until the pipeline succeeds.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">4. Write a completion marker</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">For scenarios where you can't use transactions, write a marker file indicating successful completion:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, </span><span style="color:#B392F0">createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.dat"</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> writeFile</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.dat.complete"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">""</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Before processing the output file, check for the marker. If the marker doesn't exist, the file is incomplete and should be discarded or retried.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The pattern you choose depends on your destination's capabilities and your consistency requirements. The key is to be explicit about what happens on partial failure and design your pipeline to handle it.</p>
<h2 id="destroying-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Destroying Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">You've already learned about <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.destroy()</code> in the Readable and Writable chapters. As a reminder, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on any stream transitions it to a destroyed state, emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>, and optionally emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> if you pass one.</p>
<p class="text-base leading-relaxed mb-4 font-normal">What's specific to pipelines is that when you destroy <strong class="font-bold">any</strong> stream in a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, the pipeline function automatically destroys all other streams and invokes the callback with the error:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> source</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(source, dest, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline stopped:"</span><span style="color:#E1E4E8">, err.message);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">// Later, cancel the pipeline (e.g., after user action)</span></span>
<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  source.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Cancelled by user"</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">source.destroy()</code>, the source stream stops reading, emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>, and if you passed an error, emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code>. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> function sees the error and destroys all other streams in the pipeline (in this case, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest</code>). The callback is invoked with the error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This automatic cleanup is another advantage of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> over manual <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> chaining. With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>, you'd have to track all streams and destroy them manually.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful for implementing cancellation. If a user cancels an operation, you destroy the pipeline's source stream. The pipeline stops gracefully, cleans up resources, and your callback is invoked to handle the cancellation.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also destroy with no error:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">In this case, the stream is destroyed but no <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event is emitted. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> callback is still invoked, but <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">err</code> is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>. This is useful for stopping a pipeline without treating it as a failure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One important detail: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> is idempotent. Calling it multiple times on the same stream does nothing after the first call. The stream is destroyed once, and subsequent destroy calls are ignored.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another thing - when you destroy a stream, buffered data is just... gone. If a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> has buffered writes that haven't been flushed yet, they're lost. If a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> has buffered data that hasn't been consumed yet, it's lost. Destroy means <strong class="font-bold">"stop immediately and throw away any state,"</strong> not "gracefully finish pending operations."</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you need graceful shutdown (finish writing buffered data before closing), use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> instead of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// Finish writing buffered data, then close</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">But <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> only works on Writable streams. For Readable streams, there's no graceful stop - you either consume all data or you destroy.</p>
<h2 id="async-iteration-pipelines" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Async Iteration Pipelines</h2>
<p class="text-base leading-relaxed mb-4 font-normal">In the Readable Streams chapter, we explored using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code> to consume streams with automatic backpressure handling. This pattern is also an alternative to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> for building stream processing logic.</p>
<p class="text-base leading-relaxed mb-4 font-normal">As a refresher: when you iterate over a Readable stream with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code>, the iterator protocol automatically implements backpressure. The loop doesn't pull the next chunk until the current iteration completes. If your processing is async, the stream waits:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> readableStream) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> processAsync</span><span style="color:#E1E4E8">(chunk); </span><span style="color:#6A737D">// Stream waits for this</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">We won't repeat the full backpressure mechanics here—refer to the "Backpressure in Async Iteration" section in the Readable Streams chapter for the complete explanation of how the iterator protocol manages flow control.</p>
<p class="text-base leading-relaxed mb-4 font-normal">What's relevant to this chapter is using this pattern specifically for <strong class="font-bold">pipeline construction</strong> rather than <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>. You can build pipelines by reading from a source with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code>, transforming each chunk, and writing to a destination:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> source</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> transformed</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> ok</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(transformed);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ok) {</span></span>
<span class="line"><span style="color:#F97583">    await</span><span style="color:#F97583"> new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> dest.</span><span style="color:#B392F0">once</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">, resolve));</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">dest.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is a manual pipeline. You're pulling from the source, transforming, and writing to the destination, with explicit backpressure handling (wait for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns false). This pattern gives you fine-grained control over the data flow, but it requires you to manage backpressure manually—forgetting the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> check leads to unbounded memory growth, as we discussed in the Writable Streams chapter.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A cleaner pattern is to use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.Readable.from()</code> with an async generator:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> source</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> transformed</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Readable.</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">transform</span><span style="color:#E1E4E8">(source));</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(transformed, dest);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The async generator is automatically wrapped in a Readable stream, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> handles the plumbing. This combines the clarity of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code> with the robustness of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can chain multiple generator transforms:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> toUppercase</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">toUpperCase</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> filterEmpty</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">().</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> line;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">  source,</span></span>
<span class="line"><span style="color:#E1E4E8">  toUppercase,</span></span>
<span class="line"><span style="color:#E1E4E8">  filterEmpty,</span></span>
<span class="line"><span style="color:#E1E4E8">  dest</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each generator is a pipeline stage. This is readable. Each stage is a simple <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await</code> loop that yields transformed chunks. The composition is handled by <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern is especially nice for <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> pipelines</strong> where each chunk is a structured object:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> parseJSON</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(line);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> extractField</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">field</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> obj[field];</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">  source,</span></span>
<span class="line"><span style="color:#E1E4E8">  parseJSON,</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> extractField</span><span style="color:#E1E4E8">(source, </span><span style="color:#9ECBFF">"name"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">  dest</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each stage is a function from source to async iterable. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> function stitches them together. This is functional pipeline composition, and it's often clearer than creating Transform classes.</p>
<h2 id="backpressure-with-async-iteration-in-pipelines" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Backpressure with Async Iteration in Pipelines</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We covered how backpressure works with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code> in the Readable Streams chapter. The key points to remember when using this pattern in pipelines:</p>
<ol class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:decimal;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item"><strong class="font-bold">Await async work</strong> - The iterator pulls one chunk at a time; if you await async operations, backpressure flows automatically from your processing speed back to the source</li>
<li class="ml-2 font-normal" style="display:list-item"><strong class="font-bold">Don't accumulate promises</strong> - Avoid <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">promises.push(processAsync(chunk))</code> patterns that break backpressure by reading the entire stream into memory before processing</li>
<li class="ml-2 font-normal" style="display:list-item"><strong class="font-bold">Use controlled concurrency</strong> - For parallel processing with bounded concurrency, use libraries like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">p-limit</code> to limit in-flight operations</li>
</ol>
<p class="text-base leading-relaxed mb-4 font-normal">From the Readable Streams chapter: <strong class="font-bold">you must await async operations</strong> inside the loop. Without <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">await</code>, you lose backpressure:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6A737D">// WRONG - loses backpressure</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#B392F0">  slowOperation</span><span style="color:#E1E4E8">(chunk); </span><span style="color:#6A737D">// No await! Loop continues immediately</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">// CORRECT - maintains backpressure</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> slowOperation</span><span style="color:#E1E4E8">(chunk); </span><span style="color:#6A737D">// Stream waits until this completes</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The advantage of this approach over <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> is explicit control over data flow. The disadvantage is that you must manage error handling yourself—there's no automatic cleanup like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> provides.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For the full mechanics of how the async iterator protocol implements backpressure, see the "Backpressure in Async Iteration: How It Works" section in the Readable Streams chapter.</p>
<h2 id="composable-transforms" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Composable Transforms</h2>
<p class="text-base leading-relaxed mb-4 font-normal">In the Transform Streams chapter, we covered how to implement custom transforms. Now let's look at building <strong class="font-bold">reusable pipeline components</strong> through factory functions.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The pattern is straightforward—create functions that return configured stream instances:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createCSVParser</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">    objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#79B8FF">          this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    },</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">// Use in multiple pipelines</span></span>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source1, </span><span style="color:#B392F0">createCSVParser</span><span style="color:#E1E4E8">(), dest1);</span></span>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source2, </span><span style="color:#B392F0">createCSVParser</span><span style="color:#E1E4E8">(), dest2);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each call to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">createCSVParser()</code> returns a fresh Transform instance. You can't reuse a stream instance across multiple pipelines (once a stream ends or errors, it's done), but you can reuse the factory function.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can make factories configurable:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createFieldExtractor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fields</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">    objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> extracted</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> field</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> fields) {</span></span>
<span class="line"><span style="color:#E1E4E8">        extracted[field] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> obj[field];</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(extracted);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    },</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">  source,</span></span>
<span class="line"><span style="color:#B392F0">  createFieldExtractor</span><span style="color:#E1E4E8">([</span><span style="color:#9ECBFF">"name"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"email"</span><span style="color:#E1E4E8">]),</span></span>
<span class="line"><span style="color:#E1E4E8">  dest</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now the transform is parameterized. Different pipelines can extract different fields.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For more complex pipelines, you can compose pipeline segments:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createProcessingPipeline</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">dest</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">    source,</span></span>
<span class="line"><span style="color:#B392F0">    createCSVParser</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#B392F0">    createFieldExtractor</span><span style="color:#E1E4E8">([</span><span style="color:#9ECBFF">"name"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"email"</span><span style="color:#E1E4E8">]),</span></span>
<span class="line"><span style="color:#B392F0">    createValidator</span><span style="color:#E1E4E8">(),</span></span>
<span class="line"><span style="color:#E1E4E8">    dest</span></span>
<span class="line"><span style="color:#E1E4E8">  );</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> createProcessingPipeline</span><span style="color:#E1E4E8">(source1, dest1);</span></span>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> createProcessingPipeline</span><span style="color:#E1E4E8">(source2, dest2);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">createProcessingPipeline()</code> function encapsulates the entire transformation sequence. You pass in a source and destination, and it wires up all the intermediate transforms.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is a higher-order function pattern: functions that create and compose streams. It's useful for building modular, testable streaming code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also compose generator functions:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#B392F0"> parseCSV</span><span style="color:#F97583"> =</span><span style="color:#F97583"> async</span><span style="color:#F97583"> function*</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#F97583">        yield</span><span style="color:#E1E4E8"> line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">};</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#B392F0"> extractFields</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">fields</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span></span>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#F97583"> function*</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> obj</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> extracted</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> field</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> fields) {</span></span>
<span class="line"><span style="color:#E1E4E8">        extracted[field] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> obj[field];</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> extracted;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  };</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">  source,</span></span>
<span class="line"><span style="color:#E1E4E8">  parseCSV,</span></span>
<span class="line"><span style="color:#B392F0">  extractFields</span><span style="color:#E1E4E8">([</span><span style="color:#9ECBFF">"name"</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"email"</span><span style="color:#E1E4E8">]),</span></span>
<span class="line"><span style="color:#E1E4E8">  dest</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each generator is a function from async iterable to async iterable. You compose them by passing one's output as another's input. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> function handles the plumbing.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This functional composition style fits naturally with Node.js's streaming model.</p>
<h2 id="pipeline-segments" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Pipeline Segments</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Let's formalize the concept of a pipeline segment. A segment is a reusable piece of a pipeline - it might be a single transform, or a chain of transforms, or conditional logic that routes to different transforms.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's a segment that validates objects and either passes them through or routes them to an error destination:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createValidationSegment</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">schema</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">errorDest</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> valid</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> PassThrough</span><span style="color:#E1E4E8">({ objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> invalid</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> PassThrough</span><span style="color:#E1E4E8">({ objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">  invalid.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(errorDest);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">    objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#B392F0">    transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (schema.</span><span style="color:#B392F0">validate</span><span style="color:#E1E4E8">(obj)) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        invalid.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    },</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transform validates each object. Valid objects are pushed downstream. Invalid objects are written to an error destination (like a log file or error stream). This is a branching segment: one input, two outputs.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You use it like this:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> errorLog</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"errors.log"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">  source,</span></span>
<span class="line"><span style="color:#B392F0">  createValidationSegment</span><span style="color:#E1E4E8">(mySchema, errorLog),</span></span>
<span class="line"><span style="color:#E1E4E8">  dest</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Valid objects go to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest</code>. Invalid objects go to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">errorLog</code>. The pipeline continues even when invalid objects are encountered - they're just routed elsewhere.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another pattern is conditional segments that choose different transforms based on runtime state:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> createConditionalSegment</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">condition</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">trueTransform</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">falseTransform</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">    objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#F97583">    async</span><span style="color:#B392F0"> transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">obj</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> result</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#B392F0"> condition</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> transform</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> result </span><span style="color:#F97583">?</span><span style="color:#E1E4E8"> trueTransform </span><span style="color:#F97583">:</span><span style="color:#E1E4E8"> falseTransform;</span></span>
<span class="line"><span style="color:#E1E4E8">        transform.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(obj);</span></span>
<span class="line"><span style="color:#B392F0">        callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">        callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    },</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Based on a condition function, each object is sent through either <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">trueTransform</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">falseTransform</code>. This is a routing segment.</p>
<p class="text-base leading-relaxed mb-4 font-normal">These patterns - branching, routing, conditional - are building blocks for complex data flows. You compose them into larger pipelines, creating sophisticated processing logic while keeping each segment focused and reusable.</p>
<h2 id="tee-and-broadcast-patterns" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Tee and Broadcast Patterns</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Sometimes you need to send the same data to multiple destinations. This is called a tee (like a T-junction in plumbing) or broadcast pattern.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The simplest way to tee a stream is to pipe it to multiple destinations:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(dest1);</span></span>
<span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(dest2);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Both <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest1</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest2</code> receive the same data from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">source</code>. The source emits each chunk once, and both pipes forward it to their respective destinations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But there's a catch: backpressure. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest1</code> is slow and signals backpressure, the source pauses. But <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest2</code> might be fast and ready for more data. By pausing the source, you're slowing down <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest2</code> unnecessarily.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The source can't pause for one destination and continue for another. It's <strong class="font-bold">all or nothing</strong>. So when you tee a stream with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>, the <strong class="font-bold">slowest destination controls the pace</strong> for all destinations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If this is acceptable (all destinations need the same data, and you're okay with the slowest one setting the pace), then simple piping works fine. But if you want independent backpressure per destination, you need a more sophisticated approach.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One technique is to use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">PassThrough</code> streams as intermediaries:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> pass1</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> PassThrough</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> pass2</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> PassThrough</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  pass1.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">  pass2.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">source.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  pass1.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  pass2.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">pass1.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(dest1);</span></span>
<span class="line"><span style="color:#E1E4E8">pass2.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(dest2);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest1</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest2</code> have independent backpressure. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest1</code> is slow, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pass1</code> buffers. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">dest2</code> is fast, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pass2</code> doesn't buffer. The source isn't paused by either destination.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But this breaks source-level backpressure. If both destinations are slow, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pass1</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pass2</code> both buffer, and the source isn't aware. You're buffering in memory unbounded.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For truly independent destinations with bounded memory, you need to use a fan-out stream that monitors backpressure from all destinations and pauses the source only when all destinations signal backpressure:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> FanOut</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">destinations</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.destinations </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> destinations;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> allReady</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">    // Write to all destinations and check for backpressure</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.destinations) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> canContinue</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk, encoding);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">canContinue) {</span></span>
<span class="line"><span style="color:#6A737D">        // Destination buffer is full, wait for drain</span></span>
<span class="line"><span style="color:#E1E4E8">        allReady.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#F97583">          new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">            dest.</span><span style="color:#B392F0">once</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">'drain'</span><span style="color:#E1E4E8">, resolve);</span></span>
<span class="line"><span style="color:#E1E4E8">          })</span></span>
<span class="line"><span style="color:#E1E4E8">        );</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">    // If any destination signaled backpressure, wait for all to drain</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (allReady.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">all</span><span style="color:#E1E4E8">(allReady)</span></span>
<span class="line"><span style="color:#E1E4E8">        .</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> callback</span><span style="color:#E1E4E8">())</span></span>
<span class="line"><span style="color:#E1E4E8">        .</span><span style="color:#B392F0">catch</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> callback</span><span style="color:#E1E4E8">(err));</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">      // All writes succeeded without backpressure</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _final</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // End all destinations when this stream ends</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> dest</span><span style="color:#F97583"> of</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.destinations) {</span></span>
<span class="line"><span style="color:#E1E4E8">      dest.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This writable forwards each chunk to multiple destinations. The key difference from simple piping is how it handles backpressure: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns a boolean indicating whether you can continue writing. If it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, the destination's buffer is full, and you should wait for the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event before writing more. This implementation collects promises for any destinations signaling backpressure and waits for all of them to drain before invoking the callback, which creates backpressure on the source.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You use it like this:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">pipeline</span><span style="color:#E1E4E8">(source, </span><span style="color:#F97583">new</span><span style="color:#B392F0"> FanOut</span><span style="color:#E1E4E8">([dest1, dest2]), (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">  // Pipeline done</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is a more complex pattern, and it's not common in application code. Most of the time, you either accept that the slowest destination controls the pace, or you accept unbounded buffering in PassThrough intermediaries. True fan-out with independent backpressure per destination is complex and usually only needed in specialized scenarios like logging or monitoring systems.</p>
<h2 id="abortsignal-integration" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">AbortSignal Integration</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Node.js streams support <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">AbortSignal</code> for cancellation. You can pass a signal to the promise-based <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, and if the signal is aborted, the pipeline is destroyed:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> controller</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> AbortController</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, dest, { signal: controller.signal });</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err.name </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> "AbortError"</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline cancelled"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">// Note: You can also check err.code === 'ABORT_ERR' which is more robust</span></span>
<span class="line"><span style="color:#6A737D">// since the code property is harder to accidentally modify</span></span>
<span class="line"/>
<span class="line"><span style="color:#6A737D">// To cancel: controller.abort();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">controller.abort()</code>, the pipeline is immediately destroyed. All streams are torn down, the promise rejects with an <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">AbortError</code></strong>, and any pending operations are cancelled.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful for user-initiated cancellation, timeouts, or resource cleanup in long-running operations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also create a timeout signal:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> signal</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> AbortSignal.</span><span style="color:#B392F0">timeout</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">5000</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// 5 second timeout</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, dest, { signal });</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline completed"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err.name </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> "AbortError"</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline timed out"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If the pipeline doesn't complete within 5 seconds, it's automatically aborted.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For complex scenarios with multiple cancellation sources, you can use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">AbortSignal.any()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> userCancel</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> AbortController</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> timeout</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> AbortSignal.</span><span style="color:#B392F0">timeout</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">10000</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> signal</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> AbortSignal.</span><span style="color:#B392F0">any</span><span style="color:#E1E4E8">([userCancel.signal, timeout]);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(source, transform, dest, { signal });</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (err.name </span><span style="color:#F97583">===</span><span style="color:#9ECBFF"> "AbortError"</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Cancelled by either user or timeout"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    throw</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This creates a composite signal that aborts if either the user cancels or the timeout expires.</p>
<p class="text-base leading-relaxed mb-4 font-normal">AbortSignal integration makes cancellation explicit and standardized. Instead of manually calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> on streams, you abort a signal, and the pipeline handles the cleanup.</p>
<h2 id="real-world-pipeline-examples" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Real-World Pipeline Examples</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Let's implement a few complete pipelines that demonstrate all the concepts we've covered.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">1) Log File Processing</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">Read a large log file, parse each line as JSON, filter by log level, and write to separate output files:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Transform } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> parseLines</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#E1E4E8">    buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">          yield</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(line);</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">          console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Parse error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (buffer.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(buffer);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">      console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Parse error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> LevelSplitter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">level</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">dest</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.level </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> level;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.dest </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> dest;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">log</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (log.level </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.level) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">stringify</span><span style="color:#E1E4E8">(log) </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(log);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> errorDest</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"errors.log"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> warnDest</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"warnings.log"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"app.log"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">  parseLines,</span></span>
<span class="line"><span style="color:#F97583">  new</span><span style="color:#B392F0"> LevelSplitter</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"ERROR"</span><span style="color:#E1E4E8">, errorDest),</span></span>
<span class="line"><span style="color:#F97583">  new</span><span style="color:#B392F0"> LevelSplitter</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"WARN"</span><span style="color:#E1E4E8">, warnDest),</span></span>
<span class="line"><span style="color:#B392F0">  createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"all.log"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">parseLines</code> generator handles a common challenge in line-based stream processing: chunks don't align with line boundaries. A chunk might end mid-line, splitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">{"level":"ERROR"...</code> across two chunks. The solution uses buffer accumulation:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#E1E4E8">  buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();  </span><span style="color:#6A737D">// Save incomplete line for next chunk</span></span>
<span class="line"><span style="color:#6A737D">  // Process complete lines...</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you split on <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">\n</code>, the last array element is either empty (if the chunk ended with a newline) or an incomplete line. Popping that element and saving it means the next chunk appends to it, completing the line. After the loop ends, any remaining buffered data gets processed—handling files that don't end with a newline.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">try/catch</code> around <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">JSON.parse()</code> is critical:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  yield</span><span style="color:#79B8FF"> JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(line);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Parse error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Without error handling, a single malformed JSON line crashes the entire pipeline, losing all progress. With it, the pipeline logs the error and continues. Real-world log files contain corrupted entries, so the pipeline needs to handle invalid data without stopping.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">LevelSplitter</code> both filters data to a side channel and passes all data through:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_transform</span><span style="color:#E1E4E8">(log, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (log.level </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.level) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">stringify</span><span style="color:#E1E4E8">(log) </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);  </span><span style="color:#6A737D">// Side channel</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(log);  </span><span style="color:#6A737D">// Pass through to next stage</span></span>
<span class="line"><span style="color:#B392F0">  callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Every log entry continues down the main pipeline, but ERROR-level logs are <em class="italic">also</em> written to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">errors.log</code>. This creates a branching pipeline:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span>Logs → parseLines → [All logs continue]</span></span>
<span class="line"><span>                   ↓</span></span>
<span class="line"><span>                   ERROR logs → errors.log</span></span>
<span class="line"><span>                   ↓ [All logs continue]</span></span>
<span class="line"><span>                   WARN logs → warnings.log</span></span>
<span class="line"><span>                   ↓ [All logs continue]</span></span>
<span class="line"><span>                   All logs → all.log</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This approach is memory-efficient. Reading the file once and splitting in-stream uses constant memory. Two separate pipelines would double I/O and memory usage.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">{ objectMode: true }</code> option is essential because this transform receives JavaScript objects from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">parseLines</code>, not buffers. When writing to the side destinations, we convert back to JSON strings with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">JSON.stringify(log) + "\n"</code>. Parse once, work with objects in the pipeline, serialize only when writing to disk.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The splitters chain in sequence:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">parseLines → </span><span style="color:#B392F0">LevelSplitter</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"ERROR"</span><span style="color:#E1E4E8">) → </span><span style="color:#B392F0">LevelSplitter</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"WARN"</span><span style="color:#E1E4E8">) → all.log</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each splitter calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push(log)</code>, passing objects through. The final destination <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">all.log</code> receives objects too, but since Writable streams automatically call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">toString()</code> on objects, you'd want to add a final transform that serializes to JSON for proper formatting (we've simplified this for clarity, but in production you'd add <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">async function* serializeJSON(source) { for await (const obj of source) yield JSON.stringify(obj) + "\n"; }</code> before the final destination).</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">2) CSV Import with Validation</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">Read a CSV file, parse rows, validate, and insert into a database with batching:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> parseCSV</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> headers </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#E1E4E8">    buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">headers) {</span></span>
<span class="line"><span style="color:#E1E4E8">        headers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> values</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        const</span><span style="color:#79B8FF"> row</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> headers.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">          row[headers[i]] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> values[i];</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        yield</span><span style="color:#E1E4E8"> row;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> validate</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">schema</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> row</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (schema.</span><span style="color:#B392F0">validate</span><span style="color:#E1E4E8">(row)) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> row;</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Invalid row:"</span><span style="color:#E1E4E8">, row);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> batch</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> item</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#E1E4E8">    batch.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(item);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#E1E4E8"> size) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> batch;</span></span>
<span class="line"><span style="color:#E1E4E8">      batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> batch;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">db</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.db </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> db;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#B392F0"> _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">batch</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.db.</span><span style="color:#B392F0">insertMany</span><span style="color:#E1E4E8">(batch);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data.csv"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">  parseCSV,</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> validate</span><span style="color:#E1E4E8">(source, mySchema),</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> batch</span><span style="color:#E1E4E8">(source, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#F97583">  new</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#E1E4E8">(db)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This pipeline uses composable generator functions for data transformation and batching for database operations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Unlike <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">parseLines</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">parseCSV</code> maintains state across chunks—it needs to remember the header row:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> headers </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;  </span><span style="color:#6A737D">// Persists across all chunks</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#6A737D">  // ... process chunks</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">headers) {</span></span>
<span class="line"><span style="color:#E1E4E8">    headers </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);  </span><span style="color:#6A737D">// First line becomes headers</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">    // Subsequent lines become data objects</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> values</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> line.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">","</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> row</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {};</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#E1E4E8"> headers.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      row[headers[i]] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> values[i];</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> row;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">headers</code> variable persists for the generator's lifetime, capturing the first line and using it to structure all subsequent rows. Raw CSV:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span>name,email,age</span></span>
<span class="line"><span>Alice,alice@example.com,30</span></span>
<span class="line"><span>Bob,bob@example.com,25</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Becomes structured objects:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">{ </span><span style="color:#B392F0">name</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"Alice"</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">email</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"alice@example.com"</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">age</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"30"</span><span style="color:#E1E4E8"> }</span></span>
<span class="line"><span style="color:#E1E4E8">{ </span><span style="color:#B392F0">name</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"Bob"</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">email</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"bob@example.com"</span><span style="color:#E1E4E8">, </span><span style="color:#B392F0">age</span><span style="color:#E1E4E8">: </span><span style="color:#9ECBFF">"25"</span><span style="color:#E1E4E8"> }</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">We don't load the entire CSV into memory—each row is processed as data flows through.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">validate</code> generator filters without modifying data:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> validate</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">schema</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> row</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (schema.</span><span style="color:#B392F0">validate</span><span style="color:#E1E4E8">(row)) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> row;  </span><span style="color:#6A737D">// Valid rows continue</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Invalid row:"</span><span style="color:#E1E4E8">, row);  </span><span style="color:#6A737D">// Invalid rows logged, not yielded</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Valid rows continue downstream. Invalid rows are logged but not yielded, preventing bad data from reaching the database.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Throwing an error on invalid data would crash the pipeline and lose all progress. Real-world data is messy—logging and continuing lets you review errors after the import completes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">batch</code> generator is essential for database operations:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> batch</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> item</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> source) {</span></span>
<span class="line"><span style="color:#E1E4E8">    batch.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(item);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#E1E4E8"> size) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> batch;  </span><span style="color:#6A737D">// Emit full batch</span></span>
<span class="line"><span style="color:#E1E4E8">      batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];   </span><span style="color:#6A737D">// Reset for next batch</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> batch;  </span><span style="color:#6A737D">// Don't forget partial final batch</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This transforms a stream of individual items into a stream of batches:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span>Input:  item1, item2, item3, ..., item100, item101, ...</span></span>
<span class="line"><span>Output: [item1...item100], [item101...item200], ...</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Database round-trips are expensive. Batching into groups of 100 can provide a 100x speedup over inserting one row at a time. The batch size is a trade-off: too small means many round-trips and slow performance; too large means high memory usage, timeout risk, and harder error recovery. Most databases work well with batch sizes between 100-1000.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">if (batch.length &gt; 0)</code> after the loop handles the final partial batch. Without this check, trailing rows get silently dropped.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">DatabaseWriter</code> writable handles async I/O:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">async </span><span style="color:#B392F0">_write</span><span style="color:#E1E4E8">(batch, encoding, callback) {</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.db.</span><span style="color:#B392F0">insertMany</span><span style="color:#E1E4E8">(batch);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();  </span><span style="color:#6A737D">// Signal success</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(err);  </span><span style="color:#6A737D">// Signal error</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write</code> method can be async, but you must still call the callback. Call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">callback()</code> with no arguments on success, or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">callback(err)</code> to propagate errors.</p>
<p class="text-base leading-relaxed mb-4 font-normal">While <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">await this.db.insertMany(batch)</code> runs, the stream is paused. The next batch won't be sent until the current insert completes, preventing database overload.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The arrow functions <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">(source) =&gt; validate(source, mySchema)</code> let you pass additional arguments to generators:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#B392F0">  createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data.csv"</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">  parseCSV,</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> validate</span><span style="color:#E1E4E8">(source, mySchema),</span></span>
<span class="line"><span style="color:#E1E4E8">  (</span><span style="color:#FFAB70">source</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> batch</span><span style="color:#E1E4E8">(source, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#F97583">  new</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#E1E4E8">(db)</span></span>
<span class="line"><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">You're creating specialized versions of generic generators for this specific pipeline.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This entire pipeline uses roughly constant memory regardless of file size. CSV parsing keeps only the current line in memory. Validation processes one row at a time. Batching holds at most 100 rows. Writing processes only the current batch. A 10GB CSV file uses the same memory as a 10MB file.</p>    
</body>
</html>