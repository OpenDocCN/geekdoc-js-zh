["```js\nlet a = [1, 2, 3];\n```", "```js\ninterface Type {\n equals(other: Type): boolean;\n toString(): string;\n}\n```", "```js\nBooleanType()\n```", "```js\nboolean\n```", "```js\nNumberType()\n```", "```js\nnumber\n```", "```js\nVoidType()\n```", "```js\nvoid\n```", "```js\nArrayType(element: Type)\n```", "```js\nArray<number>\n```", "```js\nFunctionType(\n  parameters: Map<string, Type>,\n  returnType: Type,\n)\n```", "```js\n(x: boolean,\n y: number)\n  => number\n```", "```js\nclass Function implements AST {\n constructor(public name: string,\n public signature: FunctionType,\n public body: AST) {}\n\n visit<T>(v: Visitor<T>) {…}\n\n equals(other: AST): boolean {…}\n}\n```", "```js\narrayType <- ARRAY LESS_THAN type GREATER_THAN\ntype <- VOID | BOOLEAN | NUMBER | arrayType\n```", "```js\noptionalTypeAnnotation <- (COLON type)?\nparameter <- ID optionalTypeAnnotation\nparameters <- (parameter (COMMA parameter)*)?\nfunctionStatement <-\n  FUNCTION ID LEFT_PAREN\n    parameters\n  RIGHT_PAREN optionalTypeAnnotation\n    blockStatement\n```", "```js\nfunction pair(x: number, y: number): Array<number> {\n return [x, y];\n}\n```", "```js\nnew Function(\n \"pair\",\n new FunctionType(\n new Map([[\"x\", new NumberType()],\n [\"y\", new NumberType()]]),\n new ArrayType(new NumberType()),\n ),\n new Block([\n new Return(new ArrayLiteral([new Id(\"x\"),\n new Id(\"y\")])),\n ]),\n)\n```", "```js\nfunction assertType(expected: Type, got: Type): void {\n if (!expected.equals(got)) {\n throw TypeError(\n `Expected ${expected}, but got ${got}`);\n }\n}\n```", "```js\nclass TypeChecker implements Visitor<Type> {\n constructor(\n public locals: Map<string, Type>,\n public functions: Map<string, FunctionType>,\n public currentFunctionReturnType: Type | null,\n ) {}\n\n …\n}\n```", "```js\n visitNumber(node: Number) {\n return new NumberType();\n }\n\n visitBoolean(node: Boolean) {\n return new BooleanType();\n }\n```", "```js\n visitUndefined(node: Undefined) {\n return new VoidType();\n }\n```", "```js\n visitNot(node: Not) {\n assertType(new BooleanType(), node.term.visit(this));\n return new BooleanType();\n }\n```", "```js\n visitAdd(node: Add) {\n assertType(new NumberType(), node.left.visit(this));\n assertType(new NumberType(), node.right.visit(this));\n return new NumberType();\n }\n```", "```js\n visitEqual(node: Equal) {\n let leftType = node.left.visit(this);\n let rightType = node.right.visit(this);\n assertType(leftType, rightType);\n return new BooleanType();\n }\n```", "```js\n visitVar(node: Var) {\n let type = node.value.visit(this);\n this.locals.set(node.name, type);\n return new VoidType();\n }\n```", "```js\n visitId(node: Id) {\n let type = this.locals.get(node.value);\n if (!type) {\n throw TypeError(`Undefined variable ${node.value}`);\n }\n return type;\n }\n```", "```js\n visitAssign(node: Assign) {\n let variableType = this.locals.get(node.name);\n if (!variableType) {\n throw TypeError(`Undefined variable ${node.name}`);\n }\n let valueType = node.value.visit(this);\n assertType(variableType, valueType);\n return new VoidType();\n }\n```", "```js\n visitArrayLiteral(node: ArrayLiteral): Type {\n if (node.args.length == 0) {\n throw TypeError(\"Can't infer type of empty array\");\n }\n let argsTypes =\n node.args.map((arg) => arg.visit(this));\n let elementType = argsTypes.reduce((prev, next) => {\n assertType(prev, next);\n return prev;\n });\n return new ArrayType(elementType);\n }\n```", "```js\n visitLength(node: Length) {\n let type = node.array.visit(this);\n if (type instanceof ArrayType) {\n return new NumberType();\n } else {\n throw TypeError(`Expected an array, got: ${type}`);\n }\n }\n```", "```js\n visitArrayLookup(node: ArrayLookup): Type {\n assertType(new NumberType(), node.index.visit(this));\n let type = node.array.visit(this);\n if (type instanceof ArrayType) {\n return type.element;\n } else {\n throw TypeError(`Expected an array, got: ${type}`);\n }\n }\n```", "```js\n visitFunction(node: Function) {\n this.functions.set(node.name, node.signature);\n let visitor = new TypeChecker(\n new Map(node.signature.parameters),\n this.functions,\n node.signature.returnType,\n );\n node.body.visit(visitor);\n return new VoidType();\n }\n```", "```js\n visitCall(node: Call) {\n let expected = this.functions.get(node.callee);\n if (!expected) {\n throw TypeError(`Function ${node.callee} undefined`);\n }\n let argsTypes = new Map();\n node.args.forEach((arg, i) =>\n argsTypes.set(`x${i}`, arg.visit(this))\n );\n let got =\n new FunctionType(argsTypes, expected.returnType);\n assertType(expected, got);\n return expected.returnType;\n }\n```", "```js\n visitReturn(node: Return) {\n let type = node.term.visit(this);\n if (this.currentFunctionReturnType) {\n assertType(this.currentFunctionReturnType, type);\n return new VoidType();\n } else {\n throw TypeError(\n \"Return statement outside of any function\");\n }\n }\n```", "```js\n visitIf(node: If) {\n node.conditional.visit(this);\n node.consequence.visit(this);\n node.alternative.visit(this);\n return new VoidType();\n }\n\n visitWhile(node: While) {\n node.conditional.visit(this);\n node.body.visit(this);\n return new VoidType();\n }\n```", "```js\nfunction wrongReturnType(x: boolean): Array<number> {\n if (x) {\n return [42];\n }\n}\n\nfunction main() {\n var a = wrontReturnType(false);\n a[0]; // Segmentation fault\n}\n```"]