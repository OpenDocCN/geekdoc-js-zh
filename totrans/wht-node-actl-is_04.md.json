["```js\nfunction third() {\n console.log(\"Three\");\n}\n function second() {\n console.log(\"Two\");\n third();\n}\n function first() {\n console.log(\"One\");\n second();\n console.log(\"Done with first\");\n}\n first();\n```", "```js\nOne\nTwo\nThree\nDone with first\n```", "```js\nconst crypto = require(\"node:crypto\");\n function hashContinuously() {\n console.log(\"Starting a blocking operation...\");\n const startTime = Date.now();\n let salt = \"some-salt\";\n // This loop will run for 5 seconds, monopolizing the call stack.\n while (Date.now() - startTime < 5000) {\n salt = crypto.pbkdf2Sync(\"password\", salt, 1000, 64, \"sha512\").toString(\"hex\");\n }\n console.log(\"...Blocking operation finished.\");\n}\n setTimeout(() => {\n console.log(\"This timer will be delayed by 5 seconds!\");\n}, 1000);\n hashContinuously();\n```", "```js\n// Function to handle a new food order\nfunction placeOrder(orderDetails) {\n // 1\\. Save order to the database (this is an async I/O operation)\n database.saveOrder(orderDetails, (error, savedOrder) => {\n // This callback runs in the Poll phase after the database write is done.\n if (error) {\n console.error(\"Failed to save order!\", error);\n return;\n }\n console.log(`Order #${savedOrder.id} confirmed in the database.`);\n // 2\\. Schedule the restaurant notification to run immediately after this.\n // This decouples the notification from the database logic.\n setImmediate(() => {\n // This code will run in the Check phase, right after the current Poll phase.\n notificationService.sendToRestaurant(savedOrder);\n console.log(`Notification for order #${savedOrder.id} sent to the restaurant.`);\n });\n // We can now immediately respond to the user without waiting for the notification to be sent.\n console.log(`Sending confirmation back to the user for order #${savedOrder.id}.`);\n });\n}\n```", "```js\nlet count = 0;\n function starveTheLoop() {\n console.log(`Starvation call: ${++count}`);\n process.nextTick(starveTheLoop);\n}\n // A timer that will never get to run\nsetTimeout(() => {\n console.log(\"This will never be logged!\");\n}, 1000);\n console.log(\"Starting the starvation...\");\nstarveTheLoop();\n```", "```js\nconst fs = require(\"node:fs\");\n console.log(\"1\\. Start\");\n // Macrotask: Timer\nsetTimeout(() => console.log(\"2\\. Timeout\"), 0);\n // Microtask: Promise\nPromise.resolve().then(() => console.log(\"3\\. Promise\"));\n // Microtask: nextTick\nprocess.nextTick(() => console.log(\"4\\. nextTick\"));\n // Macrotask: I/O\nfs.readFile(__filename, () => {\n console.log(\"5\\. I/O Callback\");\n // Macrotask from I/O: Immediate\n setImmediate(() => console.log(\"6\\. Immediate from I/O\"));\n // Microtask from I/O: nextTick\n process.nextTick(() => console.log(\"7\\. nextTick from I/O\"));\n // Microtask from I/O: Promise\n Promise.resolve().then(() => console.log(\"8\\. Promise from I/O\"));\n});\n console.log(\"9\\. End\");\n```", "```js\n    let lastCheck = Date.now();\n    setInterval(() => {\n     const now = Date.now();\n     const delay = now - lastCheck - 1000;\n     if (delay > 50) {\n     // a 50ms delay is pretty noticeable\n     console.warn(`Event Loop Latency: ${delay}ms`);\n     }\n     lastCheck = now;\n    }, 1000);\n    ```", "```js\n    const { monitorEventLoopDelay } = require(\"node:perf_hooks\");\n    const h = monitorEventLoopDelay();\n    h.enable();\n     // ... your application logic ...\n     // Periodically check the stats\n    setInterval(() => {\n     // The mean is in nanoseconds, so we convert to ms\n     console.log(\"Event Loop Delay (ms):\", h.mean / 1_000_000);\n     h.reset();\n    }, 5000);\n    ```", "```js\n// A very long array to process\nconst bigArray = Array(1_000_000)\n .fill(0)\n .map((_, i) => i);\nlet sum = 0;\nconst CHUNK_SIZE = 1000;\n function processChunk() {\n const chunk = bigArray.splice(0, CHUNK_SIZE);\n for (const item of chunk) {\n sum += item; // Do a little bit of work\n }\n if (bigArray.length > 0) {\n // There's more to do, so yield to the event loop\n // and schedule the next chunk to run ASAP.\n setImmediate(processChunk);\n } else {\n console.log(\"Processing complete. Sum:\", sum);\n }\n}\n processChunk();\nconsole.log(\"Started processing... but the loop is not blocked!\");\n```", "```js\n// main.js\nconst { Worker } = require(\"node:worker_threads\");\n console.log(\"Main Thread: Kicking off a worker for a heavy task.\");\nconst worker = new Worker(\"./heavy-task.js\");\n worker.on(\"message\", (result) => {\n console.log(`Main Thread: Got the result back! -> ${result}`);\n});\n worker.on(\"error\", (err) => console.error(err));\n // heavy-task.js\nconst { parentPort } = require(\"node:worker_threads\");\n let result = 0;\n// A truly, horribly, no-good heavy task\nfor (let i = 0; i < 1e10; i++) {\n result += 1;\n}\n // Send the result back when we're done\nparentPort.postMessage(result);\n```", "```js\nsetTimeout(() => console.log(\"Timeout\"), 0);\nsetImmediate(() => console.log(\"Immediate\"));\n```", "```js\nconst fs = require(\"node:fs\");\n fs.readFile(__filename, () => {\n setTimeout(() => console.log(\"Timeout\"), 0);\n setImmediate(() => console.log(\"Immediate\"));\n});\n```"]