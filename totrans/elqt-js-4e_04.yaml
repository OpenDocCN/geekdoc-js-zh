- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FUNCTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are one of the most central tools in Java-Script programming. The
    concept of wrapping a piece of program in a value has many uses. It gives us a
    way to structure larger programs, to reduce repetition, to associate names with
    subprograms, and to isolate these subprograms from each other.
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious use of functions is defining new vocabulary. Creating new words
    is usually bad style in prose, but it’s indispensable in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Typical adult English speakers have some 20,000 words in their vocabulary. Few
    programming languages come with 20,000 commands built in. And the vocabulary that
    *is* available tends to be more precisely defined, and thus less flexible, than
    in human language. Therefore, we *have* to introduce new words to avoid excessive
    verbosity.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function definition is a regular binding where the value of the binding is
    a function. For example, this code defines square to refer to a function that
    produces the square of a given number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A function is created with an expression that starts with the keyword function.
    Functions have a set of *parameters* (in this case, only x) and a *body*, which
    contains the statements that are to be executed when the function is called. The
    body of a function created this way must always be wrapped in braces, even when
    it consists of only a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can have multiple parameters or no parameters at all. In the following
    example, makeNoise does not list any parameter names, whereas roundTo (which rounds
    n to the nearest multiple of step) lists two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Some functions, such as roundTo and square, produce a value, and some don’t,
    such as makeNoise, whose only result is a side effect. A return statement determines
    the value the function returns. When control comes across such a statement, it
    immediately jumps out of the current function and gives the returned value to
    the code that called the function. A return keyword without an expression after
    it will cause the function to return undefined. Functions that don’t have a return
    statement at all, such as makeNoise, similarly return undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters to a function behave like regular bindings, but their initial values
    are given by the *caller* of the function, not the code in the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings and Scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each binding has a *scope*, which is the part of the program in which the binding
    is visible. For bindings defined outside of any function, block, or module (see
    [Chapter 10](ch10.xhtml#ch10)), the scope is the whole program—you can refer to
    such bindings wherever you want. These are called *global*.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings created for function parameters or declared inside a function can be
    referenced only in that function, so they are known as *local* bindings. Every
    time the function is called, new instances of these bindings are created. This
    provides some isolation between functions—each function call acts in its own little
    world (its local environment) and can often be understood without knowing a lot
    about what’s going on in the global environment.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings declared with let and const are in fact local to the *block* in which
    they are declared, so if you create one of those inside a loop, the code before
    and after the loop cannot “see” it. In pre-2015 JavaScript, only functions created
    new scopes, so old-style bindings, created with the var keyword, are visible throughout
    the whole function in which they appear—or throughout the global scope, if they
    are not in a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each scope can “look out” into the scope around it, so x is visible inside the
    block in the example. The exception is when multiple bindings have the same name—in
    that case, code can see only the innermost binding. For example, when the code
    inside the halve function refers to n, it is seeing its *own* n, not the global
    n.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Nested Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript distinguishes not just global and local bindings. Blocks and functions
    can be created inside other blocks and functions, producing multiple degrees of
    locality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this function—which outputs the ingredients needed to make a batch
    of hummus—has another function inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code inside the ingredient function can see the factor binding from the
    outer function. But its local bindings, such as unit or ingredientAmount, are
    not visible in the outer function.
  prefs: []
  type: TYPE_NORMAL
- en: The set of bindings visible inside a block is determined by the place of that
    block in the program text. Each local scope can also see all the local scopes
    that contain it, and all scopes can see the global scope. This approach to binding
    visibility is called *lexical scoping*.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function binding usually simply acts as a name for a specific piece of the
    program. Such a binding is defined once and never changed. This makes it easy
    to confuse the function and its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the two are different. A function value can do all the things that other
    values can do—you can use it in arbitrary expressions, not just call it. It is
    possible to store a function value in a new binding, pass it as an argument to
    a function, and so on. Similarly, a binding that holds a function is still just
    a regular binding and can, if not constant, be assigned a new value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 5](ch05.xhtml#ch05) we’ll discuss the interesting things we can
    do by passing function values to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a slightly shorter way to create a function binding. When the function
    keyword is used at the start of a statement, it works differently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a function *declaration*. The statement defines the binding square and
    points it at the given function. It is slightly easier to write and doesn’t require
    a semicolon after the function.
  prefs: []
  type: TYPE_NORMAL
- en: There is one subtlety with this form of function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works, even though the function is defined *below* the code
    that uses it. Function declarations are not part of the regular top-to-bottom
    flow of control. They are conceptually moved to the top of their scope and can
    be used by all the code in that scope. This is sometimes useful because it offers
    the freedom to order code in a way that seems the clearest, without worrying about
    having to define all functions before they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a third notation for functions, which looks very different from the
    others. Instead of the function keyword, it uses an arrow (=>) made up of an equal
    sign and a greater-than character (not to be confused with the greater-than-or-equal
    operator, which is written >=).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The arrow comes *after* the list of parameters and is followed by the function’s
    body. It expresses something like “this input (the parameters) produces this result
    (the body).”
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is only one parameter name, you can omit the parentheses around
    the parameter list. If the body is a single expression rather than a block in
    braces, that expression will be returned from the function. That means these two
    definitions of square do the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When an arrow function has no parameters at all, its parameter list is just
    an empty set of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There’s no deep reason to have both arrow functions and function expressions
    in the language. Apart from a minor detail, which we’ll discuss in [Chapter 6](ch06.xhtml#ch06),
    they do the same thing. Arrow functions were added in 2015, mostly to make it
    possible to write small function expressions in a less verbose way. We’ll use
    them often in [Chapter 5](ch05.xhtml#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: The Call Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The way control flows through functions is somewhat involved. Let’s take a
    closer look at it. Here is a simple program that makes a few function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A run through this program goes roughly like this: the call to greet causes
    control to jump to the start of that function (line 2). The function calls console.log,
    which takes control, does its job, and then returns control to line 2\. There,
    it reaches the end of the greet function, so it returns to the place that called
    it—line 4\. The line after that calls console.log again. After that returns, the
    program reaches its end.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could show the flow of control schematically like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because a function has to jump back to the place that called it when it returns,
    the computer must remember the context from which the call happened. In one case,
    console.log has to return to the greet function when it is done. In the other
    case, it returns to the end of the program.
  prefs: []
  type: TYPE_NORMAL
- en: The place where the computer stores this context is the *call stack*. Every
    time a function is called, the current context is stored on top of this stack.
    When a function returns, it removes the top context from the stack and uses that
    context to continue execution.
  prefs: []
  type: TYPE_NORMAL
- en: Storing this stack requires space in the computer’s memory. When the stack grows
    too big, the computer will fail with a message like “out of stack space” or “too
    much recursion.” The following code illustrates this by asking the computer a
    really hard question that causes an infinite back-and-forth between two functions.
    Or rather, it *would* be infinite, if the computer had an infinite stack. As it
    is, we will run out of space, or “blow the stack.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Optional Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code is allowed and executes without any problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We defined square with only one parameter. Yet when we call it with three, the
    language doesn’t complain. It ignores the extra arguments and computes the square
    of the first one.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is extremely broad-minded about the number of arguments you can pass
    to a function. If you pass too many, the extra ones are ignored. If you pass too
    few, the missing parameters are assigned the value undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The downside of this is that it is possible—likely, even—that you’ll accidentally
    pass the wrong number of arguments to functions. And no one will tell you about
    it. The upside is that you can use this behavior to allow a function to be called
    with different numbers of arguments. For example, this minus function tries to
    imitate the - operator by acting on either one or two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you write an = operator after a parameter, followed by an expression, the
    value of that expression will replace the argument when it is not given. For example,
    this version of roundTo makes its second argument optional. If you don’t provide
    it or pass the value undefined, it will default to one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The next chapter will introduce a way in which a function body can get at the
    whole list of arguments it was passed. This is helpful because it allows a function
    to accept any number of arguments. For example, console.log does this, outputting
    all values it is given.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ability to treat functions as values, combined with the fact that local
    bindings are re-created every time a function is called, brings up an interesting
    question: What happens to local bindings when the function call that created them
    is no longer active?'
  prefs: []
  type: TYPE_NORMAL
- en: The following code shows an example of this. It defines a function, wrapValue,
    that creates a local binding. It then returns a function that accesses and returns
    this local binding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is allowed and works as you’d hope—both instances of the binding can still
    be accessed. This situation is a good demonstration of the fact that local bindings
    are created anew for every call, and different calls don’t affect each other’s
    local bindings.
  prefs: []
  type: TYPE_NORMAL
- en: This feature—being able to reference a specific instance of a local binding
    in an enclosing scope—is called *closure*. A function that references bindings
    from local scopes around it is called *a* closure. This behavior not only frees
    you from having to worry about the lifetimes of bindings but also makes it possible
    to use function values in some creative ways.
  prefs: []
  type: TYPE_NORMAL
- en: With a slight change, we can turn the previous example into a way to create
    functions that multiply by an arbitrary amount.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The explicit local binding from the wrapValue example isn’t really needed, since
    a parameter is itself a local binding.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking about programs like this takes some practice. A good mental model is
    to think of function values as containing both the code in their body and the
    environment in which they are created. When called, the function body sees the
    environment in which it was created, not the environment in which it is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, multiplier is called and creates an environment in which its
    factor parameter is bound to 2\. The function value it returns, which is stored
    in twice, remembers this environment so that when that is called, it multiplies
    its argument by 2.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is perfectly OK for a function to call itself, as long as it doesn’t do
    it so often that it overflows the stack. A function that calls itself is called
    *recursive*. Recursion allows some functions to be written in a different style.
    Take, for example, this power function, which does the same as the ** (exponentiation)
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is rather close to the way mathematicians define exponentiation and arguably
    describes the concept more clearly than the loop we used in [Chapter 2](ch02.xhtml#ch02).
    The function calls itself multiple times with ever smaller exponents to achieve
    the repeated multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this implementation has one problem: in typical JavaScript implementations,
    it’s about three times slower than a version using a for loop. Running through
    a simple loop is generally cheaper than calling a function multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: The dilemma of speed versus elegance is an interesting one. You can see it as
    a kind of continuum between human-friendliness and machine-friendliness. Almost
    any program can be made faster by making it bigger and more convoluted. The programmer
    has to find an appropriate balance.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the power function, an inelegant (looping) version is still fairly
    simple and easy to read. It doesn’t make much sense to replace it with a recursive
    function. Often, though, a program deals with such complex concepts that giving
    up some efficiency in order to make the program more straightforward is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Worrying about efficiency can be a distraction. It’s yet another factor that
    complicates program design, and when you’re doing something that’s already difficult,
    that extra thing to worry about can be paralyzing.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you should generally start by writing something that’s correct and
    easy to understand. If you’re worried that it’s too slow—which it usually isn’t,
    since most code simply isn’t executed often enough to take any significant amount
    of time—you can measure afterward and improve it if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is not always just an inefficient alternative to looping. Some problems
    really are easier to solve with recursion than with loops. Most often these are
    problems that require exploring or processing several “branches,” each of which
    might branch out again into even more branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this puzzle: by starting from the number 1 and repeatedly either adding
    5 or multiplying by 3, an infinite set of numbers can be produced. How would you
    write a function that, given a number, tries to find a sequence of such additions
    and multiplications that produces that number? For example, the number 13 could
    be reached by first multiplying by 3 and then adding 5 twice, whereas the number
    15 cannot be reached at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a recursive solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that this program doesn’t necessarily find the *shortest* sequence of operations.
    It is satisfied when it finds any sequence at all.
  prefs: []
  type: TYPE_NORMAL
- en: It’s OK if you don’t see how this code works right away. Let’s work through
    it, since it makes for a great exercise in recursive thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner function find does the actual recursing. It takes two arguments:
    the current number and a string that records how we reached this number. If it
    finds a solution, it returns a string that shows how to get to the target. If
    it can find no solution starting from this number, it returns null.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, the function performs one of three actions. If the current number
    is the target number, the current history is a way to reach that target, so it
    is returned. If the current number is greater than the target, there’s no sense
    in further exploring this branch because both adding and multiplying will only
    make the number bigger, so it returns null. Finally, if we’re still below the
    target number, the function tries both possible paths that start from the current
    number by calling itself twice, once for addition and once for multiplication.
    If the first call returns something that is not null, it is returned. Otherwise,
    the second call is returned, regardless of whether it produces a string or null.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how this function produces the effect we’re looking for,
    let’s look at all the calls to find that are made when searching for a solution
    for the number 13.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The indentation indicates the depth of the call stack. The first time find is
    called, the function starts by calling itself to explore the solution that starts
    with (1 + 5). That call will further recurse to explore *every* continued solution
    that yields a number less than or equal to the target number. Since it doesn’t
    find one that hits the target, it returns null back to the first call. There the
    ?? operator causes the call that explores (1 * 3) to happen. This search has more
    luck—its first recursive call, through yet *another* recursive call, hits upon
    the target number. That innermost call returns a string, and each of the ?? operators
    in the intermediate calls passes that string along, ultimately returning the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Growing Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two more or less natural ways for functions to be introduced into
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: The first occurs when you find yourself writing similar code multiple times.
    You’d prefer not to do that, as having more code means more space for mistakes
    to hide and more material to read for people trying to understand the program.
    So you take the repeated functionality, find a good name for it, and put it into
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: The second way is that you find you need some functionality that you haven’t
    written yet and that sounds like it deserves its own function. You start by naming
    the function, and then write its body. You might even start writing code that
    uses the function before you actually define the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: How difficult it is to find a good name for a function is a good indication
    of how clear a concept it is that you’re trying to wrap. Let’s go through an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to write a program that prints two numbers: the numbers of cows and
    chickens on a farm, with the words Cows and Chickens after them and zeros padded
    before both numbers so that they are always three digits long.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This asks for a function of two arguments—the number of cows and the number
    of chickens. Let’s get coding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Writing .length after a string expression will give us the length of that string.
    Thus, the while loops keep adding zeros in front of the number strings until they
    are at least three characters long.
  prefs: []
  type: TYPE_NORMAL
- en: Mission accomplished! But just as we are about to send the farmer the code (along
    with a hefty invoice), she calls and tells us she’s also started keeping pigs,
    and couldn’t we please extend the software to also print pigs?
  prefs: []
  type: TYPE_NORMAL
- en: 'We sure can. But just as we’re in the process of copying and pasting those
    four lines one more time, we stop and reconsider. There has to be a better way.
    Here’s a first attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It works! But that name, printZeroPaddedWithLabel, is a little awkward. It conflates
    three things—printing, zero-padding, and adding a label—into a single function.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of lifting out the repeated part of our program wholesale, let’s try
    to pick out a single *concept*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A function with a nice, obvious name like zeroPad makes it easier for someone
    who reads the code to figure out what it does. Such a function is also useful
    in more situations than just this specific program. For example, you could use
    it to help print nicely aligned tables of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: How smart and versatile *should* our function be? We could write anything, from
    a terribly simple function that can only pad a number to be three characters wide
    to a complicated generalized number-formatting system that handles fractional
    numbers, negative numbers, alignment of decimal dots, padding with different characters,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A useful principle is to refrain from adding cleverness unless you are absolutely
    sure you’re going to need it. It can be tempting to write general “frameworks”
    for every bit of functionality you come across. Resist that urge. You won’t get
    any real work done—you’ll be too busy writing code that you never use.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and Side Effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions can be roughly divided into those that are called for their side effects
    and those that are called for their return value (though it’s also possible to
    both have side effects and return a value).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first helper function in the farm example, printZeroPaddedWithLabel, is
    called for its side effect: it prints a line. The second version, zeroPad, is
    called for its return value. It is no coincidence that the second is useful in
    more situations than the first. Functions that create values are easier to combine
    in new ways than functions that directly perform side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: A *pure* function is a specific kind of value-producing function that not only
    has no side effects but also doesn’t rely on side effects from other code—for
    example, it doesn’t read global bindings whose value might change. A pure function
    has the pleasant property that, when called with the same arguments, it always
    produces the same value (and doesn’t do anything else). A call to such a function
    can be substituted by its return value without changing the meaning of the code.
    When you are not sure that a pure function is working correctly, you can test
    it by simply calling it and know that if it works in that context, it will work
    in any context. Nonpure functions tend to require more scaffolding to test.
  prefs: []
  type: TYPE_NORMAL
- en: Still, there’s no need to feel bad when writing functions that are not pure.
    Side effects are often useful. There’s no way to write a pure version of console.log,
    for example, and console.log is good to have. Some operations are also easier
    to express in an efficient way when we use side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter taught you how to write your own functions. The function keyword,
    when used as an expression, can create a function value. When used as a statement,
    it can be used to declare a binding and give it a function as its value. Arrow
    functions are yet another way to create functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A key part of understanding functions is understanding scopes. Each block creates
    a new scope. Parameters and bindings declared in a given scope are local and not
    visible from the outside. Bindings declared with var behave differently—they end
    up in the nearest function scope or the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the tasks your program performs into different functions is helpful.
    You won’t have to repeat yourself as much, and functions can help organize a program
    by grouping code into pieces that do specific things.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Minimum*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous chapter introduced the standard function Math.min that returns
    its smallest argument. We can write a function like that ourselves now. Define
    the function min that takes two arguments and returns their minimum.
  prefs: []
  type: TYPE_NORMAL
- en: '*Recursion*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve seen that we can use % (the remainder operator) to test whether a number
    is even or odd by using % 2 to see whether it’s divisible by two. Here’s another
    way to define whether a positive whole number is even or odd:'
  prefs: []
  type: TYPE_NORMAL
- en: Zero is even.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One is odd.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For any other number *N*, its evenness is the same as *N* – 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a recursive function isEven corresponding to this description. The function
    should accept a single parameter (a positive, whole number) and return a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Test it on 50 and 75\. See how it behaves on –1\. Why? Can you think of a way
    to fix this?
  prefs: []
  type: TYPE_NORMAL
- en: '*Bean Counting*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can get the *N*th character, or letter, from a string by writing [*N*] after
    the string (for example, string[2]). The resulting value will be a string containing
    only one character (for example, “b”). The first character has position 0, which
    causes the last one to be found at position string.length - 1. In other words,
    a two-character string has length 2, and its characters have positions 0 and 1.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called countBs that takes a string as its only argument and
    returns a number that indicates how many uppercase B characters there are in the
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, write a function called countChar that behaves like countBs, except it
    takes a second argument that indicates the character that is to be counted (rather
    than counting only uppercase B characters). Rewrite countBs to make use of this
    new function.
  prefs: []
  type: TYPE_NORMAL
- en: '*On two occasions I have been asked, “Pray, Mr. Babbage, if you put into the
    machine wrong figures, will the right answers come out?” [. . .] I am not able
    rightly to apprehend the kind of confusion of ideas that could provoke such a
    question.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Charles Babbage, *Passages from the Life of a Philosopher* (1864)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0056-01.jpg)'
  prefs: []
  type: TYPE_IMG
