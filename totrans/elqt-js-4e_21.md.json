["```js\nclass Picture {\n  constructor(width, height, pixels) {\n    this.width = width;\n    this.height = height;\n    this.pixels = pixels;\n  }\n  static empty(width, height, color) {\n    let pixels = new Array(width * height).fill(color);\n    return new Picture(width, height, pixels);\n  }\n  pixel(x, y) {\n    return this.pixels[x + y * this.width];\n  }\n  draw(pixels) {\n    let copy = this.pixels.slice();\n    for (let {x, y, color} of pixels) {\n      copy[x + y * this.width] = color;\n    }\n    return new Picture(this.width, this.height, copy);\n  }\n}\n```", "```js\nfunction updateState(state, action) {\n  return {...state, ...action};\n}\n```", "```js\nfunction elt(type, props, ...children) {\n  let dom = document.createElement(type);\n  if (props) Object.assign(dom, props);\n  for (let child of children) {\n    if (typeof child != \"string\") dom.appendChild(child);\n    else dom.appendChild(document.createTextNode(child));\n  }\n  return dom;\n}\n```", "```js\n<body>\n  <script>\n    document.body.appendChild(elt(\"button\", {\n      onclick: () => console.log(\"click\")\n    }, \"The button\"));\n  </script>\n</body>\n```", "```js\nconst scale = 10;\n\nclass PictureCanvas {\n  constructor(picture, pointerDown) {\n    this.dom = elt(\"canvas\", {\n      onmousedown: event => this.mouse(event, pointerDown),\n      ontouchstart: event => this.touch(event, pointerDown)\n    });\n    this.syncState(picture);\n  }\n  syncState(picture) {\n    if (this.picture == picture) return;\n    this.picture = picture;\n    drawPicture(this.picture, this.dom, scale);\n  }\n}\n```", "```js\nfunction drawPicture(picture, canvas, scale) {\n  canvas.width = picture.width * scale;\n  canvas.height = picture.height * scale;\n  let cx = canvas.getContext(\"2d\");\n\n  for (let y = 0; y < picture.height; y++) {\n    for (let x = 0; x < picture.width; x++) {\n      cx.fillStyle = picture.pixel(x, y);\n      cx.fillRect(x * scale, y * scale, scale, scale);\n    }\n  }\n}\n```", "```js\nPictureCanvas.prototype.mouse = function(downEvent, onDown) {\n  if (downEvent.button != 0) return;\n  let pos = pointerPosition(downEvent, this.dom);\n  let onMove = onDown(pos);\n  if (!onMove) return;\n  let move = moveEvent => {\n    if (moveEvent.buttons == 0) {\n      this.dom.removeEventListener(\"mousemove\", move);\n    } else {\n      let newPos = pointerPosition(moveEvent, this.dom);\n      if (newPos.x == pos.x && newPos.y == pos.y) return;\n      pos = newPos;\n      onMove(newPos);\n    }\n  };\n  this.dom.addEventListener(\"mousemove\", move);\n};\n\nfunction pointerPosition(pos, domNode) {\n  let rect = domNode.getBoundingClientRect();\n  return {x: Math.floor((pos.clientX - rect.left) / scale),\n          y: Math.floor((pos.clientY - rect.top) / scale)};\n}\n```", "```js\nPictureCanvas.prototype.touch = function(startEvent, onDown) {\n  let pos = pointerPosition(startEvent.touches[0], this.dom);\n  let onMove = onDown(pos);\n  startEvent.preventDefault();\n  if (!onMove) return;\n  let move = moveEvent => {\n    let newPos = pointerPosition(moveEvent.touches[0], this.dom);\n    if (newPos.x == pos.x && newPos.y == pos.y) return;\n    pos = newPos;\n    onMove(newPos);\n  };\n  let end = () => {\n    this.dom.removeEventListener(\"touchmove\", move);\n    this.dom.removeEventListener(\"touchend\", end);\n  };\n  this.dom.addEventListener(\"touchmove\", move);\n  this.dom.addEventListener(\"touchend\", end);\n};\n```", "```js\nclass PixelEditor {\n  constructor(state, config) {\n    let {tools, controls, dispatch} = config;\n    this.state = state;\n\n this.canvas = new PictureCanvas(state.picture, pos => {\n      let tool = tools[this.state.tool];\n      let onMove = tool(pos, this.state, dispatch);\n      if (onMove) return pos => onMove(pos, this.state);\n    });\n    this.controls = controls.map(\n      Control => new Control(state, config));\n    this.dom = elt(\"div\", {}, this.canvas.dom, elt(\"br\"),\n                   ...this.controls.reduce(\n                     (a, c) => a.concat(\" \", c.dom), []));\n  }\n  syncState(state) {\n    this.state = state;\n    this.canvas.syncState(state.picture);\n    for (let ctrl of this.controls) ctrl.syncState(state);\n  }\n}\n```", "```js\nclass ToolSelect {\n  constructor(state, {tools, dispatch}) {\n    this.select = elt(\"select\", {\n      onchange: () => dispatch({tool: this.select.value})\n    }, ...Object.keys(tools).map(name => elt(\"option\", {\n      selected: name == state.tool\n    }, name)));\n    this.dom = elt(\"label\", null, \" Tool: \", this.select);\n  }\n  syncState(state) { this.select.value = state.tool; }\n}\n```", "```js\nclass ColorSelect {\n  constructor(state, {dispatch}) {\n    this.input = elt(\"input\", {\n      type: \"color\",\n      value: state.color,\n      onchange: () => dispatch({color: this.input.value})\n    });\n    this.dom = elt(\"label\", null, \" Color: \", this.input);\n  }\n  syncState(state) { this.input.value = state.color; }\n}\n```", "```js\nfunction draw(pos, state, dispatch) {\n  function drawPixel({x, y}, state) {\n    let drawn = {x, y, color: state.color};\n    dispatch({picture: state.picture.draw([drawn])});\n  }\n  drawPixel(pos, state);\n  return drawPixel;\n}\n```", "```js\nfunction rectangle(start, state, dispatch) {\n  function drawRectangle(pos) {\n    let xStart = Math.min(start.x, pos.x);\n    let yStart = Math.min(start.y, pos.y);\n    let xEnd = Math.max(start.x, pos.x);\n    let yEnd = Math.max(start.y, pos.y);\n    let drawn = [];\n    for (let y = yStart; y <= yEnd; y++) {\n      for (let x = xStart; x <= xEnd; x++) {\n        drawn.push({x, y, color: state.color});\n      }\n    }\n    dispatch({picture: state.picture.draw(drawn)});\n  }\n  drawRectangle(start);\n  return drawRectangle;\n}\n```", "```js\nconst around = [{dx: -1, dy: 0}, {dx: 1, dy: 0},\n                {dx: 0, dy: -1}, {dx: 0, dy: 1}];\n\nfunction fill({x, y}, state, dispatch) {\n  let targetColor = state.picture.pixel(x, y);\n  let drawn = [{x, y, color: state.color}];\n  let visited = new Set();\n  for (let done = 0; done < drawn.length; done++) {\n    for (let {dx, dy} of around) {\n      let x = drawn[done].x + dx, y = drawn[done].y + dy;\n      if (x >= 0 && x < state.picture.width &&\n          y >= 0 && y < state.picture.height &&\n          !visited.has(x + \",\" + y) &&\n          state.picture.pixel(x, y) == targetColor) {\n        drawn.push({x, y, color: state.color});\n        visited.add(x + \",\" + y);\n      }\n    }\n  }\n  dispatch({picture: state.picture.draw(drawn)});\n}\n```", "```js\nfunction pick(pos, state, dispatch) {\n  dispatch({color: state.picture.pixel(pos.x, pos.y)});\n}\n```", "```js\nclass SaveButton {\n  constructor(state) {\n    this.picture = state.picture;\n    this.dom = elt(\"button\", {\n      onclick: () => this.save()\n    }, \" Save\");\n  }\n  save() {\n    let canvas = elt(\"canvas\");\n    drawPicture(this.picture, canvas, 1);\n    let link = elt(\"a\", {\n      href: canvas.toDataURL(),\n      download: \"pixelart.png\"\n    });\n    document.body.appendChild(link);\n    link.click();\n    link.remove();\n  }\n  syncState(state) { this.picture = state.picture; }\n}\n```", "```js\nclass LoadButton {\n  constructor(_, {dispatch}) {\n    this.dom = elt(\"button\", {\n      onclick: () => startLoad(dispatch)\n    }, \" Load\");\n  }\n  syncState() {}\n}\n\nfunction startLoad(dispatch) {\n  let input = elt(\"input\", {\n    type: \"file\",\n    onchange: () => finishLoad(input.files[0], dispatch)\n  });\n  document.body.appendChild(input);\n  input.click();\n  input.remove();\n}\n```", "```js\nfunction finishLoad(file, dispatch) {\n  if (file == null) return;\n  let reader = new FileReader();\n  reader.addEventListener(\"load\", () => {\n    let image = elt(\"img\", {\n      onload: () => dispatch({\n        picture: pictureFromImage(image)\n      }),\n      src: reader.result\n    });\n  });\n  reader.readAsDataURL(file);\n}\n```", "```js\nfunction pictureFromImage(image) {\n  let width = Math.min(100, image.width);\n  let height = Math.min(100, image.height);\n  let canvas = elt(\"canvas\", {width, height});\n  let cx = canvas.getContext(\"2d\");\n  cx.drawImage(image, 0, 0);\n  let pixels = [];\n  let {data} = cx.getImageData(0, 0, width, height);\n\n function hex(n) {\n    return n.toString(16).padStart(2, \"0\");\n  }\n  for (let i = 0; i < data.length; i += 4) {\n    let [r, g, b] = data.slice(i, i + 3);\n    pixels.push(\"#\" + hex(r) + hex(g) + hex(b));\n  }\n  return new Picture(width, height, pixels);\n}\n```", "```js\nfunction historyUpdateState(state, action) {\n  if (action.undo == true) {\n    if (state.done.length == 0) return state;\n    return {\n      ...state,\n      picture: state.done[0],\n done: state.done.slice(1),\n      doneAt: 0\n    };\n  } else if (action.picture &&\n             state.doneAt < Date.now() - 1000) {\n    return {\n      ...state,\n      ...action,\n      done: [state.picture, ...state.done],\n      doneAt: Date.now()\n    };\n  } else {\n    return {...state, ...action};\n  }\n}\n```", "```js\nclass UndoButton {\n  constructor(state, {dispatch}) {\n    this.dom = elt(\"button\", {\n      onclick: () => dispatch({undo: true}),\n      disabled: state.done.length == 0\n    }, \" Undo\");\n  }\n  syncState(state) {\n    this.dom.disabled = state.done.length == 0;\n  }\n}\n```", "```js\nconst startState = {\n  tool: \"draw\",\n  color: \"#000000\",\n picture: Picture.empty(60, 30, \"#f0f0f0\"),\n  done: [],\n  doneAt: 0\n};\n\nconst baseTools = {draw, fill, rectangle, pick};\n\nconst baseControls = [\n  ToolSelect, ColorSelect, SaveButton, LoadButton, UndoButton\n];\n\nfunction startPixelEditor({state = startState,\n                           tools = baseTools,\n                           controls = baseControls}) {\n  let app = new PixelEditor(state, {\n    tools,\n    controls,\n    dispatch(action) {\n      state = historyUpdateState(state, action);\n      app.syncState(state);\n    }\n  });\n  return app.dom;\n}\n```", "```js\n<div></div>\n<script>\n  document.querySelector(\"div\").appendChild(startPixelEditor({}));\n</script>\n```"]