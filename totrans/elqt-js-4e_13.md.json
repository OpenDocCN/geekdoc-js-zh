["```js\ndo(define(x, 10),\n   if(>(x, 5),\n      print(\"large\"),\n      print(\"small\")))\n```", "```js\n{\n  type: \"apply\",\n  operator: {type: \"word\", name: \">\"},\n  args: [\n    {type: \"word\", name: \"x\"},\n    {type: \"value\", value: 5}\n  ]\n}\n```", "```js\nfunction parseExpression(program) {\n  program = skipSpace(program);\n  let match, expr;\n  if (match = /^\"([^\"]*)\"/.exec(program)) {\n    expr = {type: \"value\", value: match[1]};\n  } else if (match = /^\\d+\\b/.exec(program)) {\n    expr = {type: \"value\", value: Number(match[0])};\n  } else if (match = /^[^\\s(),#\"]+/.exec(program)) {\n    expr = {type: \"word\", name: match[0]};\n  } else {\n    throw new SyntaxError(\"Unexpected syntax: \" + program);\n  }\n\n  return parseApply(expr, program.slice(match[0].length));\n}\n\nfunction skipSpace(string) {\n  let first = string.search(/\\S/);\n  if (first == -1) return \"\";\n  return string.slice(first);\n}\n```", "```js\nfunction parseApply(expr, program) {\n  program = skipSpace(program);\n  if (program[0] != \"(\") {\n    return {expr: expr, rest: program};\n  }\n\n  program = skipSpace(program.slice(1));\n  expr = {type: \"apply\", operator: expr, args: []};\n  while (program[0] != \")\") {\n    let arg = parseExpression(program);\n    expr.args.push(arg.expr);\n    program = skipSpace(arg.rest);\n    if (program[0] == \",\") {\n      program = skipSpace(program.slice(1));\n    } else if (program[0] != \")\") {\n      throw new SyntaxError(\"Expected ',' or ')'\");\n    }\n  }\n  return parseApply(expr, program.slice(1));\n}\n```", "```js\nfunction parse(program) {\n  let {expr, rest} = parseExpression(program);\n  if (skipSpace(rest).length > 0) {\n    throw new SyntaxError(\"Unexpected text after program\");\n  }\n  return expr;\n}\n\nconsole.log(parse(\"+(a, 10)\"));\n// → {type: \"apply\",\n//    operator: {type: \"word\", name: \"+\"},\n//    args: [{type: \"word\", name: \"a\"},\n//           {type: \"value\", value: 10}]}\n```", "```js\nconst specialForms = Object.create(null);\n\nfunction evaluate(expr, scope) {\n  if (expr.type == \"value\") {\n    return expr.value;\n  } else if (expr.type == \"word\") {\n    if (expr.name in scope) {\n      return scope[expr.name];\n    } else {\n      throw new ReferenceError(\n        `Undefined binding: ${expr.name}`);\n    }\n } else if (expr.type == \"apply\") {\n    let {operator, args} = expr;\n    if (operator.type == \"word\" &&\n        operator.name in specialForms) {\n      return specialForms[operator.name](expr.args, scope);\n    } else {\n      let op = evaluate(operator, scope);\n      if (typeof op == \"function\") {\n        return op(...args.map(arg => evaluate(arg, scope)));\n      } else {\n        throw new TypeError(\"Applying a non-function.\");\n      }\n    }\n  }\n}\n```", "```js\nspecialForms.if = (args, scope) => {\n  if (args.length != 3) {\n    throw new SyntaxError(\"Wrong number of args to if\");\n  } else if (evaluate(args[0], scope) !== false) {\n    return evaluate(args[1], scope);\n  } else {\n return evaluate(args[2], scope);\n  }\n};\n```", "```js\nspecialForms.while = (args, scope) => {\n  if (args.length != 2) {\n    throw new SyntaxError(\"Wrong number of args to while\");\n  }\n  while (evaluate(args[0], scope) !== false) {\n    evaluate(args[1], scope);\n  }\n\n  // Since undefined does not exist in Egg, we return false,\n  // for lack of a meaningful result\n  return false;\n};\n```", "```js\nspecialForms.do = (args, scope) => {\n  let value = false;\n  for (let arg of args) {\n    value = evaluate(arg, scope);\n  }\n  return value;\n};\n```", "```js\nspecialForms.define = (args, scope) => {\n  if (args.length != 2 || args[0].type != \"word\") {\n    throw new SyntaxError(\"Incorrect use of define\");\n  }\n  let value = evaluate(args[1], scope);\n  scope[args[0].name] = value;\n  return value;\n};\n```", "```js\nconst topScope = Object.create(null);\n\ntopScope.true = true;\ntopScope.false = false;\n```", "```js\nlet prog = parse(`if(true, false, true)`);\nconsole.log(evaluate(prog, topScope));\n// → false\n```", "```js\nfor (let op of [\"+\", \"-\", \"*\", \"/\", \"==\", \"<\", \">\"]) {\n  topScope[op] = Function(\"a, b\", `return a ${op} b;`);\n}\n```", "```js\ntopScope.print = value => {\n  console.log(value);\n  return value;\n};\n```", "```js\nfunction run(program) {\n  return evaluate(parse(program), Object.create(topScope));\n}\n```", "```js\nrun(`\ndo(define(total, 0),\n   define(count, 1),\n   while(<(count, 11),\n         do(define(total, +(total, count)),\n            define(count, +(count, 1)))),\n   print(total))\n`);\n// → 55\n```", "```js\nspecialForms.fun = (args, scope) => {\n  if (!args.length) {\n    throw new SyntaxError(\"Functions need a body\");\n  }\n  let body = args[args.length - 1];\n  let params = args.slice(0, args.length - 1).map(expr => {\n    if (expr.type != \"word\") {\n      throw new SyntaxError(\"Parameter names must be words\");\n    }\n    return expr.name;\n  });\n\n  return function(...args) {\n    if (args.length != params.length) {\n      throw new TypeError(\"Wrong number of arguments\");\n }\n    let localScope = Object.create(scope);\n    for (let i = 0; i < args.length; i++) {\n      localScope[params[i]] = args[i];\n    }\n    return evaluate(body, localScope);\n  };\n};\n```", "```js\nrun(`\ndo(define(plusOne, fun(a, +(a, 1))),\n   print(plusOne(10)))\n`);\n// → 11\n\nrun(`\ndo(define(pow, fun(base, exp,\n   if(==(exp, 0),\n      1,\n      *(base, pow(base, -(exp, 1)))))),\n   print(pow(2, 10)))\n`);\n// → 1024\n```", "```js\nexpr = number | string | name | application\n\nnumber = digit+\n\nname = letter+\n\nstring = '\"' (! '\"')* '\"'\n\napplication = expr '(' (expr (',' expr)*)? ')'\n```", "```js\nrun(`\ndo(define(f, fun(a, fun(b, +(a, b)))),\n   print(f(4)(5)))\n`);\n// → 9\n```"]