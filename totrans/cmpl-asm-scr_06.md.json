["```js\n[\n new TokenId(\"x\"),\n new TokenOperator(\"+\"),\n new TokenId(\"y\"),\n]\n```", "```js\ninterface Parser<T> {\n parse(s: Source): ParseResult<T> | null;\n}\n```", "```js\nclass Source {\n constructor(public string: string,\n public index: number) {}\n …\n}\n```", "```js\nclass ParseResult<T> {\n constructor(public value: T,\n public source: Source) {}\n}\n```", "```js\nclass Source {\n constructor(public string: string,\n public index: number) {}\n\n match(regexp: RegExp): (ParseResult<string> | null) {\n console.assert(regexp.sticky);\n regexp.lastIndex = this.index;\n let match = this.string.match(regexp);\n if (match) {\n let value = match[0];\n let newIndex = this.index + value.length;\n let source = new Source(this.string, newIndex);\n return new ParseResult(value, source);\n }\n return null;\n }\n}\n```", "```js\nclass Parser<T> {\n constructor(\n public parse: (s: Source) => (ParseResult<T> | null)\n ) {}\n\n …\n}\n```", "```js\nclass Parser<T> {\n …\n\n static regexp(regexp: RegExp): Parser<string> {\n return new Parser(source => source.match(regexp));\n }\n}\n```", "```js\nlet hello = Parser.regexp(/hello[0-9]/y);\n```", "```js\nhello <- \"hello\" [0-9]\n```", "```js\nlet source = new Source(\"hello1 bye2\", 0);\nlet result = Parser.regexp(/hello[0-9]/y).parse(source);\n\nconsole.assert(result.value === \"hello1\");\nconsole.assert(result.source.index === 6);\n```", "```js\nclass Parser<T> {\n …\n\n static constant<U>(value: U): Parser<U> {\n return new Parser(source =>\n new ParseResult(value, source));\n }\n}\n```", "```js\nempty <- \"\"\n```", "```js\nclass Parser<T> {\n …\n\n static error<U>(message: string): Parser<U> {\n return new Parser(source => {\n throw Error(message);\n });\n }\n}\n```", "```js\nlet {regexp, constant, error} = Parser;\nlet hello = regexp(/hello[0-9]/y);\n```", "```js\nclass Parser<T> {\n …\n\n or(parser: Parser<T>): Parser<T> {\n return new Parser((source) => {\n let result = this.parse(source);\n if (result)\n return result;\n else\n return parser.parse(source);\n });\n }\n}\n```", "```js\nregexp(/a{100}b/y).or(regexp(/a{100}c/y))\n```", "```js\nlet letterOrDigit =\n regexp(/[a-z]/y).or(regexp(/[0-9]/y));\n```", "```js\nletterOrDigit <- [a-z] / [0-9]\n```", "```js\nclass Parser<T> {\n …\n\n static zeroOrMore<U>(\n parser: Parser<U>,\n ): Parser<Array<U>> {\n return new Parser(source => {\n let results = [];\n let item = null;\n while (item = parser.parse(source)) {\n source = item.source;\n results.push(item.value);\n }\n return new ParseResult(results, source);\n });\n }\n}\n```", "```js\nlet someLettersOrDigits = zeroOrMore(letterOrDigit);\n```", "```js\nsomeLettersOrDigits -> letterOrDigit*\n```", "```js\nsomeLettersOrDigits -> ([a-z] / [0-9])*\n```", "```js\nclass Parser<T> {\n …\n\n bind<U>(\n callback: (value: T) => Parser<U>,\n ): Parser<U> {\n return new Parser((source) => {\n let result = this.parse(source);\n if (result) {\n let value = result.value;\n let source = result.source;\n return callback(value).parse(source);\n } else {\n return null;\n }\n });\n }\n}\n```", "```js\nlet pair =\n regexp(/[0-9]+/y).bind((first) =>\n regexp(/,/y).bind((_) =>\n regexp(/[0-9]+/y).bind((second) =>\n constant([first, second]))));\n```", "```js\npair <- [0-9]+ \",\" [0-9]+\n```", "```js\nclass Parser<T> {\n …\n\n and<U>(parser: Parser<U>): Parser<U> {\n return this.bind((_) => parser);\n }\n}\n```", "```js\nclass Parser<T> {\n …\n\n map<U>(callback: (t: T) => U): Parser<U> {\n return this.bind((value) =>\n constant(callback(value)));\n }\n}\n```", "```js\nlet pair =\n regexp(/[0-9]+/y).bind((first) =>\n regexp(/,/y).and(\n regexp(/[0-9]+/y)).map((second) =>\n [first, second]));\n```", "```js\npair <- [0-9]+ \",\" [0-9]+\n```", "```js\nlet pair =\n regexp(/[0-9]+/y).and(\n regexp(/,/y).and(\n regexp(/[0-9]+/y)));\n```", "```js\nlet pair =\n regexp(/[0-9]+/y).bind((first) =>\n regexp(/,/y).and(\n regexp(/[0-9]+/y).bind((second) => …)));\n```", "```js\nlet pair =\n regexp(/[0-9]+/y).bind((first) =>\n regexp(/,/y).and(\n regexp(/[0-9]+/y).bind((second) =>\n constant([first, second])));\n```", "```js\nlet pair =\n regexp(/[0-9]+/y).bind((first) =>\n regexp(/,/y).and(\n regexp(/[0-9]+/y).map((second) =>\n [first, second])));\n```", "```js\nclass Parser<T> {\n …\n\n static maybe<U>(\n parser: Parser<U | null>,\n ): Parser<U | null> {\n return parser.or(constant(null));\n }\n}\n```", "```js\nlet maybeLetterOrDigit = maybe(letterOrDigit);\n```", "```js\nmaybeLetterOrDigit <- letterOrDigit?\n```", "```js\nclass Parser<T> {\n …\n\n parseStringToCompletion(string: string): T {\n let source = new Source(string, 0);\n\n let result = this.parse(source);\n if (!result)\n throw Error(\"Parse error at index 0\");\n\n let index = result.source.index;\n if (index != result.source.string.length)\n throw Error(\"Parse error at index \" + index);\n\n return result.value;\n }\n}\n```"]