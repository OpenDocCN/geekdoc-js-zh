- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HIGHER-ORDER FUNCTIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A large program is a costly program, and not just because of the time it takes
    to build. Size almost always involves complexity, and complexity confuses programmers.
    Confused programmers, in turn, introduce mistakes (*bugs*) into programs. A large
    program then provides a lot of space for these bugs to hide, making them hard
    to find.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly go back to the final two example programs in the introduction.
    The first is self-contained and six lines long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The second relies on two external functions and is one line long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Which one is more likely to contain a bug?
  prefs: []
  type: TYPE_NORMAL
- en: If we count the size of the definitions of sum and range, the second program
    is also big—even bigger than the first. But still, I’d argue that it is more likely
    to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the solution is expressed in a vocabulary that corresponds to
    the problem being solved. Summing a range of numbers isn’t about loops and counters.
    It is about ranges and sums.
  prefs: []
  type: TYPE_NORMAL
- en: The definitions of this vocabulary (the functions sum and range) will still
    involve loops, counters, and other incidental details. But because they are expressing
    simpler concepts than the program as a whole, they are easier to get right.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the context of programming, these kinds of vocabularies are usually called
    *abstractions*. Abstractions give us the ability to talk about problems at a higher
    (or more abstract) level, without getting sidetracked by uninteresting details.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an analogy, compare these two recipes for pea soup. The first goes like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Put 1 cup of dried peas per person into a container. Add water until the peas
    are well covered. Leave the peas in water for at least 12 hours. Take the peas
    out of the water and put them in a cooking pan. Add 4 cups of water per person.
    Cover the pan and keep the peas simmering for two hours. Take half an onion per
    person. Cut it into pieces with a knife. Add it to the peas. Take a stalk of celery
    per person. Cut it into pieces with a knife. Add it to the peas. Take a carrot
    per person. Cut it into pieces. With a knife! Add it to the peas. Cook for 10
    more minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this is the second recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Per person: 1 cup dried split peas, 4 cups of water, half a chopped onion,
    a stalk of celery, and a carrot.'
  prefs: []
  type: TYPE_NORMAL
- en: Soak peas for 12 hours. Simmer for 2 hours. Chop and add vegetables. Cook for
    10 more minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The second is shorter and easier to interpret. But you do need to understand
    a few more cooking-related words such as *soak*, *simmer*, *chop*, and, I guess,
    *vegetable*.
  prefs: []
  type: TYPE_NORMAL
- en: When programming, we can’t rely on all the words we need to be waiting for us
    in the dictionary. Thus, we might fall into the pattern of the first recipe—work
    out the precise steps the computer has to perform, one by one, blind to the higher-level
    concepts they express.
  prefs: []
  type: TYPE_NORMAL
- en: It is a useful skill, in programming, to notice when you are working at too
    low a level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Abstracting Repetition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plain functions, as we’ve seen them so far, are a good way to build abstractions.
    But sometimes they fall short.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common for a program to do something a given number of times. You can
    write a for loop for that, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Can we abstract “doing something *N* times” as a function? Well, it’s easy to
    write a function that calls console.log *N* times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But what if we want to do something other than logging the numbers? Since “doing
    something” can be represented as a function and functions are just values, we
    can pass our action as a function value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We don’t have to pass a predefined function to repeat. Often, it is easier to
    create a function value on the spot instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is structured a little like a for loop—it first describes the kind of loop
    and then provides a body. However, the body is now written as a function value,
    which is wrapped in the parentheses of the call to repeat. This is why it has
    to be closed with the closing brace *and* closing parenthesis. In cases like this
    example, where the body is a single small expression, you could also omit the
    braces and write the loop on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions that operate on other functions, either by taking them as arguments
    or by returning them, are called *higher-order functions*. Since we have already
    seen that functions are regular values, there is nothing particularly remarkable
    about the fact that such functions exist. The term comes from mathematics, where
    the distinction between functions and other values is taken more seriously.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions allow us to abstract over *actions*, not just values.
    They come in several forms. For example, we can have functions that create new
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can also have functions that change other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can even write functions that provide new types of control flow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is a built-in array method, forEach, that provides something like a for/of
    loop as a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Script Dataset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One area where higher-order functions shine is data processing. To process data,
    we’ll need some actual example data. This chapter will use a dataset about scripts—writing
    systems such as Latin, Cyrillic, or Arabic.
  prefs: []
  type: TYPE_NORMAL
- en: Remember Unicode, the system that assigns a number to each character in written
    language, from [Chapter 1](ch01.xhtml#ch01)? Most of these characters are associated
    with a specific script. The standard contains 140 different scripts, of which
    81 are still in use today and 59 are historic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though I can fluently read only Latin characters, I appreciate the fact that
    people are writing texts in at least 80 other writing systems, many of which I
    wouldn’t even recognize. For example, here’s a sample of Tamil handwriting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0085-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The example dataset contains some pieces of information about the 140 scripts
    defined in Unicode. It is available in the coding sandbox for this chapter (*[https://eloquentjavascript.net/code#5](https://eloquentjavascript.net/code#5)*)
    as the SCRIPTS binding. The binding contains an array of objects, each of which
    describes a script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Such an object tells us the name of the script, the Unicode ranges assigned
    to it, the direction in which it is written, the (approximate) origin time, whether
    it is still in use, and a link to more information. The direction may be “ltr”
    for left to right, “rtl” for right to left (the way Arabic and Hebrew text are
    written), or “ttb” for top to bottom (as with Mongolian writing).
  prefs: []
  type: TYPE_NORMAL
- en: The ranges property contains an array of Unicode character ranges, each of which
    is a two-element array containing a lower bound and an upper bound. Any character
    codes within these ranges are assigned to the script. The lower bound is inclusive
    (code 994 is a Coptic character) and the upper bound is noninclusive (code 1008
    isn’t).
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to find the scripts in the dataset that are still in use, the following
    function might be helpful. It filters out elements in an array that don’t pass
    a test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The function uses the argument named test, a function value, to fill a “gap”
    in the computation—the process of deciding which elements to collect.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the filter function, rather than deleting elements from the existing
    array, builds up a new array with only the elements that pass the test. This function
    is *pure*. It does not modify the array it is given.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like forEach, filter is a standard array method. The example defined the function
    only to show what it does internally. From now on, we’ll use it like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Transforming with map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say we have an array of objects representing scripts, produced by filtering
    the SCRIPTS array somehow. We want an array of names instead, which is easier
    to inspect.
  prefs: []
  type: TYPE_NORMAL
- en: The map method transforms an array by applying a function to all of its elements
    and building a new array from the returned values. The new array will have the
    same length as the input array, but its content will have been *mapped* to a new
    form by the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Like forEach and filter, map is a standard array method.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing with reduce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another common thing to do with arrays is to compute a single value from them.
    Our recurring example, summing a collection of numbers, is an instance of this.
    Another example is finding the script with the most characters.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-order operation that represents this pattern is called *reduce* (sometimes
    also called *fold*). It builds a value by repeatedly taking a single element from
    the array and combining it with the current value. When summing numbers, you’d
    start with the number zero and, for each element, add that to the sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters to reduce are, apart from the array, a combining function and
    a start value. This function is a little less straightforward than filter and
    map, so take a close look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The standard array method reduce, which of course corresponds to this function,
    has an added convenience. If your array contains at least one element, you are
    allowed to leave off the start argument. The method will take the first element
    of the array as its start value and start reducing at the second element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To use reduce (twice) to find the script with the most characters, we can write
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The characterCount function reduces the ranges assigned to a script by summing
    their sizes. Note the use of destructuring in the parameter list of the reducer
    function. The second call to reduce then uses this to find the largest script
    by repeatedly comparing two scripts and returning the larger one.
  prefs: []
  type: TYPE_NORMAL
- en: The Han script has more than 89,000 characters assigned to it in the Unicode
    standard, making it by far the biggest writing system in the dataset. Han is a
    script sometimes used for Chinese, Japanese, and Korean text. Those languages
    share a lot of characters, though they tend to write them differently. The (US-based)
    Unicode Consortium decided to treat them as a single writing system to save character
    codes. This is called *Han unification* and still makes some people very angry.
  prefs: []
  type: TYPE_NORMAL
- en: Composability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider how we would have written the previous example (finding the biggest
    script) without higher-order functions. The code is not that much worse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There are a few more bindings, and the program is four lines longer, but it
    is still very readable.
  prefs: []
  type: TYPE_NORMAL
- en: The abstractions these functions provide really shine when you need to *compose*
    operations. As an example, let’s write code that finds the average year of origin
    for living and dead scripts in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the dead scripts in Unicode are, on average, older than the
    living ones. This is not a terribly meaningful or surprising statistic. But I
    hope you’ll agree that the code used to compute it isn’t hard to read. You can
    see it as a pipeline: we start with all scripts, filter out the living (or dead)
    ones, take the years from those, average them, and round the result.'
  prefs: []
  type: TYPE_NORMAL
- en: You could definitely also write this computation as one big loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, it is harder to see what was being computed and how. And because intermediate
    results aren’t represented as coherent values, it’d be a lot more work to extract
    something like average into a separate function.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of what the computer is actually doing, these two approaches are also
    quite different. The first will build up new arrays when running filter and map,
    whereas the second computes only some numbers, doing less work. You can usually
    afford the readable approach, but if you’re processing huge arrays and doing so
    many times, the less abstract style might be worth the extra speed.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Character Codes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One interesting use of this dataset would be figuring out what script a piece
    of text is using. Let’s go through a program that does this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that each script has an array of character code ranges associated
    with it. Given a character code, we could use a function like this to find the
    corresponding script (if any):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The some method is another higher-order function. It takes a test function and
    tells you whether that function returns true for any of the elements in the array.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we get the character codes in a string?
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.xhtml#ch01), I mentioned that JavaScript strings are encoded
    as a sequence of 16-bit numbers. These are called *code units*. A Unicode character
    code was initially supposed to fit within such a unit (which gives you a little
    over 65,000 characters). When it became clear that wasn’t going to be enough,
    many people balked at the need to use more memory per character. To address these
    concerns, UTF-16, the format also used by JavaScript strings, was invented. It
    describes most common characters using a single 16-bit code unit but uses a pair
    of two such units for others.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16 is generally considered a bad idea today. It seems almost intentionally
    designed to invite mistakes. It’s easy to write programs that pretend code units
    and characters are the same thing. And if your language doesn’t use two-unit characters,
    that will appear to work just fine. But as soon as someone tries to use such a
    program with some less common Chinese characters, it breaks. Fortunately, with
    the advent of emoji, everybody has started using two-unit characters, and the
    burden of dealing with such problems is more fairly distributed.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, obvious operations on JavaScript strings, such as getting their
    length through the length property and accessing their content using square brackets,
    deal only with code units.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript’s charCodeAt method gives you a code unit, not a full character code.
    The codePointAt method, added later, does give a full Unicode character, so we
    could use that to get characters from a string. But the argument passed to codePointAt
    is still an index into the sequence of code units. To run over all characters
    in a string, we’d still need to deal with the question of whether a character
    takes up one or two code units.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml#ch04), I mentioned that a for/of loop can also be
    used on strings. Like codePointAt, this type of loop was introduced at a time
    when people were acutely aware of the problems with UTF-16\. When you use it to
    loop over a string, it gives you real characters, not code units.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you have a character (which will be a string of one or two code units), you
    can use codePointAt(0) to get its code.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have a characterScript function and a way to correctly loop over characters.
    The next step is to count the characters that belong to each script. The following
    counting abstraction will be useful there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The countBy function expects a collection (anything that we can loop over with
    for/of) and a function that computes a group name for a given element. It returns
    an array of objects, each of which names a group and tells you the number of elements
    that were found in that group.
  prefs: []
  type: TYPE_NORMAL
- en: It uses another array method, find, which goes over the elements in the array
    and returns the first one for which a function returns true. It returns undefined
    when it finds no such element.
  prefs: []
  type: TYPE_NORMAL
- en: Using countBy, we can write the function that tells us which scripts are used
    in a piece of text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The function first counts the characters by name, using characterScript to assign
    them a name and falling back to the string “none” for characters that aren’t part
    of any script. The filter call drops the entry for “none” from the resulting array,
    since we aren’t interested in those characters.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to compute percentages, we first need the total number of characters
    that belong to a script, which we can compute with reduce. If we find no such
    characters, the function returns a specific string. Otherwise, it transforms the
    counting entries into readable strings with map and then combines them with join.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being able to pass function values to other functions is a deeply useful aspect
    of JavaScript. It allows us to write functions that model computations with “gaps”
    in them. The code that calls these functions can fill in the gaps by providing
    function values.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays provide a number of useful higher-order methods. You can use forEach
    to loop over the elements in an array. The filter method returns a new array containing
    only the elements that pass the predicate function. You can transform an array
    by putting each element through a function using map. You can use reduce to combine
    all the elements in an array into a single value. The some method tests whether
    any element matches a given predicate function, while find finds the first element
    that matches a predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Flattening*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use the reduce method in combination with the concat method to “flatten” an
    array of arrays into a single array that has all the elements of the original
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Your Own Loop*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a higher-order function loop that provides something like a for loop statement.
    It should take a value, a test function, an update function, and a body function.
    Each iteration, it should first run the test function on the current loop value
    and stop if that returns false. It should then call the body function, giving
    it the current value, and finally call the update function to create a new value
    and start over from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: When defining the function, you can use a regular loop to do the actual looping.
  prefs: []
  type: TYPE_NORMAL
- en: '*Everything*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arrays have an every method analogous to the some method. This method returns
    true when the given function returns true for *every* element in the array. In
    a way, some is a version of the || operator that acts on arrays, and every is
    like the && operator.
  prefs: []
  type: TYPE_NORMAL
- en: Implement every as a function that takes an array and a predicate function as
    parameters. Write two versions, one using a loop and one using the some method.
  prefs: []
  type: TYPE_NORMAL
- en: '*Dominant Writing Direction*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a function that computes the dominant writing direction in a string of
    text. Remember that each script object has a direction property that can be ”ltr”
    (left to right), “rtl” (right to left), or “ttb” (top to bottom).
  prefs: []
  type: TYPE_NORMAL
- en: The dominant direction is the direction of a majority of the characters that
    have a script associated with them. The characterScript and countBy functions
    defined earlier in the chapter are probably useful here.
  prefs: []
  type: TYPE_NORMAL
- en: '*An abstract data type is realized by writing a special kind of program [.
    . .] which defines the type in terms of the operations which can be performed
    on it.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Barbara Liskov, *Programming Settings with Abstract Data Types*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0094-01.jpg)'
  prefs: []
  type: TYPE_IMG
