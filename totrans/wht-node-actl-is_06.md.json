["```js\nA single bit:\n[ 0 ]  (Off)   or   [ 1 ]  (On)\n```", "```js\nA single byte:\n[0][1][0][0][1][0][0][1]\n```", "```js\n┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│  7  │  6  │  5  │  4  │  3  │  2  │  1  │  0  │\n├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│  2⁷ │  2⁶ │  2⁵ │  2⁴ │  2³ │  2² │  2¹ │  2⁰ │\n├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│ 128 │ 64  │ 32  │ 16  │  8  │  4  │  2  │  1  │\n└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n```", "```js\n128    64    32    16     8     4     2     1\n┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│  0  │  1  │  0  │  0  │  1  │  0  │  0  │  1  │\n└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n Value = (0 * 128) + (1 * 64) + (0 * 32) + (0 * 16) + (1 * 8) + (0 * 4) + (0 * 2) + (1 * 1)\n = 64 + 8 + 1\n = 73\n```", "```js\nA small slice of the ASCII \"contract\":\n Decimal | Binary   | Character\n-------------------------------\n 65    | 01000001 |    'A'\n 66    | 01000010 |    'B'\n 67    | 01000011 |    'C'\n ...   | ...      |    ...\n 97    | 01100001 |    'a'\n 98    | 01100010 |    'b'\n ...   | ...      |    ...\n 32    | 00100000 |  (space)\n```", "```js\nThe word \"HELLO\" in binary (ASCII):\n01001000 01000101 01001100 01001100 01001111\n 'H'     'E'     'L'     'L'     'O'\n```", "```js\nBinary -> Hex Mapping\n0000 -> 0    1000 -> 8\n0001 -> 1    1001 -> 9\n0010 -> 2    1010 -> A\n0011 -> 3    1011 -> B\n0100 -> 4    1100 -> C\n0101 -> 5    1101 -> D\n0110 -> 6    1110 -> E\n0111 -> 7    1111 -> F\n```", "```js\n// naive-copy.js\nimport fs from \"fs\";\nimport path from \"path\";\n const sourcePath = path.resolve(\"logo.png\");\nconst destPath = path.resolve(\"logo-corrupted.png\");\n console.log(`Reading from: ${sourcePath}`);\n try {\n // Let's try the obvious. Read the file into a string.\n // We have to provide an encoding, right? 'utf8' is standard.\n const data = fs.readFileSync(sourcePath, \"utf8\");\n console.log(\"File read into a string. Here is a sample:\");\n console.log(data.slice(0, 50)); // Let's see what it looks like\n console.log(`\\nWriting data back to: ${destPath}`);\n fs.writeFileSync(destPath, data);\n console.log(\"Copy complete. Or is it?\");\n} catch (err) {\n console.error(\"An error occurred:\", err);\n}\n```", "```js\nReading from: /path/to/your/project/logo.png\nFile read into a string. Here is a sample:\n�PNG\n�\n����JFIFHH���ICC_PROFILE�0\n Writing data back to: /path/to/your/project/logo-corrupted.png\nCopy complete. Or is it?\n```", "```js\n// create-buffer.js\n // Allocate a new Buffer of 10 bytes.\nconst buf1 = Buffer.alloc(10);\nconsole.log(buf1);\n// -> <Buffer 00 00 00 00 00 00 00 00 00 00>\n```", "```js\n// buffer-from.js\n // 1\\. From a string\nconst bufFromString = Buffer.from(\"hello world\", \"utf8\");\nconsole.log(bufFromString);\n// -> <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n// This is the correct way to convert text into its binary representation.\n // 2\\. From an array of byte values\nconst bufFromArray = Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]);\nconsole.log(bufFromArray);\n// -> <Buffer 68 65 6c 6c 6f>\nconsole.log(bufFromArray.toString(\"utf8\"));\n// -> \"hello\"\n // 3\\. From another Buffer (creates a copy)\nconst bufCopy = Buffer.from(bufFromString);\nbufCopy[0] = 0x78; // Change the 'h' to an 'x'\nconsole.log(bufCopy.toString(\"utf8\")); // -> \"xello world\"\nconsole.log(bufFromString.toString(\"utf8\")); // -> \"hello world\" (original is unchanged)\n```", "```js\n// manipulate-buffer.js\nconst buf = Buffer.from(\"hey\");\n // Read a byte at a specific index\nconsole.log(buf[0]); // -> 104 (ASCII code for 'h')\nconsole.log(buf[1]); // -> 101 (ASCII code for 'e')\n // Write a byte to a specific index\nbuf[1] = 0x6f; // 0x6f is the hex code for 'o'\nconsole.log(buf.toString(\"utf8\")); // -> \"hoy\"\n```", "```js\nconst secretData = Buffer.from(\"my-super-secret-password\");\n // Represent the data as UTF-8 (the default)\nconsole.log(secretData.toString()); // -> \"my-super-secret-password\"\n // Represent it as hexadecimal - very common for debugging\nconsole.log(secretData.toString(\"hex\"));\n// -> 6d792d73757065722d7365637265742d70617373776f7264\n // Represent it as Base64 - common for transport in text-based formats like JSON or XML\nconsole.log(secretData.toString(\"base64\"));\n// -> bXktc3VwZXItc2VjcmV0LXBhc3N3b3Jk\n```", "```js\nconst responseBuffer = Buffer.alloc(128);\n // Write the first part of the header\nlet offset = responseBuffer.write(\"HTTP/1.1 200 OK\\r\\n\");\n// The write method returns the number of bytes written, which we use as the new offset\n // Write the next header\noffset += responseBuffer.write(\"Content-Type: text/plain\\r\\n\", offset);\n // And so on...\nconsole.log(responseBuffer.toString(\"utf8\", 0, offset));\n/*\nHTTP/1.1 200 OK\nContent-Type: text/plain\n*/\n```", "```js\n// buffer-is-a-uint8array.js\nconst buf = Buffer.alloc(10);\n console.log(buf instanceof Buffer); // -> true\nconsole.log(buf instanceof Uint8Array); // -> true\n```", "```js\n// buffer-and-arraybuffer.js\nconst buf = Buffer.from(\"abc\");\n // Get the underlying ArrayBuffer\nconst arrayBuf = buf.buffer;\n console.log(arrayBuf);\n// -> ArrayBuffer { [Uint8Contents]: <61 62 63>, byteLength: 3 }\n console.log(arrayBuf instanceof ArrayBuffer); // -> true\n```", "```js\n// shared-memory.js\nconst arrayBuf = new ArrayBuffer(4); // A raw slab of 4 bytes\n // Create a view that interprets all 4 bytes as 8-bit integers\nconst view1_uint8 = new Uint8Array(arrayBuf);\n // Create a view that interprets all 4 bytes as a single 32-bit integer\nconst view2_int32 = new Int32Array(arrayBuf);\n view1_uint8[0] = 0xff; // Set the first byte to 255\nview1_uint8[1] = 0xff; // Set the second byte to 255\nview1_uint8[2] = 0xff; // Set the third byte to 255\nview1_uint8[3] = 0x7f; // Set the fourth byte to 127\n // Now, read the *same memory* through the 32-bit integer view\n// On a little-endian system, this will be interpreted as 0x7FFFFFFF\nconsole.log(view2_int32[0]); // -> 2147483647\n```"]