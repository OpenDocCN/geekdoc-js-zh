["```js\nimport { Readable } from \"stream\";\n const readable = new Readable({\n highWaterMark: 1024, // 1KB buffer\n});\n```", "```js\nconst objectStream = new Readable({\n objectMode: true,\n highWaterMark: 100, // buffer up to 100 objects\n});\n```", "```js\nconst textStream = new Readable({\n encoding: \"utf8\",\n});\n```", "```js\nreadable.on(\"data\", (chunk) => {\n console.log(`Received ${chunk.length} bytes`);\n});\n```", "```js\nreadable.on(\"end\", () => {\n console.log(\"No more data\");\n});\n```", "```js\nreadable.on(\"error\", (err) => {\n console.error(\"Stream error:\", err);\n});\n```", "```js\nreadable.on(\"readable\", () => {\n let chunk;\n while ((chunk = readable.read()) !== null) {\n console.log(`Read ${chunk.length} bytes`);\n }\n});\n```", "```js\nconst readable = getReadableStream();\n readable.on(\"readable\", () => {\n let chunk;\n while ((chunk = readable.read()) !== null) {\n processChunk(chunk);\n }\n});\n readable.on(\"end\", () => {\n console.log(\"Stream ended\");\n});\n```", "```js\nconst readable = getReadableStream();\n readable.on(\"data\", (chunk) => {\n processChunk(chunk);\n});\n readable.on(\"end\", () => {\n console.log(\"Stream ended\");\n});\n```", "```js\nreadable.on(\"data\", (chunk) => {\n const canContinue = processChunk(chunk);\n if (!canContinue) {\n readable.pause();\n // Later, when processing catches up:\n // readable.resume();\n }\n});\n```", "```js\nconst chunk = readable.read(100);\nif (chunk !== null) {\n console.log(`Read ${chunk.length} bytes`);\n}\n```", "```js\nconst state = readable._readableState;\nconsole.log(`Buffer length: ${state.length} bytes`);\nconsole.log(`Buffer count: ${state.buffer.length} chunks`);\nconsole.log(`highWaterMark: ${state.highWaterMark} bytes`);\n```", "```js\nclass MyReadable extends Readable {\n _read(size) {\n const chunk = this.getDataFromSomeTypeOfSource(size);\n if (chunk) {\n this.push(chunk); // Adds to internal buffer\n } else {\n this.push(null); // Signals end of data\n }\n }\n}\n```", "```js\nclass FileReader extends Readable {\n constructor(fd, options) {\n super(options);\n this.fd = fd;\n }\n _read(size) {\n const buffer = Buffer.allocUnsafe(size);\n fs.read(this.fd, buffer, 0, size, null, (err, bytesRead) => {\n if (err) {\n this.destroy(err);\n } else if (bytesRead === 0) {\n this.push(null); // EOF\n } else {\n this.push(buffer.slice(0, bytesRead));\n }\n });\n }\n}\n```", "```js\nimport { Readable } from \"stream\";\n class CounterStream extends Readable {\n constructor(max, options) {\n super(options);\n this.max = max;\n this.current = 1;\n }\n _read() {\n if (this.current <= this.max) {\n this.push(String(this.current));\n this.current++;\n } else {\n this.push(null);\n }\n }\n}\n```", "```js\nconst counter = new CounterStream(5);\n counter.on(\"data\", (chunk) => {\n console.log(`Received: ${chunk}`);\n});\n counter.on(\"end\", () => {\n console.log(\"Counter ended\");\n});\n```", "```js\nReceived: 1\nReceived: 2\nReceived: 3\nReceived: 4\nReceived: 5\nCounter ended\n```", "```js\nimport { Readable } from \"stream\";\nimport fs from \"fs\";\n class LineStream extends Readable {\n constructor(filePath, options) {\n super(options);\n this.fd = fs.openSync(filePath, \"r\");\n this.buffer = \"\";\n this.position = 0;\n }\n _read() {\n const chunk = Buffer.alloc(1024);\n const bytesRead = fs.readSync(this.fd, chunk, 0, 1024, this.position);\n if (bytesRead === 0) {\n if (this.buffer.length > 0) {\n this.push(this.buffer);\n }\n this.push(null);\n return;\n }\n this.position += bytesRead;\n this.buffer += chunk.slice(0, bytesRead).toString();\n let lineEnd;\n while ((lineEnd = this.buffer.indexOf(\"\\n\")) !== -1) {\n const line = this.buffer.slice(0, lineEnd);\n this.buffer = this.buffer.slice(lineEnd + 1);\n if (!this.push(line)) {\n return;\n }\n }\n }\n _destroy(err, callback) {\n if (this.fd !== undefined) {\n fs.close(this.fd, callback);\n } else {\n callback(err);\n }\n }\n}\n```", "```js\nimport { Readable } from \"stream\";\n async function* generateNumbers() {\n for (let i = 1; i <= 5; i++) {\n await new Promise((resolve) => setTimeout(resolve, 100));\n yield i;\n }\n}\n const stream = Readable.from(generateNumbers());\n stream.on(\"data\", (num) => {\n console.log(`Received: ${num}`);\n});\n```", "```js\n_read() {\n this.fetchData((err, data) => {\n if (err) {\n this.destroy(err); // Emits 'error' event\n } else if (data === null) {\n this.push(null); // End of stream\n } else {\n this.push(data);\n }\n });\n}\n```", "```js\nreadable.on(\"data\", (chunk) => {\n processChunk(chunk);\n});\n readable.on(\"end\", () => {\n console.log(\"Done\");\n});\n readable.on(\"error\", (err) => {\n console.error(\"Error:\", err);\n});\n```", "```js\ntry {\n for await (const chunk of readable) {\n await processChunk(chunk);\n }\n console.log(\"Done\");\n} catch (err) {\n console.error(\"Error:\", err);\n}\n```", "```js\nreadable.on(\"readable\", () => {\n let chunk;\n while ((chunk = readable.read()) !== null) {\n processChunk(chunk);\n }\n});\n readable.on(\"end\", () => {\n console.log(\"Done\");\n});\n```", "```js\nconst header = readable.read(4);\nif (header !== null) {\n const bodyLength = header.readUInt32BE(0);\n const body = readable.read(bodyLength);\n if (body !== null) {\n processMessage(header, body);\n }\n}\n```", "```js\nreadable.pipe(writable);\n readable.on(\"error\", (err) => {\n console.error(\"Read error:\", err);\n});\n writable.on(\"error\", (err) => {\n console.error(\"Write error:\", err);\n});\n```", "```js\nimport { pipeline } from \"stream/promises\";\n try {\n await pipeline(readable, writable);\n console.log(\"Pipeline succeeded\");\n} catch (err) {\n console.error(\"Pipeline failed:\", err);\n}\n```", "```js\nconst readable = getReadableStream();\n console.log(`Initial flowing: ${readable.readableFlowing}`); // null\n readable.on(\"data\", (chunk) => {\n console.log(`Received ${chunk.length} bytes`);\n});\n console.log(`After data listener: ${readable.readableFlowing}`); // true\n readable.removeAllListeners(\"data\");\nconsole.log(`After removing listeners: ${readable.readableFlowing}`); // true (still!)\n readable.pause();\nconsole.log(`After pause: ${readable.readableFlowing}`); // false\n readable.resume();\nconsole.log(`After resume: ${readable.readableFlowing}`); // true\n```", "```js\nconst readable = fs.createReadStream(\"large-file.txt\");\n readable.on(\"data\", async (chunk) => {\n await fetch(\"https://api.example.com/process\", {\n method: \"POST\",\n body: chunk,\n });\n});\n readable.on(\"end\", () => {\n console.log(\"Done\");\n});\n```", "```js\nconst readable = fs.createReadStream(\"large-file.txt\");\n readable.on(\"data\", async (chunk) => {\n readable.pause();\n await fetch(\"https://thenodebook.com/process\", {\n method: \"POST\",\n body: chunk,\n });\n readable.resume();\n});\n readable.on(\"end\", () => {\n console.log(\"Done\");\n});\n```", "```js\nconst readable = fs.createReadStream(\"large-file.txt\");\n for await (const chunk of readable) {\n await fetch(\"https://thenodebook.com/process\", {\n method: \"POST\",\n body: chunk,\n });\n}\n console.log(\"Done\");\n```", "```js\nimport { Readable } from \"stream\";\n class RowStream extends Readable {\n constructor(db, query, options) {\n super({ ...options, objectMode: true });\n this.db = db;\n this.query = query;\n this.offset = 0;\n }\n async _read() {\n try {\n const rows = await this.db.query(this.query, { offset: this.offset, limit: 100 });\n for (const row of rows) this.push(row);\n rows.length > 0 ? (this.offset += rows.length) : this.push(null);\n } catch (err) {\n this.destroy(err);\n }\n }\n}\n```", "```js\nconst stream = new RowStream(db, \"SELECT * FROM users\");\n for await (const row of stream) {\n console.log(`User: ${row.name}, Email: ${row.email}`);\n}\n```", "```js\nconsole.log(readable._readableState);\n```", "```js\nNODE_DEBUG=stream node your-script.js\n```", "```js\nconst readable = fs.createReadStream(\"large-file.bin\", {\n highWaterMark: 128 * 1024, // 128KB\n});\n```", "```js\nconst readable = fs.createReadStream(\"file.txt\", {\n highWaterMark: 4 * 1024, // 4KB\n});\n```", "```js\nasync function* fetchPages(url) {\n let page = 1;\n while (true) {\n const response = await fetch(`${url}?page=${page}`);\n const data = await response.json();\n if (data.items.length === 0) break;\n for (const item of data.items) {\n yield item;\n }\n page++;\n }\n}\n```", "```js\nconst stream = Readable.from(fetchPages(\"https://api.example.com/items\"));\n stream.pipe(someWritable);\n```", "```js\nconst stream = Readable.from([1, 2, 3, 4, 5]);\n for await (const num of stream) {\n console.log(num);\n}\n```"]