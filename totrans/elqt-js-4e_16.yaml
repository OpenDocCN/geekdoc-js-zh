- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE DOCUMENT OBJECT MODEL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open a web page, your browser retrieves the page’s HTML text and parses
    it, much like our parser from [Chapter 12](ch12.xhtml#ch12) parsed programs. The
    browser builds up a model of the document’s structure and uses this model to draw
    the page on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This representation of the document is one of the toys that a JavaScript program
    has available in its sandbox. It is a data structure that you can read or modify.
    It acts as a *live* data structure: when it’s modified, the page on the screen
    is updated to reflect the changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Document Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can imagine an HTML document as a nested set of boxes. Tags such as <body>
    and </body> enclose other tags, which in turn contain other tags or text. Here’s
    the example document from the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This page has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0218-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The data structure the browser uses to represent the document follows this shape.
    For each box, there is an object, which we can interact with to find out things
    such as what HTML tag it represents and which boxes and text it contains. This
    representation is called the *Document Object Model*, or *DOM* for short.
  prefs: []
  type: TYPE_NORMAL
- en: The global binding document gives us access to these objects. Its documentElement
    property refers to the object representing the <html> tag. Since every HTML document
    has a head and a body, it also has head and body properties pointing at those
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Think back to the syntax trees from [Chapter 12](ch12.xhtml#ch12) for a moment.
    Their structures are strikingly similar to the structure of a browser’s document.
    Each *node* may refer to other nodes, *children*, which in turn may have their
    own children. This shape is typical of nested structures, where elements can contain
    subelements that are similar to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: We call a data structure a *tree* when it has a branching structure, no cycles
    (a node may not contain itself, directly or indirectly), and a single, well-defined
    *root*. In the case of the DOM, document.documentElement serves as the root.
  prefs: []
  type: TYPE_NORMAL
- en: Trees come up a lot in computer science. In addition to representing recursive
    structures such as HTML documents or programs, they are often used to maintain
    sorted sets of data because elements can usually be found or inserted more efficiently
    in a tree than in a flat array.
  prefs: []
  type: TYPE_NORMAL
- en: A typical tree has different kinds of nodes. The syntax tree for the Egg language
    had identifiers, values, and application nodes. Application nodes may have children,
    whereas identifiers and values are *leaves*, or nodes without children.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for the DOM. Nodes for *elements*, which represent HTML tags,
    determine the structure of the document. These can have child nodes. An example
    of such a node is document.body. Some of these children can be leaf nodes, such
    as pieces of text or comment nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Each DOM node object has a nodeType property, which contains a code (number)
    that identifies the type of node. Elements have code 1, which is also defined
    as the constant property Node.ELEMENT_NODE. Text nodes, representing a section
    of text in the document, get code 3 (Node.TEXT_NODE). Comments have code 8 (Node.COMMENT_NODE).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to visualize our document tree is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0219-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The leaves are text nodes, and the arrows indicate parent-child relationships
    between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The Standard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using cryptic numeric codes to represent node types is not a very JavaScript-like
    thing to do. Later in this chapter, we’ll see that other parts of the DOM interface
    also feel cumbersome and alien. This is because the DOM interface wasn’t designed
    for JavaScript alone. Rather, it tries to be a language-neutral interface that
    can be used in other systems as well—not just for HTML but also for XML, which
    is a generic data format with an HTML-like syntax.
  prefs: []
  type: TYPE_NORMAL
- en: This is unfortunate. Standards are often useful. But in this case, the advantage
    (cross-language consistency) isn’t all that compelling. Having an interface that
    is properly integrated with the language you’re using will save you more time
    than having a familiar interface across languages.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of this poor integration, consider the childNodes property that
    element nodes in the DOM have. This property holds an array-like object with a
    length property and properties labeled by numbers to access the child nodes. But
    it is an instance of the NodeList type, not a real array, so it does not have
    methods such as slice and map.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are issues that are simply caused by poor design. For example, there
    is no way to create a new node and immediately add children or attributes to it.
    Instead, you have to first create it and then add the children and attributes
    one by one, using side effects. Code that interacts heavily with the DOM tends
    to get long, repetitive, and ugly.
  prefs: []
  type: TYPE_NORMAL
- en: But these flaws aren’t fatal. Since JavaScript allows us to create our own abstractions,
    it is possible to design improved ways to express the operations we are performing.
    Many libraries intended for browser programming come with such tools.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Through the Tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DOM nodes contain a wealth of links to other nearby nodes. The following diagram
    illustrates these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0220-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although the diagram shows only one link of each type, every node has a parentNode
    property that points to the node it is part of, if any. Likewise, every element
    node (node type 1) has a childNodes property that points to an array-like object
    holding its children.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, you could move anywhere in the tree using just these parent and child
    links. But JavaScript also gives you access to a number of additional convenience
    links. The firstChild and lastChild properties point to the first and last child
    elements or have the value null for nodes without children. Similarly, previousSibling
    and nextSibling point to adjacent nodes, which are nodes with the same parent
    that appear immediately before or after the node itself. For a first child, previousSibling
    will be null, and for a last child, nextSibling will be null.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also the children property, which is like childNodes but contains only
    element (type 1) children, not other types of child nodes. This can be useful
    when you aren’t interested in text nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with a nested data structure like this one, recursive functions
    are often useful. The following function scans a document for text nodes containing
    a given string and returns true when it has found one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The nodeValue property of a text node holds the string of text that it represents.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigating these links among parents, children, and siblings is often useful.
    But if we want to find a specific node in the document, reaching it by starting
    at document.body and following a fixed path of properties is a bad idea. Doing
    so bakes assumptions into our program about the precise structure of the document—a
    structure you might want to change later. Another complicating factor is that
    text nodes are created even for the whitespace between nodes. The example document’s
    <body> tag has not just three children (<h1> and two <p> elements), but seven:
    those three, plus the spaces before, after, and between them.'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to get the href attribute of the link in that document, we don’t
    want to say something like “Get the second child of the sixth child of the document
    body.” It’d be better if we could say “Get the first link in the document.” And
    we can.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All element nodes have a getElementsByTagName method, which collects all elements
    with the given tag name that are descendants (direct or indirect children) of
    that node and returns them as an array-like object.
  prefs: []
  type: TYPE_NORMAL
- en: To find a specific *single* node, you can give it an id attribute and use document.getElementById
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A third, similar method is getElementsByClassName, which, much like getElementsByTagName,
    searches through the contents of an element node and retrieves all elements that
    have the given string in their class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost everything about the DOM data structure can be changed. The shape of
    the document tree can be modified by changing parent-child relationships. Nodes
    have a remove method to remove them from their current parent node. To add a child
    node to an element node, we can use appendChild, which puts it at the end of the
    list of children, or insertBefore, which inserts the node given as the first argument
    before the node given as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A node can exist in the document in only one place. Thus, inserting paragraph
    *Three* in front of paragraph *One* will first remove it from the end of the document
    and then insert it at the front, resulting in *Three*/*One*/*Two*. All operations
    that insert a node somewhere will, as a side effect, cause it to be removed from
    its current position (if it has one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The replaceChild method is used to replace a child node with another one. It
    takes as arguments two nodes: a new node and the node to be replaced. The replaced
    node must be a child of the element the method is called on. Note that both replaceChild
    and insertBefore expect the *new* node as their first argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say we want to write a script that replaces all images (<img> tags) in the document
    with the text held in their alt attributes, which specifies an alternative textual
    representation of the image. This involves not only removing the images but also
    adding a new text node to replace them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Given a string, createTextNode gives us a text node that we can insert into
    the document to make it show up on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The loop that goes over the images starts at the end of the list. This is necessary
    because the node list returned by a method like getElementsByTagName (or a property
    like childNodes) is *live*. That is, it is updated as the document changes. If
    we started from the front, removing the first image would cause the list to lose
    its first element so that the second time the loop repeats, where i is 1, it would
    stop because the length of the collection is now also 1.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a *solid* collection of nodes, as opposed to a live one, you can
    convert the collection to a real array by calling Array.from.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To create element nodes, you can use the document.createElement method. This
    method takes a tag name and returns a new empty node of the given type.
  prefs: []
  type: TYPE_NORMAL
- en: The following example defines a utility elt, which creates an element node and
    treats the rest of its arguments as children to that node. This function is then
    used to add an attribution to a quote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the resulting document looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0224-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some element attributes, such as href for links, can be accessed through a property
    of the same name on the element’s DOM object. This is the case for most commonly
    used standard attributes.
  prefs: []
  type: TYPE_NORMAL
- en: HTML allows you to set any attribute you want on nodes. This can be useful because
    it allows you to store extra information in a document. To read or change custom
    attributes, which aren’t available as regular object properties, you have to use
    the getAttribute and setAttribute methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended to prefix the names of such made-up attributes with data-
    to ensure they do not conflict with any other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: There is a commonly used attribute, class, which is a keyword in the JavaScript
    language. For historical reasons—some old JavaScript implementations could not
    handle property names that matched keywords—the property used to access this attribute
    is called className. You can also access it under its real name, “class”, with
    the getAttribute and setAttribute methods.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that different types of elements are laid out differently.
    Some, such as paragraphs (<p>) or headings (<h1>), take up the whole width of
    the document and are rendered on separate lines. These are called *block* elements.
    Others, such as links (<a>) or the <strong> element, are rendered on the same
    line with their surrounding text. Such elements are called *inline* elements.
  prefs: []
  type: TYPE_NORMAL
- en: For any given document, browsers are able to compute a layout, which gives each
    element a size and position based on its type and content. This layout is then
    used to actually draw the document.
  prefs: []
  type: TYPE_NORMAL
- en: The size and position of an element can be accessed from JavaScript. The offsetWidth
    and offsetHeight properties give you the space the element takes up in *pixels*.
    A pixel is the basic unit of measurement in the browser. It traditionally corresponds
    to the smallest dot that the screen can draw, but on modern displays, which can
    draw *very* small dots, that may no longer be the case, and a browser pixel may
    span multiple display dots.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, clientWidth and clientHeight give you the size of the space *inside*
    the element, ignoring border width.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Giving a paragraph a border causes a rectangle to be drawn around it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0226-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The most effective way to find the precise position of an element on the screen
    is the getBoundingClientRect method. It returns an object with top, bottom, left,
    and right properties, indicating the pixel positions of the sides of the element
    relative to the upper left of the screen. If you want pixel positions relative
    to the whole document, you must add the current scroll position, which you can
    find in the pageXOffset and pageYOffset bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out a document can be quite a lot of work. In the interest of speed,
    browser engines do not immediately re-layout a document every time you change
    it but wait as long as they can before doing so. When a JavaScript program that
    changed the document finishes running, the browser will have to compute a new
    layout to draw the changed document to the screen. When a program *asks* for the
    position or size of something by reading properties such as offsetHeight or calling
    getBoundingClientRect, providing that information also requires computing a layout.
  prefs: []
  type: TYPE_NORMAL
- en: A program that repeatedly alternates between reading DOM layout information
    and changing the DOM forces a lot of layout computations to happen and will consequently
    run very slowly. The following code is an example of this. It contains two different
    programs that build up a line of *X* characters 2,000 pixels wide and measures
    the time each one takes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Styling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen that different HTML elements are drawn differently. Some are displayed
    as blocks, others inline. Some add styling—<strong> makes its content bold, and
    <a> makes it blue and underlines it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way an <img> tag shows an image or an <a> tag causes a link to be followed
    when it is clicked is strongly tied to the element type. But we can change the
    styling associated with an element, such as the text color or underline. Here
    is an example that uses the style property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second link will be green instead of the default link color.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0227-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A style attribute may contain one or more *declarations*, which are a property
    (such as color) followed by a colon and a value (such as green). When there is
    more than one declaration, they must be separated by semicolons, as in “color:
    red; border: none”.'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of aspects of the document can be influenced by styling. For example,
    the display property controls whether an element is displayed as a block or an
    inline element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The block tag will end up on its own line, since block elements are not displayed
    inline with the text around them. The last tag is not displayed at all—display:
    none prevents an element from showing up on the screen. This is a way to hide
    elements. It is often preferable to removing them from the document entirely because
    it makes it easy to reveal them again later.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0227-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JavaScript code can directly manipulate the style of an element through the
    element’s style property. This property holds an object that has properties for
    all possible style properties. The values of these properties are strings, which
    we can write to in order to change a particular aspect of the element’s style.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Some style property names contain hyphens, such as font-family. Because such
    property names are awkward to work with in JavaScript (you’d have to say style[“font-family”]),
    the property names in the style object for such properties have their hyphens
    removed and the letters after them capitalized (style.fontFamily).
  prefs: []
  type: TYPE_NORMAL
- en: Cascading Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The styling system for HTML is called *CSS*, for *Cascading Style Sheets*. A
    *style sheet* is a set of rules for how to style elements in a document. It can
    be given inside a <style> tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The *cascading* in the name refers to the fact that multiple such rules are
    combined to produce the final style for an element. In the example, the default
    styling for <strong> tags, which gives them font-weight: bold, is overlaid by
    the rule in the <style> tag, which adds font-style and color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When multiple rules define a value for the same property, the most recently
    read rule gets a higher precedence and wins. For example, if the rule in the <style>
    tag included font-weight: normal, contradicting the default font-weight rule,
    the text would be normal, *not* bold. Styles in a style attribute applied directly
    to the node have the highest precedence and always win.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to target things other than tag names in CSS rules. A rule for
    .abc applies to all elements with “abc” in their class attribute. A rule for #xyz
    applies to the element with an id attribute of “xyz” (which should be unique within
    the document).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The precedence rule favoring the most recently defined rule applies only when
    the rules have the same *specificity*. A rule’s specificity is a measure of how
    precisely it describes matching elements, determined by the number and kind (tag,
    class, or ID) of element aspects it requires. For example, a rule that targets
    p.a is more specific than rules that target p or just .a and would thus take precedence
    over them.
  prefs: []
  type: TYPE_NORMAL
- en: The notation p > a {...} applies the given styles to all <a> tags that are direct
    children of <p> tags. Similarly, p a {...} applies to all <a> tags inside <p>
    tags, whether they are direct or indirect children.
  prefs: []
  type: TYPE_NORMAL
- en: Query Selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We won’t be using style sheets very much in this book. Understanding them is
    helpful when programming in the browser, but they are complicated enough to warrant
    a separate book. The main reason I introduced *selector* syntax—the notation used
    in style sheets to determine which elements a set of styles apply to—is that we
    can use this same mini-language as an effective way to find DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: The querySelectorAll method, which is defined both on the document object and
    on element nodes, takes a selector string and returns a NodeList containing all
    the elements that it matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Unlike methods such as getElementsByTagName, the object returned by querySelectorAll
    is *not* live. It won’t change when you change the document. It is still not a
    real array, though, so you need to call Array.from if you want to treat it like
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The querySelector method (without the All part) works in a similar way. This
    one is useful if you want a specific single element. It will return only the first
    matching element, or null when no element matches.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning and Animating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The position style property influences layout in a powerful way. It has a default
    value of static, meaning the element sits in its normal place in the document.
    When it is set to relative, the element still takes up space in the document,
    but now the top and left style properties can be used to move it relative to that
    normal place. When position is set to absolute, the element is removed from the
    normal document flow—that is, it no longer takes up space and may overlap with
    other elements. Its top and left properties can be used to absolutely position
    it relative to the upper-left corner of the nearest enclosing element whose position
    property isn’t static, or relative to the document if no such enclosing element
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this to create an animation. The following document displays a picture
    of a cat that moves around in an ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The gray arrow shows the path along which the image moves.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0231-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our picture is centered on the page and given a position of relative. We’ll
    repeatedly update that picture’s top and left styles to move it.
  prefs: []
  type: TYPE_NORMAL
- en: The script uses requestAnimationFrame to schedule the animate function to run
    whenever the browser is ready to repaint the screen. The animate function itself
    again calls requestAnimationFrame to schedule the next update. When the browser
    window (or tab) is active, this will cause updates to happen at a rate of about
    60 per second, which tends to produce a good-looking animation.
  prefs: []
  type: TYPE_NORMAL
- en: If we just updated the DOM in a loop, the page would freeze, and nothing would
    show up on the screen. Browsers do not update their display while a JavaScript
    program is running, nor do they allow any interaction with the page. This is why
    we need requestAnimationFrame—it lets the browser know that we are done for now,
    and it can go ahead and do the things that browsers do, such as updating the screen
    and responding to user actions.
  prefs: []
  type: TYPE_NORMAL
- en: The animation function is passed the current time as an argument. To ensure
    that the motion of the cat per millisecond is stable, it bases the speed at which
    the angle changes on the difference between the current time and the last time
    the function ran. If it just moved the angle by a fixed amount per step, the motion
    would stutter when, for example, another heavy task running on the same computer
    prevented the function from running for a fraction of a second.
  prefs: []
  type: TYPE_NORMAL
- en: Moving in circles is done using the trigonometry functions Math.cos and Math.sin.
    For those who aren’t familiar with these, I’ll briefly introduce them, since we
    will occasionally use them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Math.cos and Math.sin are useful for finding points that lie on a circle around
    point (0, 0) with a radius of 1\. Both functions interpret their argument as the
    position on this circle, with 0 denoting the point on the far right of the circle,
    going clockwise until 2*π* (about 6.28) has taken us around the whole circle.
    Math.cos tells you the x-coordinate of the point that corresponds to the given
    position, and Math.sin yields the y-coordinate. Positions (or angles) greater
    than 2*π* or less than 0 are valid—the rotation repeats so that *a* + 2*π* refers
    to the same angle as *a*.
  prefs: []
  type: TYPE_NORMAL
- en: This unit for measuring angles is called radians—a full circle is 2*π* radians,
    similar to how it is 360 degrees when measuring in degrees. The constant *π* is
    available as Math.PI in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0232-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The cat animation code keeps a counter, angle, for the current angle of the
    animation and increments it every time the animate function is called. It can
    then use this angle to compute the current position of the image element. The
    top style is computed with Math.sin and multiplied by 20, which is the vertical
    radius of our ellipse. The left style is based on Math.cos and multiplied by 200
    so that the ellipse is much wider than it is high.
  prefs: []
  type: TYPE_NORMAL
- en: Note that styles usually need *units*. In this case, we have to append “px”
    to the number to tell the browser that we are counting in pixels (as opposed to
    centimeters, “ems,” or other units). This is easy to forget. Using numbers without
    units will result in your style being ignored—unless the number is 0, which always
    means the same thing, regardless of its unit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript programs may inspect and interfere with the document that the browser
    is displaying through a data structure called the DOM. This data structure represents
    the browser’s model of the document, and a JavaScript program can modify it to
    change the visible document.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM is organized like a tree, where elements are arranged hierarchically
    according to the structure of the document. The objects representing elements
    have properties such as parentNode and childNodes, which can be used to navigate
    through this tree.
  prefs: []
  type: TYPE_NORMAL
- en: The way a document is displayed can be influenced by *styling*, both by attaching
    styles to nodes directly and by defining rules that match certain nodes. There
    are many different style properties, such as color or display. JavaScript code
    can manipulate an element’s style directly through its style property.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Build a Table*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An HTML table is built with the following tag structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For each *row*, the <table> tag contains a <tr> tag. Inside of these <tr> tags,
    we can put cell elements: either heading cells (<th>) or regular cells (<td>).'
  prefs: []
  type: TYPE_NORMAL
- en: Given a dataset of mountains, an array of objects with name, height, and place
    properties, generate the DOM structure for a table that enumerates the objects.
    It has one column per key and one row per object, plus a header row with <th>
    elements at the top, listing the column names.
  prefs: []
  type: TYPE_NORMAL
- en: Write this so that the columns are automatically derived from the objects, by
    taking the property names of the first object in the data.
  prefs: []
  type: TYPE_NORMAL
- en: Show the resulting table in the document by appending it to the element that
    has an id attribute of “mountains”.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have this working, right-align cells that contain number values by
    setting their style.textAlign property to “right”.
  prefs: []
  type: TYPE_NORMAL
- en: '*Elements by Tag Name*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The document.getElementsByTagName method returns all child elements with a given
    tag name. Implement your own version of this as a function that takes a node and
    a string (the tag name) as arguments and returns an array containing all descendant
    element nodes with the given tag name. Your function should go through the document
    itself. It may not use a method like querySelectorAll to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: To find the tag name of an element, use its nodeName property. But note that
    this will return the tag name in all uppercase. Use the toLowerCase or toUpperCase
    string methods to compensate for this.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Cat’s Hat*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Extend the cat animation defined earlier so that both the cat and his hat (<img
    src=“img/hat.png”>) orbit at opposite sides of the ellipse.
  prefs: []
  type: TYPE_NORMAL
- en: Or make the hat circle around the cat. Or alter the animation in some other
    interesting way.
  prefs: []
  type: TYPE_NORMAL
- en: To make positioning multiple objects easier, you’ll probably want to switch
    to absolute positioning. This means that top and left are counted relative to
    the upper left of the document. To avoid using negative coordinates, which would
    cause the image to move outside of the visible page, you can add a fixed number
    of pixels to the position values.
  prefs: []
  type: TYPE_NORMAL
- en: '*You have power over your mind—not outside events. Realize this, and you will
    find strength.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Marcus Aurelius, *Meditations*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0234-01.jpg)'
  prefs: []
  type: TYPE_IMG
