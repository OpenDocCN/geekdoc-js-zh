- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: THE DOCUMENT OBJECT MODEL
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档对象模型
- en: When you open a web page, your browser retrieves the page’s HTML text and parses
    it, much like our parser from [Chapter 12](ch12.xhtml#ch12) parsed programs. The
    browser builds up a model of the document’s structure and uses this model to draw
    the page on the screen.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个网页时，浏览器检索页面的 HTML 文本并解析它，就像我们在 [第 12 章](ch12.xhtml#ch12) 中的解析器解析程序一样。浏览器构建文档结构的模型，并使用该模型在屏幕上绘制页面。
- en: 'This representation of the document is one of the toys that a JavaScript program
    has available in its sandbox. It is a data structure that you can read or modify.
    It acts as a *live* data structure: when it’s modified, the page on the screen
    is updated to reflect the changes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的这种表示形式是 JavaScript 程序在其沙盒中可用的玩具之一。这是一个你可以读取或修改的数据结构。它作为一个*实时*数据结构运作：当它被修改时，屏幕上的页面会更新以反映这些更改。
- en: Document Structure
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档结构
- en: 'You can imagine an HTML document as a nested set of boxes. Tags such as <body>
    and </body> enclose other tags, which in turn contain other tags or text. Here’s
    the example document from the previous chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 HTML 文档想象成一组嵌套的框。像 <body> 和 </body> 这样的标签包围其他标签，这些标签又包含其他标签或文本。以下是上一章的示例文档：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This page has the following structure:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本页面具有以下结构：
- en: '![Image](../images/f0218-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0218-01.jpg)'
- en: The data structure the browser uses to represent the document follows this shape.
    For each box, there is an object, which we can interact with to find out things
    such as what HTML tag it represents and which boxes and text it contains. This
    representation is called the *Document Object Model*, or *DOM* for short.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器用来表示文档的数据结构遵循这种形状。对于每个框，存在一个对象，我们可以与之交互以了解它表示什么 HTML 标签以及它包含哪些框和文本。这种表示被称为*文档对象模型*，简称*DOM*。
- en: The global binding document gives us access to these objects. Its documentElement
    property refers to the object representing the <html> tag. Since every HTML document
    has a head and a body, it also has head and body properties pointing at those
    elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 全局绑定文档使我们可以访问这些对象。其 documentElement 属性指向表示 <html> 标签的对象。由于每个 HTML 文档都有头和主体，因此它也具有指向这些元素的
    head 和 body 属性。
- en: Trees
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树
- en: Think back to the syntax trees from [Chapter 12](ch12.xhtml#ch12) for a moment.
    Their structures are strikingly similar to the structure of a browser’s document.
    Each *node* may refer to other nodes, *children*, which in turn may have their
    own children. This shape is typical of nested structures, where elements can contain
    subelements that are similar to themselves.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [第 12 章](ch12.xhtml#ch12) 的语法树。它们的结构与浏览器文档的结构惊人地相似。每个*节点*可能引用其他节点，即*子节点*，而这些子节点又可能有自己的子节点。这种形状是嵌套结构的典型特征，其中元素可以包含与自己相似的子元素。
- en: We call a data structure a *tree* when it has a branching structure, no cycles
    (a node may not contain itself, directly or indirectly), and a single, well-defined
    *root*. In the case of the DOM, document.documentElement serves as the root.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据结构具有分支结构，没有循环（一个节点不能直接或间接包含自身）并且有一个单一、明确的*根*时，我们称其为*树*。在 DOM 的情况下，document.documentElement
    充当根节点。
- en: Trees come up a lot in computer science. In addition to representing recursive
    structures such as HTML documents or programs, they are often used to maintain
    sorted sets of data because elements can usually be found or inserted more efficiently
    in a tree than in a flat array.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 树在计算机科学中经常出现。除了表示递归结构（如 HTML 文档或程序）外，它们还常用于维护排序的数据集，因为在树中查找或插入元素通常比在平面数组中更有效。
- en: A typical tree has different kinds of nodes. The syntax tree for the Egg language
    had identifiers, values, and application nodes. Application nodes may have children,
    whereas identifiers and values are *leaves*, or nodes without children.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的树具有不同类型的节点。Egg 语言的语法树有标识符、值和应用节点。应用节点可以有子节点，而标识符和值则是*叶子*，或没有子节点的节点。
- en: The same goes for the DOM. Nodes for *elements*, which represent HTML tags,
    determine the structure of the document. These can have child nodes. An example
    of such a node is document.body. Some of these children can be leaf nodes, such
    as pieces of text or comment nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 也是如此。*元素*的节点代表 HTML 标签，决定文档的结构。这些节点可以有子节点。一个这样的节点的例子是 document.body。这些子节点中有些可以是叶子节点，例如文本片段或注释节点。
- en: Each DOM node object has a nodeType property, which contains a code (number)
    that identifies the type of node. Elements have code 1, which is also defined
    as the constant property Node.ELEMENT_NODE. Text nodes, representing a section
    of text in the document, get code 3 (Node.TEXT_NODE). Comments have code 8 (Node.COMMENT_NODE).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 DOM 节点对象都有一个 nodeType 属性，其中包含一个代码（数字），用以标识节点的类型。元素的代码为 1，这也被定义为常量属性 Node.ELEMENT_NODE。表示文档中一段文本的文本节点的代码为
    3（Node.TEXT_NODE）。评论的代码为 8（Node.COMMENT_NODE）。
- en: 'Another way to visualize our document tree is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可视化文档树的方法如下：
- en: '![Image](../images/f0219-01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0219-01.jpg)'
- en: The leaves are text nodes, and the arrows indicate parent-child relationships
    between nodes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 叶子是文本节点，箭头表示节点之间的父子关系。
- en: The Standard
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准
- en: Using cryptic numeric codes to represent node types is not a very JavaScript-like
    thing to do. Later in this chapter, we’ll see that other parts of the DOM interface
    also feel cumbersome and alien. This is because the DOM interface wasn’t designed
    for JavaScript alone. Rather, it tries to be a language-neutral interface that
    can be used in other systems as well—not just for HTML but also for XML, which
    is a generic data format with an HTML-like syntax.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用晦涩的数字代码来表示节点类型并不是一个非常 JavaScript 风格的做法。本章后面我们将看到，DOM 接口的其他部分也感觉笨重且陌生。这是因为
    DOM 接口并不是专为 JavaScript 设计的。相反，它试图成为一个语言中立的接口，可以在其他系统中使用——不仅仅是 HTML，还包括 XML，后者是一种具有
    HTML 类似语法的通用数据格式。
- en: This is unfortunate. Standards are often useful. But in this case, the advantage
    (cross-language consistency) isn’t all that compelling. Having an interface that
    is properly integrated with the language you’re using will save you more time
    than having a familiar interface across languages.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这很不幸。标准通常是有用的。但在这种情况下，优势（跨语言的一致性）并不是特别令人信服。拥有一个与所使用语言良好集成的接口，比在多种语言中拥有一个熟悉的接口能节省更多时间。
- en: As an example of this poor integration, consider the childNodes property that
    element nodes in the DOM have. This property holds an array-like object with a
    length property and properties labeled by numbers to access the child nodes. But
    it is an instance of the NodeList type, not a real array, so it does not have
    methods such as slice and map.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种不佳集成的一个例子，考虑 DOM 中元素节点拥有的 childNodes 属性。该属性持有一个类数组对象，具有一个 length 属性和用数字标记的属性以访问子节点。但它是
    NodeList 类型的实例，而不是一个真正的数组，因此没有像 slice 和 map 这样的函数。
- en: Then there are issues that are simply caused by poor design. For example, there
    is no way to create a new node and immediately add children or attributes to it.
    Instead, you have to first create it and then add the children and attributes
    one by one, using side effects. Code that interacts heavily with the DOM tends
    to get long, repetitive, and ugly.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有一些问题是由于设计不佳造成的。例如，没有办法创建一个新节点并立即添加子节点或属性。相反，你必须先创建它，然后逐个添加子节点和属性，使用副作用。与
    DOM 密切互动的代码往往变得冗长、重复且难以维护。
- en: But these flaws aren’t fatal. Since JavaScript allows us to create our own abstractions,
    it is possible to design improved ways to express the operations we are performing.
    Many libraries intended for browser programming come with such tools.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些缺陷并不是致命的。由于 JavaScript 允许我们创建自己的抽象，因此可以设计改进的方法来表达我们正在执行的操作。许多用于浏览器编程的库都提供了这样的工具。
- en: Moving Through the Tree
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在树中移动
- en: 'DOM nodes contain a wealth of links to other nearby nodes. The following diagram
    illustrates these:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 节点包含大量链接到其他邻近节点的信息。以下图表对此进行了说明：
- en: '![Image](../images/f0220-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0220-01.jpg)'
- en: Although the diagram shows only one link of each type, every node has a parentNode
    property that points to the node it is part of, if any. Likewise, every element
    node (node type 1) has a childNodes property that points to an array-like object
    holding its children.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图表仅显示了每种类型的一个链接，但每个节点都有一个 parentNode 属性，指向它所属的节点（如果有的话）。同样，每个元素节点（节点类型 1）都有一个
    childNodes 属性，指向一个类数组对象，包含它的子节点。
- en: In theory, you could move anywhere in the tree using just these parent and child
    links. But JavaScript also gives you access to a number of additional convenience
    links. The firstChild and lastChild properties point to the first and last child
    elements or have the value null for nodes without children. Similarly, previousSibling
    and nextSibling point to adjacent nodes, which are nodes with the same parent
    that appear immediately before or after the node itself. For a first child, previousSibling
    will be null, and for a last child, nextSibling will be null.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以仅使用这些父节点和子节点链接在树中任意移动。但是JavaScript还为您提供了许多其他方便的链接。firstChild和lastChild属性指向第一个和最后一个子元素，或者对于没有子元素的节点，其值为null。类似地，previousSibling和nextSibling指向相邻节点，即与节点本身具有相同父级并立即在其前后出现的节点。对于第一个子节点，previousSibling将为null，对于最后一个子节点，nextSibling将为null。
- en: There’s also the children property, which is like childNodes but contains only
    element (type 1) children, not other types of child nodes. This can be useful
    when you aren’t interested in text nodes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个children属性，类似于childNodes，但仅包含元素（类型1）子节点，而不包括其他类型的子节点。当您不关心文本节点时，这可能非常有用。
- en: 'When dealing with a nested data structure like this one, recursive functions
    are often useful. The following function scans a document for text nodes containing
    a given string and returns true when it has found one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理像这样的嵌套数据结构时，递归函数通常很有用。以下函数扫描文档以查找包含给定字符串的文本节点，并在找到时返回true：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The nodeValue property of a text node holds the string of text that it represents.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文本节点的nodeValue属性保存它所表示的文本字符串。
- en: Finding Elements
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找元素
- en: 'Navigating these links among parents, children, and siblings is often useful.
    But if we want to find a specific node in the document, reaching it by starting
    at document.body and following a fixed path of properties is a bad idea. Doing
    so bakes assumptions into our program about the precise structure of the document—a
    structure you might want to change later. Another complicating factor is that
    text nodes are created even for the whitespace between nodes. The example document’s
    <body> tag has not just three children (<h1> and two <p> elements), but seven:
    those three, plus the spaces before, after, and between them.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在父节点、子节点和兄弟节点之间导航链接通常很有用。但是，如果我们想在文档中找到特定的节点，通过从document.body开始并遵循固定的属性路径来达到这个目的是一个不好的主意。这样做会在我们的程序中固化关于文档精确结构的假设，而这个结构以后可能会更改。另一个复杂因素是，即使是节点之间的空格也会创建文本节点。示例文档的<body>标签不仅有三个子节点（<h1>和两个<p>元素），而是有七个：这三个，加上它们之间的空格及其前后。
- en: If we want to get the href attribute of the link in that document, we don’t
    want to say something like “Get the second child of the sixth child of the document
    body.” It’d be better if we could say “Get the first link in the document.” And
    we can.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要获取文档中链接的href属性，我们不希望说像“获取文档主体的第六个子节点的第二个子节点”。最好的方式是说“获取文档中的第一个链接”。我们可以这样做。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All element nodes have a getElementsByTagName method, which collects all elements
    with the given tag name that are descendants (direct or indirect children) of
    that node and returns them as an array-like object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有元素节点都有一个getElementsByTagName方法，该方法收集该节点的所有后代（直接或间接子节点）中具有给定标签名的元素，并将它们作为类似数组的对象返回。
- en: To find a specific *single* node, you can give it an id attribute and use document.getElementById
    instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个特定的*单个*节点，可以给它一个id属性，然后使用document.getElementById。
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A third, similar method is getElementsByClassName, which, much like getElementsByTagName,
    searches through the contents of an element node and retrieves all elements that
    have the given string in their class attribute.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个类似的方法是getElementsByClassName，它类似于getElementsByTagName，通过元素节点的内容搜索，并检索其类属性中包含给定字符串的所有元素。
- en: Changing the Document
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改文档
- en: Almost everything about the DOM data structure can be changed. The shape of
    the document tree can be modified by changing parent-child relationships. Nodes
    have a remove method to remove them from their current parent node. To add a child
    node to an element node, we can use appendChild, which puts it at the end of the
    list of children, or insertBefore, which inserts the node given as the first argument
    before the node given as the second argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以更改DOM数据结构的所有内容。可以通过更改父子关系来修改文档树的形状。节点具有remove方法可以从当前父节点中删除它们。要将子节点添加到元素节点中，可以使用appendChild将其放在子节点列表的末尾，或者使用insertBefore将给定的第一个参数节点插入到给定的第二个参数节点之前。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A node can exist in the document in only one place. Thus, inserting paragraph
    *Three* in front of paragraph *One* will first remove it from the end of the document
    and then insert it at the front, resulting in *Three*/*One*/*Two*. All operations
    that insert a node somewhere will, as a side effect, cause it to be removed from
    its current position (if it has one).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点只能在文档中存在一个位置。因此，在段落 *One* 前插入段落 *Three* 将首先从文档末尾移除它，然后插入到前面，结果将是 *Three*/*One*/*Two*。所有将节点插入某处的操作都会作为副作用使其从当前位置移除（如果它有位置的话）。
- en: 'The replaceChild method is used to replace a child node with another one. It
    takes as arguments two nodes: a new node and the node to be replaced. The replaced
    node must be a child of the element the method is called on. Note that both replaceChild
    and insertBefore expect the *new* node as their first argument.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: replaceChild 方法用于用另一个节点替换子节点。它接受两个节点作为参数：一个新节点和要被替换的节点。被替换的节点必须是调用该方法的元素的子节点。请注意，replaceChild
    和 insertBefore 都期望 *新* 节点作为它们的第一个参数。
- en: Creating Nodes
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建节点
- en: Say we want to write a script that replaces all images (<img> tags) in the document
    with the text held in their alt attributes, which specifies an alternative textual
    representation of the image. This involves not only removing the images but also
    adding a new text node to replace them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个脚本，将文档中的所有图像（<img> 标签）替换为它们 alt 属性中包含的文本，alt 属性指定图像的替代文本表示。这不仅涉及移除图像，还需要添加一个新的文本节点来替代它们。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Given a string, createTextNode gives us a text node that we can insert into
    the document to make it show up on the screen.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个字符串，createTextNode 会给我们一个文本节点，我们可以将其插入到文档中以使其在屏幕上显示。
- en: The loop that goes over the images starts at the end of the list. This is necessary
    because the node list returned by a method like getElementsByTagName (or a property
    like childNodes) is *live*. That is, it is updated as the document changes. If
    we started from the front, removing the first image would cause the list to lose
    its first element so that the second time the loop repeats, where i is 1, it would
    stop because the length of the collection is now also 1.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历图像的循环从列表的末尾开始。这是必要的，因为像 getElementsByTagName（或像 childNodes 这样的属性）返回的节点列表是
    *实时的*。也就是说，它会随着文档的变化而更新。如果我们从前面开始，移除第一个图像会导致列表失去第一个元素，因此在循环第二次重复时（当 i 为 1 时），它会停止，因为集合的长度现在也变为
    1。
- en: If you want a *solid* collection of nodes, as opposed to a live one, you can
    convert the collection to a real array by calling Array.from.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个 *固态* 的节点集合，而不是一个实时的集合，你可以通过调用 Array.from 将集合转换为一个真正的数组。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To create element nodes, you can use the document.createElement method. This
    method takes a tag name and returns a new empty node of the given type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建元素节点，可以使用 document.createElement 方法。该方法接受一个标签名并返回一个给定类型的新空节点。
- en: The following example defines a utility elt, which creates an element node and
    treats the rest of its arguments as children to that node. This function is then
    used to add an attribution to a quote.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个工具函数 elt，该函数创建一个元素节点并将其余参数视为该节点的子节点。然后使用这个函数为引文添加归属。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what the resulting document looks like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成的文档的样子：
- en: '![Image](../images/f0224-01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0224-01.jpg)'
- en: Attributes
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: Some element attributes, such as href for links, can be accessed through a property
    of the same name on the element’s DOM object. This is the case for most commonly
    used standard attributes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些元素属性，比如链接的 href，可以通过元素 DOM 对象上同名的属性访问。这是大多数常用标准属性的情况。
- en: HTML allows you to set any attribute you want on nodes. This can be useful because
    it allows you to store extra information in a document. To read or change custom
    attributes, which aren’t available as regular object properties, you have to use
    the getAttribute and setAttribute methods.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 允许你在节点上设置任何你想要的属性。这很有用，因为它允许你在文档中存储额外的信息。要读取或更改自定义属性（这些属性在常规对象属性中不可用），你必须使用
    getAttribute 和 setAttribute 方法。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is recommended to prefix the names of such made-up attributes with data-
    to ensure they do not conflict with any other attributes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 建议将这些虚构属性的名称以 data- 为前缀，以确保它们不会与其他属性冲突。
- en: There is a commonly used attribute, class, which is a keyword in the JavaScript
    language. For historical reasons—some old JavaScript implementations could not
    handle property names that matched keywords—the property used to access this attribute
    is called className. You can also access it under its real name, “class”, with
    the getAttribute and setAttribute methods.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个常用的属性 `class`，这是 JavaScript 语言中的一个关键字。由于历史原因——一些旧的 JavaScript 实现无法处理与关键字匹配的属性名——用于访问此属性的属性被称为
    `className`。你也可以通过 `getAttribute` 和 `setAttribute` 方法以其真实名称“class”访问它。
- en: Layout
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局
- en: You may have noticed that different types of elements are laid out differently.
    Some, such as paragraphs (<p>) or headings (<h1>), take up the whole width of
    the document and are rendered on separate lines. These are called *block* elements.
    Others, such as links (<a>) or the <strong> element, are rendered on the same
    line with their surrounding text. Such elements are called *inline* elements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到不同类型的元素布局方式不同。一些元素，如段落（<p>）或标题（<h1>），占据文档的整个宽度，并在单独的行上渲染。这些被称为 *块* 元素。其他元素，如链接（<a>）或
    <strong> 元素，则与其周围文本在同一行上渲染。这些元素被称为 *内联* 元素。
- en: For any given document, browsers are able to compute a layout, which gives each
    element a size and position based on its type and content. This layout is then
    used to actually draw the document.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定的文档，浏览器能够计算一个布局，根据元素的类型和内容为每个元素提供大小和位置。然后，这个布局被用于实际绘制文档。
- en: The size and position of an element can be accessed from JavaScript. The offsetWidth
    and offsetHeight properties give you the space the element takes up in *pixels*.
    A pixel is the basic unit of measurement in the browser. It traditionally corresponds
    to the smallest dot that the screen can draw, but on modern displays, which can
    draw *very* small dots, that may no longer be the case, and a browser pixel may
    span multiple display dots.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的大小和位置可以通过 JavaScript 访问。`offsetWidth` 和 `offsetHeight` 属性告诉你元素在 *像素* 中占据的空间。像素是浏览器中的基本测量单位。它传统上对应于屏幕能够绘制的最小点，但在现代显示器上，它可以绘制
    *非常* 小的点，这可能不再是事实，并且浏览器像素可能跨越多个显示点。
- en: Similarly, clientWidth and clientHeight give you the size of the space *inside*
    the element, ignoring border width.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`clientWidth` 和 `clientHeight` 给你提供 *内部* 空间的大小，忽略边框宽度。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Giving a paragraph a border causes a rectangle to be drawn around it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 给段落添加边框会在其周围绘制一个矩形。
- en: '![Image](../images/f0226-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0226-01.jpg)'
- en: The most effective way to find the precise position of an element on the screen
    is the getBoundingClientRect method. It returns an object with top, bottom, left,
    and right properties, indicating the pixel positions of the sides of the element
    relative to the upper left of the screen. If you want pixel positions relative
    to the whole document, you must add the current scroll position, which you can
    find in the pageXOffset and pageYOffset bindings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 找到元素在屏幕上精确位置的最有效方法是 `getBoundingClientRect` 方法。它返回一个对象，包含顶部、底部、左侧和右侧属性，指示元素相对于屏幕左上角的边缘的像素位置。如果你想要相对于整个文档的像素位置，你必须加上当前的滚动位置，可以在
    `pageXOffset` 和 `pageYOffset` 绑定中找到。
- en: Laying out a document can be quite a lot of work. In the interest of speed,
    browser engines do not immediately re-layout a document every time you change
    it but wait as long as they can before doing so. When a JavaScript program that
    changed the document finishes running, the browser will have to compute a new
    layout to draw the changed document to the screen. When a program *asks* for the
    position or size of something by reading properties such as offsetHeight or calling
    getBoundingClientRect, providing that information also requires computing a layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 布局一个文档可能需要相当多的工作。为了提高速度，浏览器引擎不会在每次更改文档时立即重新布局，而是尽可能长时间地等待。在更改文档的 JavaScript
    程序运行结束后，浏览器将不得不计算一个新布局，以将更改后的文档绘制到屏幕上。当程序 *请求* 通过读取 `offsetHeight` 属性或调用 `getBoundingClientRect`
    来获取某个元素的位置或大小时，提供该信息也需要计算布局。
- en: A program that repeatedly alternates between reading DOM layout information
    and changing the DOM forces a lot of layout computations to happen and will consequently
    run very slowly. The following code is an example of this. It contains two different
    programs that build up a line of *X* characters 2,000 pixels wide and measures
    the time each one takes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不断在读取 DOM 布局信息和更改 DOM 之间交替进行的程序会迫使进行大量布局计算，因此运行会非常缓慢。以下代码就是一个例子。它包含两个不同的程序，构建一行
    2,000 像素宽的 *X* 字符，并测量每个程序所需的时间。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Styling
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式
- en: We have seen that different HTML elements are drawn differently. Some are displayed
    as blocks, others inline. Some add styling—<strong> makes its content bold, and
    <a> makes it blue and underlines it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到不同的 HTML 元素有不同的绘制方式。有些显示为块，有些则内联。有些添加样式——<strong> 会使其内容变为粗体，而 <a> 会使其变为蓝色并加下划线。
- en: 'The way an <img> tag shows an image or an <a> tag causes a link to be followed
    when it is clicked is strongly tied to the element type. But we can change the
    styling associated with an element, such as the text color or underline. Here
    is an example that uses the style property:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <img> 标签如何显示图像或 <a> 标签如何在点击时跟随链接，与元素类型密切相关。但我们可以更改与元素关联的样式，例如文本颜色或下划线。这里是一个使用样式属性的示例：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second link will be green instead of the default link color.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个链接将显示为绿色，而不是默认链接颜色。
- en: '![Image](../images/f0227-01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0227-01.jpg)'
- en: 'A style attribute may contain one or more *declarations*, which are a property
    (such as color) followed by a colon and a value (such as green). When there is
    more than one declaration, they must be separated by semicolons, as in “color:
    red; border: none”.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '样式属性可以包含一个或多个 *声明*，声明是属性（如颜色）后跟冒号和一个值（如绿色）。当有多个声明时，它们必须用分号分隔，如“color: red;
    border: none”。'
- en: A lot of aspects of the document can be influenced by styling. For example,
    the display property controls whether an element is displayed as a block or an
    inline element.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的许多方面都可以受到样式的影响。例如，display 属性控制一个元素是作为块级元素还是内联元素显示。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The block tag will end up on its own line, since block elements are not displayed
    inline with the text around them. The last tag is not displayed at all—display:
    none prevents an element from showing up on the screen. This is a way to hide
    elements. It is often preferable to removing them from the document entirely because
    it makes it easy to reveal them again later.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '块标签最终会单独占据一行，因为块级元素不会与周围文本内联显示。最后一个标签根本不显示——display: none 阻止元素在屏幕上显示。这是一种隐藏元素的方法。通常，这种方式比将它们完全从文档中删除更可取，因为这使得以后再次显示它们变得简单。'
- en: '![Image](../images/f0227-02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0227-02.jpg)'
- en: JavaScript code can directly manipulate the style of an element through the
    element’s style property. This property holds an object that has properties for
    all possible style properties. The values of these properties are strings, which
    we can write to in order to change a particular aspect of the element’s style.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 代码可以通过元素的样式属性直接操作元素的样式。此属性保存一个对象，该对象具有所有可能样式属性的属性。这些属性的值是字符串，我们可以通过写入它们来更改元素样式的特定方面。
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some style property names contain hyphens, such as font-family. Because such
    property names are awkward to work with in JavaScript (you’d have to say style[“font-family”]),
    the property names in the style object for such properties have their hyphens
    removed and the letters after them capitalized (style.fontFamily).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些样式属性名称包含连字符，例如 font-family。由于这样的属性名称在 JavaScript 中处理起来很麻烦（你必须这样写 style[“font-family”]），因此此类属性在样式对象中的名称去掉了连字符，并将其后面的字母大写（style.fontFamily）。
- en: Cascading Styles
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 层叠样式
- en: The styling system for HTML is called *CSS*, for *Cascading Style Sheets*. A
    *style sheet* is a set of rules for how to style elements in a document. It can
    be given inside a <style> tag.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 的样式系统称为 *CSS*，即 *层叠样式表*。*样式表* 是一组关于如何为文档中的元素添加样式的规则。它可以放在 <style> 标签内。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The *cascading* in the name refers to the fact that multiple such rules are
    combined to produce the final style for an element. In the example, the default
    styling for <strong> tags, which gives them font-weight: bold, is overlaid by
    the rule in the <style> tag, which adds font-style and color.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '名称中的 *层叠* 指的是多个此类规则结合以产生元素的最终样式。在这个例子中，<strong> 标签的默认样式（使其 font-weight: bold）被
    <style> 标签中的规则覆盖，后者添加了 font-style 和 color。'
- en: 'When multiple rules define a value for the same property, the most recently
    read rule gets a higher precedence and wins. For example, if the rule in the <style>
    tag included font-weight: normal, contradicting the default font-weight rule,
    the text would be normal, *not* bold. Styles in a style attribute applied directly
    to the node have the highest precedence and always win.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '当多个规则为同一属性定义值时，最近读取的规则优先级更高并获胜。例如，如果 <style> 标签中的规则包含 font-weight: normal，与默认的
    font-weight 规则相矛盾，文本将显示为正常的，*而不是* 粗体。直接应用于节点的样式属性具有最高优先级，总是获胜。'
- en: 'It is possible to target things other than tag names in CSS rules. A rule for
    .abc applies to all elements with “abc” in their class attribute. A rule for #xyz
    applies to the element with an id attribute of “xyz” (which should be unique within
    the document).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '在 CSS 规则中，可以针对除标签名以外的其他东西。规则 .abc 应用于所有类属性中包含“abc”的元素。规则 #xyz 应用于具有 id 属性“xyz”的元素（在文档中应该是唯一的）。'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The precedence rule favoring the most recently defined rule applies only when
    the rules have the same *specificity*. A rule’s specificity is a measure of how
    precisely it describes matching elements, determined by the number and kind (tag,
    class, or ID) of element aspects it requires. For example, a rule that targets
    p.a is more specific than rules that target p or just .a and would thus take precedence
    over them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级规则偏向于最近定义的规则，仅在规则具有相同的 *特异性* 时适用。规则的特异性是衡量其描述匹配元素的精确程度，取决于它所要求的元素方面的数量和种类（标签、类或
    ID）。例如，针对 p.a 的规则比针对 p 或仅 .a 的规则更具特异性，因此将优先于它们。
- en: The notation p > a {...} applies the given styles to all <a> tags that are direct
    children of <p> tags. Similarly, p a {...} applies to all <a> tags inside <p>
    tags, whether they are direct or indirect children.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 记号 p > a {...} 将给定的样式应用于所有直接子元素为 <p> 标签的 <a> 标签。类似地，p a {...} 将应用于所有位于 <p> 标签内部的
    <a> 标签，无论它们是直接还是间接子元素。
- en: Query Selectors
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询选择器
- en: We won’t be using style sheets very much in this book. Understanding them is
    helpful when programming in the browser, but they are complicated enough to warrant
    a separate book. The main reason I introduced *selector* syntax—the notation used
    in style sheets to determine which elements a set of styles apply to—is that we
    can use this same mini-language as an effective way to find DOM elements.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中我们不会频繁使用样式表。理解样式表在浏览器编程时是有帮助的，但它们足够复杂，值得单独成书。我引入 *选择器* 语法（样式表中用于确定一组样式适用哪些元素的记号）的主要原因是，我们可以使用这个相同的迷你语言作为有效的方式来查找
    DOM 元素。
- en: The querySelectorAll method, which is defined both on the document object and
    on element nodes, takes a selector string and returns a NodeList containing all
    the elements that it matches.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: querySelectorAll 方法在文档对象和元素节点上都被定义，它接受一个选择器字符串并返回一个包含所有匹配元素的 NodeList。
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unlike methods such as getElementsByTagName, the object returned by querySelectorAll
    is *not* live. It won’t change when you change the document. It is still not a
    real array, though, so you need to call Array.from if you want to treat it like
    one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 getElementsByTagName 等方法不同，querySelectorAll 返回的对象是 *非活跃* 的。它在文档更改时不会变化。不过，它仍然不是一个真正的数组，因此如果你想将其视为数组，需要调用
    Array.from。
- en: The querySelector method (without the All part) works in a similar way. This
    one is useful if you want a specific single element. It will return only the first
    matching element, or null when no element matches.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: querySelector 方法（没有 All 部分）以类似的方式工作。如果你想要特定的单个元素，这个方法很有用。它只会返回第一个匹配的元素，或者在没有匹配元素时返回
    null。
- en: Positioning and Animating
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定位与动画
- en: The position style property influences layout in a powerful way. It has a default
    value of static, meaning the element sits in its normal place in the document.
    When it is set to relative, the element still takes up space in the document,
    but now the top and left style properties can be used to move it relative to that
    normal place. When position is set to absolute, the element is removed from the
    normal document flow—that is, it no longer takes up space and may overlap with
    other elements. Its top and left properties can be used to absolutely position
    it relative to the upper-left corner of the nearest enclosing element whose position
    property isn’t static, or relative to the document if no such enclosing element
    exists.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: position 样式属性以强大的方式影响布局。其默认值为 static，意味着元素在文档中的正常位置。当设置为 relative 时，元素仍然占据文档中的空间，但现在可以使用
    top 和 left 样式属性相对于正常位置移动它。当 position 设置为 absolute 时，元素从正常文档流中移除——即它不再占据空间，并可能与其他元素重叠。其
    top 和 left 属性可以用于相对于最近的包围元素的左上角进行绝对定位（该元素的 position 属性不能为 static），或者如果没有这样的包围元素，则相对于文档进行定位。
- en: 'We can use this to create an animation. The following document displays a picture
    of a cat that moves around in an ellipse:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来创建动画。以下文档显示了一只在椭圆形轨道上移动的猫的图像：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The gray arrow shows the path along which the image moves.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 灰色箭头显示了图像移动的路径。
- en: '![Image](../images/f0231-01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0231-01.jpg)'
- en: Our picture is centered on the page and given a position of relative. We’ll
    repeatedly update that picture’s top and left styles to move it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图片居中显示在页面上，并设置为相对定位。我们将不断更新该图片的顶部和左侧样式以使其移动。
- en: The script uses requestAnimationFrame to schedule the animate function to run
    whenever the browser is ready to repaint the screen. The animate function itself
    again calls requestAnimationFrame to schedule the next update. When the browser
    window (or tab) is active, this will cause updates to happen at a rate of about
    60 per second, which tends to produce a good-looking animation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本使用requestAnimationFrame来安排animate函数在浏览器准备好重新绘制屏幕时运行。animate函数本身再次调用requestAnimationFrame以安排下一次更新。当浏览器窗口（或标签页）处于活动状态时，这将导致以每秒大约60次的速率进行更新，从而产生良好的动画效果。
- en: If we just updated the DOM in a loop, the page would freeze, and nothing would
    show up on the screen. Browsers do not update their display while a JavaScript
    program is running, nor do they allow any interaction with the page. This is why
    we need requestAnimationFrame—it lets the browser know that we are done for now,
    and it can go ahead and do the things that browsers do, such as updating the screen
    and responding to user actions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个循环中仅更新DOM，页面将会冻结，屏幕上什么都不会显示。浏览器在JavaScript程序运行时不会更新显示，也不允许与页面进行任何交互。这就是我们需要requestAnimationFrame的原因——它让浏览器知道我们暂时完成了，浏览器可以继续进行其应做的事情，例如更新屏幕和响应用户操作。
- en: The animation function is passed the current time as an argument. To ensure
    that the motion of the cat per millisecond is stable, it bases the speed at which
    the angle changes on the difference between the current time and the last time
    the function ran. If it just moved the angle by a fixed amount per step, the motion
    would stutter when, for example, another heavy task running on the same computer
    prevented the function from running for a fraction of a second.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 动画函数接收当前时间作为参数。为了确保猫的运动在每毫秒内是稳定的，它根据当前时间与上次函数运行时间之间的差异来确定角度变化的速度。如果它只是以固定的量每步移动角度，当例如计算机上另一个繁重的任务阻止函数运行时，运动会出现卡顿。
- en: Moving in circles is done using the trigonometry functions Math.cos and Math.sin.
    For those who aren’t familiar with these, I’ll briefly introduce them, since we
    will occasionally use them in this book.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周运动是通过三角函数Math.cos和Math.sin实现的。对于那些不熟悉这些函数的人，我将简要介绍一下，因为我们在本书中会偶尔使用它们。
- en: Math.cos and Math.sin are useful for finding points that lie on a circle around
    point (0, 0) with a radius of 1\. Both functions interpret their argument as the
    position on this circle, with 0 denoting the point on the far right of the circle,
    going clockwise until 2*π* (about 6.28) has taken us around the whole circle.
    Math.cos tells you the x-coordinate of the point that corresponds to the given
    position, and Math.sin yields the y-coordinate. Positions (or angles) greater
    than 2*π* or less than 0 are valid—the rotation repeats so that *a* + 2*π* refers
    to the same angle as *a*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Math.cos和Math.sin对于查找围绕点(0, 0)半径为1的圆上的点非常有用。这两个函数将它们的参数解释为圆上的位置，其中0表示圆的最右侧点，顺时针方向直到2*π*（大约6.28）使我们走完整个圆。Math.cos告诉你与给定位置对应的点的x坐标，而Math.sin则返回y坐标。大于2*π*或小于0的位置（或角度）都是有效的——旋转会重复，因此*a*
    + 2*π*表示与*a*相同的角度。
- en: This unit for measuring angles is called radians—a full circle is 2*π* radians,
    similar to how it is 360 degrees when measuring in degrees. The constant *π* is
    available as Math.PI in JavaScript.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用于测量角度的单位称为弧度——一个完整的圆是2*π*弧度，类似于用度数测量时为360度。常数*π*在JavaScript中可以用Math.PI表示。
- en: '![Image](../images/f0232-01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0232-01.jpg)'
- en: The cat animation code keeps a counter, angle, for the current angle of the
    animation and increments it every time the animate function is called. It can
    then use this angle to compute the current position of the image element. The
    top style is computed with Math.sin and multiplied by 20, which is the vertical
    radius of our ellipse. The left style is based on Math.cos and multiplied by 200
    so that the ellipse is much wider than it is high.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 猫动画代码保持一个计数器`angle`，用于表示当前动画的角度，并在每次调用animate函数时递增。然后可以利用这个角度来计算图像元素的当前位置。顶部样式是通过Math.sin计算得出，并乘以20，这是我们椭圆的垂直半径。左侧样式则基于Math.cos，并乘以200，使得椭圆的宽度远大于高度。
- en: Note that styles usually need *units*. In this case, we have to append “px”
    to the number to tell the browser that we are counting in pixels (as opposed to
    centimeters, “ems,” or other units). This is easy to forget. Using numbers without
    units will result in your style being ignored—unless the number is 0, which always
    means the same thing, regardless of its unit.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，样式通常需要 *单位*。在这种情况下，我们必须在数字后附加“px”，以告诉浏览器我们是在以像素为单位计数（而不是厘米、“ems”或其他单位）。这一点容易被忘记。使用没有单位的数字会导致你的样式被忽略——除非这个数字是
    0，因为无论单位是什么，0 总是意味着同样的东西。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: JavaScript programs may inspect and interfere with the document that the browser
    is displaying through a data structure called the DOM. This data structure represents
    the browser’s model of the document, and a JavaScript program can modify it to
    change the visible document.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 程序可以通过一个称为 DOM 的数据结构检查和干扰浏览器正在显示的文档。这个数据结构代表了浏览器对文档的模型，JavaScript
    程序可以修改它以更改可见文档。
- en: The DOM is organized like a tree, where elements are arranged hierarchically
    according to the structure of the document. The objects representing elements
    have properties such as parentNode and childNodes, which can be used to navigate
    through this tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 的组织结构像一棵树，元素根据文档的结构以层级方式排列。表示元素的对象具有父节点和子节点等属性，可以用来遍历这棵树。
- en: The way a document is displayed can be influenced by *styling*, both by attaching
    styles to nodes directly and by defining rules that match certain nodes. There
    are many different style properties, such as color or display. JavaScript code
    can manipulate an element’s style directly through its style property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的显示方式可以通过 *样式* 进行影响，包括直接将样式附加到节点以及定义匹配某些节点的规则。样式属性有很多种，例如颜色或显示。JavaScript
    代码可以通过其样式属性直接操作元素的样式。
- en: Exercises
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*Build a Table*'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*构建一个表格*'
- en: 'An HTML table is built with the following tag structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 表格是通过以下标签结构构建的：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For each *row*, the <table> tag contains a <tr> tag. Inside of these <tr> tags,
    we can put cell elements: either heading cells (<th>) or regular cells (<td>).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 *行*，<table> 标签包含一个 <tr> 标签。在这些 <tr> 标签内部，我们可以放置单元格元素：可以是表头单元格（<th>）或常规单元格（<td>）。
- en: Given a dataset of mountains, an array of objects with name, height, and place
    properties, generate the DOM structure for a table that enumerates the objects.
    It has one column per key and one row per object, plus a header row with <th>
    elements at the top, listing the column names.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含名称、高度和地点属性的山脉数据集，生成一个 DOM 结构的表格来列出这些对象。每个键对应一列，每个对象对应一行，并在顶部有一个包含 <th>
    元素的标题行，列出列名。
- en: Write this so that the columns are automatically derived from the objects, by
    taking the property names of the first object in the data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样编写，以便列自动从对象中派生，通过提取数据中第一个对象的属性名称。
- en: Show the resulting table in the document by appending it to the element that
    has an id attribute of “mountains”.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将生成的表格附加到具有 id 属性为“mountains”的元素中，显示结果表格。
- en: Once you have this working, right-align cells that contain number values by
    setting their style.textAlign property to “right”.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实现了这一点，通过将其 style.textAlign 属性设置为“right”，使包含数字值的单元格右对齐。
- en: '*Elements by Tag Name*'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*按标签名称获取元素*'
- en: The document.getElementsByTagName method returns all child elements with a given
    tag name. Implement your own version of this as a function that takes a node and
    a string (the tag name) as arguments and returns an array containing all descendant
    element nodes with the given tag name. Your function should go through the document
    itself. It may not use a method like querySelectorAll to do the work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: document.getElementsByTagName 方法返回具有给定标签名的所有子元素。实现你自己的版本作为一个函数，该函数接受一个节点和一个字符串（标签名）作为参数，并返回一个包含所有具有给定标签名的后代元素节点的数组。你的函数应遍历文档本身。它可能不使用像
    querySelectorAll 这样的方式来完成工作。
- en: To find the tag name of an element, use its nodeName property. But note that
    this will return the tag name in all uppercase. Use the toLowerCase or toUpperCase
    string methods to compensate for this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到元素的标签名，可以使用其 nodeName 属性。但请注意，这将返回全大写的标签名。可以使用 toLowerCase 或 toUpperCase
    字符串方法来进行补偿。
- en: '*The Cat’s Hat*'
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*猫的帽子*'
- en: Extend the cat animation defined earlier so that both the cat and his hat (<img
    src=“img/hat.png”>) orbit at opposite sides of the ellipse.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展之前定义的猫的动画，使得猫和他的帽子（<img src=“img/hat.png”>）在椭圆的两侧绕行。
- en: Or make the hat circle around the cat. Or alter the animation in some other
    interesting way.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 或者让帽子围绕猫转动。或者以其他有趣的方式改变动画。
- en: To make positioning multiple objects easier, you’ll probably want to switch
    to absolute positioning. This means that top and left are counted relative to
    the upper left of the document. To avoid using negative coordinates, which would
    cause the image to move outside of the visible page, you can add a fixed number
    of pixels to the position values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更方便地定位多个对象，你可能需要切换到绝对定位。这意味着顶部和左侧的位置是相对于文档的左上角计算的。为了避免使用负坐标，这会导致图像移动到可见页面之外，你可以在位置值中添加一个固定的像素值。
- en: '*You have power over your mind—not outside events. Realize this, and you will
    find strength.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*你对自己的思想拥有掌控权——而不是外部事件。认识到这一点，你将找到力量。*'
- en: —Marcus Aurelius, *Meditations*
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: —马库斯·奥勒留，*《沉思录》*
- en: '![Image](../images/f0234-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0234-01.jpg)'
