["```js\nlet whitespace = regexp(/[ \\n\\r\\t]+/y);\nlet comments =\n regexp(/[/][/].*/y).or(regexp(/[/][*].*[*][/]/sy));\nlet ignored = zeroOrMore(whitespace.or(comments));\n```", "```js\n/[/][*].*[*][/]/sy\n```", "```js\n/\\/\\*.*\\*\\//sy\n```", "```js\nlet token = (pattern) =>\n regexp(pattern).bind((value) =>\n ignored.and(constant(value)));\n```", "```js\nlet FUNCTION = token(/function\\b/y);\nlet IF = token(/if\\b/y);\nlet ELSE = token(/else\\b/y);\nlet RETURN = token(/return\\b/y);\nlet VAR = token(/var\\b/y);\nlet WHILE = token(/while\\b/y);\n```", "```js\nlet COMMA = token(/[,]/y);\nlet SEMICOLON = token(/;/y);\nlet LEFT_PAREN = token(/[(]/y);\nlet RIGHT_PAREN = token(/[)]/y);\nlet LEFT_BRACE = token(/[{]/y);\nlet RIGHT_BRACE = token(/[}]/y);\n```", "```js\nlet NUMBER =\n token(/[0-9]+/y).map((digits) =>\n new Number(parseInt(digits, 10)));\n```", "```js\nlet ID = token(/[a-zA-Z_][a-zA-Z0-9_]*/y);\n```", "```js\nlet id = ID.map((x) => new Id(x));\n```", "```js\nlet NOT = token(/!/y).map((_) => Not);\nlet EQUAL = token(/==/y).map((_) => Equal);\nlet NOT_EQUAL = token(/!=/y).map((_) => NotEqual);\nlet PLUS = token(/[+]/y).map((_) => Add);\nlet MINUS = token(/[-]/y).map((_) => Subtract);\nlet STAR = token(/[*]/y).map((_) => Multiply);\nlet SLASH = token(/[/]/y).map((_) => Divide);\nlet ASSIGN = token(/=/y).map((_) => Assign);\n```", "```js\nargs <- (expression (COMMA expression)*)?\ncall <- ID LEFT_PAREN args RIGHT_PAREN\natom <- call / ID / NUMBER\n      / LEFT_PAREN expression RIGHT_PAREN\nunary <- NOT? atom\nproduct <- unary ((STAR / SLASH) unary)*\nsum <- product ((PLUS / MINUS) product)*\ncomparison <- sum ((EQUAL / NOT_EQUAL) sum)*\nexpression <- comparison\n```", "```js\nlet expression: Parser<AST> =\n Parser.error(\n \"Expression parser used before definition\");\n```", "```js\nexpression.parse = comparison.parse;\n```", "```js\nargs <- (expression (COMMA expression)*)?\ncall <- ID LEFT_PAREN args RIGHT_PAREN\n```", "```js\n// args <- (expression (COMMA expression)*)?\nlet args =\n maybe(\n expression.and(zeroOrMore(COMMA.and(expression))))\n```", "```js\n// args <- (expression (COMMA expression)*)?\nlet args: Parser<Array<AST>> =\n expression.bind((arg) =>\n zeroOrMore(COMMA.and(expression)).bind((args) =>\n constant([arg, ...args]))).or(constant([]))\n```", "```js\n// call <- ID LEFT_PAREN args RIGHT_PAREN\nlet call =\n ID.and(LEFT_PAREN.and(args.and(RIGHT_PAREN)))\n```", "```js\n// call <- ID LEFT_PAREN args RIGHT_PAREN\nlet call: Parser<AST> =\n ID.bind((callee) =>\n LEFT_PAREN.and(args.bind((args) =>\n RIGHT_PAREN.and(\n constant(new Call(callee, args))))));\n```", "```js\n// atom <- call / ID / NUMBER\n//       / LEFT_PAREN expression RIGHT_PAREN\nlet atom: Parser<AST> =\n call.or(id).or(NUMBER).or(\n LEFT_PAREN.and(expression).bind((e) =>\n RIGHT_PAREN.and(constant(e))));\n```", "```js\n// unary <- NOT? atom\nlet unary: Parser<AST> =\n maybe(NOT).bind((not) =>\n atom.map((term) => not ? new Not(term) : term));\n```", "```js\nproduct <- unary ((STAR / SLASH) unary)*\nsum <- product ((PLUS / MINUS) product)*\ncomparison <- sum ((EQUAL / NOT_EQUAL) sum)*\n```", "```js\n// product <- unary ((STAR / SLASH) unary)*\nlet product =\n unary.and(zeroOrMore(STAR.or(SLASH).and(unary)));\n```", "```js\n[\n {operator: Multiply, term: new Id(\"y\")},\n {operator: Divide,   term: new Id(\"z\")},\n]\n```", "```js\nnew Divide(\n new Multiply(new Id(\"x\"), new Id(\"y\")),\n new Id(\"z\"))\n```", "```js\n// product <- unary ((STAR / SLASH) unary)*\nlet product =\n unary.bind((first) =>\n zeroOrMore(STAR.or(SLASH).bind((operator) =>\n unary.bind((term) =>\n constant({operator, term})))).map((operatorTerms) =>\n operatorTerms.reduce((left, {operator, term}) =>\n new operator(left, term), first)));\n```", "```js\nlet infix = (operatorParser, termParser) =>\n termParser.bind((term) =>\n zeroOrMore(operatorParser.bind((operator) =>\n termParser.bind((term) =>\n constant({operator, term})))).map((operatorTerms) =>\n operatorTerms.reduce((left, {operator, term}) =>\n new operator(left, term), term)));\n```", "```js\n// product <- unary ((STAR / SLASH) unary)*\nlet product = infix(STAR.or(SLASH), unary);\n\n// sum <- product ((PLUS / MINUS) product)*\nlet sum = infix(PLUS.or(MINUS), product);\n\n// comparison <- sum ((EQUAL / NOT_EQUAL) sum)*\nlet comparison = infix(EQUAL.or(NOT_EQUAL), sum);\n```", "```js\nnew Divide(\n new Multiply(new Id(\"x\"), new Id(\"y\")),\n new Id(\"z\"))\n```", "```js\n// expression <- comparison\nexpression.parse = comparison.parse;\n```", "```js\nreturnStatement <- RETURN expression SEMICOLON\n\nexpressionStatement <- expression SEMICOLON\n\nifStatement <-\n  IF LEFT_PAREN expression RIGHT_PAREN\n    statement\n  ELSE\n    statement\n\nwhileStatement <-\n  WHILE LEFT_PAREN expression RIGHT_PAREN statement\n\nvarStatement <- VAR ID ASSIGN expression SEMICOLON\n\nassignmentStatement <- ID ASSIGN EXPRESSION SEMICOLON\n\nblockStatement <- LEFT_BRACE statement* RIGHT_BRACE\n\nparameters <- (ID (COMMA ID)*)?\n\nfunctionStatement <-\n  FUNCTION ID LEFT_PAREN parameters RIGHT_PAREN\n  blockStatement\n\nstatement <- returnStatement\n           / ifStatement\n           / whileStatement\n           / varStatement\n           / assignmentStatemnt\n           / blockStatement\n           / functionStatement\n           / expressionStatement\n```", "```js\nlet statement: Parser<AST> =\n Parser.error(\n \"Statement parser used before definition\");\n```", "```js\n// returnStatement <- RETURN expression SEMICOLON\nlet returnStatement: Parser<AST> =\n RETURN.and(expression).bind((term) =>\n SEMICOLON.and(constant(new Return(term))));\n```", "```js\n// expressionStatement <- expression SEMICOLON\nlet expressionStatement: Parser<AST> =\n expression.bind((term) =>\n SEMICOLON.and(constant(term)));\n```", "```js\n// ifStatement <-\n//   IF LEFT_PAREN expression RIGHT_PAREN\n//     statement\n//   ELSE\n//     statement\nlet ifStatement: Parser<AST> =\n IF.and(LEFT_PAREN).and(expression).bind(\n (conditional) =>\n RIGHT_PAREN.and(statement).bind((consequence) =>\n ELSE.and(statement).bind((alternative) =>\n constant(new If(conditional,\n consequence,\n alternative)))));\n```", "```js\n// whileStatement <-\n//   WHILE LEFT_PAREN expression RIGHT_PAREN statement\nlet whileStatement: Parser<AST> =\n WHILE.and(LEFT_PAREN).and(expression).bind(\n (conditional) =>\n RIGHT_PAREN.and(statement).bind((body) =>\n constant(new While(conditional, body))));\n```", "```js\n// varStatement <-\n//   VAR ID ASSIGN expression SEMICOLON\nlet varStatement: Parser<AST> =\n VAR.and(ID).bind((name) =>\n ASSIGN.and(expression).bind((value) =>\n SEMICOLON.and(constant(new Var(name, value)))));\n```", "```js\n// assignmentStatement <- ID ASSIGN EXPRESSION SEMICOLON\nlet assignmentStatement: Parser<AST> =\n ID.bind((name) =>\n ASSIGN.and(expression).bind((value) =>\n SEMICOLON.and(constant(new Assign(name, value)))));\n```", "```js\n// blockStatement <- LEFT_BRACE statement* RIGHT_BRACE\nlet blockStatement: Parser<AST> =\n LEFT_BRACE.and(zeroOrMore(statement)).bind(\n (statements) =>\n RIGHT_BRACE.and(constant(new Block(statements))));\n```", "```js\n// parameters <- (ID (COMMA ID)*)?\nlet parameters: Parser<Array<string>> =\n ID.bind((param) =>\n zeroOrMore(COMMA.and(ID)).bind((params) =>\n constant([param, ...params]))).or(constant([]))\n```", "```js\n// functionStatement <-\n//   FUNCTION ID LEFT_PAREN parameters RIGHT_PAREN\n//   blockStatement\nlet functionStatement: Parser<AST> =\n FUNCTION.and(ID).bind((name) =>\n LEFT_PAREN.and(parameters).bind((parameters) =>\n RIGHT_PAREN.and(blockStatement).bind((block) =>\n constant(\n new Function(name, parameters, block)))));\n```", "```js\n// statement <- returnStatement\n//            / ifStatement\n//            / whileStatement\n//            / varStatement\n//            / assignmentStatement\n//            / blockStatement\n//            / functionStatement\n//            / expressionStatement\n```", "```js\nlet statementParser: Parser<AST> =\n returnStatement\n .or(functionStatement)\n .or(ifStatement)\n .or(whileStatement)\n .or(varStatement)\n .or(assignmentStatement)\n .or(blockStatement)\n .or(expressionStatement);\n\nstatement.parse = statementParser.parse;\n```", "```js\nlet parser: Parser<AST> =\n ignored.and(zeroOrMore(statement)).map((statements) =>\n new Block(statements));\n```", "```js\nlet source = `\n function factorial(n) {\n var result = 1;\n while (n != 1) {\n result = result * n;\n n = n - 1;\n }\n return result;\n }\n`;\n```", "```js\nlet expected = new Block([\n new Function(\"factorial\", [\"n\"], new Block([\n new Var(\"result\", new Number(1)),\n new While(new NotEqual(new Id(\"n\"),\n new Number(1)), new Block([\n new Assign(\"result\", new Multiply(new Id(\"result\"),\n new Id(\"n\"))),\n new Assign(\"n\", new Subtract(new Id(\"n\"),\n new Number(1))),\n ])),\n new Return(new Id(\"result\")),\n ])),\n]);\n\nlet result = parser.parseStringToCompletion(source);\n\nconsole.assert(result.equals(expected));\n```"]