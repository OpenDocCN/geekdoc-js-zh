["```js\n(function (exports, require, module, __filename, __dirname) {\n // Your module's code goes here\n});\n```", "```js\nfunction renderReport(templateName) {\n // templateName was a unique path like '/tmp/report-1662781800.js'\n const template = require(templateName); // PLEASE, NEVER DO THIS\n return template.render();\n}\n```", "```js\n// throws a ReferenceError in an ES module\nconsole.log(__filename);\nconsole.log(__dirname);\n // The new way. It's... a bit clunky, I'll admit.\nimport { fileURLToPath } from \"url\";\nimport { dirname, join } from \"path\";\n const __filename = fileURLToPath(import.meta.url);\nconst __dirname = dirname(__filename);\n console.log(\"Look mom, I found my way:\", join(__dirname, \"logs.txt\"));\n```", "```js\n// Old CJS way - wrap everything in an async function\nasync function main() {\n const db = await connectToDatabase();\n // ... rest of the startup\n}\nmain();\n // New ESM way with top-level await:\nimport { connectToDatabase } from \"./database.js\";\n console.log(\"Connecting to database...\");\n// This is happening at the top level! No async function needed.\nconst db = await connectToDatabase();\nconsole.log(\"Database connected!\");\n // Now you can start your server, confident the DB is ready.\nimport { startServer } from \"./server.js\";\nstartServer(db);\n```", "```js\n// A common, but seriously flawed, bootstrap pattern\nconsole.log(\"Process starting...\");\n // 1\\. Load configuration\nconst config = require(\"./config\"); // Sync I/O\n // 2\\. Initialize services\nconst database = require(\"./database\"); // More sync I/O\nconst logger = require(\"./logger\");\n // 3\\. Connect to the database\ndatabase\n .connect(config.db)\n .then(() => {\n console.log(\"Database connected.\");\n // 4\\. Set up the web server\n const app = require(\"./app\"); // Loads Express, routes, etc.\n const server = app.listen(config.port, () => {\n console.log(`Server listening on port ${config.port}`);\n });\n // ... some shutdown logic ...\n })\n .catch((err) => {\n console.error(\"Bootstrap failed. Bailing out.\", err);\n process.exit(1);\n });\n```", "```js\n// A much more robust bootstrap pattern\nclass Application {\n constructor() {\n this.config = null;\n this.db = null;\n this.server = null;\n }\n async start() {\n console.log(\"Starting application bootstrap...\");\n try {\n // Load config. Still sync, but keep it minimal.\n this.config = require(\"./config\");\n // Asynchronously initialize all I/O dependencies.\n // You can even run these in parallel with Promise.all if they're independent.\n console.log(\"Connecting to database...\");\n this.db = require(\"./database\");\n await this.db.connect(this.config.db, { retries: 5, delay: 1000 }); // Resilience! But not the preferred way. Check the note below\n console.log(\"Database connected.\");\n // Start the server, but only after dependencies are ready.\n // Use dependency injection! Pass the DB connection to the app.\n const app = require(\"./app\")(this.db);\n this.server = app.listen(this.config.port);\n // Wait for the 'listening' event. This is the true \"ready\" signal.\n await new Promise((resolve) => this.server.on(\"listening\", resolve));\n console.log(`Server is ready and listening on port ${this.config.port}.`);\n } catch (error) {\n console.error(\"FATAL: Application failed to start.\", error);\n // Try to clean up whatever might have started.\n await this.stop();\n process.exit(1);\n }\n }\n async stop() {\n // ... shutdown logic goes here ...\n }\n}\n // And in your main entry point:\nconst app = new Application();\napp.start();\n```", "```js\nconsole.log(`My PID is: ${process.pid}`);\n // This is the one you absolutely must handle in production.\nprocess.on(\"SIGTERM\", () => {\n console.log(\"Received SIGTERM. I should start shutting down now...\");\n // ... kick off your graceful shutdown logic ...\n process.exit(0);\n});\n // This is for local development (Ctrl+C).\nprocess.on(\"SIGINT\", () => {\n console.log(\"Received SIGINT. Cleaning up and getting out of here...\");\n // ... maybe a faster shutdown for dev ...\n});\n // A custom signal for debugging.\nprocess.on(\"SIGUSR2\", () => {\n console.log(\"Received SIGUSR2\\. Dumping some state...\");\n // ... print debug info ...\n});\n // Let's keep the process alive so we can send it signals.\nsetInterval(() => {}, 1000);\n```", "```js\n// A much safer pattern we may come up for signal handling\nlet isShuttingDown = false;\n function gracefulShutdown() {\n if (isShuttingDown) {\n // Already shutting down, don't start again.\n return;\n }\n isShuttingDown = true;\n console.log(\"Shutdown initiated. Draining requests...\");\n // 1\\. You stop taking new requests.\n server.close(async () => {\n console.log(\"Server closed.\");\n // 2\\. Now you close the database.\n await database.close();\n console.log(\"Database closed.\");\n // 3\\. All clean. You exit peacefully.\n process.exit(0);\n // or even better -> process.exitCode = 0\n });\n // A safety net. If you're still here in 10 seconds, something is wrong.\n setTimeout(() => {\n console.error(\"Graceful shutdown timed out. Forcing exit.\");\n process.exit(1);\n }, 10000);\n}\n process.on(\"SIGTERM\", gracefulShutdown);\nprocess.on(\"SIGINT\", gracefulShutdown);\n```", "```js\n// A stateful shutdown manager\nclass ShutdownManager {\n constructor(server, db) {\n this.server = server;\n this.db = db;\n this.isShuttingDown = false;\n this.SHUTDOWN_TIMEOUT_MS = 15_000;\n process.on(\"SIGTERM\", () => this.gracefulShutdown(\"SIGTERM\"));\n process.on(\"SIGINT\", () => this.gracefulShutdown(\"SIGINT\"));\n }\n async gracefulShutdown(signal) {\n if (this.isShuttingDown) return;\n this.isShuttingDown = true;\n console.log(`Received ${signal}. Starting graceful shutdown.`);\n // A timeout to prevent hanging forever.\n const timeout = setTimeout(() => {\n console.error(\"Shutdown timed out. Forcing exit.\");\n process.exit(1);\n }, this.SHUTDOWN_TIMEOUT_MS);\n try {\n // 1\\. Stop the server\n await new Promise((resolve, reject) => {\n this.server.close((err) => {\n if (err) return reject(err);\n console.log(\"HTTP server closed.\");\n resolve();\n });\n });\n // 2\\. In a real app, you'd wait for in-flight requests here.\n // 3\\. Close the database\n if (this.db) {\n await this.db.close();\n console.log(\"Database connection pool closed.\");\n }\n console.log(\"Graceful shutdown complete.\");\n clearTimeout(timeout);\n process.exit(0);\n } catch (error) {\n console.error(\"Error during graceful shutdown:\", error);\n clearTimeout(timeout);\n process.exit(1);\n }\n }\n}\n // How you'd use it:\n// new ShutdownManager(server, db);\n```", "```js\n// This process will never exit.\n// The setInterval creates a referenced handle that keeps it alive forever.\nsetInterval(() => {\n console.log(\"Still here...\");\n}, 1000);\n```", "```js\n// This process WILL exit immediately.\nconst timer = setInterval(() => {\n // This will never even run.\n console.log(\"You won't see me.\");\n}, 1000);\n timer.unref();\n```", "```js\nconst http = require(\"http\");\n const PORT = 8080;\n// We'll use a Set to keep track of all active socket connections.\nconst activeSockets = new Set();\n const server = http.createServer((req, res) => {\n console.log(\"ðŸ”Œ Client connected!\");\n // Keep the connection alive for 20 seconds before responding.\n // This gives us plenty of time to send the shutdown signal.\n setTimeout(() => {\n res.writeHead(200, { \"Content-Type\": \"text/plain\" });\n res.end(\"Hello from the slow server!\\n\");\n console.log(\"âœ… Response sent to client.\");\n }, 20000);\n});\n // When a new connection is established, add its socket to our Set.\nserver.on(\"connection\", (socket) => {\n activeSockets.add(socket);\n // When the socket closes, remove it from the Set.\n socket.on(\"close\", () => {\n activeSockets.delete(socket);\n });\n});\n server.listen(PORT, () => {\n console.log(`ðŸš€ Server started on port ${PORT} with PID: ${process.pid}`);\n console.log('   Run \"curl http://localhost:8080\" in another terminal to connect.');\n console.log(`   Then, run \"kill ${process.pid}\" to send the shutdown signal.`);\n});\n // Here's the graceful shutdown logic.\nfunction shutdown() {\n console.log(\"\\nðŸ›‘ SIGTERM signal received: closing HTTP server...\");\n // 1\\. Stop accepting new connections.\n server.close((err) => {\n if (err) {\n console.error(err);\n process.exit(1);\n }\n // 4\\. If server.close() callback fires, all connections were closed gracefully.\n console.log(\"âœ… All connections closed. Server shut down successfully.\");\n process.exit(0);\n });\n // 2\\. The server is no longer accepting connections, but existing ones might still be open.\n //    If connections don't close within 5 seconds, destroy them forcefully.\n setTimeout(() => {\n console.error(\"ðŸ’¥ Could not close connections in time, forcefully shutting down!\");\n // 3\\. Destroy all remaining active sockets.\n for (const socket of activeSockets) {\n socket.destroy();\n }\n }, 5000); // 5-second timeout\n}\n // Listen for the SIGTERM signal. `kill <PID>` sends this by default.\nprocess.on(\"SIGTERM\", shutdown);\n// Listen for Ctrl+C in the terminal.\nprocess.on(\"SIGINT\", shutdown);\n```", "```js\nnode server.js\n ðŸš€ Server started on port 8080 with PID: 54321 <-- REMEMBER THIS\n Run \"curl http://localhost:8080\" in another terminal to connect.\n Then, run \"kill 54321\" to send the shutdown signal.\n```", "```js\ncurl http://localhost:8080\n```", "```js\n# Replace 54321 with the actual PID of your server process\nkill 54321\n```", "```js\nðŸ›‘ SIGTERM signal received: closing HTTP server...\n```", "```js\nðŸ’¥ Could not close connections in time, forcefully shutting down!\n```", "```js\nconst net = require(\"net\");\n function printActiveHandles() {\n console.log(\"--- Active Handles ---\");\n process._getActiveHandles().forEach((handle) => {\n console.log(`Type: ${handle.constructor.name}`);\n });\n console.log(\"----------------------\");\n}\n console.log(\"Initial state:\");\nprintActiveHandles();\n const server = net.createServer(() => {}).listen(8080);\nconsole.log(\"\\nAfter creating server:\");\nprintActiveHandles();\n const timer = setInterval(() => {}, 5000);\nconsole.log(\"\\nAfter creating timer:\");\nprintActiveHandles();\n // Now let's clean up\nserver.close();\nclearInterval(timer);\nconsole.log(\"\\nAfter cleaning up:\");\n// Give the event loop a tick to process the close events\nsetTimeout(printActiveHandles, 100);\n```", "```js\nMemory (RSS)\n ^\n |\n |      +-------------------------> Phase 2: Operational Plateau\n |     /\n |    /  <-- Module Cache Growth\n |   /\n |  /   <-- V8 Heap Init\n +-------------------------------------> Time\n ^\n Process Start\n```", "```js\nasync function gracefulShutdown(error) {\n // ... do all your cleanup ...\n if (error) {\n console.error(\"Shutting down because of an error:\", error);\n process.exitCode = 1;\n } else {\n console.log(\"Shutdown completed successfully.\");\n process.exitCode = 0;\n }\n // Now, we just let the event loop empty. No need for process.exit()!\n // Node will exit on its own once all handles are closed.\n}\n```", "```js\n// Being a responsible parent process\nconst { spawn } = require(\"child_process\");\nconst children = [];\n const child = spawn(\"node\", [\"cool-lil-script.js\"]);\nchildren.push(child);\n process.on(\"SIGTERM\", () => {\n console.log(\"Parent got SIGTERM. Telling children to shut down...\");\n children.forEach((child) => {\n child.kill(\"SIGTERM\"); // Pass the signal on\n });\n // Let's just wait for all children to exit before the parent exits\n Promise.all(children.map((c) => new Promise((resolve) => c.on(\"close\", resolve)))).then(() => {\n console.log(\"All children are gone. Parent exiting.\");\n process.exit(0);\n });\n});\n```", "```js\nconst v8 = require(\"node:v8\");\n// Hook this up to a signal for on-demand snapshots in production.\nprocess.on(\"SIGUSR2\", () => {\n const filename = v8.getHeapSnapshot();\n console.log(`Heap snapshot written to ${filename}`);\n});\n```"]