["```js\n// This function gets called for thousands of incoming multi-megabyte chunks.\nfunction getSessionId(logBuffer) {\n // The session ID is always the first 16 bytes.\n const headerSlice = logBuffer.slice(0, 16);\n```", "```js\n// We'll store this slice in a map or cache to batch requests later.\n return headerSlice;\n}\n```", "```js\n// Imagine this is a 50MB buffer read from a network stream.\nconst massiveBuffer = Buffer.alloc(50 * 1024 * 1024);\nmassiveBuffer.write(\"USER_ID:12345|REST_OF_DATA...\");\n```", "```js\n// This creates a VIEW into the same memory. No copy!\nconst userIdSlice = massiveBuffer.slice(9, 14); // Extracts \"12345\"\nconsole.log(userIdSlice.toString()); // Output: 12345\n```", "```js\n// Let's modify the slice.\nuserIdSlice.write(\"99999\");\n```", "```js\n// Now let's look at the original buffer again.\nconsole.log(massiveBuffer.toString(\"utf-8\", 0, 20));\n// Output: USER_ID:99999|REST_O\n```", "```js\nconst mainBuffer = Buffer.from([1, 2, 3, 4, 5]);\nconst sub = mainBuffer.subarray(1, 3); // A view of bytes [2, 3]\n```", "```js\nsub[0] = 99; // Modify the view\nconsole.log(mainBuffer); // Output: <Buffer 01 63 03 04 05> (Note the 99 is 0x63)\n```", "```js\nconst largeBuffer = Buffer.alloc(10 * 1024 * 1024); // 10MB\nconst chunkSize = 1024; // 1KB\n```", "```js\n// --- The Zero-Copy View ---\nconsole.time(\"view creation\");\nconst view = largeBuffer.subarray(5000, 5000 + chunkSize);\nconsole.timeEnd(\"view creation\");\n```", "```js\n// --- The Full Copy ---\nconsole.time(\"copy creation\");\nconst copy = Buffer.alloc(chunkSize);\nlargeBuffer.copy(copy, 0, 5000, 5000 + chunkSize);\nconsole.timeEnd(\"copy creation\");\n```", "```js\nconst buf = Buffer.from(\"hello\");\nconsole.log(buf instanceof Uint8Array); // true\n```", "```js\n// A 12-byte ArrayBuffer, zero-filled for safety.\nconst messageArrayBuffer = new ArrayBuffer(12); //\n```", "```js\n// View 1: A Buffer to write a status string into the LAST 8 bytes.\nconst stringView = Buffer.from(messageArrayBuffer, 4, 8); //\nstringView.write(\"CONFIRMD\"); //\n // View 2: An Int32Array to read a 4-byte integer from the FIRST 4 bytes.\nconst intView = new Int32Array(messageArrayBuffer, 0, 1); //\nconsole.log(\"Initial integer value:\", intView[0]); // 0\n```", "```js\n// Here comes the bug. We accidentally create the string view at offset 0.\nconst buggyStringView = Buffer.from(messageArrayBuffer, 0, 8); //\n // We write a status update, thinking we're writing to the string part.\nbuggyStringView.write(\"CANCELED\"); //\n```", "```js\n// Now let's read the integer from our original, \"safe\" view.\nconsole.log(\"Corrupted integer value:\", intView[0]); // 1128353859\n```", "```js\nimport { readFileSync } from \"fs\";\nconst videoBuffer = readFileSync(\"large_video.mp4\"); // 1GB in memory\n```", "```js\n// The WRONG way for long-term storage\nconst metadataView = videoBuffer.slice(0, 1024);\n```", "```js\n// If we pass metadataView to another part of our app that holds onto it...\n// we are keeping the entire 1GB videoBuffer in memory just for that 1KB view.\n```", "```js\nimport { readFileSync } from \"fs\";\nconst videoBuffer = readFileSync(\"large_video.mp4\"); // 1GB in memory\n // The RIGHT way for long-term storage\nconst metadataCopy = Buffer.alloc(1024);\nvideoBuffer.copy(metadataCopy, 0, 0, 1024);\n```", "```js\n// Now, videoBuffer can be garbage collected as soon as it goes out of scope.\n// We've spent a few microseconds copying 1KB to save 1GB of memory.\n```", "```js\nconst source = Buffer.from(\"abcdefghijklmnopqrstuvwxyz\");\nconst target = Buffer.alloc(10);\n```", "```js\n// Copy the first 10 bytes from source into target.\nsource.copy(target, 0, 0, 10);\nconsole.log(target.toString()); // 'abcdefghij'\n```", "```js\n// Copy 'klmno' from the source into the middle of the target.\nsource.copy(target, 3, 10, 15); // target, targetStart, sourceStart, sourceEnd\nconsole.log(target.toString()); // 'abcklmnohij'\n```", "```js\nconst original = Buffer.from(\"This is the original buffer\");\n// Create a new buffer with a copy of the original's data.\nconst clone = Buffer.from(original);\n```", "```js\nclone.write(\"That\"); // Modify the clone\nconsole.log(original.toString()); // 'This is the original buffer'\nconsole.log(clone.toString()); // 'That is the original buffer'\n```", "```js\nfunction getSessionId(logBuffer) {\n // Instead of a view, we make an explicit copy.\n const sessionId = Buffer.alloc(16);\n logBuffer.copy(sessionId, 0, 0, 16);\n```", "```js\n// Now, storing 'sessionId' retains only 16 bytes, not the whole logBuffer.\n return sessionId.toString(\"utf-8\");\n}\n```", "```js\n// main.js\nimport { Worker } from \"worker_threads\";\n // Create a SharedArrayBuffer of 4 bytes.\nconst sab = new SharedArrayBuffer(4);\n```", "```js\n// Create a view over it on the main thread.\nconst mainThreadView = new Int32Array(sab);\nmainThreadView[0] = 123; // Initial value\n```", "```js\nconst worker = new Worker(\"./worker.js\");\nworker.postMessage({ sab });\n```", "```js\nworker.on(\"message\", () => {\n console.log(\"Main thread sees:\", mainThreadView[0]); // Output: 456\n});\n```", "```js\n// worker.js\nimport { parentPort } from \"worker_threads\";\n parentPort.on(\"message\", ({ sab }) => {\n const workerView = new Int32Array(sab);\n console.log(\"Worker sees initial value:\", workerView[0]); // Output: 123\n```", "```js\n// Modify the memory from the worker thread.\n workerView[0] = 456;\n parentPort.postMessage(\"done\");\n});\n```", "```js\n// Before: A view that retains the parent\nfunction createView(parent) {\n return parent.slice(0, 10);\n}\n```", "```js\n// After: A copy that lets the parent be freed\nfunction createCopy(parent) {\n return Buffer.from(parent.slice(0, 10));\n}\n```", "```js\n// Naive, copy-heavy parsing\nfunction parseMessageWithCopies(buffer) {\n const messageType = buffer.slice(0, 2).readUInt16BE();\n const messageLength = buffer.slice(2, 4).readUInt16BE();\n const flags = buffer.slice(4, 5).readUInt8();\n```", "```js\nconst sessionId = buffer.slice(5, 21).toString(\"utf-8\");\n const payload = buffer.slice(21); // This slice could be huge!\n return { messageType, messageLength, flags, sessionId, payload };\n}\n```", "```js\n// Efficient, zero-copy parsing\nfunction parseMessageWithViews(buffer) {\n const messageType = buffer.readUInt16BE(0); // Read directly from offset\n const messageLength = buffer.readUInt16BE(2);\n const flags = buffer.readUInt8(4);\n```", "```js\n// For the session ID and payload, we create views\n const sessionIdView = buffer.subarray(5, 21);\n const payloadView = buffer.subarray(21);\n return { messageType, messageLength, flags, sessionIdView, payloadView };\n}\n```", "```js\n// A 16-bit integer, 258, in Big-Endian format is [0x01, 0x02]\nconst networkBuffer = Buffer.from([0x01, 0x02]);\n // Using the Buffer method correctly:\nconsole.log(networkBuffer.readUInt16BE(0)); // 258, Correct!\n```", "```js\n// Using a TypedArray view on a little-endian machine:\nconst int16View = new Int16Array(networkBuffer.buffer, networkBuffer.byteOffset, 1);\nconsole.log(int16View[0]); // 513, Incorrect! (It read 0x0201)\n```", "```js\nconst arrayBuffer = new ArrayBuffer(4);\nconst dataView = new DataView(arrayBuffer);\n // Write a 32-bit integer in Big-Endian format\ndataView.setInt32(0, 123456789, false); // false for big-endian\n```", "```js\n// Read it back in Little-Endian format (will be wrong)\nconsole.log(dataView.getInt32(0, true)); // Some garbage number\n // Read it back correctly in Big-Endian format\nconsole.log(dataView.getInt32(0, false)); // 123456789\n```", "```js\n// Strategic view for temporary processing\nfunction processChunk(largeBuffer, offset, length) {\n const view = largeBuffer.subarray(offset, offset + length);\n const result = performComplexCalculation(view);\n```", "```js\n// Once the function returns, 'view' is eligible for GC.\n return result;\n}\n```", "```js\nconst longLivedCache = new Map();\n function processAndCache(dataBuffer) {\n const key = dataBuffer.subarray(0, 16); // Temporary view for the key\n const value = dataBuffer.subarray(16); // Temporary view for the value\n```", "```js\n// Before storing, we make a defensive copy.\n const storedValue = Buffer.from(value);\n // The key is converted to a string, which is implicitly a copy.\n longLivedCache.set(key.toString(\"hex\"), storedValue);\n}\n```", "```js\n/**\n * Parses a message header from a buffer.\n * WARNING: Returns a view into the original buffer. Do not store\n * the returned value long-term without creating a copy.\n * @param {Buffer} buffer The source buffer.\n * @returns {{id: Buffer, body: Buffer}} Views for id and body.\n */\nfunction parseHeader(buffer) {\n return {\n id: buffer.subarray(0, 8),\n body: buffer.subarray(8),\n };\n}\n```", "```js\n// Consumer of the function decides the memory strategy\nconst rawMessage = getMessageFromNetwork();\nconst { id, body } = parseHeader(rawMessage);\n // I need to use 'id' later, so I'll copy it.\nconst savedId = Buffer.from(id);\n// I'm just logging the body, so the temporary view is fine.\nlogBodyPreview(body);\n```", "```js\nconst largeBuffer = Buffer.alloc(50 * 1024 * 1024);\nconst views = [];\nfor (let i = 0; i < 100000; i++) {\n views.push(largeBuffer.slice(0, 10));\n}\n// At this point, take a heap snapshot.\n```", "```js\nconst largeBuffer = Buffer.alloc(50 * 1024 * 1024);\nconst copies = [];\nfor (let i = 0; i < 100000; i++) {\n // Creating a copy for each item\n copies.push(Buffer.from(largeBuffer.slice(0, 10)));\n}\n```", "```js\n// At this point, 'largeBuffer' can be garbage collected.\n```"]