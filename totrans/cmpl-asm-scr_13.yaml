- en: Chapter 11 Arrays and Heap Allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/11-arrays-and-heap-allocation](https://keleshev.com/compiling-to-assembly-from-scratch/11-arrays-and-heap-allocation)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Compiling to Assembly from Scratch](./#table-of-contents)'
  prefs: []
  type: TYPE_NORMAL
- en: by [Vladimir Keleshev](/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement simple arrays that can be created using literal notation: `[10,
    20, 30]`. We want to be able to extract elements by indexing into an array (`a[0]`),
    and to query for array’s length (`length(a)`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We would also like to implements bounds checking. In other words, if we ask
    for an index that is out of bounds, we don’t want a segmentation fault. In this
    case, in JavaScript, we expect `undefined` to be returned. In other languages,
    it could be `null` or an exception can be raised. We ignore the fact that `undefined`
    is nothing but a glorified `0` until later.
  prefs: []
  type: TYPE_NORMAL
- en: To cover this functionality, we need three new AST nodes, listed in the following
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of AST constructor signatures with examples
  prefs: []
  type: TYPE_NORMAL
- en: '| AST Constructor Signature | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayLiteral(args: Array<AST>)``ArrayLookup(array: AST, index: AST)``Length(array:
    AST)` | `[a1, a2, a3]``array[index]``length(array)` |'
  prefs: []
  type: TYPE_TB
- en: We have picked the name `ArrayLiteral` as opposed to `Array` in order not to
    clash with JavaScript built-in `Array` class that we already use a lot in the
    implementation. We decided to use a `length` function as opposed to a method (like
    in JavaScript) since we don’t have support for methods yet. However, we could
    have a special syntax for `x.length` just for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add two new tokens: `LEFT_BRACKET` and `RIGHT_BRACKET` standing for “`[`”
    and “`]`”. We also extend our grammar (and parser) with two new rules that we
    integrate into the `atom` rule.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways to lay out an array in memory. The simplest is the layout
    of a fixed-size array. Such array is represented as a pointer to a single stretch
    of memory containing array length and the elements. In the following figure, you
    can see such array layout for an example array `[10, 20, 30]`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Word-diagram of a fixed-sized array layout](../Images/9c7748769afe1802b02a494fc713f270.png)'
  prefs: []
  type: TYPE_IMG
- en: Word-diagram of a fixed-sized array layout
  prefs: []
  type: TYPE_NORMAL
- en: However, fixed-size arrays are, well, fixed-size. To implement growable or resizable
    arrays, we need a more sophisticated layout, like the one in the following figure.
    It stores array length and its *capacity*, as well as a pointer to the actual
    array of elements. The idea is to *over-allocate* array to some extent, such that
    the capacity is larger than the length. This way, elements could be added to the
    array without memory allocation (to some extent). When an array grows beyond capacity,
    a new span of memory is allocated for the elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Word-diagram of a resizable array layout](../Images/b757793282193066c44158e7efed93ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Word-diagram of a resizable array layout
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at code generation for fixed-size arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Array literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with code generation for array literals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `malloc` to allocate enough memory to store the length of the
    array and the elements. Since `malloc` takes the number of *bytes* to be allocated
    we need to multiply the length by four and add one more word to store the length
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, `malloc` returns a pointer to the freshly-allocated memory in `r0`. However,
    `r0` is a lousy register for this. As we emit code for each array element, `r0`
    will be clobbered. Thus, let’s use `r4` for this, which is a call-preserved register.
    But before we do that we need to save the previous value of `r4` on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we store array length in the first word of the allocated span of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After that, we emit code for each element and store it into the corresponding
    memory slot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We finish by returning the pointer in `r0` and restoring the call-preserved
    `r4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Array lookup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next is code generation for array lookup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we store the array pointer in `r1` and array index in `r0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, we load array length into `r2` and compare it with the array index to
    perform bounds checking. If array index is out of bounds, we do a conditional
    `mov` with `hs` suffix and return zero. If it succeeds, then we execute three
    instructions with `lo` suffix. In these three instructions, we convert array index
    into byte offset. We add 4 to skip over the length slot, and we do *logical shift
    left* or `lsl` to convert from word offset to byte offset. Shifting left by two
    is virtually the same as multiplying by 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using some of the ARM assembly language features that we have not
    covered in the book (like auto-increment and barrel shifter) we can shortern the
    same code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Which is an elegant way to do a bounds check and convert array index into a
    byte offset at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Array length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array length can be obtained by following the slot directly pointed by the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strings can be thought as arrays of bytes with a particular encoding. They can
    be implemented similarly to arrays, but using byte variants of the load and store
    instructions, `ldrb` and `strb`, instead of the regular `ldr` and `str`. However,
    when we see `a[i]` we need to know if it’s an array or a string to execute the
    right code. We either need to know the static type of the variable at compile
    time, or its dynamic type (or tag) by inspecting the data-structure at run time.
    But before we jump into that, we need to learn about one particular pattern that
    will help us maintain our code better.
  prefs: []
  type: TYPE_NORMAL
- en: '[Next: Chapter 12\. Visitor Pattern](./12-visitor-pattern)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
