["```js\nconst payloadBuffer = Buffer.allocUnsafe(estimatedSize);\n```", "```js\n// We allocate a 50MB buffer off-heap.\nconst bigBuffer = Buffer.alloc(50 * 1024 * 1024);\n // This will show where that memory is accounted for.\nconsole.log(process.memoryUsage());\n```", "```js\n{\n \"rss\": 39845888,\n \"heapTotal\": 5341184,\n \"heapUsed\": 3638280,\n \"external\": 53790468,\n \"arrayBuffers\": 52439315\n}\n```", "```js\n// Allocate a buffer the safe way.\nconst buf = Buffer.alloc(10);\n // You can be 100% certain of its contents.\nconsole.log(buf);\n// <Buffer 00 00 00 00 00 00 00 00 00 00>\n```", "```js\n// This runs for every incoming image chunk.\nfunction processChunk(chunk) {\n // We need a new buffer to apply a watermark.\n const workBuffer = Buffer.alloc(chunk.length);\n chunk.copy(workBuffer);\n // ... rest of the watermarking logic\n}\n```", "```js\n// Handler for /update-profile\nfunction handleUpdate(req, res) {\n const userSession = { userId: 123, role: \"admin\", token: \"...\" };\n const sessionBuffer = Buffer.from(JSON.stringify(userSession));\n // ... do something with the sessionBuffer ...\n}\n```", "```js\n// Handler for /generate-report\nfunction handleReport(req, res) {\n // Oops, developer tried to optimize.\n const reportBuffer = Buffer.allocUnsafe(1024);\n // They only write 500 bytes of report data.\n const reportData = generateReportData(); // returns 500 bytes\n reportData.copy(reportBuffer, 0);\n // The remaining 524 bytes are uninitialized!\n res.send(reportBuffer);\n}\n```", "```js\nconst fs = require(\"node:fs\");\n const fd = fs.openSync(\"script.js\", \"r\");\nconst size = fs.fstatSync(fd).size;\n // SAFE. We know fs.readSync will fill the buffer completely.\nconst buf = Buffer.allocUnsafe(size);\nconst bytesRead = fs.readSync(fd, buf, 0, size, 0);\n // We've now overwritten the entire uninitialized buffer with file data.\n```", "```js\nconst buf = Buffer.from(\"hello world\", \"utf8\");\n// <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n```", "```js\nconst buf1 = Buffer.from(\"learn_node\");\nconst buf2 = Buffer.from(buf1);\n buf2[0] = 0x6e; // 'n'\n console.log(buf1.toString()); // 'learn_node'\nconsole.log(buf2.toString()); // 'nearn_node'\n```", "```js\nconst buf = Buffer.from([0x48, 0x69, 0x21]); // 'Hi!'\n```", "```js\n// some-upload-library gives us an ArrayBuffer\nconst arrayBuffer = getUploadAsArrayBuffer();\n // You create a buffer to inspect the file header.\n// This might NOT be a copy! It could share memory with arrayBuffer.\nconst headerBuffer = Buffer.from(arrayBuffer, 0, 16);\n // Meanwhile, another asynchronous function gets the same ArrayBuffer.\n// This function sanitizes the data by overwriting certain byte patterns.\nsanitizeFileInMemory(arrayBuffer);\n```", "```js\n// This function runs while your other code is paused\nsanitizeFileInMemory(arrayBuffer);\n```", "```js\n// The safe way to handle an ArrayBuffer you don't own.\nconst arrayBuffer = getUploadAsArrayBuffer();\n // 1\\. Allocate a new, clean buffer that you control.\nconst headerBuffer = Buffer.alloc(16);\n// 2\\. Create a temporary view to copy from the source.\nconst sourceView = Buffer.from(arrayBuffer, 0, 16);\n// 3\\. Explicitly copy the data into your own buffer.\nsourceView.copy(headerBuffer);\n // Now, headerBuffer is completely decoupled from the original arrayBuffer.\nsanitizeFileInMemory(arrayBuffer); // This can't hurt you anymore.\n```", "```js\nconst { performance } = require(\"node:perf_hooks\");\n const ITERATIONS = 10000;\n /**\n * A helper function to run and time a specific buffer allocation method.\n * @param {string} name - The name of the benchmark to display.\n * @param {number} size - The size of the buffer to allocate.\n * @param {(size: number) => Buffer} allocFn - The allocation function to benchmark.\n */\nfunction benchmark(name, size, allocFn) {\n const start = performance.now();\n for (let i = 0; i < ITERATIONS; i++) {\n allocFn(size);\n }\n const end = performance.now();\n console.log(`- ${name}(${size}) x ${ITERATIONS}: ${(end - start).toFixed(2)}ms`);\n}\n console.log(\"--- Benchmarking Buffer Allocation ---\");\nconsole.log(`(Iterations: ${ITERATIONS}, Node.js: ${process.version})`);\n // --- Scenario 1: Small allocations that use the internal buffer pool ---\nconsole.log(\"\\nScenario 1: Small Allocations (100 bytes, pooled)\");\nbenchmark(\"Buffer.alloc\", 100, (s) => Buffer.alloc(s));\nbenchmark(\"Buffer.allocUnsafe\", 100, (s) => Buffer.allocUnsafe(s));\n // --- Scenario 2: Medium allocations just above the pool size ---\nconsole.log(\"\\nScenario 2: Medium Allocations (10KB, non-pooled)\");\nconst mediumSize = 10 * 1024;\nbenchmark(\"Buffer.alloc\", mediumSize, (s) => Buffer.alloc(s));\nbenchmark(\"Buffer.allocUnsafe\", mediumSize, (s) => Buffer.allocUnsafe(s));\n // --- Scenario 3: Large allocations where zero-filling is very expensive ---\nconsole.log(\"\\nScenario 3: Large Allocations (1MB, non-pooled)\");\nconst largeSize = 1024 * 1024;\nbenchmark(\"Buffer.alloc\", largeSize, (s) => Buffer.alloc(s));\nbenchmark(\"Buffer.allocUnsafe\", largeSize, (s) => Buffer.allocUnsafe(s));\n console.log(\"\\n--- Benchmarking Buffer.from ---\");\n const largeString = \"a\".repeat(largeSize);\nconst existingLargeBuffer = Buffer.alloc(largeSize);\n let start = performance.now();\nBuffer.from(largeString, \"utf8\");\nlet end = performance.now();\nconsole.log(`- Buffer.from(1MB string): ${(end - start).toFixed(2)}ms`);\n start = performance.now();\nBuffer.from(existingLargeBuffer);\nend = performance.now();\nconsole.log(`- Buffer.from(1MB buffer, copy): ${(end - start).toFixed(2)}ms`);\n```", "```js\n- Buffer.alloc(100) x 10000: 3.11ms\n- Buffer.allocUnsafe(100) x 10000: 1.23ms\n```", "```js\n- Buffer.alloc(10240) x 10000: 9.65ms\n- Buffer.allocUnsafe(10240) x 10000: 12.84ms\n```", "```js\n- Buffer.alloc(1048576) x 10000: 1151.15ms\n- Buffer.allocUnsafe(1048576) x 10000: 988.47ms\n```", "```js\n- Buffer.from(1MB string): 1.42ms\n- Buffer.from(1MB buffer, copy): 0.24ms\n```", "```js\n// Attacker sends: { \"data\": \"very...long...string\" }\nconst body = JSON.parse(req.body);\n// The server decodes and allocates based on attacker input.\nconst dataBuffer = Buffer.from(body.data, \"base64\");\n```", "```js\nlet internalBuffer = Buffer.alloc(0);\n function handleData(chunk) {\n internalBuffer = Buffer.concat([internalBuffer, chunk]);\n // ... try to parse messages from internalBuffer ...\n}\n```", "```js\n// BEFORE - Leaks uninitialized memory.\nconst unsafeBuf = new Buffer(1024);\n // AFTER - Safe, zero-filled buffer.\nconst safeBuf = Buffer.alloc(1024);\n```", "```js\n// BEFORE - Deprecated and less explicit.\nconst oldWay = new Buffer(\"hello\", \"utf8\");\n // AFTER - Modern, clear, and correct.\nconst newWay = Buffer.from(\"hello\", \"utf8\");\n```", "```js\n// A GOOD comment that explains the reason\n//\n// Using allocUnsafe here because profiling showed Buffer.alloc\n// was consuming 30% of CPU under load. See [link-to-profiler-results].\n// The buffer is immediately and completely overwritten by the contents\n// of the file read by fs.readSync, mitigating the security risk.\nconst buf = Buffer.allocUnsafe(fileSize);\nfs.readSync(fd, buf, 0, fileSize, 0);\n```"]