<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 10
Primitive Scalar Data Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chapter 10
Primitive Scalar Data Types</h1>
<blockquote>原文：<a href="https://keleshev.com/compiling-to-assembly-from-scratch/10-primitive-scalar-data-types">https://keleshev.com/compiling-to-assembly-from-scratch/10-primitive-scalar-data-types</a></blockquote>




<header>

<a href="./#table-of-contents">Compiling to Assembly from Scratch</a>
<br/>by <a href="/">Vladimir Keleshev</a>
</header>
<p> </p>
<p>When we say <em>scalar data types</em> we mean data types that fit into a single machine word, which is not a pointer but carries a value in itself. We already have one scalar data type for integer numbers.</p>
<p>Let’s introduce a boolean data type. First, we need an AST node for it:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"/><span class="kw">class</span> <span class="bu">Boolean</span> <span class="kw">implements</span> AST {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"/>  <span class="fu">constructor</span>(<span class="kw">public</span> <span class="dt">value</span><span class="op">:</span> boolean) {}</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"/></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"/>  <span class="fu">emit</span>(<span class="dt">env</span><span class="op">:</span> Environment) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"/>    <span class="cf">if</span> (<span class="kw">this</span><span class="op">.</span><span class="at">value</span>) {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"/>      <span class="fu">emit</span>(<span class="vs">`  mov r0, #1`</span>)<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"/>    } <span class="cf">else</span> {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"/>      <span class="fu">emit</span>(<span class="vs">`  mov r0, #0`</span>)<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"/>    }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"/>  }</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"/></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"/>  <span class="fu">equals</span>(<span class="dt">other</span><span class="op">:</span> AST)<span class="op">:</span> boolean {…}</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"/>}</span></code></pre></div>
<p>We emit it the same way as integers 1 and 0 (for <code class="sourceCode javascript"><span class="kw">true</span></code> and <code class="sourceCode javascript"><span class="kw">false</span></code>).</p>
<p>In the parser, we introduce new tokens for <code class="sourceCode javascript"><span class="kw">true</span></code> and <code class="sourceCode javascript"><span class="kw">false</span></code>, and compose them to create a <code class="sourceCode javascript">boolean</code> parser:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"/><span class="kw">let</span> TRUE <span class="op">=</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"/>  <span class="fu">token</span>(<span class="ss">/true</span><span class="sc">\b</span><span class="ss">/y</span>)<span class="op">.</span><span class="fu">map</span>((_) <span class="kw">=&gt;</span> <span class="kw">new</span> <span class="bu">Boolean</span>(<span class="kw">true</span>))<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"/><span class="kw">let</span> FALSE <span class="op">=</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"/>  <span class="fu">token</span>(<span class="ss">/false</span><span class="sc">\b</span><span class="ss">/y</span>)<span class="op">.</span><span class="fu">map</span>((_) <span class="kw">=&gt;</span> <span class="kw">new</span> <span class="bu">Boolean</span>(<span class="kw">false</span>))<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"/></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"/><span class="kw">let</span> boolean<span class="op">:</span> Parser<span class="op">&lt;</span>AST<span class="op">&gt;</span> <span class="op">=</span> TRUE<span class="op">.</span><span class="fu">or</span>(FALSE)</span></code></pre></div>
<p>We can extend the <code>atom</code> rule of the expression grammar by adding a <code>boolean</code> alternative. A good idea at this point is to introduce an additional <code>scalar</code> rule:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"/>scalar <span class="op">&lt;-</span> boolean <span class="op">/</span> ID <span class="op">/</span> NUMBER</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"/>atom <span class="op">&lt;-</span> call <span class="op">/</span> scalar <span class="op">/</span> LEFT_PAREN expression RIGHT_PAREN</span></code></pre></div>
<p>Then, after implementing this grammar as a parser we get booleans in our extended baseline language:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"/><span class="fu">assert</span>(<span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"/><span class="fu">assert</span>(<span class="op">!</span><span class="kw">false</span>)<span class="op">;</span></span></code></pre></div>
<p>However, they behave exactly like integers <code>1</code> and <code>0</code>, so <code class="sourceCode javascript"><span class="fu">assert</span>(<span class="kw">true</span> <span class="op">==</span> <span class="dv">1</span>)</code> will succeed. Under static typing, this comparison would be rejected by the compiler. Under dynamic typing, this would evaluate to <code class="sourceCode javascript"><span class="kw">false</span></code> at run-time.</p>
<hr/>
<p>Similarly, we can add other scalars, such as <code class="sourceCode javascript"><span class="kw">undefined</span></code>, <code class="sourceCode javascript"><span class="kw">null</span></code> (that compile to 0, like <code class="sourceCode javascript"><span class="kw">false</span></code>), or a character type, which could compile to the integer value of its ASCII code (though, JavaScript and TypeScript treat characters as strings).</p>
<table>
<caption>Summary of AST constructor signatures with examples</caption>
<colgroup>
<col style="width: 77%"/>
<col style="width: 22%"/>
</colgroup>
<thead>
<tr class="header">
<th>AST Constructor Signature</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code class="sourceCode javascript"><span class="bu">Boolean</span>(value<span class="op">:</span> boolean)</code></p>
<p><code>Undefined()</code></p>
<p><code>Null()</code></p></td>
<td><p><code class="sourceCode javascript"><span class="kw">true</span></code></p>
<p><code class="sourceCode javascript"><span class="kw">undefined</span></code></p>
<p><code class="sourceCode javascript"><span class="kw">null</span></code></p></td>
</tr>
</tbody>
</table>
<center><p><a href="./11-arrays-and-heap-allocation">Next: Chapter 11. Arrays and Heap Allocation</a></p></center>


  <hr class="fleuron"/>
    
</body>
</html>