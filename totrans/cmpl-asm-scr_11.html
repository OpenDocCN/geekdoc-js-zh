<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Chapter 9
Introduction to Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Chapter 9
Introduction to Part II</h1>
<blockquote>原文：<a href="https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2">https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2</a></blockquote>




<header>

<a href="./#table-of-contents">Compiling to Assembly from Scratch</a>
<br/>by <a href="/">Vladimir Keleshev</a>
</header>
<p> </p>
<p>Before extending the compiler, let’s discuss the language we have implemented so far.</p>
<p>Is our language memory-safe? What is memory safety, anyway? Simply speaking, a language is memory-safe if it does not allow you to write a program that causes a segmentation fault. The baseline language is memory-safe if we limit ourselves to calling functions that we have defined ourselves. However, our calling convention allows us to call arbitrary <code>libc</code> functions. You can find creative ways to call these functions that will lead to a segmentation fault (try <code>free(42)</code>). So, unless we do something about that, the baseline language is not memory-safe.</p>
<p>A way to fix that is to introduce a prefix for function labels. For example, a function <code>factorial</code> can be compiled with a label <code>ts$factorial:</code>, and a call to <code>factorial</code> can be compiled to a jump to <code>ts$factorial</code>. This way, you can only call functions that are defined in the source language, or that had explicit wrappers written in assembly. These wrappers can be auto-generated by the compiler and also handle type conversion, if necessary.</p>
<p>Is our language dynamically-typed? Or is it statically-typed? Both and neither! The baseline language supports only integer numbers. So, it could be thought of as a dynamically-typed language with only one data type, or as a statically-typed language with one static type. But we are soon to change this.</p>
<p>However, before we explore static and dynamic typing, we need to have more than one data type in our language. We will start by introducing booleans, undefined, and then arrays. First, we will introduce them in an unsafe/untyped manner, and then we will apply static/dynamic treatment to them.</p>
<center><a href="./10-primitive-scalar-data-types">Next: Chapter 10. Primitive Scalar Data Types</a></center>


  <hr class="fleuron"/>
    
</body>
</html>