- en: Chapter 10 Primitive Scalar Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/10-primitive-scalar-data-types](https://keleshev.com/compiling-to-assembly-from-scratch/10-primitive-scalar-data-types)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Compiling to Assembly from Scratch](./#table-of-contents)'
  prefs: []
  type: TYPE_NORMAL
- en: by [Vladimir Keleshev](/)
  prefs: []
  type: TYPE_NORMAL
- en: When we say *scalar data types* we mean data types that fit into a single machine
    word, which is not a pointer but carries a value in itself. We already have one
    scalar data type for integer numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s introduce a boolean data type. First, we need an AST node for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We emit it the same way as integers 1 and 0 (for `true` and `false`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the parser, we introduce new tokens for `true` and `false`, and compose
    them to create a `boolean` parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend the `atom` rule of the expression grammar by adding a `boolean`
    alternative. A good idea at this point is to introduce an additional `scalar`
    rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after implementing this grammar as a parser we get booleans in our extended
    baseline language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, they behave exactly like integers `1` and `0`, so `assert(true == 1)`
    will succeed. Under static typing, this comparison would be rejected by the compiler.
    Under dynamic typing, this would evaluate to `false` at run-time.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can add other scalars, such as `undefined`, `null` (that compile
    to 0, like `false`), or a character type, which could compile to the integer value
    of its ASCII code (though, JavaScript and TypeScript treat characters as strings).
  prefs: []
  type: TYPE_NORMAL
- en: Summary of AST constructor signatures with examples
  prefs: []
  type: TYPE_NORMAL
- en: '| AST Constructor Signature | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean(value: boolean)``Undefined()``Null()` | `true``undefined``null`
    |'
  prefs: []
  type: TYPE_TB
- en: '[Next: Chapter 11\. Arrays and Heap Allocation](./11-arrays-and-heap-allocation)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
