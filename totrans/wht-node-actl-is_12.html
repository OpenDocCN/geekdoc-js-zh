<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Writable Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Writable Streams</h1>
<blockquote>原文：<a href="https://www.thenodebook.com/streams/writable-streams">https://www.thenodebook.com/streams/writable-streams</a></blockquote><p class="text-base leading-relaxed mb-4 font-normal">You've seen how Readable streams work. You understand how they maintain internal buffers, how they transition between modes, and how they deliver data to consumers. Now we need to flip the perspective and look at the other side of the streaming equation: <strong class="font-bold">where does data go once it's been produced?</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">This is the domain of <strong class="font-bold">Writable streams</strong>. If Readable streams are about getting data out of a source, Writable streams are about getting data <em class="italic">into</em> a destination. Files on disk, network sockets, HTTP responses, compression algorithms, database connections - anywhere you're sending data chunk by chunk, you're working with some form of Writable stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Writing to a Writable stream isn't simple. It's not just "call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> with your data and move on." There's a critical feedback mechanism built into the API, and if you ignore it, you'll eventually see your process consume more memory than you expect. That feedback mechanism is <strong class="font-bold">backpressure</strong>, and understanding it is essential for production Node.js code that handles data streams.</p>
<p class="text-base leading-relaxed mb-4 font-normal">We're going to examine Writable streams from the ground up. First, we'll look at the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> class itself - what options it takes, what events it emits, and what the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> method's return value actually means. Then we'll dive deep into <strong class="font-bold">backpressure</strong>, exploring why it exists, how the internal buffering creates it, and what happens when you ignore it. After that, we'll implement custom Writable streams so you understand exactly what happens when data flows into a destination. Finally, we'll look at the correct patterns for writing to Writable streams in real applications.</p>
<h2 id="the-writable-stream-class" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The Writable Stream Class</h2>
<p class="text-base leading-relaxed mb-4 font-normal">When you create or receive a Writable stream, you're working with an object that extends <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">EventEmitter</code>, just like Readable. This should feel familiar by now. Streams in Node.js communicate through events because asynchronous I/O operations don't return values immediately - they signal completion or failure through events.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The Writable stream's job is straightforward in concept: accept chunks of data through its <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> method, and send those chunks to some underlying destination. The destination could be anything. A file descriptor managed by the operating system. A TCP socket. An in-memory array. The Writable stream doesn't care. It provides the interface and the buffering logic. The underlying destination is abstracted away into an internal method called <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>, which subclasses implement.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The configuration options control how the Writable stream behaves under load.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> option works similarly to Readable streams, but its meaning is slightly different. For a Writable stream, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> represents the <strong class="font-bold">maximum number of bytes</strong> (or objects in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>) that the stream will buffer internally before it starts signaling backpressure. The default is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">16384</code> bytes, the same 16KB default that Readable streams use.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> on a Writable stream, that data doesn't necessarily get written to the underlying destination immediately. Instead, it gets added to an internal buffer. If the destination is fast (like writing to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">/dev/null</code> or to a socket with plenty of bandwidth), the buffer stays mostly empty, and writes complete quickly. But if the destination is slow (like writing to a mechanical hard drive during heavy I/O load, or sending data over a congested network), the buffer starts to fill up.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When the buffered data reaches or exceeds <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> method <strong class="font-bold">returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code></strong>. This is the <strong class="font-bold">backpressure signal</strong>. The stream is saying "I'm buffering too much data. You need to slow down or stop writing until I tell you I'm ready again." If the application ignores this signal and keeps calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>, the internal buffer keeps growing, consuming more and more memory until the process runs out.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A Writable stream configuration looks like this:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Writable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> writable</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  highWaterMark: </span><span style="color:#79B8FF">8192</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// 8KB buffer threshold</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This creates a Writable stream that will signal backpressure when its internal buffer reaches 8KB. Note that the stream doesn't stop accepting writes when backpressure is signaled - it just returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> to indicate that you should pause.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> option, just like with Readable streams, changes the stream from dealing with bytes to dealing with arbitrary JavaScript objects. In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> represents the <strong class="font-bold">number of objects</strong> buffered, not the byte count. The default in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> is 16 objects.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> objectWritable</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  highWaterMark: </span><span style="color:#79B8FF">50</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// buffer up to 50 objects</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful when you're building data processing pipelines where each chunk represents a logical unit - a database row, a parsed log entry, a JSON document - rather than a chunk of bytes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">decodeStrings</code> option controls whether strings passed to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> are converted to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> objects before being passed to the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method. By default, this is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>. If you set it to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, strings are passed through as-is. Most of the time you won't need to touch this, but it matters if you're implementing a Writable stream that specifically wants to handle strings differently from buffers.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> stringWritable</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  decodeStrings: </span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// keep strings as strings</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">There's also a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">defaultEncoding</code> option that specifies the encoding used when strings are converted to buffers (if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">decodeStrings</code> is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>). The default is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'utf8'</code>, which is almost always what you want for text data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Finally, there's an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">emitClose</code> option that controls whether the stream emits a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> event when it's destroyed. The default is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>. Unless you have a specific reason to suppress the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> event, you should leave this alone.</p>
<p class="text-base leading-relaxed mb-4 font-normal">To use Writable streams effectively, you need to understand the events they emit and what they signal.</p>
<h2 id="events-on-writable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Events on Writable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Writable streams emit several events that signal state changes. Each event fires at a specific point in the stream's lifecycle.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The most critical event for managing backpressure is <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code></strong>. This event fires when the Writable stream's internal buffer was full (meaning <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> was returning <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>) and has now drained below the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> threshold. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event is your signal to resume writing.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The intended usage pattern:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> writeData</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">writable</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">data</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(data)) {</span></span>
<span class="line"><span style="color:#E1E4E8">    writable.</span><span style="color:#B392F0">once</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6A737D">      // Buffer drained, safe to write more</span></span>
<span class="line"><span style="color:#B392F0">      continueWriting</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> call returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, which means the buffer is full. So we attach a one-time <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event listener and pause our writing logic. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires, the buffer has space again, and we can resume.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you've never worked with streams before, or haven't read my earlier chapters on streams, this might feel strange. <strong class="font-bold">Blocking would defeat the entire purpose of Node.js's asynchronous I/O model.</strong> If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> blocked, your entire event loop would freeze while waiting for the write to complete. By using an event-based signal, the event loop stays free to handle other work while the stream's internal buffer drains.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code></strong> event fires when you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> on the stream and all buffered data has been successfully written to the underlying destination. This is the signal that the stream has completed its work. Note that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> fires <em class="italic">before</em> <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>. The stream has finished writing, but it might not have closed its underlying resources yet.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"finish"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"All data written"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"some data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// signals end of writes</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> method tells the stream "I'm not going to write any more data." After you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code>, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> will throw an error. The stream processes any remaining buffered data, and when everything has been written, it emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code></strong> event fires when the stream and its underlying resources have been closed. This happens <em class="italic">after</em> <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>. Not all streams emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>, and whether they do depends on the implementation of the underlying resource. For file streams, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> fires when the file descriptor is closed. For socket streams, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> fires when the socket is closed.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"close"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream closed"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code></strong> event fires when something goes wrong during writing. Maybe the file system is full. Maybe the network connection dropped. Maybe the underlying destination threw an error for some internal reason. When an error occurs, the stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> with the error object. Just like with Readable streams, if you don't have an error handler attached, the error will be thrown, potentially crashing your process.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Write error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe</code></strong> event fires when a Readable stream is piped into this Writable stream using the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> method. The event passes the source Readable stream as an argument. This is mainly useful for logging or debugging - knowing which Readable streams are currently piped into this Writable.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"pipe"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">src</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Something is piping into me"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Similarly, there's an <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">unpipe</code></strong> event that fires when a Readable stream is unpiped from this Writable.</p>
<p class="text-base leading-relaxed mb-4 font-normal">These events form the API surface for interacting with Writable streams. But to really understand how to use them correctly, we need to dive into the core concept that governs flow control in streaming systems: <strong class="font-bold">backpressure</strong>.</p>
<h2 id="understanding-backpressure" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Understanding Backpressure</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Backpressure is one of those concepts that sounds abstract until you see what happens without it. Consider a concrete scenario.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You're writing a program that reads a large file and writes it to another location. The <strong class="font-bold">naive approach</strong> looks like this:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.dat"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> writable</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.dat"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This code reads chunks from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">input.dat</code> and writes them to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">output.dat</code>. Simple, right? But there's a <strong class="font-bold">hidden problem</strong>. What if the Readable stream produces data faster than the Writable stream can consume it?</p>
<p class="text-base leading-relaxed mb-4 font-normal">The file system can read 100MB/sec from the source disk, but it can only write 50MB/sec to the destination disk. The Readable stream is producing 100MB/sec worth of chunks, and you're calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> for every chunk. The Writable stream can only process 50MB/sec, so the other 50MB/sec <strong class="font-bold">accumulates in its internal buffer</strong>. After one second, there's 50MB in the buffer. After two seconds, 100MB. After ten seconds, 500MB. The buffer keeps growing until your process runs out of memory and crashes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is the problem backpressure solves. The Writable stream signals to the producer "slow down, I can't keep up" by <strong class="font-bold">returning <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code></strong>. The producer is then supposed to pause until the Writable stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>, indicating that it's caught up and ready for more data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The correct version:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> canContinue</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">canContinue) {</span></span>
<span class="line"><span style="color:#E1E4E8">    readable.</span><span style="color:#B392F0">pause</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    writable.</span><span style="color:#B392F0">once</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      readable.</span><span style="color:#B392F0">resume</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, we pause the Readable stream. It stops emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events. The Writable stream's internal buffer drains as it writes data to the underlying destination. When the buffer drops below <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires, and we resume the Readable stream. <strong class="font-bold">Data flow is regulated by the consumer's capacity, not the producer's speed.</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern is so common that Node.js provides <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> as a built-in method that handles this exact flow control automatically. We'll cover <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> in depth in a later sub-chapter, but this illustrates that backpressure management is a fundamental part of the streaming model, important enough to warrant dedicated helper methods.</p>
<p class="text-base leading-relaxed mb-4 font-normal">What actually happens inside the Writable stream when you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>?</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable.write(chunk)</code>, the stream does several things. First, it checks if it's already writing data to the underlying destination. If it is, the chunk gets added to an internal buffer. If it's not currently writing, the chunk is passed immediately to the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method, which handles the actual I/O.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The internal buffer is a <strong class="font-bold">linked list of write requests</strong>. Each write request contains the chunk to write, the encoding (if it's a string), and a callback to invoke when the write completes. As you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> repeatedly, more write requests are appended to this list.</p>
<p class="text-base leading-relaxed mb-4 font-normal">After adding the chunk to the buffer (or passing it to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>), the stream calculates the current buffer size. For byte streams, this is the sum of all buffered chunk lengths. For <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> streams, it's the count of buffered chunks. If this total meets or exceeds <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. Otherwise, it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A simplified mental model:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> SimplifiedWritable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.highWaterMark </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> options.highWaterMark </span><span style="color:#F97583">||</span><span style="color:#79B8FF"> 16384</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.bufferSize </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.writing </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.bufferSize </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.writing) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_processBuffer</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.bufferSize </span><span style="color:#F97583">&lt;</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.highWaterMark;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _processBuffer</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#6A737D">    // writes chunks to destination</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This simplified model captures the core idea. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> method adds to a buffer and returns a boolean based on whether the buffer is below the threshold.</p>
<p class="text-base leading-relaxed mb-4 font-normal">What determines how fast the buffer drains? That's entirely up to the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method's implementation and the underlying destination's performance. If you're writing to a fast SSD, the buffer drains quickly. If you're writing to a slow network connection, the buffer drains slowly. The Writable stream itself doesn't control the drain rate - it only measures it and signals when the buffer is too full.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is why <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is a <strong class="font-bold">tuning parameter</strong>. If you set it too low, you'll get backpressure signals very frequently, even though the destination could handle more data. This can reduce throughput because you're constantly pausing and resuming. If you set it too high, you'll buffer a lot of data in memory, which might be fine if you have memory to spare, but can lead to problems if you're processing many streams simultaneously or running in a memory-constrained environment.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold">default 16KB</strong> is a reasonable middle ground for most use cases. It's large enough that you're not hitting backpressure constantly for typical write operations, but small enough that you're not buffering massive amounts of data if the destination is slow.</p>
<p class="text-base leading-relaxed mb-4 font-normal">What happens when you ignore backpressure? Suppose you write a million 1KB chunks to a Writable stream that's writing to a slow destination. You call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> a million times without checking the return value. Each call adds 1KB to the internal buffer. The buffer grows to 1GB. Your process now has <strong class="font-bold">1GB of data sitting in memory</strong> just for this one stream's buffer, waiting to be written.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you're processing multiple files simultaneously, or handling multiple concurrent HTTP requests, this memory usage multiplies. You might have 10GB or more of buffered write data across all your streams. At some point, the operating system's memory allocator can't keep up, and your process crashes with an <strong class="font-bold">out-of-memory error</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This happens frequently in production systems when developers don't respect backpressure. I've debugged memory issues in Node.js applications where the root cause was exactly this: streaming data from a fast source to a slow destination without handling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>'s return value.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The fix is simple but requires discipline. <strong class="font-bold">Check the return value. Pause the producer. Wait for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>. Resume.</strong> It's a pattern that becomes second nature once you've internalized it.</p>
<h2 id="internal-buffering-in-writable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Internal Buffering in Writable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">The internal buffer's structure and management determines how streams handle memory usage and performance. This will help you reason about memory usage and performance in your streaming code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The Writable stream maintains a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writableState</code> object that tracks its internal state. This object is <strong class="font-bold">private</strong> (indicated by the leading underscore), but it's useful to understand what's in there because it affects the stream's behavior.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One key property is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">bufferedRequestCount</code>, which is exactly what it sounds like: the number of write requests currently buffered. Each time you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>, if the stream is already busy writing, the new chunk becomes a buffered request, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">bufferedRequestCount</code> increments. As chunks are written to the destination, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">bufferedRequestCount</code> decrements.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another property is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">length</code>, which tracks the total size of buffered data. For byte streams, this is the sum of all buffered chunk lengths. For <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> streams, this is the count of buffered objects. This is the value that gets compared to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> to determine whether <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> should return <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's also a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writing</code> flag that indicates whether the stream is currently in the middle of a write operation. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is called, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writing</code> is set to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>. When the callback passed to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is invoked (indicating the write completed), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writing</code> is set to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. While <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writing</code> is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>, new chunks get buffered rather than being passed directly to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The buffer itself (in older Node.js versions) was a <strong class="font-bold">linked list</strong> of write request objects. In newer versions, it's implemented as a more efficient data structure, but conceptually it's still a <strong class="font-bold">queue: first-in, first-out</strong>. The oldest buffered chunk is written first, then the next oldest, and so on.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> is called, the stream checks the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writing</code> flag. If it's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, the chunk is passed immediately to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> along with a callback. The callback is invoked by the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> implementation when the write operation completes (or errors). When that callback runs, the stream checks if there are more buffered chunks. If there are, it pulls the next chunk from the buffer and calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> again. This continues until the buffer is empty.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If at any point during this process the buffer size drops below <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, and the buffer size was previously at or above <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, the stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>. This is the signal that <strong class="font-bold">backpressure is relieved</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A more detailed mental model:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> DetailedWritable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.highWaterMark </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> options.highWaterMark </span><span style="color:#F97583">||</span><span style="color:#79B8FF"> 16384</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.writing </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.needDrain </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> +=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> ret</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &lt;</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.highWaterMark;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ret) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.needDrain </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.writing) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_doWrite</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> ret;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _doWrite</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.needDrain) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.needDrain </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">emit</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">shift</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.writing </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_write</span><span style="color:#E1E4E8">(chunk, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.writing </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">emit</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_doWrite</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is still simplified, but it shows the core flow. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> method adds chunks to a buffer and returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> if the buffer exceeds <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_doWrite()</code> method processes the buffer one chunk at a time, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> and waiting for its callback before moving to the next chunk. When the buffer is empty and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">needDrain</code> is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> is emitted.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The buffer is a <strong class="font-bold">queue between the producer</strong> (the code calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>) and the underlying destination (the code in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>). The producer can add to the queue as fast as it wants, but if the destination is slow, the queue grows. The backpressure mechanism (<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returning <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event) is the feedback loop that tells the producer to slow down when the queue gets too large.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The stream doesn't <em class="italic">enforce</em> backpressure - it just <strong class="font-bold">signals</strong> it. If you keep calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> even when it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, the stream will keep buffering. It won't throw an error. It won't drop data. It will just keep growing the buffer until memory runs out. This design choice is intentional - it gives applications flexibility to decide how to handle backpressure. Some applications might have hard real-time constraints and choose to drop data rather than pause. Others might choose to buffer more aggressively because they have memory to spare. But the <strong class="font-bold">default, correct behavior is to pause when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code></strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The memory used by the buffer is in addition to the memory used by the chunks themselves. Each write request is an object that holds the chunk, encoding, callback, and other metadata. For very large numbers of small writes, the overhead of these objects can be non-trivial. This is one reason why batching small writes into larger chunks can improve performance - fewer write requests means less object overhead.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> methods are specifically designed to optimize buffering for scenarios where you're making many small writes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable.cork()</code>, the stream enters a <strong class="font-bold">corked state</strong>. In this state, all writes are buffered, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is not called at all. The idea is that you're about to make a bunch of small writes, and you want to buffer them all and then write them in one batch.</p>
<p class="text-base leading-relaxed mb-4 font-normal">After you've made all your writes, you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable.uncork()</code>. This flushes the buffered writes. If the stream's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> method is implemented (which allows writing multiple chunks at once), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> will call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> with all the buffered chunks. Otherwise, it calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> repeatedly for each chunk.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's an example:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">cork</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"line 1</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"line 2</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"line 3</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">uncork</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Without <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code>, each <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> call might immediately call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>, resulting in three separate I/O operations. With <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code>, all three writes are buffered, and when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> is called, they're written together (if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> is implemented) or sequentially without any pause in between.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This can significantly improve performance when you're making many small writes, because it reduces the number of system calls. Writing three 8-byte chunks in three separate calls to the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> syscall is slower than writing one 24-byte chunk in a single call.</p>
<p class="text-base leading-relaxed mb-4 font-normal">However, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> are not something you need to think about in most application code. They're most useful when you're implementing a library or protocol handler that's generating many small chunks. For typical application code, just calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> directly is fine.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One important note: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> can be called multiple times, and each call increments an internal counter. You need to call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> the same number of times to actually flush the buffer. This allows <strong class="font-bold">nested corking</strong> in complex code paths.</p>
<h2 id="implementing-custom-writable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Implementing Custom Writable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Understanding how to use Writable streams is one thing. Understanding how they work internally is another. The <strong class="font-bold">best way to solidify that understanding is to implement your own Writable stream</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The pattern is straightforward. You extend the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Writable</code> class and implement the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method. This method receives <strong class="font-bold">three arguments</strong>: the chunk to write, the encoding (if it's a string), and a callback to invoke when the write completes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's the simplest possible custom Writable stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Writable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> NullWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// write completes immediately</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is essentially <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">/dev/null</code>. It accepts data and does nothing with it. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method just calls the callback immediately, signaling that the write succeeded.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A Writable stream that writes to an array:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> ArrayWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.data </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.data.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now chunks are accumulated in the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> array. Each write just pushes the chunk and calls the callback.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But what if the write operation is <strong class="font-bold">asynchronous</strong>? What if we're writing to a database, or sending data over a network? This is where the callback becomes important. <strong class="font-bold">The callback must be invoked after the asynchronous operation completes.</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">A simulated async write:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> AsyncWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Wrote:"</span><span style="color:#E1E4E8">, chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">());</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">setTimeout</code> simulates an asynchronous I/O operation that takes 100ms. The callback is invoked inside the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">setTimeout</code> callback, signaling that the write has completed. Until <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">callback()</code> is called, the stream won't process the next buffered chunk. <strong class="font-bold">This is how the stream paces itself to match the destination's speed.</strong></p>
<p class="text-base leading-relaxed mb-4 font-normal">If an error occurs during writing, you pass the error to the callback:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> ErrorWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">includes</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"bad"</span><span style="color:#E1E4E8">)) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Invalid data"</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you pass an error to the callback, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event. Any buffered writes are discarded, and the stream enters an <strong class="font-bold">errored state</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> method is an <strong class="font-bold">optional optimization</strong> you can implement to handle batch writes more efficiently. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> is implemented, and multiple chunks are buffered (or the stream is corked), the stream will call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> with an array of all buffered chunks instead of calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> repeatedly.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> signature is slightly different:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> BatchWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _writev</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunks</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> allData</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">concat</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#E1E4E8">      chunks.</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">c</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> c.chunk)</span></span>
<span class="line"><span style="color:#E1E4E8">    );</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Batch write:"</span><span style="color:#E1E4E8">, allData.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">, </span><span style="color:#9ECBFF">"bytes"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">chunks</code> parameter is an array of objects, each with a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">chunk</code> property (the data) and an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">encoding</code> property. You can process them all at once and call the callback when done.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Implementing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> is optional. If you don't implement it, the stream will call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> once for each buffered chunk. But if your underlying destination has an API for batch writes (like SQL <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">INSERT</code> with multiple rows, or a network protocol that supports bundling multiple messages), implementing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> can <strong class="font-bold">significantly improve performance</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> hook is called when the stream is ending (after <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> is called and all buffered writes have been processed), but <em class="italic">before</em> the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> event is emitted. It's useful for cleanup or final actions, like closing a file descriptor or flushing a buffer.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> CleanupWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#6A737D">    // write data</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _final</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Finalizing..."</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#6A737D">    // perform cleanup</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> callback must be invoked to signal that finalization is complete. After it's called, the stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A more realistic custom Writable stream that writes to a log file with a custom format:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Writable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { open, write </span><span style="color:#F97583">as</span><span style="color:#E1E4E8"> fsWrite } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> LogWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">filename</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.filename </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> filename;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.fd </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_open</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _open</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    open</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.filename, </span><span style="color:#9ECBFF">"a"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">fd</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.fd </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fd;</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">emit</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"open"</span><span style="color:#E1E4E8">, fd);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">once</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"open"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_write</span><span style="color:#E1E4E8">(chunk, encoding, callback);</span></span>
<span class="line"><span style="color:#E1E4E8">      });</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> =</span><span style="color:#9ECBFF"> `[${</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Date</span><span style="color:#9ECBFF">().</span><span style="color:#B392F0">toISOString</span><span style="color:#9ECBFF">()</span><span style="color:#9ECBFF">}] ${</span><span style="color:#E1E4E8">chunk</span><span style="color:#9ECBFF">}</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">`</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">    fsWrite</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd, line, callback);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _final</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd) {</span></span>
<span class="line"><span style="color:#B392F0">      require</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"fs"</span><span style="color:#E1E4E8">).</span><span style="color:#B392F0">close</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd, callback);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This stream opens a file for appending in the constructor. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is called, it formats the chunk with a timestamp and writes it to the file using the low-level <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fs.write()</code> function. In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code>, it closes the file descriptor.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Note how <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> handles the case where the file isn't open yet by waiting for the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">open</code> event. This is a <strong class="font-bold">common pattern</strong> when the underlying resource initialization is asynchronous.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Implementing custom Writable streams like this gives you <strong class="font-bold">complete control</strong> over where data goes and how it's processed. You can write to databases, to external APIs, to compression streams, to anything. The Writable interface is flexible enough to accommodate any destination.</p>
<h2 id="writing-to-writable-streams-correctly" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Writing to Writable Streams Correctly</h2>
<p class="text-base leading-relaxed mb-4 font-normal">With an understanding of how Writable streams work internally, here are the practical patterns for writing to them correctly in application code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold">most important rule</strong>: always check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>'s return value. If it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, pause your data source and wait for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> before continuing.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The pattern in the context of reading from one stream and writing to another:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream, createWriteStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> reader</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"input.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> writer</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createWriteStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"output.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">reader.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> ok</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> writer.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ok) {</span></span>
<span class="line"><span style="color:#E1E4E8">    reader.</span><span style="color:#B392F0">pause</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  reader.</span><span style="color:#B392F0">resume</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">reader.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  writer.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">We call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> and capture the return value. If it's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, we pause the reader. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires on the writer, we resume the reader. This ensures that the writer's buffer never grows unbounded.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you're done writing, you must call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> to signal that no more data will be written. You can optionally pass a final chunk to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"final chunk"</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is equivalent to:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"final chunk"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">After <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> is called, the stream processes any remaining buffered writes, calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> if it's implemented, and then emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>. At that point, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> will throw an error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The error is specifically a <strong class="font-bold">write-after-end error</strong>, and it looks like this:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"more data"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// throws ERR_STREAM_WRITE_AFTER_END</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is a <strong class="font-bold">common mistake</strong> when you have asynchronous code that writes to a stream and another part of the code calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> before the async writes complete. You need to ensure that all writes are finished before calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In application code, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> have specific uses. If you're making many small writes in quick succession, you can use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> to buffer them and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> to flush:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">cork</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;</span><span style="color:#79B8FF"> 1000</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  writer.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`line ${</span><span style="color:#E1E4E8">i</span><span style="color:#9ECBFF">}</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#E1E4E8">writer.</span><span style="color:#B392F0">uncork</span><span style="color:#E1E4E8">();</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">But in practice, you rarely need to do this manually. If you're using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, backpressure is handled automatically. If you're writing to a stream directly, the buffering in the stream already provides some batching. <strong class="font-bold">Cork is mainly useful in library code</strong> that's generating structured output, like an HTTP/2 frame encoder or a database protocol handler.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One scenario where manual backpressure handling is unavoidable is when you're generating data from a <strong class="font-bold">non-stream source</strong>. For example, iterating over an array and writing each element:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> writeArray</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">writable</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">array</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> item</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> array) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> ok</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(item);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ok) {</span></span>
<span class="line"><span style="color:#F97583">      await</span><span style="color:#F97583"> new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">        writable.</span><span style="color:#B392F0">once</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">, resolve);</span></span>
<span class="line"><span style="color:#E1E4E8">      });</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This function writes each array element to the stream. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, it waits for the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event before continuing. This ensures that the stream's buffer doesn't overflow, even if the array is huge and the stream is slow.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another pattern is using Writable streams with async iteration. Node.js provides a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.Writable.toWeb()</code> method that creates a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">WritableStream</code> (from the WHATWG Streams standard), which can be used with async iteration. But that's a more advanced topic we'll cover in the context of modern web APIs.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Writable streams have built-in flow control through the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> return value and the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event. <strong class="font-bold">Respecting this flow control is not optional.</strong> It's the difference between code that works under light load but crashes under heavy load, and code that works reliably in production.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A complete example that ties everything together: We'll write a program that reads a large CSV file, parses each line, transforms the data, and writes it to a database. We'll use Writable streams and handle backpressure correctly.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { createReadStream } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Writable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">db</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.db </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> db;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#B392F0"> _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">row</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.db.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(row);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> importCSV</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">filename</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">db</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> reader</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> createReadStream</span><span style="color:#E1E4E8">(filename);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> parser</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> parseCSV</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// hypothetical CSV parser</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> writer</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> DatabaseWriter</span><span style="color:#E1E4E8">(db);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(reader, parser, writer);</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Import complete"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This example uses <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, which handles backpressure automatically. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">DatabaseWriter</code> is a custom Writable that writes each row to a database. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">async</code>, which is allowed - you can use async functions or return promises from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>, and Node.js will wait for them to resolve before processing the next chunk.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Notice that we don't manually check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> return values or listen for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>. That's because <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> does it for us. This is the <strong class="font-bold">recommended pattern for most streaming code</strong>: use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>, let Node.js handle backpressure, and focus on the transformation logic.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But when you can't use <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> - when you're dealing with multiple sources or destinations, or when you're integrating with non-stream APIs - you need to handle backpressure manually. And when you do, the pattern is always the same: <strong class="font-bold">check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>, pause when it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, resume when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires</strong>.</p>
<h2 id="the-mechanics-of-buffer-overflow" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The Mechanics of Buffer Overflow</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Tracing through the exact sequence of events that leads to memory exhaustion helps you understand why the backpressure prevention mechanism exists.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Consider a scenario where you're reading from a fast source and writing to a slow destination. You're copying a 1GB file from an SSD to a network share over a congested link. The SSD can deliver data at 500 MB/sec. The network can only send at 10 MB/sec. That's a <strong class="font-bold">50x speed differential</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Your code looks like this:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk); </span><span style="color:#6A737D">// ignoring return value</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The Readable stream starts delivering 64KB chunks as fast as the SSD can provide them. Every <strong class="font-bold">128 microseconds</strong>, a new chunk arrives (64KB at 500 MB/sec). Each chunk is passed to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>. The Writable stream attempts to send each chunk over the network, but the network can only handle about one 64KB chunk every <strong class="font-bold">6.4 milliseconds</strong> (64KB at 10 MB/sec).</p>
<p class="text-base leading-relaxed mb-4 font-normal">In the first 6.4 milliseconds, the Readable stream delivers 50 chunks. The Writable stream sends 1 chunk. The other 49 chunks are buffered. That's 3.1MB of buffered data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">After 64 milliseconds, the Readable stream has delivered 500 chunks. The Writable stream has sent 10 chunks. There are 490 chunks buffered. That's 30.6MB.</p>
<p class="text-base leading-relaxed mb-4 font-normal">After one second, there's 490MB buffered. After two seconds, 980MB. At some point, the process runs out of heap space and crashes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This isn't a gradual slowdown. <strong class="font-bold">The process runs fine until it suddenly dies.</strong> The event loop is responsive right up until the moment the allocator fails to allocate memory for the next buffer, and V8 throws an out-of-memory exception.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In contrast, code that <strong class="font-bold">respects backpressure</strong>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> ok</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ok) {</span></span>
<span class="line"><span style="color:#E1E4E8">    readable.</span><span style="color:#B392F0">pause</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"drain"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  readable.</span><span style="color:#B392F0">resume</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When the buffer reaches <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> (16KB by default), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. The Readable stream is paused. It stops delivering chunks. The Writable stream continues sending buffered chunks over the network. When the buffer drops below <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires, and the Readable stream resumes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The buffer size oscillates between 0 and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. It never grows unbounded. Memory usage is bounded by <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> plus the size of a single chunk from the Readable stream. For default settings, that's about <strong class="font-bold">32KB total for buffering</strong>, regardless of how large the file is or how slow the destination is.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is the <strong class="font-bold">power of backpressure</strong>. It decouples the speed of the producer from the speed of the consumer while maintaining bounded memory usage.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But there's a subtlety here that's worth exploring. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> <strong class="font-bold">isn't a hard limit</strong>. The buffer can exceed <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. What <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> controls is <em class="italic">when</em> <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> with a 10MB chunk, and the buffer is empty, the chunk gets buffered, and the buffer size is now 10MB, far exceeding the 16KB <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. But <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> will return <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> on this call, signaling backpressure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This means that the actual peak memory usage is <strong class="font-bold"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> plus the size of the largest single chunk</strong>. If you're streaming with 64KB chunks and a 16KB <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, peak buffering is around 80KB. If you're streaming with 1MB chunks, peak buffering is around 1MB. This is why <strong class="font-bold">choosing appropriate chunk sizes matters</strong>, especially in memory-constrained environments.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's another scenario where ignoring backpressure causes problems: <strong class="font-bold">writing from multiple producers to a single Writable stream</strong>. Suppose you have 10 concurrent operations all writing to the same log file stream. If none of them respect backpressure, and each is producing data as fast as possible, the buffer grows to accommodate all 10 streams' output. What might be 16KB of buffering for one stream becomes 160KB or more for 10 streams. Multiply this across hundreds or thousands of concurrent operations in a busy server, and you have a memory leak.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The solution is the same: respect backpressure. Each producer checks <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>'s return value and pauses when it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. The Writable stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> once, and all paused producers resume. The buffer stays bounded.</p>
<h2 id="error-handling-in-writable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Error Handling in Writable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've talked about the happy path - data flows, backpressure is respected, the stream ends cleanly. But what happens when things go wrong?</p>
<p class="text-base leading-relaxed mb-4 font-normal">Errors in Writable streams can occur at several points. The underlying destination might fail - the disk might fill up, the network might disconnect, a permission error might occur. The data itself might be invalid for the destination. The stream might be in an invalid state when an operation is attempted.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When an error occurs in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code>, or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code>, the error is passed to the callback. The stream handles this by emitting an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event. After an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event is emitted, the stream enters an <strong class="font-bold">errored state</strong>. Any buffered writes are discarded, and further writes will throw an error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This looks like:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> FailingWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Write failed"</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> writable</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> FailingWritable</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream error:"</span><span style="color:#E1E4E8">, err.message);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"test"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// triggers error event</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"more"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// throws ERR_STREAM_DESTROYED</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The first <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> triggers the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event. After that, the stream is destroyed, and subsequent writes throw an exception.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you don't attach an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event listener, the error is thrown, potentially crashing your process. <strong class="font-bold">You must always attach error handlers to streams</strong>, especially in production code. An unhandled stream error is one of the most common causes of unexpected Node.js process crashes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's a pattern for handling errors gracefully in stream pipelines, which we'll cover in depth in the sub-chapter on pipelines. But for now, understand that <strong class="font-bold">error handling is not optional</strong>. Every Writable stream you create or receive must have an error handler.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another error scenario is calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> after calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code>. This is a <strong class="font-bold">programming error</strong>, not a runtime error. It indicates a bug in your code's logic. When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code>, you're telling the stream "no more writes." If you then call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>, the stream throws an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">ERR_STREAM_WRITE_AFTER_END</code> error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This often happens in asynchronous code where multiple code paths are writing to the same stream, and one path calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> while another still has writes pending. The fix is to coordinate your code so that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> is only called after all writes are complete. This might involve using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Promise.all()</code> to wait for all async writes, or using a counter to track pending writes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">An example of the problem:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> buggyWrite</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">writable</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">  setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">    writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"async write"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// called before async write</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">And the fix:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> correctWrite</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">writable</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#F97583"> new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">    setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"async write"</span><span style="color:#E1E4E8">, resolve);</span></span>
<span class="line"><span style="color:#E1E4E8">    }, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">end</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> is only called after the async write completes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's also the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> method, which forcefully closes the stream and optionally emits an error. Calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable.destroy(err)</code> immediately puts the stream in a destroyed state, discards buffered writes, and emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> (if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">err</code> is provided) followed by <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> Error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Aborted"</span><span style="color:#E1E4E8">));</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful when you need to cancel an in-progress stream operation, like when a user cancels a file upload. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> doesn't wait for buffered writes to complete - it's an <strong class="font-bold">immediate, forceful shutdown</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroyed</code> property tells you if a stream has been destroyed:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">writable.destroyed) {</span></span>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Using this check can prevent errors in code that might attempt to write to a stream that's already been destroyed.</p>
<h2 id="properties-and-introspection" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Properties and Introspection</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Writable streams expose several properties that let you introspect their current state. These are useful for debugging, monitoring, and making runtime decisions about flow control.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableLength</code> property tells you how many bytes (or objects in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>) are currently buffered:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(writable.writableLength);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If this value is approaching <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableHighWaterMark</code>, you know backpressure is about to be signaled. You might use this to implement soft rate limiting or to provide feedback to users about upload progress.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableHighWaterMark</code> property exposes the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> value:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(writable.writableHighWaterMark);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is the threshold that determines when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. It's set during stream construction and generally doesn't change, but you can read it to understand the stream's buffering behavior.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable</code> property is a boolean indicating whether it's safe to call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (writable.writable) {</span></span>
<span class="line"><span style="color:#E1E4E8">  writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> if the stream has been destroyed or ended. It's a quick check before attempting a write.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableEnded</code> property tells you if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> has been called:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(writable.writableEnded);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code> after <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end()</code> is called, even if the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> event hasn't fired yet. It indicates that no more writes will be accepted.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableFinished</code> property tells you if the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> event has been emitted:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(writable.writableFinished);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code> after all writes have been processed and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> has fired. It indicates that the stream has completed its work.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableCorked</code> property tells you how many times <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> has been called without a corresponding <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">cork</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">cork</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(writable.writableCorked); </span><span style="color:#6A737D">// 2</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is mainly useful for debugging <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code>/<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> usage.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableObjectMode</code> property tells you if the stream is in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(writable.writableObjectMode);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is set during construction and doesn't change. It's useful when writing generic code that handles both byte streams and object streams.</p>
<p class="text-base leading-relaxed mb-4 font-normal">These properties give you visibility into the stream's internal state. In most application code, you won't need them. But when debugging stream issues, or when implementing generic stream utilities, they're <strong class="font-bold">invaluable</strong>.</p>
<h2 id="deep-dive-the-write-request-queue" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Deep Dive: The Write Request Queue</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Understanding how write requests are managed internally in the queue structure helps you reason about performance and memory usage.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>, the chunk and its associated metadata are wrapped in a <strong class="font-bold">write request object</strong>. This object contains:</p>
<ul class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:disc;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item">The chunk itself (<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code>, string, or object)</li>
<li class="ml-2 font-normal" style="display:list-item">The encoding (if it's a string)</li>
<li class="ml-2 font-normal" style="display:list-item">The callback to invoke when the write completes (optional)</li>
<li class="ml-2 font-normal" style="display:list-item">A reference to the next write request in the queue</li>
</ul>
<p class="text-base leading-relaxed mb-4 font-normal">These write request objects form a <strong class="font-bold">linked list</strong>. The head of the list is the write request currently being processed. The tail is the most recently added request. When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>, a new write request is appended to the tail.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> completes (when its callback is invoked), the current write request is removed from the head of the list, and the next request becomes the new head. If there's a next request, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is called again with that request's chunk. If there's no next request, the queue is empty, and the stream waits for more <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> calls.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This queue structure has implications for memory usage. Each write request object has <strong class="font-bold">overhead</strong> - pointers, metadata, closures. For small writes, this overhead can be significant relative to the chunk size. If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> a million times with 1-byte chunks, you have a million write request objects, each with 50-100 bytes of overhead. That's 50-100 MB of memory just for the queue structure, even though the actual data is only 1 MB.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is why <strong class="font-bold">batching small writes improves performance</strong>. Instead of a million 1-byte writes, do 1000 1KB writes. The data is the same, but the queue overhead is 1/1000th.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">uncork()</code> methods interact with this queue. When you cork a stream, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> still creates write request objects and appends them to the queue, but <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is not called. The requests accumulate. When you uncork, if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> is implemented, all accumulated requests are passed to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> in a single call. Otherwise, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> is called repeatedly for each request.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A corked write sequence:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">cork</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"a"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// creates request, queues it</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"b"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// creates request, queues it</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"c"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// creates request, queues it</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">uncork</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// calls _writev(["a", "b", "c"])</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Without <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">cork()</code>:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"a"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// creates request, calls _write("a")</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"b"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// creates request, queues it</span></span>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"c"</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// creates request, queues it</span></span>
<span class="line"><span style="color:#6A737D">// as each _write completes, the next is called</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The difference is that in the corked case, <strong class="font-bold">all three chunks can be written in a single I/O operation</strong> if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> is implemented efficiently. In the uncorked case, each chunk is written separately, resulting in three I/O operations.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For some destinations, like network sockets or files, reducing the number of I/O operations significantly improves throughput. For others, like in-memory arrays, it doesn't matter. This is why <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_writev()</code> is optional - it's an optimization that's only worthwhile when the destination benefits from batching.</p>
<h2 id="objectmode-writable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">ObjectMode Writable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've mostly talked about byte streams, but <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> is a critical feature for building data processing pipelines. In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, the behavior of Writable streams changes in specific ways.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is measured in <strong class="font-bold">object count</strong>, not byte count. The default is 16 objects. When you write objects to an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> stream, the stream increments its buffer count by 1 for each object, regardless of the object's size in memory.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This means that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> <strong class="font-bold">is not a memory limit</strong>. It's a count limit. If you write 16 objects, each of which is a 10MB buffer, the stream has buffered 160MB of data, even though <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is 16.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is intentional. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> is designed for scenarios where each chunk represents a <strong class="font-bold">logical unit of work</strong>, and you want to limit the number of units in flight, not the total byte size. For example, if you're processing database rows, you might want to buffer 100 rows at a time, regardless of whether each row is 100 bytes or 10KB.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Implementing an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> Writable is the same as a byte stream, except you set <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode: true</code> in the options:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> RowWriter</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">db</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.db </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> db;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#B392F0"> _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">row</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.db.</span><span style="color:#B392F0">insert</span><span style="color:#E1E4E8">(row);</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Each <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> call passes a row object. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method receives the row and inserts it into the database. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">encoding</code> parameter is ignored in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> (it's always <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'buffer'</code>), but it's still passed to maintain the signature.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One common pattern is converting a byte stream to an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> stream using a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code>. For example, parsing JSON lines:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Transform } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> JSONLineParser</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Transform</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _transform</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> lines</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">split</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lines.</span><span style="color:#B392F0">pop</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// incomplete line</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> lines) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (line.</span><span style="color:#B392F0">trim</span><span style="color:#E1E4E8">()) {</span></span>
<span class="line"><span style="color:#F97583">        try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">          this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">JSON</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">parse</span><span style="color:#E1E4E8">(line));</span></span>
<span class="line"><span style="color:#E1E4E8">        } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#F97583">          return</span><span style="color:#B392F0"> callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Transform</code> reads byte chunks, accumulates them into lines, and pushes parsed JSON objects. The output is an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> stream, even though the input is a byte stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> streams are essential for building composable data pipelines where each stage processes logical records rather than byte chunks. They're common in <strong class="font-bold">ETL</strong> (extract, transform, load) systems, log processing, data import/export, and anywhere you're dealing with structured data.</p>
<h2 id="the-_final-hook-in-detail" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> Hook in Detail</h2>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> method deserves more attention because it's often misunderstood. It's <strong class="font-bold">not a destructor</strong>. It's not called when the stream is destroyed. It's called when the stream is ending normally, after all writes have completed, but <em class="italic">before</em> the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> event is emitted.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The purpose of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> is to perform any cleanup or final writes that need to happen before the stream is considered finished. For example, if you're writing to a compressed file, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> is where you'd write the final compression footer. If you're accumulating data for a batch write, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> is where you'd flush that batch.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A Writable that accumulates writes and flushes them in batches:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> BatchingWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">batchSize</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batchSize </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> batchSize;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batch.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.batchSize) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_flush</span><span style="color:#E1E4E8">(callback);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _final</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_flush</span><span style="color:#E1E4E8">(callback);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _flush</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> data</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">concat</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.batch);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.batch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>
<span class="line"><span style="color:#6A737D">    // write data to destination</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method adds chunks to a batch. When the batch reaches <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">batchSize</code>, it's flushed. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> method ensures that any remaining partial batch is flushed when the stream ends.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Without <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code>, the partial batch would be lost</strong> when the stream ends. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> event would fire, but the last few chunks wouldn't have been written to the destination. This is a <strong class="font-bold">common bug</strong> in custom Writable streams that perform batching or buffering.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> callback must be invoked, just like the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> callback. If you don't invoke it, the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code> event never fires, and the stream hangs. If you pass an error to the callback, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event instead of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">An async version:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">async </span><span style="color:#B392F0">_final</span><span style="color:#E1E4E8">(callback) {</span></span>
<span class="line"><span style="color:#F97583">  try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">flushAsync</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#B392F0">    callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Or, since Node.js supports returning promises from stream methods, you can omit the callback:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">async </span><span style="color:#B392F0">_final</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">flushAsync</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_final()</code> returns a promise, Node.js waits for it to resolve before emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">finish</code>, or emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> if it rejects.</p>
<h2 id="advanced-custom-writable-example-rate-limited-writer" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Advanced Custom Writable Example: Rate-Limited Writer</h2>
<p class="text-base leading-relaxed mb-4 font-normal">A more complex custom Writable stream that rate-limits writes to a destination: This demonstrates several advanced concepts: backpressure management, timing control, and queue manipulation.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Writable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> RateLimitedWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">dest</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">bytesPerSecond</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.dest </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> dest;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.bytesPerSecond </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> bytesPerSecond;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> bytesPerSecond;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.lastRefill </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Date.</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">_refillTokens</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">&gt;=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">-=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk, encoding, callback);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> wait</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> ((chunk.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.tokens) </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.bytesPerSecond) </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 1000</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#B392F0">      setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk, encoding, callback);</span></span>
<span class="line"><span style="color:#E1E4E8">      }, wait);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _refillTokens</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> now</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Date.</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> elapsed</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> (now </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.lastRefill) </span><span style="color:#F97583">/</span><span style="color:#79B8FF"> 1000</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.bytesPerSecond,</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.tokens </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> elapsed </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.bytesPerSecond</span></span>
<span class="line"><span style="color:#E1E4E8">    );</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.lastRefill </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> now;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This stream uses a <strong class="font-bold">token bucket algorithm</strong> to rate-limit writes. It maintains a count of available tokens (bytes). Each second, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">bytesPerSecond</code> tokens are added. When writing, if there are enough tokens, the write happens immediately. If not, the write is delayed until enough time has passed to accumulate the needed tokens.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_refillTokens()</code> method is called before each write to add tokens based on elapsed time. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_write()</code> method checks if there are enough tokens, and if not, schedules the write for later using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">setTimeout</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern can be adapted for various rate-limiting scenarios: limiting requests per second to an API, throttling log writes, pacing data exports, etc.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Note that this implementation doesn't invoke the callback immediately if the write is delayed. The callback is passed to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">setTimeout</code> and eventually to the destination's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> call. This means the Writable stream's internal queue is blocked while waiting. This is <strong class="font-bold">correct behavior</strong> - the stream should signal backpressure if writes are being rate-limited, which happens naturally because the callback isn't invoked until the delayed write completes.</p>
<h2 id="backpressure-across-multiple-writers" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Backpressure Across Multiple Writers</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We touched on this earlier, but it's worth exploring in more depth. When multiple producers are writing to a single Writable stream, backpressure becomes more complex.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Each producer calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> independently. Each sees the return value indicating whether the buffer is full. But the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event is broadcast to all listeners. When one producer pauses because <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returned <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, and then <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires, all paused producers resume simultaneously.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This can lead to a <strong class="font-bold">thundering herd problem</strong>. Suppose 100 producers are all paused waiting for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code>. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> fires, all 100 resume and immediately call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code>. The buffer, which just drained, instantly fills up again, and all 100 producers pause again.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The stream oscillates between drained and full, making no forward progress. This is an extreme case, but it illustrates a real issue: coordinating backpressure across multiple producers is non-trivial.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One solution is to use a queue at a higher level. Instead of having 100 producers write directly to the stream, have them enqueue their data, and have a single consumer read from the queue and write to the stream. The single consumer handles backpressure, and the queue coordinates the producers.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another solution is to use a semaphore or similar coordination primitive to limit how many producers can write concurrently. Only N producers are allowed to write at once. When one finishes, another gets a turn. This prevents the thundering herd.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In practice, the simplest solution is often to <strong class="font-bold">avoid having many concurrent writers to a single stream</strong>. If you need to aggregate writes from multiple sources, consider using a higher-level abstraction, like a log library that internally coordinates writes, or a stream multiplexer that interleaves data from multiple sources.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Backpressure is a per-stream signal, not a per-producer signal.</strong> If you have multiple producers, you need higher-level coordination to avoid pathological behavior.</p>
<h2 id="memory-profiling-a-writable-stream" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Memory Profiling a Writable Stream</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Debugging memory issues in code that uses Writable streams requires systematic approaches. Suppose your application's memory usage is growing over time, and you suspect it's related to streaming. How do you diagnose it?</p>
<p class="text-base leading-relaxed mb-4 font-normal">First, check if you're respecting backpressure. Add logging to your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> calls:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> ok</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> writable.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ok) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Backpressure! Buffer size:"</span><span style="color:#E1E4E8">, writable.writableLength);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If you see "Backpressure!" messages but your code isn't pausing, that's the problem. You're <strong class="font-bold">ignoring backpressure</strong>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you are pausing correctly but memory is still growing, check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableLength</code> periodically:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">setInterval</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Buffer size:"</span><span style="color:#E1E4E8">, writable.writableLength);</span></span>
<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If this value is steadily increasing, the stream's buffer is growing, which means the destination is slower than the producer. This might be expected (if the destination is legitimately slow), or it might indicate a problem with the destination (if it's blocked or stalled).</p>
<p class="text-base leading-relaxed mb-4 font-normal">Use Node.js's built-in <strong class="font-bold">heap snapshot feature</strong> to see where memory is allocated:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> v8</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> require</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"v8"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> fs</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> require</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"fs"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> snapshot</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> v8.</span><span style="color:#B392F0">writeHeapSnapshot</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Heap snapshot written to"</span><span style="color:#E1E4E8">, snapshot);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Load the snapshot in Chrome DevTools to see object allocations. Look for large numbers of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> objects or write request objects. If you see millions of small objects related to streams, you've found your leak.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another useful tool is the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">--trace-gc</code> flag, which logs garbage collection events:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span>node --trace-gc app.js</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">If you see frequent GC cycles and high memory usage despite GC running, it means you're allocating faster than GC can reclaim, which is consistent with an unbounded buffer growing.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For production monitoring, track <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writable.writableLength</code> as a metric. If it's consistently near <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">writableHighWaterMark</code>, you're hitting backpressure frequently, which might indicate a bottleneck in your pipeline.</p>
<h2 id="practical-patterns-combining-multiple-writables" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Practical Patterns: Combining Multiple Writables</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Sometimes you need to write the same data to multiple destinations simultaneously. For example, writing to a file and to a database, or sending data to multiple network endpoints. How do you structure this?</p>
<p class="text-base leading-relaxed mb-4 font-normal">One approach is to write to multiple streams manually:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> writeToAll</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">writables</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> results</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> writables.</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">w</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> w.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk));</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> results.</span><span style="color:#B392F0">every</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">r</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> r </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> ok</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> writeToAll</span><span style="color:#E1E4E8">([writable1, writable2], chunk);</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">ok) {</span></span>
<span class="line"><span style="color:#6A737D">  // at least one stream signaled backpressure</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This works, but handling backpressure is tricky. If one stream signals backpressure but others don't, should you pause? If you wait for all streams to drain, the fast streams are unnecessarily slowed down. If you don't wait, the slow stream's buffer grows.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A better approach is to use a fan-out stream that handles this internally:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> FanOutWritable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Writable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">destinations</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.destinations </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> destinations;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _write</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">encoding</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> pending </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.destinations.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> error </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#B392F0"> done</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (err) error </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> err;</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">pending </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">        callback</span><span style="color:#E1E4E8">(error);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    };</span></span>
<span class="line"/>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.destinations.</span><span style="color:#B392F0">forEach</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">dest</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">      dest.</span><span style="color:#B392F0">write</span><span style="color:#E1E4E8">(chunk, encoding, done);</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This stream writes to all destinations concurrently and waits for all to complete before invoking the callback. If any destination errors, the error is passed to the callback. Backpressure is handled naturally - the callback isn't invoked until all destinations finish, so if one is slow, the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">FanOutWritable</code>'s buffer fills up, signaling backpressure to its producer.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern is useful for logging to multiple outputs, replicating data, or broadcasting events.</p>
<h2 id="choosing-highwatermark-for-writable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Choosing highWaterMark for Writable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've mentioned <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> throughout this chapter, but how do you choose the right value?</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <strong class="font-bold">default 16KB</strong> is a reasonable balance for most scenarios. It's large enough to avoid excessive backpressure signals for typical write patterns, but small enough that you're not buffering unreasonable amounts of data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you're writing large chunks, consider <strong class="font-bold">increasing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> to match</strong>. If your chunks are 1MB each, a 16KB <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> means you'll signal backpressure on every write, which is inefficient. Setting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> to 2MB or 4MB gives the stream some breathing room.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you're running in a <strong class="font-bold">memory-constrained environment</strong> (like a Docker container with strict limits, or on an embedded device), consider decreasing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> to reduce memory footprint. Setting it to 4KB or 8KB means less data is buffered at any given time.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you're processing many streams concurrently, multiply your per-stream <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> by the number of concurrent streams to estimate total buffer memory usage. If you have 1000 concurrent HTTP response streams, and each has a 16KB <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, that's potentially 16MB of buffer memory just for stream buffers. If that's too much, lower the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> streams, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> controls the <strong class="font-bold">object count</strong>, not byte size. Choose a value based on how many objects you want in flight. For database writes, 100 or 1000 might make sense. For file parsing, 10 or 50 might be appropriate. There's no universal answer - it depends on your objects' size and your throughput requirements.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One technique is to make <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> <strong class="font-bold">configurable</strong> and tune it based on observed performance. Start with defaults, measure throughput and memory usage, and adjust as needed.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Remember that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is a <strong class="font-bold">threshold, not a limit</strong>. The buffer can exceed <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, especially if chunks are large. So don't treat <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> as a hard memory budget - treat it as a signal point.</p>    
</body>
</html>