["```js\n// This code lives in examples/v8/hidden-classes-demo.js\n // Run with: node --allow-natives-syntax hidden-classes-demo.js\nconst obj1 = {};\nconsole.log(%HaveSameMap(obj1, {})); // true. Both share the initial hidden class.\n // Adding a property creates a new hidden class and a transition.\nobj1.x = 1;\n const obj2 = {};\nconsole.log(%HaveSameMap(obj1, obj2)); // false. obj1's hidden class has changed.\n obj2.x = 5;\n// Now obj2 has followed the same transition path as obj1.\nconsole.log(%HaveSameMap(obj1, obj2)); // true. They now share the same hidden class again.\n```", "```js\nfunction createConfig(base, userOverrides, requestParams) {\n let config = { ...base }; // Start with a consistent shape\n // User overrides could have any number of properties in any order\n for (const key in userOverrides) {\n config[key] = userOverrides[key];\n }\n // This was the killer: a conditional property\n if (requestParams.useNewFeature) {\n config.optionalFeature = true; // This addition forks the hidden class tree\n }\n return config;\n}\n```", "```js\nfunction createConfigV2(base, userOverrides, requestParams) {\n // Initialize a stable, predictable shape. All possible keys are present.\n let config = {\n ...base,\n settingA: null,\n settingB: null,\n optionalFeature: false, // Always present!\n };\n // Now, we are just *updating* properties, not adding them.\n // This does not change the hidden class.\n for (const key in userOverrides) {\n if (key in config) {\n config[key] = userOverrides[key];\n }\n }\n if (requestParams.useNewFeature) {\n config.optionalFeature = true;\n }\n return config;\n}\n```", "```js\nfunction getX(point) {\n return point.x; // <-- THIS is the call site for the '.x' property access.\n}\n getX({ x: 10, y: 20 }); // Execution hits the call site inside getX\ngetX({ x: 30, y: 40 }); // Execution hits the SAME call site again\n```", "```js\n// This code lives in examples/v8/monomorphic-patterns.js\n// Run with: node --allow-natives-syntax monomorphic-patterns.js\n const ITERATIONS = 10000000;\n class Point2D {\n constructor(x, y) {\n this.x = x;\n this.y = y;\n }\n}\n class Point3D {\n constructor(x, y, z) {\n this.x = x;\n this.y = y;\n this.z = z;\n }\n}\n // This function's call site is MONOMORPHIC. It will always see Point2D objects.\n// V8 will heavily optimize this.\nfunction getX_Monomorphic(point) {\n return point.x;\n}\n // This function's call site is POLYMORPHIC. It will see two different shapes.\n// V8 can handle this, but it's slower.\nfunction getX_Polymorphic(point) {\n return point.x;\n}\n // ========= BENCHMARK =============\n // Prime the functions so V8 can optimize them\nfor (let i = 0; i < 1000; i++) {\n getX_Monomorphic(new Point2D(i, i));\n // Pass both shapes to the polymorphic function\n getX_Polymorphic(new Point2D(i, i));\n getX_Polymorphic(new Point3D(i, i, i));\n}\n console.time(\"Monomorphic\");\nlet mono_sum = 0;\nfor (let i = 0; i < ITERATIONS; i++) {\n mono_sum += getX_Monomorphic(new Point2D(i, i));\n}\nconsole.timeEnd(\"Monomorphic\");\n console.time(\"Polymorphic\");\nlet poly_sum = 0;\nfor (let i = 0; i < ITERATIONS; i++) {\n // Alternate between the two shapes\n const point = i % 2 === 0 ? new Point2D(i, i) : new Point3D(i, i, i);\n poly_sum += getX_Polymorphic(point);\n}\nconsole.timeEnd(\"Polymorphic\");\n // Note: Ensure sums are used to prevent V8 from optimizing away the loops.\nconsole.log(mono_sum, poly_sum);\n```", "```js\n// This is what you CAN'T do\nconst value = BigInt(rawTx.value); // e.g., 100000000000000000000n\nconst slippage = value * 0.005; // THROWS: TypeError: Cannot mix BigInt and other types\n```", "```js\n// Represent slippage in basis points (bps) as a BigInt\nconst MAX_SLIPPAGE_BPS = 50n; // 50bps = 0.50%\n // The ingestion function now normalizes everything to BigInt\nfunction handleRawTx(rawTx) {\n const tx = {\n ...rawTx,\n value: BigInt(rawTx.value),\n };\n return validateTransaction(tx);\n}\n // The hot function is now 100% BigInt-safe and type-stable\nfunction validateTransaction(tx) {\n // tx.value is always a BigInt\n const slippage = (tx.value * MAX_SLIPPAGE_BPS) / 10000n;\n // ... rest of BigInt-only logic\n return isProfitable;\n}\n```", "```js\nfunction handleRawTx(rawTx) {\n const val = BigInt(rawTx.value);\n // Dispatch to the correct specialized function at the boundary\n if (val <= BigInt(Number.MAX_SAFE_INTEGER)) {\n const tx = { ...rawTx, value: Number(val) };\n return validateTransactionNumber(tx); // Fast path for most transactions\n } else {\n const tx = { ...rawTx, value: val };\n return validateTransactionBigInt(tx); // Path for whale transactions\n }\n}\n function validateTransactionNumber(tx) {\n // Hot Function #1\n const slippage = tx.value * 0.005; // Fast, floating-point math\n // ...\n}\n function validateTransactionBigInt(tx) {\n // Hot Function #2\n const slippage = (tx.value * 50n) / 10000n; // BigInt math\n // ...\n}\n```", "```js\nfunction validateTransaction(tx) {\n if (typeof tx.value === \"bigint\") {\n // BigInt branch\n const slippage = (tx.value * 50n) / 10000n;\n // ...\n } else {\n // Number branch\n const slippage = tx.value * 0.005;\n // ...\n }\n}\n```", "```js\n// Bad code\n const user = { name: \"Alice\" };\n if (isAdmin) {\n user.permissions = [\"...\"];\n }\n // `user` now has two possible shapes.\n```", "```js\n// Good code!\n const user = {\n name: \"Alice\",\n permissions: null, // or `undefined` - always initialize\n };\n if (isAdmin) {\n user.permissions = [\"...\"];\n }\n // `user` has one stable shape.\n```", "```js\n// Bad code\n function getIdentifier(entity) {\n // This function might get a User, a Product, a Company...\n return entity.id || entity.uuid || entity.productId;\n }\n```", "```js\n// Better!\n // Create separate, monomorphic functions.\n function getUserId(user) {\n return user.id;\n }\n function getProductIdentifier(product) {\n return product.productId;\n }\n```", "```js\n// This code lives in examples/v8/performance-cliffs.js\n const cache = {};\n function setCache(key, value) {\n cache[key] = value;\n}\n // The performance killer\nfunction evictWithDelete(key) {\n delete cache[key]; // This poisons the cache object.\n}\n // The performant way\nfunction evictWithUndefined(key) {\n cache[key] = undefined; // The hidden class remains stable.\n}\n```", "```js\n// This code lives in examples/v8/optimization-triggers.js\n // 1\\. Use a class or a constructor function to define a stable shape.\n// This is the most reliable way to ensure all objects share a hidden class.\nclass DataPacket {\n constructor(id, timestamp, payloadType, payload) {\n // 2\\. Initialize all properties in the constructor.\n // The order here DEFINES the hidden class. Keep it consistent.\n this.id = id; // Should be a Smi if possible\n this.timestamp = timestamp; // Number\n this.payloadType = payloadType; // String\n this.payload = payload; // Object or null\n }\n}\n // 3\\. Keep your processing function MONOMORPHIC.\n// It's designed to work ONLY with DataPacket objects.\n// Use types (e.g., TypeScript) to enforce this at the boundary.\nfunction processPacket(packet) {\n // 4\\. Access properties consistently. This keeps ICs warm and monomorphic.\n const id = packet.id;\n const type = packet.payloadType;\n // 5\\. Prefer Smi-friendly arithmetic in hot loops.\n // Bitwise operations are a good sign you're dealing with Smis.\n if ((id & 1) === 0) {\n // Do something for even IDs\n }\n // 6\\. Avoid deoptimization triggers.\n // No `delete`, no `arguments`, no `try/catch` in the absolute hottest part.\n if (type === \"USER_EVENT\" && packet.payload) {\n // Process payload\n }\n}\n // This is how you could use the points mentioned above\n const packets = [];\n// 7\\. Create objects with the same shape.\nfor (let i = 0; i < 1000; i++) {\n packets.push(new DataPacket(i, Date.now(), \"USER_EVENT\", { data: \"...\" }));\n}\n // 8\\. Run the hot function. V8 will optimize `processPacket`\n// based on the stable `DataPacket` shape.\nfunction processAll() {\n for (let i = 0; i < packets.length; i++) {\n processPacket(packets[i]);\n }\n}\n // 9\\. Profile and measure!\nconsole.time(\"Processing\");\nprocessAll();\nconsole.timeEnd(\"Processing\");\n```", "```js\n# 1\\. Generate the V8 log file\nnode --prof my_app.js\n # 2\\. Process the log file into a human-readable summary\nnode --prof-process isolate-XXXX-v8.log > profile.txt\n```", "```js\n# Run your app with the inspect flag\nnode --inspect my_app.js\n # Or to break on the first line:\nnode --inspect-brk my_app.js\n```", "```js\n# See what gets optimized\nnode --trace-opt my_script.js\n # See what gets deoptimized (and why)\nnode --trace-deopt my_script.js\n # See Inline Cache state changes\nnode --trace-ic my_script.js\n # Combine and filter for a specific function\nnode --trace-opt --trace-deopt my_script.js | grep \"myHotFunction\"\n```", "```js\n# Must be run with --allow-natives-syntax\nnode --allow-natives-syntax my_benchmark.js\n```"]