<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Readable Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Readable Streams</h1>
<blockquote>原文：<a href="https://www.thenodebook.com/streams/readable-streams">https://www.thenodebook.com/streams/readable-streams</a></blockquote><p class="text-base leading-relaxed mb-4 font-normal">Now you understand why streams exist. You know they solve the problem of processing large datasets without loading everything into memory. You've seen the conceptual difference between push and pull models, and you know that Node.js streams blend both approaches. Now comes the practical question: how do you actually use Readable streams in your code, and more importantly, how do they work internally?</p>
<p class="text-base leading-relaxed mb-4 font-normal">Readable streams are the entry point to streaming in Node.js. They produce data - from files, from network connections, from in-memory structures, from anywhere. Understanding how Readable streams manage their internal state, how they buffer data, and how they communicate with consumers is important to work effectively with streams in any capacity.</p>
<p class="text-base leading-relaxed mb-4 font-normal">We're going to build that understanding methodically. First, we'll explore the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> stream class itself - its options, its contract, its events. Then we'll talk about the two operating modes and what triggers transitions between them. After that, we'll examine internal buffering in detail, because this is where memory management happens and where <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> actually matters. Finally, we'll implement our own Readable streams and explore all the ways to consume them. By the end, you'll have a complete mental model of how data moves from a source through a Readable stream to a consumer.</p>
<h2 id="the-readable-stream-class" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">The Readable Stream Class</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Let's start with the object itself. When you import <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream</code> from Node and access <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.Readable</code>, you're getting a class that extends <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">EventEmitter</code>. This inheritance is significant. Every Readable stream is fundamentally an event emitter, which means it can emit events like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code>, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code>. Much of the Readable stream's behavior is expressed through these events.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Creating a Readable stream directly is uncommon in application code. More often, you receive Readable streams from Node.js APIs like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fs.createReadStream()</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">http.IncomingMessage</code>. But when you do create one, either by extending the class or using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">new stream.Readable(options)</code>, you provide a configuration object that controls the stream's behavior.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The most important option is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. This is a number representing the maximum number of bytes (or objects, if you're in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>) that the stream will buffer internally before it stops pulling data from the underlying source. Think of this as the stream's memory budget for buffering. The default is 65536 bytes, which is 64 kilobytes. This default is not a random number - it represents a balance between memory usage and system call efficiency that the Node team settled on through experimentation and production usage.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Why does this matter? Because the Readable stream doesn't just pass data directly from the source to the consumer. It maintains an internal buffer. When the consumer is ready for data, it pulls from this buffer. When the buffer runs low, the stream asks the underlying source for more data to refill it. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> controls when the stream decides "my buffer is full enough, I should stop asking the source for more data." If the buffer contains bytes equal to or exceeding <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, the stream will not request more data from the source until the buffer is drained below that threshold.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Let's see what this looks like:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Readable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  highWaterMark: </span><span style="color:#79B8FF">1024</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// 1KB buffer</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Here we've created a Readable stream with a 1KB buffer threshold. If this stream is reading from a file, it will not request more than 1KB of data ahead of the consumer's consumption rate.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Another critical option is <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>. By default, Readable streams work with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> objects and strings. But sometimes you want to stream arbitrary JavaScript objects. Setting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode: true</code> changes the stream's behavior. Instead of buffering bytes, it buffers objects. Instead of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> representing a byte count, it represents an object count. In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, the default <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is 16 objects, not 64KB.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> objectStream</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">  highWaterMark: </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// buffer up to 100 objects</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is useful when you're building pipelines that process structured data. For instance, if you're reading rows from a database and want to stream them through transform stages, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> makes each row a single unit in the stream, which is conceptually cleaner than converting rows to buffers and back.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">encoding</code> option is another configurational detail. By default, Readable streams emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> objects when you read from them. If you set an encoding like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">'utf8'</code>, the stream automatically converts those buffers to strings using that encoding. This is purely a convenience - you can always call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">buffer.toString('utf8')</code> yourself - but it can make code cleaner when you know you're always working with text.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> textStream</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8">({</span></span>
<span class="line"><span style="color:#E1E4E8">  encoding: </span><span style="color:#9ECBFF">"utf8"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now when this stream emits data, it will emit strings, not buffers.</p>
<p class="text-base leading-relaxed mb-4 font-normal">These are the foundational options. There are others - <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read</code> (a function to implement reading logic inline), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy</code> (a cleanup function), and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">autoDestroy</code> (whether to automatically destroy the stream after it ends) - but <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">encoding</code> are the ones you'll configure most frequently, and they're the ones that most significantly affect the stream's runtime behavior.</p>
<h2 id="events" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Events</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Readable streams communicate with the outside world primarily through events. Let's check each one and understand when it fires and what it means.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event is the most straightforward. When a Readable stream is in flowing mode, it emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events whenever it has data available. Each <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event carries a chunk of data - either a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code>, a string (if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">encoding</code> is set), or an object (if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> is true).</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Received ${</span><span style="color:#E1E4E8">chunk</span><span style="color:#9ECBFF">.</span><span style="color:#79B8FF">length</span><span style="color:#9ECBFF">} bytes`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When you attach a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event listener to a Readable stream, you are implicitly switching the stream into flowing mode. This is important. The act of listening for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> changes the stream's behavior. Data will begin flowing as soon as it's available, pushed to your listener. You don't have to pull. The stream pushes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> event fires when the stream has no more data to provide. The underlying source has been fully consumed. If you're reading a file, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> fires when you've reached the end of the file. If you're reading from an HTTP response, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> fires when the server has finished sending the response body. This event has no arguments. It's just a signal: "I'm done."</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"No more data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event fires when something goes wrong. Maybe the file you're reading was deleted mid-read. Maybe the network connection dropped. Maybe the underlying source threw an error for some reason. When an error occurs, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event with the error object. If you don't have an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event listener attached, Node.js will throw the error, potentially crashing your app. This is why you should <strong class="font-bold">always</strong> attach an error handler to streams.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> event is more subtle. It fires when data is available to be read from the stream. This event is relevant primarily when the stream is in paused mode (we read bout <strong class="font-bold">flowing</strong> and <strong class="font-bold">paused</strong> modes in the previous chapter, don't worry, we'll clarify modes again shortly). The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> event is a signal that says "I have data in my internal buffer. If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code>, you'll get something."</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"readable"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> chunk;</span></span>
<span class="line"><span style="color:#F97583">  while</span><span style="color:#E1E4E8"> ((chunk </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> readable.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">()) </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">    console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Read ${</span><span style="color:#E1E4E8">chunk</span><span style="color:#9ECBFF">.</span><span style="color:#79B8FF">length</span><span style="color:#9ECBFF">} bytes`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Here's what's happening. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> event fires. Inside the handler, we call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable.read()</code> in a loop, pulling chunks from the internal buffer until <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>, which means the buffer is empty. This is a pull-based consumption pattern, as opposed to the push-based pattern of the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's also a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> event that fires when the stream and any underlying resources have been closed. This is distinct from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code>. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> event means "no more data," but resources might still be open. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> event means "resources have been released." Not all streams emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>, and in many cases you don't need to listen for it, but it's there if you need to know when cleanup has completed.</p>
<p class="text-base leading-relaxed mb-4 font-normal">These events form the API surface of Readable streams. Your interactions with Readable streams, whether you're consuming them or implementing them, will revolve around these events and their semantics.</p>
<h2 id="flowing-mode-vs-paused-mode-recap" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Flowing mode vs Paused mode (recap)</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Now let's address the concept that I explained briefly in the previous chapter: operating modes. Every Readable stream is in one of two modes at any given time: <strong class="font-bold">flowing mode</strong> or <strong class="font-bold">paused mode</strong>. The mode determines how data moves from the stream's internal buffer to your code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In <strong class="font-bold">paused mode</strong>, data does not flow automatically. The stream will fill its internal buffer up to the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, but it will not push that data to you. You must explicitly call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable.read()</code> to pull data from the buffer. Paused mode is the default state when you create a new Readable stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In <strong class="font-bold">flowing mode</strong>, data flows automatically. As soon as data is available in the internal buffer, the stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events with chunks of data. You don't call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code>. The data comes to you.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Why have two modes? Because different consumption patterns benefit from different control flows. Sometimes you want the stream to push data to you as fast as possible, and you'll handle backpressure by pausing and resuming the stream. Other times, you want fine-grained control over when data is pulled, reading exactly when you're ready for more. Paused mode gives you that control. Flowing mode optimizes for simplicity and throughput when you're ready to process data as fast as it arrives.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Let's see how you switch between modes. When a Readable stream is created, it starts in paused mode. You switch to flowing mode by doing any of the following:</p>
<ul class="mb-4 space-y-2 ml-6 font-normal" style="list-style-type:disc;list-style-position:outside">
<li class="ml-2 font-normal" style="display:list-item">Attaching a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event listener</li>
<li class="ml-2 font-normal" style="display:list-item">Calling the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code> method</li>
<li class="ml-2 font-normal" style="display:list-item">Calling the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> method to pipe the stream to a Writable stream</li>
</ul>
<p class="text-base leading-relaxed mb-4 font-normal">Conversely, you switch from flowing mode back to paused mode by calling the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> method (but only if there are no <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> destinations).</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's a subtlety here. If you've piped a Readable stream to a Writable stream using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> doesn't actually pause the stream. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> mechanism manages flow control internally, and it will continue operating based on the backpressure signals from the Writable stream. This is by design - <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> is a higher-level abstraction that handles backpressure for you, and manual <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code>/<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code> calls would interfere with that.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Let's look at paused mode consumption:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> getReadableStream</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"readable"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> chunk;</span></span>
<span class="line"><span style="color:#F97583">  while</span><span style="color:#E1E4E8"> ((chunk </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> readable.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">()) </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    processChunk</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream ended"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Here the stream stays in paused mode. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> event tells us data is available. We call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> repeatedly until it returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>. We're in control of when data is pulled.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Now let's look at flowing mode consumption:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> getReadableStream</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  processChunk</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Stream ended"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">As soon as we attach the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listener, the stream switches to flowing mode. Data is pushed to us automatically. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">processChunk()</code> is slow, data will buffer in memory waiting to be processed, unless we implement backpressure by pausing.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's how you implement backpressure in flowing mode:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> canContinue</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> processChunk</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">canContinue) {</span></span>
<span class="line"><span style="color:#E1E4E8">    readable.</span><span style="color:#B392F0">pause</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#6A737D">    // Later, when processing catches up:</span></span>
<span class="line"><span style="color:#6A737D">    // readable.resume();</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">processChunk()</code> indicates it can't keep up, we pause the stream. This stops the flow of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events. Later, when processing catches up (perhaps in a callback or a resolved promise), we call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code> to restart the flow.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's a third, less common way to consume a stream: the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read(size)</code> method in paused mode without a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> listener. You can call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable.read(size)</code> directly at any time to pull a specific number of bytes from the internal buffer. If the buffer doesn't have that many bytes, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> returns whatever is available, or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> if the buffer is empty.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> readable.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (chunk </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Read ${</span><span style="color:#E1E4E8">chunk</span><span style="color:#9ECBFF">.</span><span style="color:#79B8FF">length</span><span style="color:#9ECBFF">} bytes`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This gives you precise control over how much data you pull at a time, which can be useful when implementing protocols with fixed-size headers or structures.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The key is that these modes reflect different strategies for managing memory and concurrency. Paused mode gives you control and makes backpressure explicit. Flowing mode gives you simplicity and performance when your processing can keep up with the data rate. Understanding when and how to use each mode is part of mastering streams.</p>
<h2 id="internal-buffering" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Internal Buffering</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Let's dig further into what's really happening inside a Readable stream. When you create a Readable stream and start reading from it, data doesn't teleport directly from the underlying source (a file, a socket, a generator) to your consumption code. It passes through an internal buffer maintained by the stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The internal buffer is a queue of chunks. When the stream pulls data from the underlying source, those chunks are added to the buffer. When you consume data from the stream (either by calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> in paused mode or by receiving <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events in flowing mode), chunks are removed from the buffer. The buffer grows when the source is producing faster than the consumer is consuming, and it shrinks when the consumer catches up.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The buffer is not a single <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> object. It's actually an array of chunks (earlier it was a linked list, but this was changed for better performance). Each chunk remains in its original allocated <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code>, and the array just tracks the sequence. While arrays require occasional resizing, JavaScript's array implementation handles this efficiently, and the benefits of better cache locality and simpler iteration typically outweighs the occasional reallocation cost.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can inspect the current state of the buffer using the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_readableState</code> property. This property is technically internal (the underscore prefix signals that), but it's useful for debugging and understanding what's happening.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> state</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> readable._readableState;</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Buffer length: ${</span><span style="color:#E1E4E8">state</span><span style="color:#9ECBFF">.</span><span style="color:#79B8FF">length</span><span style="color:#9ECBFF">} bytes`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Buffer count: ${</span><span style="color:#E1E4E8">state</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">buffer</span><span style="color:#9ECBFF">.</span><span style="color:#79B8FF">length</span><span style="color:#9ECBFF">} chunks`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`highWaterMark: ${</span><span style="color:#E1E4E8">state</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">highWaterMark</span><span style="color:#9ECBFF">} bytes`</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.length</code> tells you how many bytes are currently buffered. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.buffer</code> is the array itself, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.buffer.length</code> tells you how many chunks are in the array. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.highWaterMark</code> is the threshold we configured or the default 64KB if not configured.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Now, here's the critical mechanism. When the buffer's total length is below the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> and the stream needs more data (either because a consumer is reading or because the stream is in flowing mode), the stream calls an internal method called <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>. This method is responsible for fetching more data from the underlying source and pushing it into the buffer. If you're implementing a custom Readable stream, you provide the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> implementation. If you're using a built-in stream like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fs.createReadStream()</code>, the Node internals provide the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> implementation.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> is called, it's being told: "The buffer has space. Please fetch more data." The implementation of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> should fetch data from the source and push it into the buffer using the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code> method. Here's a simplified version:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> MyReadable</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">getDataFromSomeTypeOfSource</span><span style="color:#E1E4E8">(size);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (chunk) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(chunk); </span><span style="color:#6A737D">// Adds to internal buffer</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// Signals end of data</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read(size)</code> method receives a size hint - typically the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> value - suggesting how much data it should fetch. This is only a hint. You're allowed to push more or less. The stream will adapt. But respecting the hint helps optimize I/O efficiency.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.push(chunk)</code>, several things happen. First, the chunk is added to the internal buffer. Second, if the stream is in flowing mode, the chunk may be immediately emitted as a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event (bypassing the buffer entirely if there's a consumer ready). Third, if the stream is in paused mode, a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> event may be emitted to signal that data is available.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Importantly, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code> returns a boolean. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, it means the buffer has reached or exceeded the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> (specifically, when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.length &gt;= state.highWaterMark</code>), and the stream is requesting that the source stop producing data. In response, your <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> implementation should stop fetching data from the source. The stream will call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> again later when the buffer drains back below the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's a more complete example:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> FileReader</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">fd</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.fd </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fd;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">size</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> buffer</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">allocUnsafe</span><span style="color:#E1E4E8">(size);</span></span>
<span class="line"><span style="color:#E1E4E8">    fs.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd, buffer, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, size, </span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">bytesRead</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (bytesRead </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// EOF</span></span>
<span class="line"><span style="color:#E1E4E8">      } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, bytesRead));</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    });</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is a simplified file reader. When <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> is called, it reads <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">size</code> bytes from the file descriptor and pushes them into the stream. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fs.read()</code> returns zero bytes, we've reached the end of the file, so we push <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> to signal EOF. If an error occurs, we destroy the stream with the error.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The Node.js stream implementation guarantees that <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> will not be called again until we call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code>, so even though <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fs.read()</code> is asynchronous, we don't need to track a flag to prevent overlapping calls. The stream's internal state machine handles this automatically. Backpressure is also handled automatically - <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> won't be called again until the buffer drains below the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, ensuring we respect backpressure even with asynchronous data sources.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The buffer's behavior also differs between <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code> and byte mode. In byte mode, the buffer tracks total bytes buffered and compares it against a byte-based <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, the buffer tracks the number of objects buffered and compares it against an object-count-based <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. Internally, the same structure is used, but the accounting changes.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One more detail. The stream doesn't just drain the buffer when you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> or when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events fire. There's also a concept of a "reading state" tracked internally. If the stream is actively reading (meaning <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> has been called and hasn't yet pushed new data or pushed <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>), the stream won't call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> again until the current read completes. This prevents redundant reads and keeps the source from being overwhelmed by concurrent read requests.</p>
<p class="text-base leading-relaxed mb-4 font-normal">All of this buffering machinery exists to smooth out mismatches between the source's data rate and the consumer's consumption rate. If the source produces data in bursts (for example, reading from a network socket that receives data in packets), the buffer accumulates those bursts so the consumer sees a steady stream. If the consumer occasionally pauses (for example, waiting for a database write to complete), the buffer holds data until the consumer is ready again. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> controls the size of this buffer, which directly controls the trade-off between memory usage and throughput.</p>
<h2 id="implementing-custom-readable-streams" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Implementing Custom Readable Streams</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Now that we understand the internals, let's implement our own Readable streams. This is less common than consuming streams, but it's very very important for building libraries, creating custom data sources, or deeply understanding stream behavior.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The standard approach is to extend the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> class and implement the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> method. Let's start with a simple example: a stream that emits numbers from 1 to N.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Readable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> CounterStream</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">max</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.max </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> max;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.current </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.current </span><span style="color:#F97583">&lt;=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.max) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">String</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.current));</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.current</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This stream pushes each number as a string. When the counter exceeds <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">max</code>, it pushes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> to signal the end. Notice we don't check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code>'s return value. Since we're producing data synchronously and the stream is calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> when it needs more data, the flow control is already handled by the stream's internal logic. If the buffer fills up, the stream won't call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> again until it drains.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Let's consume this stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> counter</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> CounterStream</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">counter.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Received: ${</span><span style="color:#E1E4E8">chunk</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">counter.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Counter ended"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Output:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span>Received: 1</span></span>
<span class="line"><span>Received: 2</span></span>
<span class="line"><span>Received: 3</span></span>
<span class="line"><span>Received: 4</span></span>
<span class="line"><span>Received: 5</span></span>
<span class="line"><span>Counter ended</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now let's implement something more realistic: a stream that reads lines from a text file. This is a common pattern when processing large log files or CSV files.</p>
<div class="relative my-6 p-4 border-l-4 rounded-r border-blue-500 bg-blue-50 dark:bg-blue-950/30 text-blue-900 dark:text-blue-100" role="alert"><div class="flex gap-3"><span class="text-2xl flex-shrink-0">ℹ️</span><div class="flex-1"><div class="font-bold text-sm mb-1">Note</div><div class="text-sm leading-relaxed [&amp;&gt;p]:mb-2 [&amp;&gt;p:last-child]:mb-0"><p class="text-base leading-relaxed mb-4 font-normal">Don't worry if you do not understand the code related to the 'fs' API below. We're going to dive deep into files in the next chapter.</p></div></div></div></div>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Readable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> fs </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "fs"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> LineStream</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">filePath</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">(options);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.fd </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">openSync</span><span style="color:#E1E4E8">(filePath, </span><span style="color:#9ECBFF">"r"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> ""</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.position </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _read</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Buffer.</span><span style="color:#B392F0">alloc</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">1024</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> bytesRead</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">readSync</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd, chunk, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1024</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.position);</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (bytesRead </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">        this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.buffer);</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"/>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.position </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> bytesRead;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> chunk.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, bytesRead).</span><span style="color:#B392F0">toString</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">    let</span><span style="color:#E1E4E8"> lineEnd;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> ((lineEnd </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">indexOf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">)) </span><span style="color:#F97583">!==</span><span style="color:#F97583"> -</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> line</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, lineEnd);</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.buffer </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.buffer.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">(lineEnd </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(line)) {</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">      }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#B392F0">  _destroy</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">callback</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> undefined</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">      fs.</span><span style="color:#B392F0">close</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.fd, callback);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">      callback</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This stream reads chunks from a file, accumulates them in an internal string buffer, and pushes complete lines to the stream. When it encounters a newline, it pushes the line (without the newline) and continues. If there's leftover data in the buffer when the file ends, it pushes that as the final line.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Notice the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_destroy()</code> method. This is a cleanup hook that's called when the stream is destroyed. By default, Readable streams have <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">autoDestroy: true</code>, which means <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_destroy()</code> will be called <strong class="font-bold">automatically</strong> after the stream ends (after <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push(null)</code>). We use it to close the file descriptor, ensuring we don't leak file handles. We check if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.fd</code> is defined before closing to handle edge cases safely.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Also notice that inside the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">while</code> loop, we check the return value of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code>. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, we return early from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>, stopping further pushes. This respects backpressure. If the consumer pauses or the buffer fills up, we won't push more lines until <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> is called again.</p>
<p class="text-base leading-relaxed mb-4 font-normal">As we saw in the previous chapter, there's a simpler way to create Readable streams for many use cases: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.Readable.from()</code>. This utility function creates a Readable stream from an iterable or async iterable. If you have an array, a generator, or an async generator, you can turn it into a Readable stream with one line.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Readable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> generateNumbers</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&lt;=</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    await</span><span style="color:#F97583"> new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#B392F0"> setTimeout</span><span style="color:#E1E4E8">(resolve, </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8">));</span></span>
<span class="line"><span style="color:#F97583">    yield</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> stream</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Readable.</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">generateNumbers</span><span style="color:#E1E4E8">());</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">stream.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">num</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Received: ${</span><span style="color:#E1E4E8">num</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This is incredibly convenient. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable.from()</code> method handles all the heavy-lifting. It calls the async generator's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">next()</code> method, waits for the promise to resolve, pushes the value into the stream, and repeats until the generator is done. If you're building a Readable stream from structured data or implementing a simple custom data source, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable.from()</code> can eliminate the need to extend <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> manually.</p>
<p class="text-base leading-relaxed mb-4 font-normal">One more consideration when implementing Readable streams is <strong class="font-bold">handling errors</strong>. If an error occurs while fetching data from the source, you should destroy the stream with that error. This stops the stream, emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event, and cleans up resources.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#B392F0">_read</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#79B8FF">  this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">fetchData</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">data</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(err); </span><span style="color:#6A737D">// Emits 'error' event</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> (data </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// End of stream</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(data);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">this.destroy(err)</code> transitions the stream to a destroyed state. No more <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> calls will be made, and the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event will be emitted with the error object. If you've implemented <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_destroy()</code>, it will be called to clean up resources.</p>
<h2 id="consuming-patterns" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Consuming Patterns</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've seen bits and pieces of consumption throughout this chapter. Now let's systematically cover all the ways to consume Readable streams, with tips on when to use each approach.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Event-based consumption (flowing mode)</strong> is the most straightforward. Attach <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> listeners, and the stream pushes data to you.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#B392F0">  processChunk</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Done"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern is simple and performant when your processing is fast. However, if <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">processChunk()</code> is slow or asynchronous, you need to implement backpressure manually by calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code>, which adds complexity.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Async iteration consumption</strong> is the most modern, straight-forward and ergonomic approach. Readable streams are async iterables, so you can consume them with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code>.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> readable) {</span></span>
<span class="line"><span style="color:#F97583">    await</span><span style="color:#B392F0"> processChunk</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Done"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern handles backpressure automatically. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">processChunk()</code> returns a promise, the loop waits for it to resolve before pulling the next chunk. This means the stream won't push more data until you're ready. It's clean, easy to reason about, and recommended for most use cases.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Explicit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> consumption (paused mode)</strong> gives you fine-grained control. You call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> when you're ready for data.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"readable"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> chunk;</span></span>
<span class="line"><span style="color:#F97583">  while</span><span style="color:#E1E4E8"> ((chunk </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> readable.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">()) </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    processChunk</span><span style="color:#E1E4E8">(chunk);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Done"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">You can also call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read(size)</code> to pull a specific number of bytes, which is useful for parsing binary protocols where you need to read fixed-size headers or structures.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> header</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> readable.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">if</span><span style="color:#E1E4E8"> (header </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> bodyLength</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> header.</span><span style="color:#B392F0">readUInt32BE</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">  const</span><span style="color:#79B8FF"> body</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> readable.</span><span style="color:#B392F0">read</span><span style="color:#E1E4E8">(bodyLength);</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> (body </span><span style="color:#F97583">!==</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#B392F0">    processMessage</span><span style="color:#E1E4E8">(header, body);</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern is powerful but verbose and error-prone. You have to manage the state machine yourself, handling cases where not enough data is available yet.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code></strong> connects a Readable stream to a Writable stream, handling backpressure automatically. Don't worry we have a dedicated sub-chapter on pipes and writable streams.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(writable);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Read error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">writable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"error"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">err</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Write error:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> method listens for <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events on the Readable stream and calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> on the Writable stream. If <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">write()</code> returns <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code> (signaling that the Writable stream's buffer is full), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> on the Readable stream. When the Writable stream emits a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">drain</code> event (signaling that its buffer has space again), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code> on the Readable stream. This automatic backpressure handling is why <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> is so convenient.</p>
<p class="text-base leading-relaxed mb-4 font-normal">However, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> has limitations. Error handling is awkward as errors don't propagate automatically, so you must attach error listeners to both streams. Also, if an error occurs in the middle of piping, cleanup can be tricky. The streams might not be properly closed or destroyed.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.pipeline()</code></strong> is the modern, robust alternative to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>. It connects multiple streams in a pipeline and handles errors and cleanup automatically.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { pipeline } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream/promises"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> pipeline</span><span style="color:#E1E4E8">(readable, writable);</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline succeeded"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">} </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">error</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Pipeline failed:"</span><span style="color:#E1E4E8">, err);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> function from <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream/promises</code> returns a promise that resolves when the pipeline completes successfully or rejects if any stream emits an error. When an error occurs, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> automatically destroys all streams in the pipeline, ensuring resources are cleaned up. This makes it the recommended way to compose streams in production code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also pass transform functions to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>, which we'll explore in later chapters when we cover Transform streams.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Each consumption pattern has its place. For simple, fast processing, event-based consumption is fine. For async processing with clean backpressure handling, async iteration is ideal. For binary protocol parsing or fine-grained control, explicit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> is necessary. For piping streams together, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> is the safest and most robust choice.</p>
<h2 id="mode-transitions-and-state-management" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Mode Transitions and State Management</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've discussed flowing and paused modes, but let's clarify exactly when transitions happen and what the internal state looks like. This can lead to bugs where data is lost or backpressure is not respected.</p>
<p class="text-base leading-relaxed mb-4 font-normal">When a Readable stream is created, it's in paused mode, and its internal state has a flag <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.flowing</code> set to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>. This is neither paused nor flowing - it's an initial state where the stream hasn't started yet.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The first time you attach a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listener, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.flowing</code> becomes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>, and the stream switches to flowing mode. Data begins flowing immediately if the internal buffer has data, or as soon as data becomes available.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.flowing</code> becomes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>. The stream stops emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events. However, the internal buffer continues to fill up to the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>. The source keeps producing data until the buffer is full, at which point <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> stops being called.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.flowing</code> becomes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code> again. The stream starts emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events from the buffer, and if the buffer drains below the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> is called to fetch more data from the source.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you remove all <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listeners (and the stream is not piped anywhere), <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.flowing</code> remains <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>. This is a slight nuance: the stream stays in flowing mode structurally, but with no listeners attached, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events have nowhere to go. The stream will continue to drain its buffer and call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>, but the emitted data effectively disappears. If you attach a new <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listener later, the stream will immediately start emitting events to it (you won't receive data that was already emitted while no listener was attached). To actually pause the stream and stop it from processing data, you must explicitly call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code>, which sets <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">state.flowing</code> to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This distinction matters when you're dynamically adding and removing listeners. Simply removing a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listener doesn't pause the stream - it just removes the destination for the events. The stream continues consuming from its source. If you want to temporarily stop data processing (perhaps to apply backpressure or wait for some condition), you need to explicitly <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> the stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Paused mode (<code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>) requires an explicit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code> call or occurs when the stream is piped and the destination applies backpressure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You may ask, why? Because if you're dynamically adding and removing listeners, or if you're building middleware that wraps streams, you need to understand these state transitions to avoid accidentally losing data or failing to control when the stream processes data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's a snippet to observe these transitions:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> getReadableStream</span><span style="color:#E1E4E8">();</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Initial flowing: ${</span><span style="color:#E1E4E8">readable</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">readableFlowing</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// null</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`Received ${</span><span style="color:#E1E4E8">chunk</span><span style="color:#9ECBFF">.</span><span style="color:#79B8FF">length</span><span style="color:#9ECBFF">} bytes`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`After data listener: ${</span><span style="color:#E1E4E8">readable</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">readableFlowing</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">removeAllListeners</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`After removing listeners: ${</span><span style="color:#E1E4E8">readable</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">readableFlowing</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true (still!)</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">pause</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`After pause: ${</span><span style="color:#E1E4E8">readable</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">readableFlowing</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// false</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">resume</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`After resume: ${</span><span style="color:#E1E4E8">readable</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">readableFlowing</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// true</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readableFlowing</code> property is public and safe to read. It reflects the current state: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">false</code>, or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">true</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's another state consideration: the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">ended</code> flag. Once the stream has emitted <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code>, no more data will be emitted. If you try to read from an ended stream, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> will return <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>. The stream remains in this ended state until it's destroyed. Even if new data somehow becomes available (which shouldn't happen in well-behaved streams), an ended stream will not emit it.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroyed</code> flag is also tracked. Once a stream is destroyed, it will not emit any more events (except <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code>), and attempts to read or write will fail. The stream's resources are released, and it's effectively dead.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Understanding these state flags and transitions helps debug issues like "why isn't my stream emitting data?" or "why is my stream stuck?" Often, the stream is in a state you didn't expect - paused when you thought it was flowing, ended when you thought there was more data, or destroyed when you thought it was still active.</p>
<h2 id="backpressure-in-practice" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Backpressure in Practice</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Let's make backpressure concrete. We've talked about it abstractly, but let's see what it looks like in real code and what happens if you ignore it.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Suppose you're reading a large file and processing each chunk by making an HTTP request to an API. Each request takes 100ms. Here's naive code that ignores backpressure:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"large-file.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">async</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> fetch</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"https://api.example.com/process"</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">    method: </span><span style="color:#9ECBFF">"POST"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    body: chunk,</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Done"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">What happens here? The stream emits <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events as fast as it can read from the file. Each event fires the async handler, which initiates an HTTP request. But the handler doesn't block the stream. The stream keeps emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events, creating more and more concurrent HTTP requests. If the file is large and the chunks are small, you could end up with thousands of in-flight requests, exhausting memory and network resources.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This is a backpressure failure. The consumer (the HTTP request logic) is slower than the producer (the file read), but there's no mechanism to slow down the producer.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's how you fix it with explicit pause and resume:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"large-file.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"data"</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">async</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">chunk</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  readable.</span><span style="color:#B392F0">pause</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> fetch</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"https://thenodebook.com/process"</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">    method: </span><span style="color:#9ECBFF">"POST"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    body: chunk,</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">  readable.</span><span style="color:#B392F0">resume</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">readable.</span><span style="color:#B392F0">on</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"end"</span><span style="color:#E1E4E8">, () </span><span style="color:#F97583">=&gt;</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Done"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Now, as soon as a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event is emitted, we pause the stream. This stops further <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events. We process the chunk asynchronously. Once the HTTP request completes, we resume the stream, allowing the next <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event to fire. This serializes the processing, ensuring only one request is in flight at a time. The file read rate matches the HTTP request rate.</p>
<p class="text-base leading-relaxed mb-4 font-normal">But honestly, this pattern is <strong class="font-bold">awkward</strong> and bad. The pause/resume calls clutter the logic, and if an error occurs, you might forget to resume, leaving the stream stuck.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The cleaner solution is async iteration:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"large-file.txt"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> chunk</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> readable) {</span></span>
<span class="line"><span style="color:#F97583">  await</span><span style="color:#B392F0"> fetch</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"https://thenodebook.com/process"</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">    method: </span><span style="color:#9ECBFF">"POST"</span><span style="color:#E1E4E8">,</span></span>
<span class="line"><span style="color:#E1E4E8">    body: chunk,</span></span>
<span class="line"><span style="color:#E1E4E8">  });</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Done"</span><span style="color:#E1E4E8">);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This achieves the same backpressure behavior automatically. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code> loop doesn't pull the next chunk until the current iteration completes. If the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fetch()</code> takes time, the stream waits. The producer's rate matches the consumer's rate, with no explicit pause or resume calls.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Now, what if you want controlled concurrency - say, up to 5 requests in flight at once? Async iteration alone doesn't give you that. You'd need to implement a concurrency limiter, which is beyond the scope of this chapter but is a common pattern in production and I am pretty sure you're smart enough to implement it yourself. If not, don't worry, libraries like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">p-limit</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">async</code> provide utilities for this.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The key takeaway is that backpressure is not automatic unless you use mechanisms that enforce it. Event-based consumption with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listeners does not enforce backpressure by default. You must add it manually with pause/resume. Async iteration enforces backpressure by design. Piping with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> enforces backpressure automatically by monitoring the Writable stream's state. Choose your consumption pattern based on whether automatic backpressure handling is important to you.</p>
<h2 id="reading-in-object-mode" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Reading in Object Mode</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Object mode changes the semantics of Readable streams slightly. Instead of pushing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code> objects or strings, you push arbitrary JavaScript values. Instead of <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> being a byte count, it's an object count. Let's see what this looks like in practice.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Here's a Readable stream that emits database rows:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { Readable } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "stream"</span><span style="color:#E1E4E8">;</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> RowStream</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> Readable</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">  constructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">db</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">query</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">options</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#79B8FF">    super</span><span style="color:#E1E4E8">({ </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">options, objectMode: </span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.db </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> db;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.query </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> query;</span></span>
<span class="line"><span style="color:#79B8FF">    this</span><span style="color:#E1E4E8">.offset </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">  async</span><span style="color:#B392F0"> _read</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#F97583">    try</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#F97583">      const</span><span style="color:#79B8FF"> rows</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.db.</span><span style="color:#B392F0">query</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.query, { offset: </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.offset, limit: </span><span style="color:#79B8FF">100</span><span style="color:#E1E4E8"> });</span></span>
<span class="line"><span style="color:#F97583">      for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> row</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> rows) </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(row);</span></span>
<span class="line"><span style="color:#E1E4E8">      rows.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &gt;</span><span style="color:#79B8FF"> 0</span><span style="color:#F97583"> ?</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.offset </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> rows.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">:</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">    } </span><span style="color:#F97583">catch</span><span style="color:#E1E4E8"> (err) {</span></span>
<span class="line"><span style="color:#79B8FF">      this</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">destroy</span><span style="color:#E1E4E8">(err);</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This stream queries a database in batches of 100 rows. Each row is pushed as a JavaScript object. The stream's internal buffer handles backpressure - when it fills up, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> won't be called again until space is available, naturally pausing database queries. The consumer sees a stream of row objects:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> stream</span><span style="color:#F97583"> =</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> RowStream</span><span style="color:#E1E4E8">(db, </span><span style="color:#9ECBFF">"SELECT * FROM users"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> row</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> stream) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`User: ${</span><span style="color:#E1E4E8">row</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">name</span><span style="color:#9ECBFF">}, Email: ${</span><span style="color:#E1E4E8">row</span><span style="color:#9ECBFF">.</span><span style="color:#E1E4E8">email</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">Object mode is powerful when you're working with structured data that doesn't naturally map to bytes. Instead of serializing rows to JSON, pushing the JSON as a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Buffer</code>, and then parsing it back in the consumer, you just push the objects directly. This is more efficient and cleaner.</p>
<div class="relative my-6 p-4 border-l-4 rounded-r border-purple-500 bg-purple-50 dark:bg-purple-950/30 text-purple-900 dark:text-purple-100" role="alert"><div class="flex gap-3"><span class="text-2xl flex-shrink-0">📌</span><div class="flex-1"><div class="font-bold text-sm mb-1">Important</div><div class="text-sm leading-relaxed [&amp;&gt;p]:mb-2 [&amp;&gt;p:last-child]:mb-0"><p class="text-base leading-relaxed mb-4 font-normal">Since <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is an object count, not a byte count, the stream's memory usage depends entirely on the size of the objects you push. If you push 16 objects and each is 10MB, you're buffering 160MB, even though the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> is just 16. Node.js has no way to measure the byte size of arbitrary JavaScript objects, so it relies on the object count. This means you, as the programmer, must <strong class="font-bold">carefully calculate</strong> appropriate <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> values based on expected object sizes.</p></div></div></div></div>
<h2 id="edge-cases-and-debugging" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Edge Cases and Debugging</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Readable streams have several edge cases that can trip you up if you're not aware of them. I'm going to cover a few.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Empty streams.</strong> A Readable stream can end immediately without pushing any data. If you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push(null)</code> in <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> without ever pushing actual data, the stream will emit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> without ever emitting <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code>. This is valid and sometimes intentional (for example, reading an empty file), but it can surprise consumers who expect at least one <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> event.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Unhandled <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> events.</strong> If a Readable stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event and there's no listener, Node.js will throw the error, potentially crashing your app/process. Always attach an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> listener, even if it just logs the error.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Destroyed streams.</strong> Once a stream is destroyed, you cannot read from it anymore. If you destroy a stream prematurely (for example, calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy()</code> while there's still buffered data), that data is lost. If you need to clean up resources but still want to emit buffered data, call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push(null)</code> to signal the end gracefully, rather than destroying immediately.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Mixing consumption patterns.</strong> If you attach both a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> listener and a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listener to the same stream, the behavior can be confusing. Attaching a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> listener prevents the stream from entering flowing mode, even if a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> listener is attached afterward. The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> listener takes precedence, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events won't fire as expected. Stick to one consumption pattern per stream.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Misunderstanding <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read(size)</code>.</strong> Calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read(size)</code> does not guarantee you'll get exactly <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">size</code> bytes. You'll get up to <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">size</code> bytes, depending on what's available in the buffer. If the buffer has fewer than <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">size</code> bytes, you get what's there. If the buffer is empty, you get <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code>. Don't assume <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read(size)</code> blocks or waits - it's non-blocking and returns immediately.</p>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Ignoring <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable.destroyed</code>.</strong> If you're implementing custom logic that interacts with streams, always check <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable.destroyed</code> before calling methods like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> or <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push()</code>. Operating on a destroyed stream can lead to errors or unexpected behavior.</p>
<p class="text-base leading-relaxed mb-4 font-normal">For debugging, the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_readableState</code> property is invaluable. It exposes the internal state of the stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(readable._readableState);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This logs an object with properties like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">buffer</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">length</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">flowing</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">ended</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">endEmitted</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">reading</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroyed</code>, and more. If a stream is misbehaving, inspecting this state can reveal what's going wrong.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also enable debug logging for streams by setting the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">NODE_DEBUG</code> environment variable:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span>NODE_DEBUG=stream node your-script.js</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This logs detailed internal stream events to stderr, showing when <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> is called, when data is pushed, when events are emitted, and more. It's verbose, but it's useful for understanding the exact sequence of operations.</p>
<h2 id="memory-implications-and-choosing-highwatermark" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Memory Implications and Choosing highWaterMark</h2>
<p class="text-base leading-relaxed mb-4 font-normal">We've mentioned <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> repeatedly, but let's discuss how to choose a good value. The default of 64KB is a reasonable compromise for most use cases, but it's not optimal for all scenarios.</p>
<p class="text-base leading-relaxed mb-4 font-normal">If you're streaming large files where the source and consumer are roughly balanced in speed, increasing the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> can improve throughput. A larger buffer means fewer system calls to read from the source. For example, if you're reading a file from a fast SSD, increasing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> to 128KB or 256KB can reduce the overhead of repeated <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">fs.read()</code> calls.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"large-file.bin"</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">  highWaterMark: </span><span style="color:#79B8FF">128</span><span style="color:#F97583"> *</span><span style="color:#79B8FF"> 1024</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// 128KB</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">However, larger buffers mean more memory usage. If you're processing thousands of streams concurrently (for example, in a high-traffic web server where each request reads from a file), the cumulative memory usage of all those buffers can be significant. In such cases, you might want to decrease the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> to reduce per-stream memory footprint.</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> readable</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> fs.</span><span style="color:#B392F0">createReadStream</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"file.txt"</span><span style="color:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#E1E4E8">  highWaterMark: </span><span style="color:#79B8FF">4</span><span style="color:#F97583"> *</span><span style="color:#79B8FF"> 1024</span><span style="color:#E1E4E8">, </span><span style="color:#6A737D">// 4KB</span></span>
<span class="line"><span style="color:#E1E4E8">});</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">There's also a latency consideration. If you're streaming real-time data (for example, a live video feed), a smaller <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> means lower latency. The consumer gets data sooner because the stream doesn't wait to fill a large buffer before pushing data. Conversely, if latency is not a concern and throughput is paramount, a larger <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> reduces overhead.</p>
<p class="text-base leading-relaxed mb-4 font-normal">In <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">objectMode</code>, the trade-off is similar, but the units are objects, not bytes. If each object is small, a <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> of 16 might be too low, causing frequent <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> calls and reducing throughput. If each object is large, 16 might be too high, consuming too much memory.</p>
<p class="text-base leading-relaxed mb-4 font-normal">There's no one-size-fits-all answer. Profile your application. Measure memory usage and throughput with different <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> values. The default is usually fine, but for performance-critical applications, tuning can make a difference.</p>
<h2 id="readablefrom-and-async-iterables" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Readable.from() and Async Iterables</h2>
<p class="text-base leading-relaxed mb-4 font-normal">Before we close this chapter, let's revisit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable.from()</code> and understand why it's so powerful. This utility bridges the gap between async iterables (generators, arrays, async generators) and Readable streams, allowing you to leverage the stream API without manually implementing <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Suppose you have an async generator that fetches paginated data from an API:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function*</span><span style="color:#B392F0"> fetchPages</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">url</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">  let</span><span style="color:#E1E4E8"> page </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">  while</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">true</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> response</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#B392F0"> fetch</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">`${</span><span style="color:#E1E4E8">url</span><span style="color:#9ECBFF">}?page=${</span><span style="color:#E1E4E8">page</span><span style="color:#9ECBFF">}`</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">    const</span><span style="color:#79B8FF"> data</span><span style="color:#F97583"> =</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> response.</span><span style="color:#B392F0">json</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (data.items.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> item</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> data.items) {</span></span>
<span class="line"><span style="color:#F97583">      yield</span><span style="color:#E1E4E8"> item;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    page</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This generator fetches pages of items and yields each item. You can turn it into a Readable stream:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> stream</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Readable.</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">fetchPages</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"https://api.example.com/items"</span><span style="color:#E1E4E8">));</span></span>
<span class="line"/>
<span class="line"><span style="color:#E1E4E8">stream.</span><span style="color:#B392F0">pipe</span><span style="color:#E1E4E8">(someWritable);</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable.from()</code> method handles all the heavy-lifting. It calls the generator's <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">next()</code> method, waits for the promise to resolve, pushes the yielded value into the stream, and repeats. If the generator throws an error, the stream emits an <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> event. If the generator completes, the stream pushes <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">null</code> to signal the end.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This pattern is incredibly composable. If you have a function that returns an async iterable, you can plug it into the stream ecosystem with a single line. You get all the benefits of streams - backpressure, event-based consumption, piping to Writable streams, compatibility with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code> - without writing any stream-specific code.</p>
<p class="text-base leading-relaxed mb-4 font-normal">You can also pass regular iterables, not just async ones:</p>
<div class="my-6 overflow-x-auto rounded-lg border border-gray-200 dark:border-gray-700"><pre class="shiki github-dark" style="background-color:#24292e;color:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> stream</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Readable.</span><span style="color:#B392F0">from</span><span style="color:#E1E4E8">([</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">4</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">5</span><span style="color:#E1E4E8">]);</span></span>
<span class="line"/>
<span class="line"><span style="color:#F97583">for</span><span style="color:#F97583"> await</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> num</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> stream) {</span></span>
<span class="line"><span style="color:#E1E4E8">  console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(num);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre></div>
<p class="text-base leading-relaxed mb-4 font-normal">This creates a Readable stream from an array. Each array element becomes a chunk in the stream. It's a simple way to convert synchronous data into a stream for testing or integration with stream-based APIs.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The lesson here is that Readable streams are not just about reading files or sockets. They're a general abstraction for producing sequences of values, whether those values come from I/O, computation, or iteration over data structures. <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable.from()</code> makes that abstraction accessible to any code that produces an iterable or async iterable, lowering the barrier to adopting streams in your codebase.</p>
<h2 id="wrapping-up" class="text-2xl md:text-3xl font-bold mb-4 mt-8 scroll-mt-20">Wrapping Up</h2>
<p class="text-base leading-relaxed mb-4 font-normal"><strong class="font-bold">Aaaah… finally!</strong> We've covered a lot of ground. Let's do a quick recap on what we've covered.</p>
<p class="text-base leading-relaxed mb-4 font-normal">A Readable stream is a producer of data. It pulls data from an underlying source (a file, a socket, a generator, a database query) and makes that data available to consumers. The stream maintains an internal buffer - an array of chunks - that sits between the source and the consumer, smoothing out rate mismatches and providing backpressure.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The stream operates in one of two modes: paused or flowing. In paused mode, data must be explicitly pulled using <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code>. In flowing mode, data is automatically pushed via <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> events. You control the mode through event listeners and method calls like <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pause()</code>, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">resume()</code>, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">The <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> option controls the buffer size threshold. When the buffer's length exceeds <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, the stream stops calling <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>, applying backpressure to the source. When the buffer drains below <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, the stream calls <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code> again, requesting more data.</p>
<p class="text-base leading-relaxed mb-4 font-normal">To implement a custom Readable stream, you extend the <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">Readable</code> class and implement <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>. Inside <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">_read()</code>, you fetch data from your source and call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push(chunk)</code> to add it to the buffer. When there's no more data, you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">push(null)</code> to signal the end. If an error occurs, you call <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">destroy(err)</code>.</p>
<p class="text-base leading-relaxed mb-4 font-normal">To consume a Readable stream, you have several options: event-based consumption with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> listeners, async iteration with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">for await...of</code>, explicit <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">read()</code> calls in paused mode, piping with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipe()</code>, or robust pipelines with <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">stream.pipeline()</code>. Each pattern has trade-offs in terms of simplicity, backpressure handling, and control.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Readable streams emit events to communicate state changes: <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">data</code> for chunks, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">end</code> for completion, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">error</code> for errors, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">readable</code> for data availability, and <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">close</code> for resource cleanup. Your code reacts to these events to process data and handle edge cases.</p>
<p class="text-base leading-relaxed mb-4 font-normal">Backpressure is critical to bounded memory usage. If your consumer is slower than the producer, you must either use a consumption pattern that enforces backpressure automatically (async iteration, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">pipeline()</code>), or implement it manually (pause/resume).</p>
<p class="text-base leading-relaxed mb-4 font-normal">Object mode changes the stream's semantics from byte-based to object-based, allowing you to push arbitrary JavaScript values and treating <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code> as an object count rather than a byte count.</p>
<p class="text-base leading-relaxed mb-4 font-normal">This mental model - source, buffer, <code class="px-1.5 py-0.5 bg-gray-100 dark:bg-gray-800 text-sm font-mono rounded border border-gray-200 dark:border-gray-700">highWaterMark</code>, modes, events, backpressure - is the base for working with all streams in Node.js, not just Readable streams. Writable, Transform, and Duplex streams build on these same concepts, adding their own specific behaviors and contracts. Understanding Readable streams deeply means you've mastered half of the streaming paradigm. The other half - writing data, transforming data, and composing streams - builds naturally on what you've learned here.</p>    
</body>
</html>