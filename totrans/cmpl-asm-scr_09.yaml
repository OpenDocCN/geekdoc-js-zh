- en: 'Chapter 8 Second Pass: Code Generation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章 第二遍：代码生成
- en: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/08-second-pass-code-generation](https://keleshev.com/compiling-to-assembly-from-scratch/08-second-pass-code-generation)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/08-second-pass-code-generation](https://keleshev.com/compiling-to-assembly-from-scratch/08-second-pass-code-generation)
- en: '[Compiling to Assembly from Scratch](./#table-of-contents)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[从头开始编译到汇编](./#table-of-contents)'
- en: by [Vladimir Keleshev](/)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [Vladimir Keleshev](/) 编写
- en: The second and the last pass of our compiler is called the *emitter* or the
    *code generator*, since it generates the assembly code. It converts an AST of
    a program into assembly instrucitons. How do we organize that? We extend the `AST`
    interface with a new method called `emit`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译器的第二遍和最后一遍被称为 *发射器* 或 *代码生成器*，因为它生成汇编代码。它将程序的 AST 转换为汇编指令。我们如何组织这些呢？我们通过添加一个名为
    `emit` 的新方法来扩展 `AST` 接口。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It’s a cool method—you may say—it takes no parameters and returns nothing (or
    `void`). So, what’s the use of it? First, it takes the implicit `this` parameter,
    and with it all the instance variables of each node. Second, even though the signature
    return type is `void`, when this method is called, it will emit assembly as a
    *side effect*. For that we will use an `emit` function (as opposed to a method).
    Using this function we can emit instructions like this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很酷的方法——你可能这么说——它不接受任何参数，也不返回任何内容（或 `void`）。那么，它的用途是什么呢？首先，它接受隐式的 `this`
    参数，以及每个节点的所有实例变量。其次，尽管签名返回类型是 `void`，当这个方法被调用时，它将作为 *副作用* 输出汇编代码。为此，我们将使用一个 `emit`
    函数（而不是一个方法）。使用这个函数，我们可以输出这样的指令：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'More often, we will use template literals for string interpolation when emitting
    code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是，在输出代码时，我们会使用模板字符串进行字符串插值：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will emit `add r1, r2, #42`. How do we implement the `emit` function?
    We can define it so that it appends a line to an array, or writes a line to a
    file. But for now, let’s define it as follows, for simplicity:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '这将输出 `add r1, r2, #42`。我们如何实现 `emit` 函数呢？我们可以定义它，使其向数组追加一行，或者将一行写入文件。但为了简单起见，我们先这样定义它：'
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s right, `emit` simply prints to the console’s standard output channel.
    This is good enough, for now. We can redirect standard output to a file, and then
    assemble it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，`emit` 简单地打印到控制台的标准输出通道。目前来说，这已经足够好了。我们可以将标准输出重定向到文件，然后将其组装起来。
- en: What about the *method* `emit`? First, we define this method on every AST node
    to satisfy the interface. A dummy implementation will suffice, for a start. Let’s
    use `Number` node as an example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于 `emit` 这个 *方法* 呢？首先，我们在每个 AST 节点上定义这个方法以满足接口。一开始，一个虚拟实现就足够了。让我们以 `Number`
    节点为例。
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will modify each node to emit the correct assembly. For example, in
    case of `Number` it will eventually be as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改每个节点以输出正确的汇编代码。例如，对于 `Number` 节点，它最终将是这样的：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This way, each AST node will be able to emit corresponding assembly. Nodes that
    have other nodes as instance variables will be able to call their `emit` methods.
    Note that the order of calls matters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个 AST 节点都将能够输出相应的汇编代码。具有其他节点作为实例变量的节点将能够调用它们的 `emit` 方法。请注意，调用顺序很重要。
- en: 'There’s one rule that we will follow: each node, when emitted, will produce
    assembly code that will put its result into the register `r0`. This is alredy
    how function calls work, but we extend it for all nodes that produce a value.
    This way, we will know where each value ends up when we emit it.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循一条规则：每个节点在输出时，都会生成将结果放入寄存器 `r0` 的汇编代码。这已经是如何函数调用的方式了，但我们将其扩展到所有产生值的节点。这样，当我们输出时，我们将知道每个值最终会去哪里。
- en: Test bench
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试平台
- en: 'To test our emitter pass as we develop it, I suggest adding a few temporary
    AST nodes: `Main` and `Assert`. As we teach our compiler to emit each kind of
    node, we want to see the results immediately, not until we can define a somewhat
    complicated function like `assert`, so we make it into a primitive. It’s the same
    with `Main`: we want our compiler to produce an entry point to our program before
    we can define functions. We define `Main` to take an array of statements.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们正在开发的发射器，我建议添加几个临时的 AST 节点：`Main` 和 `Assert`。当我们教会编译器输出每种节点时，我们希望立即看到结果，而不是等到我们可以定义一个稍微复杂一些的函数，比如
    `assert`，所以我们将其简化。对于 `Main` 也是一样：我们希望在定义函数之前，我们的编译器能够生成程序的入口点。我们将 `Main` 定义为接受一个语句数组。
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While `Assert` takes a single `condition` on which it will make the assertion:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Assert` 只接受一个 `condition` 条件，它将基于此进行断言：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve left out the `emit` methods for now.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前省略了 `emit` 方法。
- en: 'We sligtly modify the `functionStatement` parser to temporarily produce the
    `Main` node, in case the function name is `main`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`functionStatement`解析器进行了轻微修改，以便临时生成`Main`节点，以防函数名称是`main`：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Same with `Assert`: we produce it inside the `call` parser in case the callee
    is called `assert`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Assert`类似：如果被调用者名为`assert`，我们就在`call`解析器内部生成它。
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As soon as we have enough functionality to define our own functions like `assert`,
    we’ll be able to roll this back.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有足够的功能来定义自己的函数，如`assert`，我们就能回滚这个操作。
- en: Main entry point
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主入口点
- en: Let’s imagine how our main entry point should look like in assembly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下我们的主入口点在汇编中的样子。
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As before, we need the `main` label declared as `.global`. We won’t strictly
    need it until we implement calls, but let’s save the `lr` register, so it won’t
    get clobbered eventually, and we can safely return from `main`. Since we need
    to align the stack at the double-word boundary, we can push some other register
    together with `lr`. We could push `ip` as a dummy, but why not as well push the
    frame pointer `fp` to get the “classical” function prologue going. Then we generate
    the inner statements. We set the return value to zero, which will be the default
    return code of the program. We finish with the “classical” epilogue, where we
    restore `fp` and by pushing the saved `lr` into `pc` we return from `main` as
    well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '与之前一样，我们需要将`main`标签声明为`.global`。我们不会严格需要它，直到我们实现调用，但让我们保存`lr`寄存器，这样它就不会最终被破坏，并且我们可以安全地从`main`返回。由于我们需要在双字边界对齐堆栈，我们可以将`lr`和其他寄存器一起推入。我们可以将`ip`作为虚拟寄存器推入，但为什么不也推入帧指针`fp`以启动“经典”函数前导呢。然后我们生成内部语句。我们将返回值设置为零，这将成为程序的默认返回代码。我们以“经典”后导结束，其中我们恢复`fp`，通过将保存的`lr`推入`pc`，我们从`main`返回。 '
- en: 'Now we can implement the `emit` method of `Main`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现`Main`的`emit`方法：
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inbetween the prologue and the epilogue, we emit the inner statements in order,
    using `forEach` loop. Though, we haven’t defined any of the statement nodes that
    could be emitted here yet. Nevertheless, our `Main` node is enough to make the
    first test for our emitter pass: a program that does nothing successfully!'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前导和后导之间，我们按顺序发出内部语句，使用`forEach`循环。尽管如此，我们还没有定义可以在这里发出的任何语句节点。然而，我们的`Main`节点足以使我们的发射器通过第一次测试：一个什么也不做的程序成功！
- en: 'When testing the emitter pass, we could do that in isolation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试发射器通过时，我们可以单独进行：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or we could integrate it with the parser:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将其与解析器集成：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can pipe the resulting assembly into a file, assemble it and execute it!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将生成的汇编代码管道输入到文件中，进行汇编和执行！
- en: Congratulations, our compiler has just compiled its first program end-to-end!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们的编译器刚刚从头到尾编译了它的第一个程序！
- en: Assert
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Assert
- en: Like a function call, assert will expect its only argument to be located in
    the `r0` register. We compare it with `1` which we treat as a truthy value in
    our untyped language with no proper booleans. If equal, we save an ASCII code
    for dot into `r0` to signify success. Otherwise, we save the code for `F` to signify
    failure. We call `putchar` from `libc` to print it. We do not terminate the program.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数调用一样，断言将期望其唯一参数位于`r0`寄存器中。我们将其与`1`进行比较，我们在没有适当布尔值的无类型语言中将其视为真值。如果相等，我们将点（`.`）的ASCII码保存到`r0`中以表示成功。否则，我们将`F`的代码保存到`r0`以表示失败。我们从`libc`调用`putchar`来打印它。我们不终止程序。
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To implement the `Assert` node, we just copy-paste this assembly into the `emit`
    method. We also make sure to emit the condition, so the result ends up in `r0`.
    We don’t have any nodes that could be emitted here yet, but that will change quickly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`Assert`节点，我们只需将这段汇编复制粘贴到`emit`方法中。我们还确保发出条件，以便结果最终存储在`r0`中。我们还没有可以在这里发出的任何节点，但这种情况会很快改变。
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Number
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: Let’s start with the node for a literal integer. This way, we can put our `Assert`
    to use as soon as possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从字面整数值的节点开始。这样，我们就可以尽快使用`Assert`。
- en: We need to load the integer value into `r0`. We could use `mov` with an immediate,
    but the range of immediate values is quite restrictive. That’s why we use the
    `ldr` pseudo-instruction. As you remember, the assembler will convert it into
    `mov` with an immediate, if possible.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将整数值加载到`r0`中。我们可以使用带立即数的`mov`指令，但立即数的范围相当有限。这就是为什么我们使用`ldr`伪指令。如您所记，汇编器如果可能，会将其转换为带立即数的`mov`指令。
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we can use `Number` in an assertion.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在断言中使用`Number`。
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We compile, assemble, and run this program, and we can see that it prints a
    mighty dot, signifying that the assertion passes. If you change the integer to
    0, you can see the program prints `F`, as it should.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译、汇编并运行这个程序，可以看到它打印了一个强大的点，表示断言通过。如果你将整数改为 0，你可以看到程序打印了 `F`，正如它应该的那样。
- en: Negation
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 否定
- en: Next up is the negation operator! It is, to some degree, similar to `Assert`.
    It takes a single term, that we emit, and compares it to zero. Depending on that,
    we move either `1` or `0` into `r0`, thus logically negating the result.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个是否定操作符！它在某种程度上类似于 `Assert`。它接受一个项，我们发出它，并将其与零进行比较。根据这个结果，我们将 `1` 或 `0` 移入
    `r0`，从而逻辑上否定结果。
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we can extend our test program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扩展我们的测试程序：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From here on, we will skip the boilerplate when we discuss our test program.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，当我们讨论测试程序时，我们将跳过样板代码。
- en: Infix operators
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中缀操作符
- en: 'Next up are infix operators: `==`, `!=`, `+`, `-`, `*`, `/` with nodes `Equal`,
    `NotEqual`, `Add`, `Subtract`, `Multiply`, `Divide`. All of them are very similar:
    they take two terms `left` and `right` and operate on them.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是中缀操作符：`==`、`!=`、`+`、`-`、`*`、`/`，对应节点 `Equal`、`NotEqual`、`Add`、`Subtract`、`Multiply`、`Divide`。它们都非常相似：它们接受两个项
    `left` 和 `right` 并对它们进行操作。
- en: Let’s use `Add` as an example.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 `Add` 为例。
- en: 'We could emit one node, move the value into a temporary register (say, `r1`),
    then emit the second node (which value ends up in `r0`) and then sum them up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发出一个节点，将值移动到一个临时寄存器（比如说，`r1`），然后发出第二个节点（其值最终在 `r0` 中），然后将它们相加：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, this will not work for long: as soon as the `right` node is something
    more complicated than just a `Number`, emitting it will likely clobber `r1` that
    stores the `left` result. This will be the case, for example, if we have two nested
    infix nodes. That’s why we need to save `r1` onto the stack before emitting `right`,
    then restore it before we perform the addition:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不会持续太久：一旦 `right` 节点比仅仅是 `Number` 更复杂，发出它很可能会覆盖存储 `left` 结果的 `r1`。例如，如果我们有两个嵌套的中缀节点，就会发生这种情况。这就是为什么在我们发出
    `right` 之前需要将其保存到栈上，然后在我们执行加法之前恢复它：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To maintain 8-byte stack alignment, we also save and restore the dummy `ip`
    register. If the `left` node is another nested expression, the pushes and pops
    will match, and we will be at the same stack pointer location before and after
    we emit it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持 8 字节栈对齐，我们也保存和恢复虚拟 `ip` 寄存器。如果 `left` 节点是另一个嵌套表达式，推送和弹出将匹配，我们将在发出它之前和之后处于相同的栈指针位置。
- en: Like in our first attempt, we can avoid using stack in some cases. We can also
    do better than waste stack space on saving `ip` each time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的第一次尝试中一样，我们可以避免在某些情况下使用栈。我们还可以做得比每次浪费栈空间来保存 `ip` 更好。
- en: 'All our infix operators will have the same structure: emit right, push, emit
    left, pop, then the action. Only the last part will be different. So, here is
    a quick table that shows the action part of each infix node.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的中缀操作符都将具有相同的结构：发出右，推送，发出左，弹出，然后是动作。只有最后一部分会有所不同。所以，这里有一个快速表格，展示了每个中缀节点的动作部分。
- en: Action part of each infix node
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中缀节点的动作部分
- en: '| AST Node | Emits |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| AST 节点 | 发出 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|  |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `Add` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `Add` |'
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `Subtract` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `Subtract` |'
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `Multiply` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Multiply` |'
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `Divide` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `Divide` |'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `Equal` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Equal` |'
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: '| `NotEqual` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `NotEqual` |'
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |  |'
- en: If you want to reduce duplication, you can pull the common part into a new AST
    node called `Infix`, for example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要减少重复，你可以将公共部分拉入一个新的 AST 节点，称为 `Infix`，例如。
- en: 'In the end, we can add an integration test for infix operators:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为中缀操作符添加一个集成测试：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are getting somewhere!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在取得进展！
- en: Block statement
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块语句
- en: Block statement is similar to `Main` but without all the entry point fuss. It
    merely emits each statement.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 块语句类似于 `Main` 但没有所有入口点的麻烦。它只是发出每个语句。
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Simple test:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 简单测试：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Function calls
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数调用
- en: Next is function calls. As we learned in the previous chapter, according to
    the ARM calling convention we need to put the first four arguments into registers
    `r0`–`r3`, and expect the return value in `r0`. Let’s remind ourselves that the
    `Call` node holds a `callee` string and an `args` array.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个是函数调用。正如我们在上一章所学，根据 ARM 调用约定，我们需要将前四个参数放入寄存器 `r0`–`r3`，并期望返回值在 `r0` 中。让我们提醒自己，`Call`
    节点包含一个 `callee` 字符串和一个 `args` 数组。
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can start with something simple: calling a function with no arguments. That’s
    just branching-and-link to the callee label:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一些简单的事情开始：调用不带参数的函数。这仅仅是分支和链接到调用者标签：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'How about one argument? If we emit the first argument, it will be in `r0`.
    And that’s precisely where we need it! Then we `bl` to it, as previously:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 那一个参数呢？如果我们发出第一个参数，它将在 `r0` 中。这正是我们需要它的地方！然后我们 `bl` 到它，就像之前一样：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'More arguments? We could have special cases for two, three, and four arguments,
    and it would also be good for performance reasons, but how about we jump straight
    to a more general case. The following will handle two, three, or four arguments.
    It was nice not to use any stack space for zero or one arguments. However, to
    evaluate more arguments, we need to put them on the stack temporarily. Otherwise,
    as we evaluate one, we risk clobbering the value of the other arguments. Here’s
    how we do it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更多参数吗？我们可以为两个、三个和四个参数设置特殊案例，这也有利于性能，但让我们直接跳到一个更通用的案例。以下将处理两个、三个或四个参数。对于零个或一个参数，我们没有使用任何栈空间，这真是太好了。然而，为了评估更多的参数，我们需要暂时将它们放在栈上。否则，当我们评估一个参数时，我们可能会破坏其他参数的值。以下是我们的做法：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, we allocate enough stack space for up to four arguments, or in other
    words, 16 bytes. We do that by subtracting from the stack pointer since the stack
    grows from higher memory addresses to lower. Then we loop through arguments using
    `forEach`, which takes a callback with each item, and optionally its index `i`.
    For each argument, we first emit it and then store the result into each stack
    slot. We multiply by four to convert array indexes `0`, `1`, `2`, `3` into stack
    offsets in bytes: `0`, `4`, `8`, `12`. At this point, the arguments will all be
    emitted and stored on the stack. However, we want them to be in registers. So
    we `pop` them into the registers in one elegant go. Now, we’ve got everything
    in place so we can branch to the label.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为最多四个参数分配足够的栈空间，或者说，16 字节。我们通过从栈指针中减去来实现这一点，因为栈是从高内存地址向低内存地址增长的。然后我们使用
    `forEach` 遍历参数，它接受一个带有每个项的回调，以及可选的索引 `i`。对于每个参数，我们首先发出它，然后将结果存储在每个栈槽中。我们乘以四，将数组索引
    `0`、`1`、`2`、`3` 转换为栈偏移量（以字节为单位）：`0`、`4`、`8`、`12`。此时，所有参数都将被发出并存储在栈上。然而，我们希望它们在寄存器中。所以我们一次性将它们
    `pop` 到寄存器中。现在，我们已经准备好了，可以跳转到标签。
- en: Here’s the complete version that combines all three approaches by dispatching
    on the number of arguments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个结合了所有三种方法的完整版本，通过根据参数数量进行分派。
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We throw an error in the case of more than four arguments, which we don’t support
    in the baseline compiler.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有超过四个参数，我们抛出错误，因为基线编译器不支持这种情况。
- en: '**Explore**'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**探索**'
- en: ''
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By specializing code generators for two, three, and four arguments separately
    (like we did for zero and one argument) you will be able to produce better code
    (for example, not allocate four slots for two arguments, like we do now). From
    the previous chapter you might have an idea about how to handle more than four
    arguments.
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过为两个、三个和四个参数分别专门化代码生成器（就像我们对零个和单个参数所做的那样），你将能够生成更好的代码（例如，不要为两个参数分配四个槽位，就像我们现在所做的那样）。从上一章中，你可能已经对如何处理超过四个参数有了想法。
- en: How do we test this? We don’t yet have a way to define functions. But we can
    use some of the `libc` functions to test this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何测试这个？我们还没有定义函数的方法。但我们可以使用一些 `libc` 函数来测试这个。
- en: 'As you remember, `putchar` takes one parameter: let’s put it into use by printing
    the ASCII code for a dot (46), as our test.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记，`putchar` 只接受一个参数：让我们通过打印点（46）的 ASCII 码来使用它，作为我们的测试。
- en: There’s also a function called `rand` that takes no arguments and returns a
    random number. That’s not the best function to base our tests on, but we can use
    it until we can define our own functions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `rand` 的函数，它不接受任何参数并返回一个随机数。这不是基于测试的最佳函数，但我们可以使用它，直到我们可以定义自己的函数。
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: I couldn’t find any portable `libc` function that takes two, three, or four
    integer arguments, so we’ll have to wait to test that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我找不到任何可移植的 `libc` 函数，它接受两个、三个或四个整数参数，所以我们必须等待测试。
- en: '**Explore**'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**探索**'
- en: ''
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the parser such that a character literal like `'.'` produces an AST node
    with the corresponding ASCII code, like `new Number(46)`. You can use `string.charCodeAt(index)`
    method.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改解析器，使其能够生成一个与字符 `'.'` 对应的 ASCII 码的 AST 节点，例如 `new Number(46)`。你可以使用 `string.charCodeAt(index)`
    方法。
- en: If-statement
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果语句
- en: 'Next one is fun: conditional statement, or, in other words, if-statement. It
    is fun because we are finally getting to work with control-flow.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个更有趣：条件语句，或者说，if 语句。它很有趣，因为我们终于可以处理控制流了。
- en: 'Let’s look at an example first. What if we wanted to compile the following
    if-statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一个例子。如果我们想编译以下 if 语句：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How would we compile this by hand? We could start with two labels `ifTrue` and
    `ifFalse`. We branch to `ifFalse` if the condition is zero, otherwise to `ifTrue`.
    Below each of these labels, we emit the code corresponding to that branch. In
    the end, we put an `endIf` label and make sure that both branches jump to it when
    they reach their end.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何手动编译这个呢？我们可以从两个标签`ifTrue`和`ifFalse`开始。如果条件为零，我们分支到`ifFalse`，否则分支到`ifTrue`。在每个标签下面，我们发出对应分支的代码。最后，我们放置一个`endIf`标签，并确保两个分支在到达末尾时都跳转到它。
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can do precisely that, but there are few improvements that we can make,
    to reduce the number of instructions. First, the `ifFalse` branch ends with `b
    endIf` immediately followed by `endIf:` label. That means we don’t have to jump
    to it since it points to the next instruction anyway. Similar with `bne ifTrue`,
    but with one nuance: although this branch is conditional (`ne` suffix), it is
    in fact not. Since the two conditions `beq` and `bne` are mutually exclusive,
    if the execution reached `bne ifTrue` we already know that it will execute. Furthermore,
    since `bne ifTrue` is the only use of this label, we can remove `ifTrue` completely.
    Here’s the resulting code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做到这一点，但我们可以做一些改进，以减少指令的数量。首先，`ifFalse`分支以`b endIf`立即跟随`endIf:`标签结束。这意味着我们不需要跳转到它，因为它无论如何都指向下一个指令。类似地，对于`bne
    ifTrue`，但有一个细微差别：尽管这个分支是条件性的（`ne`后缀），但实际上它不是。因为两个条件`beq`和`bne`是互斥的，如果执行到达`bne
    ifTrue`，我们已经知道它将执行。此外，由于`bne ifTrue`是这个标签的唯一用途，我们可以完全删除`ifTrue`。以下是生成的代码：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It is shorter, has fewer branches, so it can be executed more efficiently.
    But before we jump straight to implementing this in our emitter, we need to solve
    one problem. We can’t have two different labels called `ifFalse` or `endIf`: labels
    must be unique. We need to generate unique labels.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它更短，分支更少，因此可以更有效地执行。但在我们直接在我们的发射器中实现它之前，我们需要解决一个问题。我们不能有两个不同的标签称为`ifFalse`或`endIf`：标签必须是唯一的。我们需要生成唯一的标签。
- en: '* * *'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: By convention, labels starting with prefix `.L`, for example, `.L123` are used
    for code generation. Let’s create a class that will help us generate such labels.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，以前缀`.L`开始的标签，例如`.L123`，用于代码生成。让我们创建一个类来帮助我们生成这样的标签。
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This class has a global `counter` which is incremented each time the constructor
    is called. When a `Label` object is created, this counter value is stored in the
    object’s `value` instance variable. We define a `toString` method that adds the
    `.L` prefix, so that these objects work well with string interpolation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个全局的`counter`，每次调用构造函数时都会增加。当创建一个`Label`对象时，这个计数器的值存储在对象的`value`实例变量中。我们定义了一个`toString`方法，添加了`.L`前缀，这样这些对象就可以很好地与字符串插值一起使用。
- en: '* * *'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Now we have all things in place to implement the emitter. We crate two label
    objects `ifFalseLabel` and `endIfLabel` and use them with string interpolation
    in the `emit` calls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实现发射器了。我们创建了两个标签对象`ifFalseLabel`和`endIfLabel`，并在`emit`调用中使用它们进行字符串插值。
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now all of our if-statements will have unique labels!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有我们的if语句都将有唯一的标签！
- en: 'We can throw in a small unit test, for good measure:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保质量，我们可以添加一个小型单元测试：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Function definition and variable look-up
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数定义和变量查找
- en: 'It was nice that we could develop and test function calls in isolation, without
    even being able to define functions. However, the next two concepts are highly
    intertwined: function definition and variable look-up. We already have a special
    node called `Main` that could be thought of as a function that takes no parameters,
    and always returns `0`. We will use it as a template for making our `Function`
    node’s emitter:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们可以在不定义函数的情况下开发和测试函数调用，但是接下来的两个概念高度交织：函数定义和变量查找。我们已经有了一个名为`Main`的特殊节点，可以将其视为一个不接受参数的函数，并且总是返回`0`。我们将使用它作为我们的`Function`节点发射器的模板：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Similar to `Call` we will limit ourselves to four parameters this time. We make
    a guard to enforce this and raise an error otherwise. We start by emitting an
    empty line to separate assembly functions for readability. Similarly to `Main`,
    we emit the `.global` directive and the label. However, this time we don’t hardcode
    it to `main`, but use the name of the function instead, using string interpolation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Call`类似，这次我们将限制自己使用四个参数。我们创建一个守卫来强制执行此操作，并在其他情况下引发错误。我们首先发出一个空行，以使汇编函数的可读性更好。类似于`Main`，我们发出`.global`指令和标签。然而，这次我们不是将其硬编码为`main`，而是使用函数的名称，使用字符串插值。
- en: Here the function prologue starts. We have split the function prologue and epilogue
    into its own methods for readability. This is not something that we have done
    before.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里函数前导部分开始。我们将函数前导和后导部分拆分成独立的方法以提高可读性。这不是我们以前做过的事情。
- en: Let’s look at the prologue, first. We save the frame pointer and the link registers,
    and we set our new frame pointer. We expect our parameters to be in registers
    `r0`–`r3`. However, as soon as we start emitting the body of the function, we
    risk clobbering them, so we need to save them on the stack. Fortunately, ARM allows
    us to do it with a single `push` instruction. (An optimizing compiler would make
    an analysis called register allocation to determine which parameters can be kept
    in registers.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看前导部分。我们保存帧指针和链接寄存器，并设置新的帧指针。我们预计参数将在寄存器`r0`–`r3`中。然而，一旦我们开始生成函数体，我们就有破坏它们的危险，因此我们需要将它们保存在堆栈上。幸运的是，ARM允许我们使用单个`push`指令来完成它。（优化编译器会进行称为寄存器分配的分析，以确定哪些参数可以保留在寄存器中。）
- en: 'Next, we emit the body of the function, which is followed by the function epilogue.
    Here we undo the effect of the function prologue: by setting the stack pointer
    value to frame pointer value we effectively deallocate whatever stack space we
    allocated (in the prologue, or otherwise). We set `r0` and thus our return value
    to `0`. This is to mimic the fact that JavaScript functions return `undefined`
    when there’s no explicit return. We pick `0` because it is falsy, like `undefined`.
    This also removes the risk of returning a garbage value that was a leftover of
    some computation, in case we forget to have a `return` statement. As the last
    instruction, we restore the caller’s frame pointer and pop the saved link register
    into the program counter, effectively returning from the function.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们生成函数体，然后是函数后导部分。在这里，我们撤销函数前导部分的影响：通过将堆栈指针值设置为帧指针值，我们实际上释放了我们在前导部分或其它地方分配的任何堆栈空间。我们将`r0`设置为我们的返回值，即`0`。这是为了模仿JavaScript函数在没有显式返回时返回`undefined`的事实。我们选择`0`因为它是一个假值，就像`undefined`一样。这也消除了返回垃圾值的危险，这些值可能是某些计算留下的遗留物，以防我们忘记编写`return`语句。作为最后一条指令，我们恢复调用者的帧指针，并将保存的链接寄存器弹出程序计数器，从而有效地从函数返回。
- en: '**Explore**'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**探索**'
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We pushed four registers onto the stack. An improvement could be to specialize
    this code to handle the cases with fewer parameters more efficiently. If you do
    that, don’t forget about 8-byte stack alignment.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将四个寄存器推入堆栈。一个改进的方法是将此代码专门化以更有效地处理参数较少的情况。如果你这样做，别忘了8字节堆栈对齐。
- en: 'So far, so good. Now, how do we access those parameters in the body of the
    function? They are located at well-known offsets from the frame pointer. Since
    the stack grows from high addresses to low, we know that we can access parameters
    using negative offsets relative to the frame pointer. We also know that `push
    {r0, r1, r2, r3}` pushes the registers in the reverse order, same as this equivalent
    (but bulkier) code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在，我们如何在函数体中访问这些参数呢？它们位于从帧指针的已知偏移量处。由于堆栈是从高地址向低地址增长的，我们知道我们可以使用相对于帧指针的负偏移量来访问参数。我们还知道`push
    {r0, r1, r2, r3}`以相反的顺序推入寄存器，这与这个等效（但更庞大）的代码相同：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That means that the fourth parameter (from register `r3`) will be stored at
    the location `fp - 4`, third (`r2`) at `fp - 8`, second (`r1`) at `fp - 12`, first
    at `fp - 16`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第四个参数（从寄存器`r3`）将存储在位置`fp - 4`，第三个（`r2`）在`fp - 8`，第二个（`r1`）在`fp - 12`，第一个在`fp
    - 16`。
- en: 'So, when we encounter an identifier that refers to one of the parameters, all
    we need to know is the offset from the frame pointer to locate its value. We can
    load it with `ldr`. Here’s an example of loading the first parameter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们遇到一个引用参数之一的标识符时，我们只需要知道从帧指针到其值的偏移量。我们可以使用`ldr`来加载它。以下是一个加载第一个参数的示例：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What we can do is to store the mapping from parameter name to an offset from
    the frame pointer and make sure it is passed down to all emitters. That means
    that whenever we encounter an identifier node `Id` we can look up the offset in
    that mapping and then we will know how to load it. This mapping is usually called
    an *environment*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做到的是存储从参数名称到帧指针偏移量的映射，并确保将其传递给所有发射器。这意味着每当我们在映射中遇到标识符节点`Id`时，我们都可以查找偏移量，然后我们将知道如何加载它。这种映射通常被称为*环境*。
- en: 'We could just pass around a `Map<string, number>`, but my crystal ball tells
    me that we will need to extend this data structure in the near future. So, instead
    we will introduce a data class with this map as an instance variable called `locals`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只是传递一个`Map<string, number>`，但我的水晶球告诉我，我们将在不久的将来需要扩展这个数据结构。所以，我们将引入一个具有这个映射作为实例变量`locals`的数据类：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We call this class `Environment`. Right now it only contains the `locals` map,
    which is the environment for our local variables, but it could include other environments,
    such as global variable environment, or type environments, or an environment with
    function signatures. We called our map `locals` and not `parameters`, because
    we foresee that we will use it for other local variables, and not just for function
    parameters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个类为`Environment`。目前它只包含`locals`映射，这是我们的局部变量的环境，但它可以包含其他环境，例如全局变量环境、类型环境或具有函数签名的环境。我们称我们的映射为`locals`而不是`parameters`，因为我们预见我们将用它来存储其他局部变量，而不仅仅是函数参数。
- en: Now, there is a hefty change that we need to make. We need to adjust the `AST`
    interface to take the new `Environment` parameter, which we will pass to `emit`.
    We will consistently call this parameter `env`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要进行一项重大更改。我们需要调整`AST`接口以接受新的`Environment`参数，我们将将其传递给`emit`。我们将一致地调用此参数为`env`。
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will also require us to modify all AST nodes to take this environment and
    pass it down to all other node emitters. This is a very invasive, but mechanical
    change. We’ll not go through all the nodes for this, let’s just use `Add` as our
    example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将要求我们修改所有AST节点以接受此环境并将其传递给所有其他节点发射器。这是一个非常侵入性的、但机械性的更改。我们不会遍历所有节点，让我们以`Add`为例。
- en: '[PRE48]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The emitter now takes an `env` parameter, which it passes down to both its
    child AST nodes: `left` and `right`, in this case.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器现在接受一个`env`参数，并将其传递给其子AST节点：在这个例子中是`left`和`right`。
- en: 'Now, back to our `Function`. We need to modify it to fulfil the new `AST` interface
    with `Environment`. However, we will ignore the incoming environment since we
    will not support nested functions. We will bind it to an underscore to signify
    to the reader of this code that this variable is not used on purpose. Here’s our
    new take on function definition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`Function`。我们需要修改它以符合新的`AST`接口和`Environment`。然而，我们将忽略传入的环境，因为我们不会支持嵌套函数。我们将它绑定到下划线，以向阅读此代码的读者表明这个变量是有意不使用的。以下是我们的新函数定义方法：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, in the function definition node, we know both the names of the parameters
    and the offsets at which they will be stored. So this is the ideal place to create
    a new environment. We do that in a method called `setUpEnvironment`. First, we
    create an empty environment, and then we loop through the parameters using `forEach`
    and set the locals map for each parameter to its offset relative to the frame
    pointer. Here, `forEach` passes not only items but also (optionally) each item’s
    index `i`. To map each index to its frame pointer offset we multiply the index
    by four to convert from words to bytes, and remove `16` since this is how many
    bytes we had allocated on the stack when we popped the four parameters in the
    prologue. We pass the constructed environment when emitting the body, which, in
    turn, will pass it to all its children, and so forth.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在函数定义节点中，我们知道参数的名称以及它们将被存储的偏移量。因此，这是创建新环境的理想位置。我们在`setUpEnvironment`方法中这样做。首先，我们创建一个空环境，然后使用`forEach`遍历参数，并将每个参数的本地映射设置为相对于帧指针的偏移量。在这里，`forEach`不仅传递项目，而且（可选地）传递每个项目的索引`i`。为了将每个索引映射到其帧指针偏移量，我们将索引乘以四，从单词转换为字节，并减去`16`，因为我们弹出序言中的四个参数时在堆上分配了这么多字节。我们在发出体时传递构建的环境，这将反过来将其传递给所有子节点，依此类推。
- en: 'Now, a node that needs to access a local parameter can look it up in the environment.
    And what node could it be if not `Id`, the node for the identifiers in our code?
    All the hard work is done in the `Function` node, so our `Id` node will be quite
    simple:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个需要访问局部参数的节点可以在环境中查找它。如果不是我们的代码中标识符的节点`Id`，那它还能是哪个节点呢？所有困难的工作都在`Function`节点中完成，所以我们的`Id`节点将会非常简单：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It looks up the offset from the local environment by identifier name. If the
    name is not in the environment, it throws an error. This means that a variable
    was used before it is defined. Otherwise, it loads the value using `ldr` relative
    to the frame pointer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过标识符名称查找本地环境中的偏移量。如果该名称不在环境中，它会抛出一个错误。这意味着在定义之前已经使用了变量。否则，它将使用相对于帧指针的`ldr`加载值。
- en: These frame pointers are handy, aren’t they?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些帧指针很方便，不是吗？
- en: 'Now that we have implemented functions with parameters, we can implement quite
    a few interesting ones! First, we can get rid of the `Main` node, and generate
    the `main` function just like any other. Second, we can get rid of our `Assert`
    primitive, and implement it instead as a function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了带有参数的函数，我们可以实现相当多的有趣函数！首先，我们可以去掉`Main`节点，并像任何其他函数一样生成`main`函数。其次，我们可以去掉我们的`Assert`原语，并实现它作为一个函数：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, it’s good to test that we got parameter passing right. Here’s one
    of such tests:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，测试我们是否正确实现了参数传递是很好的。这里有一个这样的测试：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: It could be called as `assert1234(1, 2, 3, 4)` from `main`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以从`main`中调用为`assert1234(1, 2, 3, 4)`。
- en: It feels like we can implement almost anything now; however, one critical piece
    is still missing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在感觉我们几乎可以实施任何东西；然而，仍然缺少一个关键的部分。
- en: Return
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回
- en: 'Functions must be able to return values. Even fans of continuation-passing
    style would agree. And thanks to frame pointers, implementing the `Return` node
    is easy:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须能够返回值。即使是延续传递风格的支持者也会同意。多亏了帧指针，实现`Return`节点是容易的：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We only need to emit the node (which is returned) into `r0`, and then repeat
    the same instructions as in the epilogue.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要将节点（返回值）发出到`r0`，然后重复与结尾相同的指令。
- en: 'Now, the language of our compiler is technically-speaking Turing-complete.
    Loops, you say? We can loop using recursion, which we get for free since our functions
    are using the stack. (We are not getting tail-call optimization for free, though).
    This step warrants extensive testing, but the one test I have in mind is this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从技术角度讲，我们的编译器语言是图灵完备的。循环？你说？我们可以通过递归来实现循环，因为我们的函数正在使用栈。（我们并没有免费获得尾调用优化）。这一步需要广泛的测试，但我心中想的测试是这样的：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The factorial function! We can call it from `main` as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数！我们可以从`main`中这样调用它：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It’s a small dot for a test suite, but a giant leap for our compiler!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小小的测试套件，但对于我们的编译器来说是一个巨大的飞跃！
- en: '* * *'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'We’ve got all the essentials in place now. We will finish this chapter with
    a couple of niceties: local variables, assignments, and while loops. As a treat.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有基本要素。我们将以一些小优点结束这一章：本地变量、赋值和while循环。作为奖励。
- en: Local variables
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地变量
- en: Here we will set out to implement local variables, as declared with `var` keyword
    in JavaScript and represented as `Var` node in our AST.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将着手实现本地变量，就像JavaScript中使用`var`关键字声明的，并在我们的AST中表示为`Var`节点。
- en: Why `var` and not `let`? We have used only `let` in the implementation of this
    compiler!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是`var`而不是`let`？我们在这个编译器的实现中只使用了`let`！
- en: 'Let’s remind ourselves of the difference. Here’s a function using `let`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒一下它们之间的区别。这是一个使用`let`的函数：
- en: '[PRE57]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And the same one using `var`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`的相同例子：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first one prints `1`, and the second one prints `2`. The difference is
    that the `var` bindings work at the function scope, and `let` bindings work at
    the block scope. So the two “vars” refer to the same variables, but the two “lets”
    are different: the second one is within another scope delimited by braces.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个打印`1`，第二个打印`2`。区别在于`var`绑定在函数作用域内工作，而`let`绑定在块作用域内工作。所以这两个“var”指向相同的变量，但这两个“let”是不同的：第二个是在由大括号分隔的另一个作用域内。
- en: 'The reason we implement `var` is that it simplifies scope handling: you only
    need one scope per function. That’s probably also the reason JavaScript introduced
    `var` first, and `let` much later. There’s also `const`, which is just like `let`,
    but makes the assignment forbidden on its bindings.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现`var`的原因是它简化了作用域处理：每个函数只需要一个作用域。这也可能是JavaScript首先引入`var`，而`let`则晚得多的原因。还有`const`，它与`let`类似，但禁止对其绑定进行赋值。
- en: 'So, how do we implement `var`? We can push the value on the stack, then look
    it up in the environment, just like with parameters. However, when defining parameters,
    we know their offset: they are at the beginning of the frame. However, when we
    emit a `var`, we don’t know how far down the stack we currently are. But we can
    track this in the environment!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实现`var`？我们可以将值压入栈中，然后在环境中查找它，就像参数一样。然而，当我们定义参数时，我们知道它们的偏移量：它们在帧的起始位置。但是，当我们发出一个`var`时，我们不知道当前栈有多深。但我们可以通过环境来跟踪这一点！
- en: Let’s modify the `Environment` class to store the `nextLocalOffset` number,
    which represents the next available frame pointer offset. This is also sometimes
    called a *stack index*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`Environment`类以存储`nextLocalOffset`数字，它表示下一个可用的帧指针偏移量。这有时也被称为*栈索引*。
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For starters, we could initialize it to `0`. However, in `Function` we need
    to set it up depending on how many parameters we allocate. Right now we always
    allocate four, at offsets `-4`, `-8`, `-12`, and `-16`. So the next available
    offset is `-20`. And that’s the value that we use in the environment setup:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以将其初始化为`0`。然而，在`Function`中，我们需要根据我们分配的参数数量来设置它。目前我们总是分配四个，偏移量为`-4`、`-8`、`-12`和`-16`。所以下一个可用的偏移量是`-20`。这就是我们在环境设置中使用的值：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, onto the `Var` node. Theoretically, we could add the variable name to
    the `local` environment mapping, so it maps to the `nextLocalOffset` value, then
    push the value onto the stack, and update the `nextLocalOffset` to point to the
    next available offset. However, we need to maintain 8-byte alignment, so it is
    slightly more involved:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Var`节点。从理论上讲，我们可以将变量名添加到`local`环境映射中，使其映射到`nextLocalOffset`值，然后将值推送到栈上，并更新`nextLocalOffset`以指向下一个可用的偏移量。然而，我们需要保持8字节对齐，所以这稍微复杂一些：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We still start by emitting the value and pushing it onto the stack, but we also
    need to push something like an `ip` register to keep the stack 8-byte aligned.
    This way it’s the `ip` that will be located at the `nextLocalOffset`, so when
    updating the local environment, we subtract another `4` bytes from it. Now, we
    need to advance `nextLocalOffset` two stack slots ahead; in other words, we decrement
    it by `8`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然从发出值并将其推送到栈上开始，但我们也需要推送一个类似`ip`寄存器的值以保持栈8字节对齐。这样，`ip`就会位于`nextLocalOffset`处，因此在更新本地环境时，我们从它减去另一个`4`字节。现在，我们需要将`nextLocalOffset`向前推进两个栈槽；换句话说，我们将其减去`8`。
- en: '**Explore**'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**探索**'
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This wastes 50% of the stack space for locals. Here’s a way to fix it: you
    can add an array of offsets `vacantOffsets` to the `Environment`. Then each time
    you need a stack slot you first check if there are any vacant slots, and try to
    use it (and remove it from the array). And only if there are no such slots, you
    allocate new stack space. This technique can also be used to take advantage of
    over-allocating in other situations, for example, when you have an odd number
    of function parameters. There’s also a way to organize it all neatly into a `Frame`
    data structure that handles this offset twiddling in one place, so every relevant
    emitter doesn’t have to keep track of the offset math.'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这浪费了本地变量栈空间的50%。这里有一个修复方法：你可以在`Environment`中添加一个偏移量数组`vacantOffsets`。然后每次你需要栈槽时，首先检查是否有任何空槽，并尝试使用它（并从数组中移除）。只有当没有这样的槽时，你才分配新的栈空间。这种技术也可以用于利用其他情况下的过度分配，例如，当你有奇数个函数参数时。还有一种方法可以将所有这些组织得井井有条，放入一个`Frame`数据结构中，该结构在一个地方处理这种偏移量调整，这样每个相关的发射器就不必跟踪偏移量数学。
- en: 'Let’s add an assertion to test our `var` handling:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个断言来测试我们的`var`处理：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Assignment
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值
- en: 'Assignment handling is very similar to identifier look-up. Except instead of
    reading its value, we are writing it. We emit the value into `r0`. Then we look
    up the frame pointer offset in the local environment. If the environment look-up
    fails, we throw an error: that variable was not defined at this point of time.
    Otherwise, we use the `str` instruction to store the value from `r0` into the
    frame pointer offset.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值处理与标识符查找非常相似。除了不读取其值，我们正在写入它。我们将值发出到`r0`。然后我们在本地环境中查找帧指针偏移量。如果环境查找失败，我们抛出一个错误：在那个时间点该变量未定义。否则，我们使用`str`指令将`r0`中的值存储到帧指针偏移量。
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A simple test for the assignment:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对赋值的简单测试：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '**Explore**'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**探索**'
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implement `const` bindings similar to `var`, but such that assignment is not
    allowed on them. A way to do that would be to change the locals mapping to include
    not only an offset but also a flag that signifies whether the binding is constant
    or not. Then, when the assignment looks it up, check that the constant flag is
    not set, and fail otherwise.
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现`const`绑定类似于`var`，但对其不允许赋值。实现这一点的办法是将局部映射更改包括不仅是一个偏移量，还有一个标志来表示绑定是否为常量。然后，当赋值查找时，检查常量标志是否未设置，否则失败。
- en: While-loop
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当循环
- en: While-loop handling is in many ways similar to the `If` statement handling.
    It has a conditional expression, which is checked for truthiness, but it has only
    one branch. The other difference is that at the end of that branch, it jumps back
    to the beginning.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环处理在很多方面与`If`语句处理相似。它有一个条件表达式，该表达式被检查为真值，但它只有一个分支。另一个区别是在那个分支的末尾，它会跳回开始。
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Here we generate two unique labels: `loopStart` and `loopEnd`. We check the
    conditional and branch off to `loopEnd` if it is falsy. Then follows the body
    of the loop. In the end, we unconditionally branch to the `loopStart` label. A
    quick test for the `while` loop may look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成了两个唯一的标签：`loopStart`和`loopEnd`。我们检查条件，如果条件为假，则跳转到`loopEnd`。然后是循环的主体。最后，我们无条件地跳转到`loopStart`标签。对`while`循环的一个快速测试可能看起来像这样：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We’ve put away the `while` loop handling for so long because to test it we
    first need the assignment to work. We can now also implement a version of the
    `factorial` function using the `while` loop:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`while`循环的处理放了一段时间，因为要测试它，我们首先需要赋值功能正常工作。现在，我们也可以实现一个使用`while`循环的`factorial`函数版本：
- en: '[PRE67]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '**Explore**'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**探索**'
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'How do you implement a `for` loop? A `for` loop can be thought of as a special
    case of the `while` loop. Consider that the following `for` loop:'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你如何实现一个`for`循环？`for`循环可以被视为`while`循环的一种特殊情况。考虑以下`for`循环：
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Is equivalent to this `while` loop:'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等价于以下`while`循环：
- en: ''
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The baseline compiler is done. Now, onto *Part II*, where we will continue extending
    and expanding the compiler with new functionality.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 基线编译器已完成。现在，进入**第二部分**，我们将继续通过添加新功能来扩展和扩展编译器。
- en: '[Next: Chapter 9\. Introduction to Part II](./09-introduction-to-part-2)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[下一章：第二部分简介](./09-introduction-to-part-2)'
- en: '* * *'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
