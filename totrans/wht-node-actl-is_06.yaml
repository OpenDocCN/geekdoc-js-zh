- en: What is a Buffer?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»€ä¹ˆæ˜¯ç¼“å†²åŒºï¼Ÿ
- en: åŸæ–‡ï¼š[https://www.thenodebook.com/buffers/what-is-buffer](https://www.thenodebook.com/buffers/what-is-buffer)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://www.thenodebook.com/buffers/what-is-buffer](https://www.thenodebook.com/buffers/what-is-buffer)
- en: I'd recommend you to grab a coffee, for the next few chapters. We're about to
    pull back the curtain on one of the most fundamental, and frankly, most misunderstood
    parts of Node.js. If you've ever found yourself staring at a `<Buffer ...>` in
    your console and felt a slight sense of unease, you're in the right place.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å»ºè®®ä½ å–æ¯å’–å•¡ï¼Œä¸ºæ¥ä¸‹æ¥çš„å‡ ç« åšå¥½å‡†å¤‡ã€‚æˆ‘ä»¬å°†æ­å¼€ Node.js æœ€åŸºæœ¬ã€å¦ç™½è¯´ä¹Ÿæ˜¯è¢«è¯¯è§£æœ€å¤šçš„ä¸€ä¸ªéƒ¨åˆ†çš„ç¥ç§˜é¢çº±ã€‚å¦‚æœä½ æ›¾ç»åœ¨è‡ªå·±çš„æ§åˆ¶å°ä¸­ç›¯ç€
    `<Buffer ...>` æ„Ÿåˆ°ä¸€ä¸ä¸å®‰ï¼Œé‚£ä¹ˆä½ å°±åœ¨æ­£ç¡®çš„ä½ç½®ã€‚
- en: Look, I can just quote what you could find with a simple google search, say
    a **'Buffer is a fixed-size chunk of memory, bla... bla... bla...'** and call
    it a day, but where's the real understanding in that? This isn't about learning
    an API, it's about rewiring a part of your brain that JavaScript has trained to
    think exclusively in text.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: å—¯ï¼Œæˆ‘å¯ä»¥ç”¨ç®€å•çš„è°·æ­Œæœç´¢åˆ°çš„ä¿¡æ¯æ¥å¼•ç”¨ï¼Œæ¯”å¦‚è¯´ä¸€ä¸ª**â€œç¼“å†²åŒºæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„å†…å­˜å—ï¼Œbla... bla... bla...â€**ï¼Œç„¶åå°±ç®—å®Œæˆäº†ï¼Œä½†è¿™æ ·çœŸçš„èƒ½ç†è§£å—ï¼Ÿè¿™ä¸ä»…ä»…å…³äºå­¦ä¹ ä¸€ä¸ª
    APIï¼Œè¿™æ˜¯å…³äºé‡æ–°è¿æ¥ä½ å¤§è„‘çš„ä¸€éƒ¨åˆ†ï¼ŒJavaScript å·²ç»è®­ç»ƒå®ƒåªä»¥æ–‡æœ¬çš„æ–¹å¼æ€è€ƒã€‚
- en: ğŸ’¡Tip
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡æç¤º
- en: Mastering Buffers isn't just for Node.js. The concepts of byte arrays, encodings,
    and memory management are universal in systems programming. This knowledge will
    give you a significant head start if you ever work with languages like Go, Rust,
    C++, or Java.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: æŒæ¡ç¼“å†²åŒºä¸ä»…ä»…æ˜¯é’ˆå¯¹ Node.jsã€‚å­—èŠ‚æ•°ç»„ã€ç¼–ç å’Œå†…å­˜ç®¡ç†çš„æ¦‚å¿µåœ¨ç³»ç»Ÿç¼–ç¨‹ä¸­æ˜¯é€šç”¨çš„ã€‚å¦‚æœä½ å°†æ¥ä¸ Goã€Rustã€C++ æˆ– Java ç­‰è¯­è¨€ä¸€èµ·å·¥ä½œï¼Œè¿™äº›çŸ¥è¯†å°†ç»™ä½ å¸¦æ¥æ˜¾è‘—çš„ä¼˜åŠ¿ã€‚
- en: The World Outside the String
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å­—ç¬¦ä¸²ä¹‹å¤–çš„ä¸–ç•Œ
- en: As JavaScript developers, we live in a comfortable, well-lit world. Our data
    is structured. It arrives as JSON, we parse it into objects, manipulate strings,
    and send it back out as JSON. It's a world of text, of Unicode characters, of
    human-readable information. Even when we're dealing with arrays of numbers, they're
    typically just that - numbers, representing quantities or scores or coordinates.
    This is our comfort zone.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸º JavaScript å¼€å‘è€…ï¼Œæˆ‘ä»¬ç”Ÿæ´»åœ¨ä¸€ä¸ªèˆ’é€‚ã€æ˜äº®çš„ä¸–ç•Œé‡Œã€‚æˆ‘ä»¬çš„æ•°æ®æ˜¯æœ‰ç»“æ„çš„ã€‚å®ƒä»¥ JSON çš„å½¢å¼åˆ°æ¥ï¼Œæˆ‘ä»¬å°†å…¶è§£æä¸ºå¯¹è±¡ï¼Œæ“ä½œå­—ç¬¦ä¸²ï¼Œç„¶åå†ä»¥
    JSON çš„å½¢å¼å‘é€å‡ºå»ã€‚è¿™æ˜¯ä¸€ä¸ªæ–‡æœ¬çš„ä¸–ç•Œï¼Œæ˜¯ Unicode å­—ç¬¦çš„ä¸–ç•Œï¼Œæ˜¯å¯è¯»ä¿¡æ¯çš„ä¸–ç•Œã€‚å³ä½¿æˆ‘ä»¬å¤„ç†çš„æ˜¯æ•°å­—æ•°ç»„ï¼Œå®ƒä»¬é€šå¸¸ä¹Ÿä»…ä»…æ˜¯æ•°å­—ï¼Œä»£è¡¨æ•°é‡ã€åˆ†æ•°æˆ–åæ ‡ã€‚è¿™å°±æ˜¯æˆ‘ä»¬çš„èˆ’é€‚åŒºã€‚
- en: So, imagine your boss comes to you with a new project. "We need a high-performance
    TCP proxy," she says. "It just needs to take every single byte that comes in on
    one connection and forward it, untouched, to another connection. No inspection,
    no modification, just pure, fast data transfer." Or maybe it's, "We're building
    an image processing service. The first step is to read the first 512 bytes of
    an uploaded JPEG file to extract the EXIF metadata."
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œæƒ³è±¡ä¸€ä¸‹ä½ çš„è€æ¿æ¥æ‰¾ä½ ï¼Œå¸¦ç€ä¸€ä¸ªæ–°çš„é¡¹ç›®ã€‚â€œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªé«˜æ€§èƒ½çš„ TCP ä»£ç†ï¼Œâ€å¥¹è¯´ã€‚â€œå®ƒåªéœ€è¦å°†ä¸€ä¸ªè¿æ¥ä¸Šæ¥æ”¶åˆ°çš„æ¯ä¸€ä¸ªå­—èŠ‚åŸå°ä¸åŠ¨åœ°è½¬å‘åˆ°å¦ä¸€ä¸ªè¿æ¥ã€‚æ²¡æœ‰æ£€æŸ¥ï¼Œæ²¡æœ‰ä¿®æ”¹ï¼Œåªæ˜¯çº¯ç²¹ã€å¿«é€Ÿçš„æ•°æ®ä¼ è¾“ã€‚â€æˆ–è€…å¯èƒ½æ˜¯ï¼Œâ€œæˆ‘ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªå›¾åƒå¤„ç†æœåŠ¡ã€‚ç¬¬ä¸€æ­¥æ˜¯è¯»å–ä¸Šä¼ çš„
    JPEG æ–‡ä»¶çš„å‰ 512 ä¸ªå­—èŠ‚ä»¥æå– EXIF å…ƒæ•°æ®ã€‚â€
- en: You nod, open your editor, and then... you pause.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ç‚¹å¤´ï¼Œæ‰“å¼€ä½ çš„ç¼–è¾‘å™¨ï¼Œç„¶å...ä½ åœäº†ä¸‹æ¥ã€‚
- en: How do you represent that stream of raw image data? Those TCP packets? What
    JavaScript data type holds... *that*?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¦‚ä½•è¡¨ç¤ºé‚£è‚¡åŸå§‹å›¾åƒæ•°æ®æµï¼Ÿé‚£äº› TCP æ•°æ®åŒ…ï¼ŸJavaScript ä¸­å“ªç§æ•°æ®ç±»å‹å¯ä»¥æŒæœ‰... *é‚£ç§*ï¼Ÿ
- en: The first, most obvious thought that will pop into any seasoned JavaScript developer's
    head is a string. It's the only primitive data type we have for representing a
    sequence of... well, a sequence of *stuff*. It feels like the right tool for the
    job.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä»»ä½•ç»éªŒä¸°å¯Œçš„ JavaScript å¼€å‘è€…å¤´è„‘ä¸­é¦–å…ˆæµ®ç°çš„æƒ³æ³•å¯èƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¿™æ˜¯æˆ‘ä»¬ç”¨æ¥è¡¨ç¤º...å—¯ï¼Œä¸€ç³»åˆ—â€œä¸œè¥¿â€çš„å”¯ä¸€åŸå§‹æ•°æ®ç±»å‹ã€‚å®ƒæ„Ÿè§‰åƒæ˜¯å®Œæˆè¿™é¡¹å·¥ä½œçš„æ­£ç¡®å·¥å…·ã€‚
- en: And this is where we hit the first, massive "uh oh" moment. This isn't just
    a missing feature in JavaScript; it's a fundamental, philosophical mismatch between
    the language's design and the task at hand. JavaScript was born and raised in
    the browser. Its entire worldview was shaped by the Document Object Model, user
    events, and AJAX requests - a world dominated by HTML, CSS, and text-based data
    formats.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯æˆ‘ä»¬åœ¨ç¬¬ä¸€ä¸ªã€å·¨å¤§çš„â€œå“¦å“¦â€æ—¶åˆ»é‡åˆ°çš„ã€‚è¿™ä¸ä»…ä»…æ˜¯åœ¨ JavaScript ä¸­ç¼ºå¤±çš„åŠŸèƒ½ï¼›è¿™æ˜¯è¯­è¨€è®¾è®¡çš„åŸºæœ¬å“²å­¦ä¸å½“å‰ä»»åŠ¡ä¹‹é—´çš„æ ¹æœ¬ä¸åŒ¹é…ã€‚JavaScript
    æ˜¯åœ¨æµè§ˆå™¨ä¸­è¯ç”Ÿå’Œæˆé•¿çš„ã€‚å®ƒçš„æ•´ä¸ªä¸–ç•Œè§‚æ˜¯ç”±æ–‡æ¡£å¯¹è±¡æ¨¡å‹ã€ç”¨æˆ·äº‹ä»¶å’Œ AJAX è¯·æ±‚å¡‘é€ çš„â€”â€”ä¸€ä¸ªç”± HTMLã€CSS å’ŒåŸºäºæ–‡æœ¬çš„æ•°æ®æ ¼å¼ä¸»å¯¼çš„ä¸–ç•Œã€‚
- en: Node.js, on the other hand, ripped JavaScript out of that comfortable browser
    sandbox and threw it into the cold, stark reality of the server closet. This is
    a world of filesystems, network sockets, cryptographic operations, and low-level
    system calls. And in this world, the universal language isn't text. It's bytes.
    Raw, uninterpreted, glorious bytes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åï¼ŒNode.jså°†JavaScriptä»é‚£ä¸ªèˆ’é€‚çš„æµè§ˆå™¨æ²™ç›’ä¸­æ‹‰äº†å‡ºæ¥ï¼Œæ‰”è¿›äº†å¯’å†·ã€ä¸¥å³»çš„æœåŠ¡å™¨é—´ç°å®ã€‚è¿™æ˜¯ä¸€ä¸ªæ–‡ä»¶ç³»ç»Ÿã€ç½‘ç»œå¥—æ¥å­—ã€åŠ å¯†æ“ä½œå’Œåº•å±‚ç³»ç»Ÿè°ƒç”¨çš„ä¸–ç•Œã€‚åœ¨è¿™ä¸ªä¸–ç•Œé‡Œï¼Œé€šç”¨çš„è¯­è¨€ä¸æ˜¯æ–‡æœ¬ã€‚å®ƒæ˜¯å­—èŠ‚ã€‚åŸå§‹çš„ã€æœªç»è§£é‡Šçš„ã€è¾‰ç…Œçš„å­—èŠ‚ã€‚
- en: This chapter is about that conflict. We're going to explore *why* JavaScript's
    native tools are not just inefficient, but actively dangerous for handling binary
    data. We're not just going to learn the `Buffer` API. We're going to build a deep,
    foundational mental model of why `Buffer` had to be invented in the first place.
    We'll experience the problem firsthand, uncover the clever memory architecture
    that makes the solution possible, and see how Node's original, proprietary solution
    has elegantly merged with modern JavaScript standards.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬ç« æ˜¯å…³äºè¿™ç§å†²çªçš„ã€‚æˆ‘ä»¬å°†æ¢è®¨JavaScriptåŸç”Ÿå·¥å…·ä¸ºä»€ä¹ˆä¸ä»…æ•ˆç‡ä½ä¸‹ï¼Œè€Œä¸”å¤„ç†äºŒè¿›åˆ¶æ•°æ®æ—¶å®é™…ä¸Šæ˜¯æœ‰å®³çš„ã€‚æˆ‘ä»¬ä¸ä»…å°†å­¦ä¹ `Buffer` APIã€‚æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªæ·±å…¥çš„åŸºç¡€å¿ƒç†æ¨¡å‹ï¼Œè§£é‡Šä¸ºä»€ä¹ˆ`Buffer`æœ€åˆå¿…é¡»è¢«å‘æ˜ã€‚æˆ‘ä»¬å°†äº²èº«ä½“éªŒè¿™ä¸ªé—®é¢˜ï¼Œæ­ç¤ºä½¿è§£å†³æ–¹æ¡ˆæˆä¸ºå¯èƒ½çš„å·§å¦™å†…å­˜æ¶æ„ï¼Œå¹¶çœ‹åˆ°Nodeçš„åŸå§‹ã€ä¸“æœ‰çš„è§£å†³æ–¹æ¡ˆå¦‚ä½•ä¼˜é›…åœ°ä¸ç°ä»£JavaScriptæ ‡å‡†ç›¸ç»“åˆã€‚
- en: But before we can see strings fail, we have to get really clear on what they're
    failing *at*. We've used the word "byte" a few times already, but what does that
    actually mean? Let's pause and have a necessary crash course. Forget about JavaScript
    for a minute. Let's go all the way down to the metal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åœ¨æˆ‘ä»¬çœ‹åˆ°å­—ç¬¦ä¸²å¤±è´¥ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»éå¸¸æ¸…æ¥šå®ƒä»¬å¤±è´¥çš„åŸå› ã€‚æˆ‘ä»¬å·²ç»å‡ æ¬¡æåˆ°äº†â€œå­—èŠ‚â€è¿™ä¸ªè¯ï¼Œä½†å®ƒå®é™…ä¸Šæ„å‘³ç€ä»€ä¹ˆï¼Ÿè®©æˆ‘ä»¬æš‚åœä¸€ä¸‹ï¼Œè¿›è¡Œå¿…è¦çš„å¿«é€Ÿè¯¾ç¨‹ã€‚å¿˜è®°JavaScriptä¸€åˆ†é’Ÿã€‚è®©æˆ‘ä»¬æ·±å…¥åˆ°åº•å±‚ã€‚
- en: Bits and Bytes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¯”ç‰¹å’Œå­—èŠ‚
- en: 'Everything in a modern computer, from the text you''re reading to the most
    complex 3D game, is built on an incredibly simple foundation: a switch that can
    be either on or off. That''s it. There''s no magic. We represent "off" with a
    0 and "on" with a 1\. This single piece of information, this 0 or 1, is called
    a **bit**. It''s the smallest possible unit of data in computing.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ç°ä»£è®¡ç®—æœºä¸­çš„æ‰€æœ‰ä¸œè¥¿ï¼Œä»ä½ æ­£åœ¨é˜…è¯»çš„æ–‡æœ¬åˆ°æœ€å¤æ‚çš„3Dæ¸¸æˆï¼Œéƒ½æ˜¯å»ºç«‹åœ¨æå…¶ç®€å•çš„åŸºçŸ³ä¹‹ä¸Šçš„ï¼šä¸€ä¸ªå¯ä»¥å¼€æˆ–å…³çš„å¼€å…³ã€‚å°±æ˜¯è¿™æ ·ã€‚æ²¡æœ‰é­”æ³•ã€‚æˆ‘ä»¬ç”¨0è¡¨ç¤ºâ€œå…³â€ï¼Œç”¨1è¡¨ç¤ºâ€œå¼€â€ã€‚è¿™ä¸ªå•ä¸€çš„ä¿¡æ¯ç‰‡æ®µï¼Œè¿™ä¸ª0æˆ–1ï¼Œè¢«ç§°ä¸º**æ¯”ç‰¹**ã€‚å®ƒæ˜¯è®¡ç®—ä¸­æœ€å°çš„æ•°æ®å•ä½ã€‚
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A single bit is pretty limited. You can't represent much with it - yes or no,
    true or false. To do anything useful, we need to group them together. By convention,
    which has solidified over decades of computing history, we group them into sets
    of eight.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å•ä¸ªæ¯”ç‰¹ç›¸å½“æœ‰é™ã€‚ä½ ç”¨ä¸äº†å¤šå°‘ä¸œè¥¿â€”â€”æ˜¯æˆ–å¦ï¼ŒçœŸæˆ–å‡ã€‚è¦å®Œæˆä»»ä½•æœ‰ç”¨çš„ä»»åŠ¡ï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒä»¬ç»„åˆåœ¨ä¸€èµ·ã€‚æŒ‰ç…§æ•°åå¹´çš„è®¡ç®—æœºå†å²ä¸­å½¢æˆçš„æƒ¯ä¾‹ï¼Œæˆ‘ä»¬å°†å®ƒä»¬åˆ†æˆå…«ä½çš„é›†åˆã€‚
- en: An **8-bit group is called a byte**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ª**8ä½é›†åˆç§°ä¸ºå­—èŠ‚**ã€‚
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the fundamental building block we'll be dealing with. When we talk about
    "binary data," we are talking about a sequence of these bytes. A 1-megabyte file
    is simply a sequence of about a million of these 8-bit patterns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æˆ‘ä»¬å°†è¦å¤„ç†çš„åŸºæœ¬æ„å»ºå—ã€‚å½“æˆ‘ä»¬è°ˆè®ºâ€œäºŒè¿›åˆ¶æ•°æ®â€æ—¶ï¼Œæˆ‘ä»¬æ˜¯åœ¨è°ˆè®ºè¿™äº›å­—èŠ‚çš„åºåˆ—ã€‚ä¸€ä¸ª1å…†å­—èŠ‚çš„æ–‡ä»¶ç®€å•åœ°è¯´å°±æ˜¯å¤§çº¦ä¸€ç™¾ä¸‡ä¸ªè¿™æ ·çš„8ä½æ¨¡å¼ã€‚
- en: 'Now, the most important concept to internalize is this: **a byte, by itself,
    has no intrinsic meaning.** It is just a pattern. The byte `01001001` isn''t inherently
    the letter ''I'' or the color blue or a musical note. It''s just a pattern. To
    turn that pattern into something meaningful, we must apply an *interpretation*.
    This is the source of all the problems we''re about to see.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæœ€é‡è¦çš„æ¦‚å¿µæ˜¯ï¼š**ä¸€ä¸ªå­—èŠ‚æœ¬èº«æ²¡æœ‰å›ºæœ‰çš„æ„ä¹‰**ã€‚å®ƒåªæ˜¯ä¸€ä¸ªæ¨¡å¼ã€‚å­—èŠ‚`01001001`æœ¬èº«å¹¶ä¸æ˜¯å­—æ¯'I'æˆ–è“è‰²æˆ–éŸ³ç¬¦ã€‚å®ƒåªæ˜¯ä¸€ä¸ªæ¨¡å¼ã€‚è¦å°†è¿™ä¸ªæ¨¡å¼å˜æˆæœ‰æ„ä¹‰çš„ï¼Œæˆ‘ä»¬å¿…é¡»åº”ç”¨ä¸€ä¸ª**è§£é‡Š**ã€‚è¿™æ˜¯æˆ‘ä»¬å³å°†çœ‹åˆ°çš„æ‰€æœ‰é—®é¢˜çš„æ ¹æºã€‚
- en: A Byte as a Number
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å­—èŠ‚ä½œä¸ºæ•°å­—
- en: ğŸ“ŒImportant
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ“Œé‡è¦
- en: This is the single most critical concept in this chapter. The data is just a
    sequence of numbers. It is your code that gives it meaning by applying an interpretation
    (e.g., "treat this number as a UTF-8 character" or "treat this number as a pixel's
    color intensity"). All binary data bugs stem from applying the wrong interpretation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æœ¬ç« æœ€é‡è¦çš„æ¦‚å¿µã€‚æ•°æ®åªæ˜¯ä¸€ç³»åˆ—æ•°å­—ã€‚æ˜¯æ‚¨çš„ä»£ç é€šè¿‡åº”ç”¨è§£é‡Šï¼ˆä¾‹å¦‚ï¼Œâ€œå°†è¿™ä¸ªæ•°å­—è§†ä¸ºUTF-8å­—ç¬¦â€æˆ–â€œå°†è¿™ä¸ªæ•°å­—è§†ä¸ºåƒç´ çš„é¢œè‰²å¼ºåº¦â€ï¼‰èµ‹äºˆäº†å®ƒæ„ä¹‰ã€‚æ‰€æœ‰äºŒè¿›åˆ¶æ•°æ®é”™è¯¯éƒ½æºäºåº”ç”¨äº†é”™è¯¯çš„è§£é‡Šã€‚
- en: The most direct interpretation of a byte is as a number. How do we get a number
    from a pattern of 1s and 0s? We use the binary (base-2) number system. It works
    just like the decimal (base-10) system you use every day, but instead of each
    position representing a power of 10 (1s, 10s, 100s, etc.), each position represents
    a power of 2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å­—èŠ‚æœ€ç›´æ¥çš„è§£é‡Šæ˜¯ä½œä¸ºæ•°å­—ã€‚æˆ‘ä»¬å¦‚ä½•ä»1å’Œ0çš„æ¨¡å¼ä¸­è·å¾—ä¸€ä¸ªæ•°å­—ï¼Ÿæˆ‘ä»¬ä½¿ç”¨äºŒè¿›åˆ¶ï¼ˆåŸº-2ï¼‰æ•°åˆ¶ã€‚å®ƒçš„å·¥ä½œæ–¹å¼å°±åƒä½ æ¯å¤©ä½¿ç”¨çš„åè¿›åˆ¶ï¼ˆåŸº-10ï¼‰ç³»ç»Ÿä¸€æ ·ï¼Œä½†æ¯ä¸ªä½ç½®ä»£è¡¨çš„ä¸æ˜¯10çš„å¹‚ï¼ˆ1sï¼Œ10sï¼Œ100sç­‰ï¼‰ï¼Œè€Œæ˜¯2çš„å¹‚ã€‚
- en: 'Let''s look at a byte''s structure. Reading from right to left, the positions
    have increasing value:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹å­—èŠ‚çš„ç»“æ„ã€‚ä»å³åˆ°å·¦è¯»å–ï¼Œä½ç½®å…·æœ‰é€’å¢çš„å€¼ï¼š
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To find the number represented by a byte, you just add up the values of the
    positions that have a `1` in them. Let''s take our example from before: `01001001`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ‰¾åˆ°å­—èŠ‚æ‰€è¡¨ç¤ºçš„æ•°å­—ï¼Œä½ åªéœ€å°†å…¶ä¸­åŒ…å«`1`çš„ä½ç½®çš„å€¼ç›¸åŠ ã€‚è®©æˆ‘ä»¬ä»¥å‰é¢çš„ä¾‹å­ä¸ºä¾‹ï¼š`01001001`ã€‚
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, the binary pattern `01001001` represents the integer `73`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼ŒäºŒè¿›åˆ¶æ¨¡å¼`01001001`ä»£è¡¨æ•´æ•°`73`ã€‚
- en: 'With 8 bits, the smallest number we can make is `00000000`, which is 0\. The
    largest is `11111111`, which is `128 + 64 + 32 + 16 + 8 + 4 + 2 + 1 = 255`. This
    is a critical range to remember: a single byte can represent any integer from
    **0 to 255**. This is why you see this number pop up so often in low-level programming,
    like for RGB color values.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨8ä½ï¼Œæˆ‘ä»¬å¯ä»¥åˆ¶ä½œçš„æœ€å°æ•°å­—æ˜¯`00000000`ï¼Œå³0ã€‚æœ€å¤§çš„æ˜¯`11111111`ï¼Œå³`128 + 64 + 32 + 16 + 8 + 4 +
    2 + 1 = 255`ã€‚è¿™æ˜¯ä¸€ä¸ªéœ€è¦è®°ä½çš„å…³é”®èŒƒå›´ï¼šä¸€ä¸ªå­—èŠ‚å¯ä»¥è¡¨ç¤ºä»**0åˆ°255**çš„ä»»ä½•æ•´æ•°ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ç»å¸¸åœ¨ä½çº§ç¼–ç¨‹ä¸­çœ‹åˆ°è¿™ä¸ªæ•°å­—ï¼Œæ¯”å¦‚RGBé¢œè‰²å€¼ã€‚
- en: â„¹ï¸Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: The range 0-255 is fundamental. When you see APIs that deal with individual
    bytes (like accessing a Buffer by index `buf[i]`), the values you read and write
    will always be within this range.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: èŒƒå›´0-255æ˜¯åŸºæœ¬çš„ã€‚å½“ä½ çœ‹åˆ°å¤„ç†å•ä¸ªå­—èŠ‚çš„APIï¼ˆå¦‚é€šè¿‡ç´¢å¼•è®¿é—®ç¼“å†²åŒº`buf[i]`ï¼‰æ—¶ï¼Œä½ è¯»å–å’Œå†™å…¥çš„å€¼å°†å§‹ç»ˆåœ¨è¿™ä¸ªèŒƒå›´å†…ã€‚
- en: A Byte as a Character
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å­—èŠ‚ä½œä¸ºå­—ç¬¦
- en: This is where things get interesting and directly relevant to our chapter. What
    if we agree on a standard mapping? We could create a table that says, "Whenever
    you see the number 65, interpret it as the character 'A'. When you see 66, it's
    'B'."
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ­£æ˜¯äº‹æƒ…å˜å¾—æœ‰è¶£å¹¶ç›´æ¥ä¸æˆ‘ä»¬æœ¬ç« ç›¸å…³çš„åœ°æ–¹ã€‚å¦‚æœæˆ‘ä»¬åŒæ„ä¸€ä¸ªæ ‡å‡†æ˜ å°„ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªè¡¨æ ¼ï¼Œå…¶ä¸­è¯´ï¼Œâ€œæ¯å½“æ‚¨çœ‹åˆ°æ•°å­—65ï¼Œå°†å…¶è§£é‡Šä¸ºå­—ç¬¦'A'ã€‚å½“æ‚¨çœ‹åˆ°66ï¼Œå®ƒæ˜¯'B'ã€‚â€
- en: This is exactly what **ASCII** (American Standard Code for Information Interchange)
    is. It's an interpretation scheme. It's a contract.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ­£æ˜¯**ASCII**ï¼ˆç¾å›½ä¿¡æ¯äº¤æ¢æ ‡å‡†ä»£ç ï¼‰çš„å«ä¹‰ã€‚å®ƒæ˜¯ä¸€ç§è§£é‡Šæ–¹æ¡ˆã€‚å®ƒæ˜¯ä¸€ç§åˆåŒã€‚
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, under the ASCII interpretation, our byte `01001001` (which is the number
    73) represents the uppercase letter **'I'**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåœ¨ASCIIè§£é‡Šä¸‹ï¼Œæˆ‘ä»¬çš„å­—èŠ‚`01001001`ï¼ˆå³æ•°å­—73ï¼‰ä»£è¡¨å¤§å†™å­—æ¯**'I'**ã€‚
- en: 'This is the key. The bits didn''t change. The underlying number didn''t change.
    Only our *interpretation* of that number changed. This is what a **character encoding**
    is: a set of rules for mapping numbers to characters. ASCII is a simple one. UTF-8,
    which we''ll see soon, is a more complex but far more powerful set of rules that
    can represent virtually any character from any language in the world.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å…³é”®ã€‚ä½æ²¡æœ‰æ”¹å˜ã€‚åŸºç¡€æ•°å­—æ²¡æœ‰æ”¹å˜ã€‚åªæ˜¯æˆ‘ä»¬å¯¹é‚£ä¸ªæ•°å­—çš„è§£é‡Šæ”¹å˜äº†ã€‚è¿™å°±æ˜¯**å­—ç¬¦ç¼–ç **ï¼šä¸€ç»„å°†æ•°å­—æ˜ å°„åˆ°å­—ç¬¦çš„è§„åˆ™ã€‚ASCIIæ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚æˆ‘ä»¬å¾ˆå¿«å°±ä¼šçœ‹åˆ°çš„UTF-8ï¼Œæ˜¯ä¸€å¥—æ›´å¤æ‚ä½†åŠŸèƒ½æ›´å¼ºå¤§çš„è§„åˆ™é›†ï¼Œå¯ä»¥è¡¨ç¤ºä¸–ç•Œä¸Šä»»ä½•è¯­è¨€çš„å‡ ä¹ä»»ä½•å­—ç¬¦ã€‚
- en: '**Interpretation 3: A Byte as... Anything Else**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**è§£é‡Š3ï¼šå­—èŠ‚ä½œä¸º...å…¶ä»–ä»»ä½•äº‹ç‰©**'
- en: 'The same byte, `01001001` (number 73), could mean countless other things depending
    on the context:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åŒä¸€ä¸ªå­—èŠ‚ï¼Œ`01001001`ï¼ˆæ•°å­—73ï¼‰ï¼Œæ ¹æ®ä¸Šä¸‹æ–‡å¯èƒ½ä»£è¡¨æ— æ•°å…¶ä»–äº‹ç‰©ï¼š
- en: '**In an image file,** It might represent the intensity of the blue component
    for a single pixel.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åœ¨å›¾åƒæ–‡ä»¶ä¸­ï¼Œ**å®ƒå¯èƒ½ä»£è¡¨å•ä¸ªåƒç´ çš„è“è‰²æˆåˆ†çš„å¼ºåº¦ã€‚'
- en: '**In a sound file,** It could be a single sample of a waveform, defining the
    speaker''s position at a microsecond in time.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åœ¨å£°éŸ³æ–‡ä»¶ä¸­ï¼Œ**å®ƒå¯èƒ½æ˜¯ä¸€ä¸ªæ³¢å½¢æ ·æœ¬ï¼Œå®šä¹‰äº†åœ¨æ—¶é—´å¾®ç§’çº§æ—¶çš„æ‰¬å£°å™¨ä½ç½®ã€‚'
- en: '**On a network,** It might be part of an IP address.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åœ¨ç½‘ç»œä¸Šï¼Œ**å®ƒå¯èƒ½æ˜¯IPåœ°å€çš„ä¸€éƒ¨åˆ†ã€‚'
- en: '**In a program,** It could be a machine code instruction telling the CPU to
    perform a specific operation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**åœ¨ç¨‹åºä¸­ï¼Œ**å®ƒå¯èƒ½æ˜¯ä¸€æ¡æœºå™¨ä»£ç æŒ‡ä»¤ï¼Œå‘Šè¯‰CPUæ‰§è¡Œç‰¹å®šæ“ä½œã€‚'
- en: The computer doesn't know or care. It just sees `01001001`. It's the software,
    the program - *your code* - that provides the context and applies the correct
    interpretation. The "String Catastrophe" we're about to witness is the direct
    result of applying the wrong interpretation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: è®¡ç®—æœºä¸çŸ¥é“ä¹Ÿä¸å…³å¿ƒã€‚å®ƒåªçœ‹åˆ°`01001001`ã€‚æä¾›ä¸Šä¸‹æ–‡å¹¶åº”ç”¨æ­£ç¡®è§£é‡Šçš„æ˜¯è½¯ä»¶ï¼Œå³ç¨‹åºâ€”â€”*æ‚¨çš„ä»£ç *ã€‚æˆ‘ä»¬å³å°†è§è¯çš„â€œå­—ç¬¦ä¸²ç¾éš¾â€æ˜¯åº”ç”¨é”™è¯¯è§£é‡Šçš„ç›´æ¥ç»“æœã€‚
- en: '**Scaling Up: Sequences and Shorthand**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ‰©å±•ï¼šåºåˆ—å’Œç¼©å†™**'
- en: We rarely work with a single byte. We work with thousands, millions, or billions
    of them in sequence. Writing them out in binary is incredibly tedious.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¾ˆå°‘å•ç‹¬å¤„ç†ä¸€ä¸ªå­—èŠ‚ã€‚æˆ‘ä»¬æŒ‰é¡ºåºå¤„ç†æˆåƒä¸Šä¸‡ã€æ•°ç™¾ä¸‡ç”šè‡³æ•°åäº¿ä¸ªå­—èŠ‚ã€‚ç”¨äºŒè¿›åˆ¶å½¢å¼å†™å‡ºå®ƒä»¬æ˜¯éå¸¸ç¹ççš„ã€‚
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is unreadable for humans. To make our lives easier, we use a shorthand:
    **hexadecimal** (base-16). Hexadecimal uses 16 symbols: 0-9 and A-F. The magic
    of hex is that a single hex digit can represent exactly four bits (a "nibble").
    This means any byte (8 bits) can be perfectly represented by exactly two hex digits.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹äººç±»æ¥è¯´éš¾ä»¥é˜…è¯»ã€‚ä¸ºäº†ä½¿æˆ‘ä»¬çš„ç”Ÿæ´»æ›´ç®€å•ï¼Œæˆ‘ä»¬ä½¿ç”¨ç¼©å†™ï¼š**åå…­è¿›åˆ¶**ï¼ˆåŸºæ•°ä¸º 16ï¼‰ã€‚åå…­è¿›åˆ¶ä½¿ç”¨ 16 ä¸ªç¬¦å·ï¼š0-9 å’Œ A-Fã€‚åå…­è¿›åˆ¶çš„é­”åŠ›åœ¨äºä¸€ä¸ªåå…­è¿›åˆ¶æ•°å­—å¯ä»¥ç²¾ç¡®è¡¨ç¤ºå››ä¸ªæ¯”ç‰¹ï¼ˆä¸€ä¸ªâ€œåŠå­—èŠ‚â€ï¼‰ã€‚è¿™æ„å‘³ç€ä»»ä½•å­—èŠ‚ï¼ˆ8
    æ¯”ç‰¹ï¼‰éƒ½å¯ä»¥ç”±æ°å¥½ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°å­—å®Œç¾è¡¨ç¤ºã€‚
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s convert our "HELLO" sequence: `01001000` -> `0100` is `4`, `1000` is
    `8` -> `48` `01000101` -> `0100` is `4`, `0101` is `5` -> `45` `01001100` -> `0100`
    is `4`, `1100` is `C` -> `4C`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è½¬æ¢æˆ‘ä»¬çš„â€œHELLOâ€åºåˆ—ï¼š`01001000` -> `0100` æ˜¯ `4`ï¼Œ`1000` æ˜¯ `8` -> `48` `01000101`
    -> `0100` æ˜¯ `4`ï¼Œ`0101` æ˜¯ `5` -> `45` `01001100` -> `0100` æ˜¯ `4`ï¼Œ`1100` æ˜¯ `C` ->
    `4C`
- en: 'So, "HELLO" in hexadecimal is: `48 45 4C 4C 4F`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œâ€œHELLOâ€çš„åå…­è¿›åˆ¶è¡¨ç¤ºä¸ºï¼š`48 45 4C 4C 4F`ã€‚
- en: 'This is *exactly* what you see when you `console.log` a Buffer in Node: `<Buffer
    48 45 4c 4c 4f>`. Node is giving you this convenient, human-readable hexadecimal
    representation of the raw byte sequence. It''s not a different format; it''s just
    a different way of *displaying* the same underlying binary data.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯å½“ä½ ä½¿ç”¨ Node çš„ `console.log` æ‰“å° Buffer æ—¶ä½ æ‰€çœ‹åˆ°çš„**ç¡®åˆ‡**å†…å®¹ï¼š`<Buffer 48 45 4c 4c 4f>`ã€‚Node
    ç»™ä½ çš„æ˜¯åŸå§‹å­—èŠ‚åºåˆ—çš„æ–¹ä¾¿ã€å¯è¯»çš„åå…­è¿›åˆ¶è¡¨ç¤ºå½¢å¼ã€‚è¿™ä¸æ˜¯ä¸åŒçš„æ ¼å¼ï¼›è¿™åªæ˜¯æ˜¾ç¤ºç›¸åŒåº•å±‚äºŒè¿›åˆ¶æ•°æ®çš„ä¸åŒæ–¹å¼ã€‚
- en: 'Finally, what about numbers larger than 255? We just use more bytes. A 16-bit
    integer (two bytes) can store values up to 65,535\. A 32-bit integer (four bytes)
    can store values up to about 4.2 billion. But this introduces a new question:
    if a 16-bit number is made of two bytes, say `0x12` and `0x34`, in what order
    do we store them in memory?'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œå…³äºå¤§äº 255 çš„æ•°å­—æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬åªéœ€ä½¿ç”¨æ›´å¤šçš„å­—èŠ‚ã€‚ä¸€ä¸ª 16 ä½æ•´æ•°ï¼ˆä¸¤ä¸ªå­—èŠ‚ï¼‰å¯ä»¥å­˜å‚¨é«˜è¾¾ 65,535 çš„å€¼ã€‚ä¸€ä¸ª 32 ä½æ•´æ•°ï¼ˆå››ä¸ªå­—èŠ‚ï¼‰å¯ä»¥å­˜å‚¨é«˜è¾¾çº¦
    42 äº¿çš„å€¼ã€‚ä½†è¿™å¼•å…¥äº†ä¸€ä¸ªæ–°çš„é—®é¢˜ï¼šå¦‚æœä¸€ä¸ª 16 ä½æ•°å­—ç”±ä¸¤ä¸ªå­—èŠ‚ç»„æˆï¼Œæ¯”å¦‚è¯´ `0x12` å’Œ `0x34`ï¼Œæˆ‘ä»¬åœ¨å†…å­˜ä¸­æŒ‰ä»€ä¹ˆé¡ºåºå­˜å‚¨å®ƒä»¬ï¼Ÿ
- en: '`[0x12][0x34]` or `[0x34][0x12]`?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`[0x12][0x34]` æˆ– `[0x34][0x12]`ï¼Ÿ'
- en: This is the problem of **Endianness**. Systems that store the most significant
    byte first (`[0x12][0x34]`) are called **Big-Endian**. Systems that store the
    least significant byte first (`[0x34][0x12]`) are called **Little-Endian**. Networks
    generally use Big-Endian (it's often called "network byte order"), while many
    modern CPUs (like Intel/AMD x86) are Little-Endian. It's just another convention,
    another interpretation rule that software must agree on to communicate correctly.
    This is why you'll see methods like `buf.readInt16BE()` and `buf.readInt16LE()`
    later on - you have to tell Node which byte order to use for the interpretation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯**å­—èŠ‚åº**çš„é—®é¢˜ã€‚å­˜å‚¨æœ€é«˜æœ‰æ•ˆå­—èŠ‚å…ˆçš„ç³»ç»Ÿï¼ˆ`[0x12][0x34]`ï¼‰è¢«ç§°ä¸º**å¤§ç«¯**ã€‚å­˜å‚¨æœ€ä½æœ‰æ•ˆå­—èŠ‚å…ˆçš„ç³»ç»Ÿï¼ˆ`[0x34][0x12]`ï¼‰è¢«ç§°ä¸º**å°ç«¯**ã€‚ç½‘ç»œé€šå¸¸ä½¿ç”¨å¤§ç«¯ï¼ˆå¸¸ç§°ä¸ºâ€œç½‘ç»œå­—èŠ‚åºâ€ï¼‰ï¼Œè€Œè®¸å¤šç°ä»£
    CPUï¼ˆå¦‚ Intel/AMD x86ï¼‰æ˜¯å°ç«¯ã€‚è¿™åªæ˜¯å¦ä¸€ä¸ªçº¦å®šï¼Œå¦ä¸€ä¸ªè½¯ä»¶å¿…é¡»åŒæ„ä»¥æ­£ç¡®é€šä¿¡çš„è§£é‡Šè§„åˆ™ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆä½ ä¼šåœ¨åé¢çœ‹åˆ°åƒ `buf.readInt16BE()`
    å’Œ `buf.readInt16LE()` è¿™æ ·çš„æ–¹æ³•â€”â€”ä½ å¿…é¡»å‘Šè¯‰ Node ä½¿ç”¨å“ªç§å­—èŠ‚åºè¿›è¡Œè§£é‡Šã€‚
- en: â„¹ï¸Note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: Endianness is a classic "gotcha" when working with binary data from different
    sources (like network streams vs. local files). If you read a multi-byte number
    and get a value that seems wildly incorrect, mismatched endianness is one of the
    first things you should check.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å­—èŠ‚åºæ˜¯å¤„ç†æ¥è‡ªä¸åŒæ¥æºçš„äºŒè¿›åˆ¶æ•°æ®ï¼ˆå¦‚ç½‘ç»œæµä¸æœ¬åœ°æ–‡ä»¶ï¼‰æ—¶çš„ç»å…¸â€œé™·é˜±â€ã€‚å¦‚æœä½ è¯»å–ä¸€ä¸ªå¤šå­—èŠ‚æ•°å­—å¹¶å¾—åˆ°ä¸€ä¸ªçœ‹èµ·æ¥éå¸¸ä¸æ­£ç¡®çš„å€¼ï¼Œä¸åŒ¹é…çš„å­—èŠ‚åºæ˜¯ä½ åº”è¯¥é¦–å…ˆæ£€æŸ¥çš„äº‹æƒ…ä¹‹ä¸€ã€‚
- en: The "A-C-F" Trick for Memorizing Hex Characters
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: è®°å¿†åå…­è¿›åˆ¶å­—ç¬¦çš„â€œA-C-Fâ€æŠ€å·§
- en: Forget trying to memorize all six letters and their corresponding numbers at
    once. Your brain only needs to lock in three of them. **The Best Way is to Remember
    A, C, and F only.**
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸è¦è¯•å›¾ä¸€æ¬¡æ€§è®°å¿†æ‰€æœ‰å…­ä¸ªå­—æ¯åŠå…¶å¯¹åº”çš„æ•°å­—ã€‚ä½ çš„å¤§è„‘åªéœ€è¦é”å®šå…¶ä¸­ä¸‰ä¸ªã€‚**æœ€ä½³æ–¹æ³•æ˜¯åªè®°ä½ Aã€C å’Œ F**ã€‚
- en: Think of these three letters as your "anchors." All the other letters just fall
    into place around them. **A is 10.** This one's easy. It's the very first letter,
    coming right **A**fter the number 9\. i.e **A = 10**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™ä¸‰ä¸ªå­—æ¯è§†ä¸ºä½ çš„â€œé”šç‚¹â€ã€‚æ‰€æœ‰å…¶ä»–å­—æ¯éƒ½å›´ç»•å®ƒä»¬æ’åˆ—ã€‚**A æ˜¯ 10**ã€‚è¿™ä¸ªå¾ˆç®€å•ã€‚å®ƒæ˜¯ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œç´§**A**åœ¨æ•°å­— 9 çš„åé¢ã€‚å³ **A
    = 10**ã€‚
- en: '**C is 12.** Think of a **C**lock (C for Clock). A standard clock face has
    **12** hours. i.e **C = 12**.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**C æ˜¯ 12**ã€‚æƒ³è±¡ä¸€ä¸ª**æ—¶é’Ÿ**ï¼ˆC ä»£è¡¨ Clockï¼‰ã€‚ä¸€ä¸ªæ ‡å‡†çš„æ—¶é’Ÿé¢æœ‰ **12** ä¸ªå°æ—¶ã€‚å³ **C = 12**ã€‚'
- en: '**F is 15.** Think **F** for **F**ifteen. Or, think of it as the **F**inal
    or **F**ull value a single hex digit can hold. So, **F = 15**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**F æ˜¯ 15**ã€‚ç”¨ **F** æ¥è¡¨ç¤º **F**ifteenã€‚æˆ–è€…ï¼ŒæŠŠå®ƒçœ‹ä½œæ˜¯å•ä¸ªåå…­è¿›åˆ¶æ•°å­—å¯ä»¥æŒæœ‰çš„ **F**inal æˆ– **F**ull
    å€¼ã€‚æ‰€ä»¥ï¼Œ**F = 15**ã€‚'
- en: '**So, how do you get the others (B, D, E)?** They are simply the numbers *in
    between* your anchors!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**é‚£ä¹ˆï¼Œå¦‚ä½•å¾—åˆ°å…¶ä»–çš„ï¼ˆBã€Dã€Eï¼‰å‘¢ï¼Ÿ** å®ƒä»¬åªæ˜¯ä½ çš„é”šç‚¹ä¹‹é—´çš„ **æ•°å­—**ï¼'
- en: '**What is B?** It''s between A (10) and C (12). The only number between them
    is **11**. So, **B = 11**. Or even simpler, **B** is `A + 1`, or `11`. **What
    are D and E?** They are between C (12) and F (15). For D, remember it comes after
    **C**, and since **C** is 12, **D** is 13\. For **E**, it comes before **F**,
    so that''s **14**.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bæ˜¯ä»€ä¹ˆï¼Ÿ** å®ƒåœ¨Aï¼ˆ10ï¼‰å’ŒCï¼ˆ12ï¼‰ä¹‹é—´ã€‚å®ƒä»¬ä¹‹é—´çš„å”¯ä¸€æ•°å­—æ˜¯ **11**ã€‚æ‰€ä»¥ï¼Œ**B = 11**ã€‚æˆ–è€…æ›´ç®€å•ï¼Œ**B** æ˜¯ `A
    + 1`ï¼Œæˆ–è€… `11`ã€‚**Då’ŒEæ˜¯ä»€ä¹ˆï¼Ÿ** å®ƒä»¬åœ¨Cï¼ˆ12ï¼‰å’ŒFï¼ˆ15ï¼‰ä¹‹é—´ã€‚å¯¹äºDï¼Œè®°ä½å®ƒæ˜¯åœ¨ **C** ä¹‹åï¼Œè€Œ **C** æ˜¯12ï¼Œæ‰€ä»¥ **D**
    æ˜¯13ã€‚å¯¹äº **E**ï¼Œå®ƒæ˜¯åœ¨ **F** ä¹‹å‰ï¼Œæ‰€ä»¥æ˜¯ **14**ã€‚'
- en: That's it! By memorizing just three key letters with simple associations, you
    can instantly figure out all the others.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: å°±è¿™æ ·ï¼åªéœ€è®°ä½ä¸‰ä¸ªå…³é”®å­—æ¯åŠå…¶ç®€å•çš„å…³è”ï¼Œä½ å°±å¯ä»¥ç«‹å³æ‰¾å‡ºæ‰€æœ‰å…¶ä»–çš„å­—æ¯ã€‚
- en: '| Your Anchors | How to Remember | The "In-Betweens" |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| ä½ çš„é”šç‚¹ | å¦‚ä½•è®°å¿† | â€œä¸­é—´çš„â€ |'
- en: '| --- | --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **A = 10** | The first letter, **A**fter 9 |  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **A = 10** | ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œ**A**fter 9 |'
- en: '|  |  | **B = 11** (It''s between A & C) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **B = 11**ï¼ˆå®ƒåœ¨Aå’ŒCä¹‹é—´ï¼‰|'
- en: '| **C = 12** | A **C**lock has 12 hours |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **C = 12** | ä¸€ä¸ª **C**lockæœ‰12ä¸ªå°æ—¶ |  |'
- en: '|  |  | **D = 13** (It''s after C) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **D = 13**ï¼ˆå®ƒåœ¨Cä¹‹åï¼‰|'
- en: '|  |  | **E = 14** (It''s before F) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  |  | **E = 14**ï¼ˆå®ƒåœ¨Fä¹‹å‰ï¼‰|'
- en: '| **F = 15** | **F** is for **F**ifteen / **F**ull |  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **F = 15** | **F** æ˜¯ **F**ifteen / **F**ull |'
- en: How to Understand a Hexadecimal Byte
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å¦‚ä½•ç†è§£åå…­è¿›åˆ¶å­—èŠ‚
- en: A hexadecimal byte, like `B7` or `4E`, is simply a number written in the **base-16**
    system. While our everyday numbers are base-10 (using digits 0-9), hexadecimal
    uses sixteen symbols (0-9 and A-F). The key to understanding it is to recognize
    that a byte is **always represented by two hexadecimal digits**, and each digit
    has a specific place value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªåå…­è¿›åˆ¶å­—èŠ‚ï¼Œå¦‚ `B7` æˆ– `4E`ï¼Œå®é™…ä¸Šæ˜¯åœ¨ **åŸºæ•°ä¸º16** çš„ç³»ç»Ÿä¸­è¡¨ç¤ºçš„æ•°å­—ã€‚è™½ç„¶æˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„æ•°å­—æ˜¯åŸºæ•°ä¸º10ï¼ˆä½¿ç”¨æ•°å­—0-9ï¼‰ï¼Œä½†åå…­è¿›åˆ¶ä½¿ç”¨åå…­ä¸ªç¬¦å·ï¼ˆ0-9å’ŒA-Fï¼‰ã€‚ç†è§£å®ƒçš„å…³é”®æ˜¯è®¤è¯†åˆ°ä¸€ä¸ªå­—èŠ‚
    **æ€»æ˜¯ç”±ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°å­—è¡¨ç¤º**ï¼Œå¹¶ä¸”æ¯ä¸ªæ•°å­—éƒ½æœ‰ä¸€ä¸ªç‰¹å®šçš„ä½å€¼ã€‚
- en: The Two Place Values
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªä½å€¼
- en: Think of a two-digit hexadecimal number as having two columns or "places." The
    digit on the **right** is in the **"Ones Place"** (16â°). Its value is multiplied
    by 1\. The digit on the **left** is in the **"Sixteens Place"** (16Â¹). Its value
    is multiplied by 16.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å°†ä¸€ä¸ªä¸¤ä½æ•°çš„åå…­è¿›åˆ¶æ•°å­—çœ‹ä½œæœ‰ä¸¤ä¸ªåˆ—æˆ–â€œä½ç½®â€ã€‚å³è¾¹çš„æ•°å­—åœ¨ **â€œä¸ªä½â€**ï¼ˆ16â°ï¼‰ä¸­ã€‚å®ƒçš„å€¼ä¹˜ä»¥1ã€‚å·¦è¾¹çš„æ•°å­—åœ¨ **â€œåå…­ä½â€**ï¼ˆ16Â¹ï¼‰ä¸­ã€‚å®ƒçš„å€¼ä¹˜ä»¥16ã€‚
- en: '| Sixteens Place (value x 16) | Ones Place (value x 1) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| åå…­ä½ï¼ˆå€¼ä¹˜ä»¥16ï¼‰ | ä¸ªä½ï¼ˆå€¼ä¹˜ä»¥1ï¼‰ |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left Digit | Right Digit |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| å·¦è¾¹çš„æ•°å­— | å³è¾¹çš„æ•°å­— |'
- en: To find the total value, you calculate the value of each place and add them
    together. Let's convert the hexadecimal byte **`A9`** into a regular decimal number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ‰¾åˆ°æ€»å€¼ï¼Œä½ éœ€è¦è®¡ç®—æ¯ä¸ªä½ç½®çš„å€¼å¹¶å°†å®ƒä»¬ç›¸åŠ ã€‚è®©æˆ‘ä»¬å°†åå…­è¿›åˆ¶å­—èŠ‚ **`A9`** è½¬æ¢ä¸ºå¸¸è§„çš„åè¿›åˆ¶æ•°å­—ã€‚
- en: '`Step 1` Break the byte into its two digits. Left Digit is `A`. Right Digit
    is `9`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤ 1` å°†å­—èŠ‚åˆ†è§£ä¸ºå…¶ä¸¤ä¸ªæ•°å­—ã€‚å·¦è¾¹çš„æ•°å­—æ˜¯ `A`ã€‚å³è¾¹çš„æ•°å­—æ˜¯ `9`ã€‚'
- en: '`Step 2` Calculate the value of the left digit (the "Sixteens Place"). First,
    convert the hex character to its decimal number: `A = 10`. Now, multiply that
    number by 16 - `10 Ã— 16 = 160`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤ 2` è®¡ç®—å·¦è¾¹çš„æ•°å­—ï¼ˆâ€œåå…­ä½â€ï¼‰çš„å€¼ã€‚é¦–å…ˆï¼Œå°†åå…­è¿›åˆ¶å­—ç¬¦è½¬æ¢ä¸ºå®ƒçš„åè¿›åˆ¶æ•°å­—ï¼š`A = 10`ã€‚ç°åœ¨ï¼Œå°†è¿™ä¸ªæ•°å­—ä¹˜ä»¥16 - `10 Ã—
    16 = 160`ã€‚'
- en: '`Step 3` Calculate the value of the right digit (the "Ones Place"). The hex
    character `9` is already a decimal number: `9`. Multiply that number by 1 - `9
    Ã— 1 = 9`.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤ 3` è®¡ç®—å³è¾¹çš„æ•°å­—ï¼ˆâ€œä¸ªä½â€ï¼‰çš„å€¼ã€‚åå…­è¿›åˆ¶å­—ç¬¦ `9` å·²ç»æ˜¯åè¿›åˆ¶æ•°å­—ï¼š`9`ã€‚å°†è¿™ä¸ªæ•°å­—ä¹˜ä»¥1 - `9 Ã— 1 = 9`ã€‚'
- en: '`Step 4` Add the two values together. `160 + 9 = 169`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤ 4` å°†ä¸¤ä¸ªå€¼ç›¸åŠ ã€‚`160 + 9 = 169`ã€‚'
- en: Therefore, the hexadecimal byte **`A9`** represents the decimal number **169**.
    Don't worry, you'll get used to it and it will take a matter of weeks, if not
    days for your brain to start finding out the patterns to convert hexadecimal values
    within seconds.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåå…­è¿›åˆ¶å­—èŠ‚ **`A9`** è¡¨ç¤ºçš„åè¿›åˆ¶æ•°å­—æ˜¯ **169**ã€‚åˆ«æ‹…å¿ƒï¼Œä½ ä¼šä¹ æƒ¯çš„ï¼Œè€Œä¸”å¤§è„‘å¼€å§‹æ‰¾åˆ°è½¬æ¢åå…­è¿›åˆ¶å€¼çš„æ¨¡å¼å¯èƒ½åªéœ€è¦å‡ å‘¨ï¼Œç”šè‡³å‡ å¤©ã€‚
- en: Another Example, convert `C5`
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªä¾‹å­ï¼Œè½¬æ¢ `C5`
- en: Let's do one more to make it crystal clear.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†åšä¸€ä¸ªï¼Œè®©å®ƒæ›´æ¸…æ™°ã€‚
- en: '`Step 1` Break the digits. `C` (left) and `5` (right).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤ 1` åˆ†è§£æ•°å­—ã€‚`C`ï¼ˆå·¦ï¼‰å’Œ`5`ï¼ˆå³ï¼‰ã€‚'
- en: '`Step 2` Convert `C` to decimal: `C = 12`. Multiply by its place value: `12
    Ã— 16 = 192`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤ 2` å°† `C` è½¬æ¢ä¸ºåè¿›åˆ¶ï¼š`C = 12`ã€‚ä¹˜ä»¥å…¶ä½å€¼ï¼š`12 Ã— 16 = 192`ã€‚'
- en: '`Step 3` Convert `5` to decimal: `5`. Multiply by its place value: `5 Ã— 1 =
    5`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤3` å°† `5` è½¬æ¢ä¸ºåè¿›åˆ¶ï¼š`5`ã€‚ä¹˜ä»¥å…¶ä½å€¼ï¼š`5 Ã— 1 = 5`ã€‚'
- en: '`Step 4` Add them up i.e `192 + 5 = 197`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`æ­¥éª¤4` å°†å®ƒä»¬åŠ èµ·æ¥ï¼Œå³ `192 + 5 = 197`ã€‚'
- en: So, the hexadecimal byte **`C5`** is the decimal number **197**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œåå…­è¿›åˆ¶å­—èŠ‚**`C5`**æ˜¯åè¿›åˆ¶æ•°**197**ã€‚
- en: '**Why is it used?** This system is incredibly efficient for computers. A single
    byte is made of 8 bits (0s and 1s). One hexadecimal digit perfectly represents
    4 bits, so two hex digits perfectly represent all 8 bits of a byte. It''s much
    easier for a person to read and write `C5` than the binary equivalent `11000101`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¸ºä»€ä¹ˆå®ƒè¢«ä½¿ç”¨ï¼Ÿ**è¿™ä¸ªç³»ç»Ÿå¯¹è®¡ç®—æœºæ¥è¯´æ•ˆç‡éå¸¸é«˜ã€‚ä¸€ä¸ªå­—èŠ‚ç”±8ä½ï¼ˆ0så’Œ1sï¼‰ç»„æˆã€‚ä¸€ä¸ªåå…­è¿›åˆ¶æ•°å­—å®Œç¾åœ°ä»£è¡¨4ä½ï¼Œæ‰€ä»¥ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°å­—å®Œç¾åœ°ä»£è¡¨ä¸€ä¸ªå­—èŠ‚çš„å…¨éƒ¨8ä½ã€‚å¯¹äºä¸€ä¸ªäººæ¥è¯´ï¼Œé˜…è¯»å’Œå†™å…¥`C5`æ¯”äºŒè¿›åˆ¶çš„ç­‰æ•ˆå€¼`11000101`è¦å®¹æ˜“å¾—å¤šã€‚'
- en: Tying It All Back
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: å°†æ‰€æœ‰å†…å®¹ä¸²è”èµ·æ¥
- en: Okay, crash course over. Let's connect this back to Node.js.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œå¿«é€Ÿè¯¾ç¨‹åˆ°æ­¤ç»“æŸã€‚è®©æˆ‘ä»¬å°†å…¶ä¸Node.jsè”ç³»èµ·æ¥ã€‚
- en: When `fs.readFileSync('logo.png')` runs, what Node gets from the operating system
    is a raw sequence of bytes. It's a stream of `01001001`s and `11101010`s. These
    bytes represent pixel colors, image dimensions, and compression metadata, all
    according to the rules of the PNG file format specification. They are *not* intended
    to be interpreted as text according to the rules of ASCII or UTF-8.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ `fs.readFileSync('logo.png')` è¿è¡Œæ—¶ï¼ŒNodeä»æ“ä½œç³»ç»Ÿè·å–çš„æ˜¯ä¸€ç³»åˆ—åŸå§‹çš„å­—èŠ‚ã€‚å®ƒæ˜¯ä¸€ä¸² `01001001`s å’Œ
    `11101010`sã€‚è¿™äº›å­—èŠ‚ä»£è¡¨åƒç´ é¢œè‰²ã€å›¾åƒå°ºå¯¸å’Œå‹ç¼©å…ƒæ•°æ®ï¼Œæ‰€æœ‰è¿™äº›éƒ½éµå¾ªPNGæ–‡ä»¶æ ¼å¼è§„èŒƒã€‚å®ƒä»¬**ä¸æ˜¯**æ ¹æ®ASCIIæˆ–UTF-8çš„è§„åˆ™è¢«è§£é‡Šä¸ºæ–‡æœ¬ã€‚
- en: The core problem we are about to explore is the catastrophic consequence of
    telling JavaScript to apply the wrong set of interpretation rules to this data.
    We're about to ask it to read a love letter written in the language of pixels
    using a dictionary designed for human words. The result, as you'll see, is chaos.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å³å°†æ¢è®¨çš„æ ¸å¿ƒé—®é¢˜æ˜¯å‘Šè¯‰JavaScriptå¯¹è¿™ç»„æ•°æ®è¿›è¡Œé”™è¯¯è§£é‡Šè§„åˆ™åº”ç”¨çš„ç¾éš¾æ€§åæœã€‚æˆ‘ä»¬å³å°†è¦æ±‚å®ƒä½¿ç”¨ä¸ºäººç±»æ–‡å­—è®¾è®¡çš„å­—å…¸æ¥è¯»å–ç”¨åƒç´ è¯­è¨€å†™çš„æƒ…ä¹¦ã€‚ç»“æœï¼Œæ­£å¦‚ä½ å°†çœ‹åˆ°çš„ï¼Œæ˜¯æ··ä¹±ã€‚
- en: Now, with this solid foundation of what a byte truly is, let's watch it all
    go wrong.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæœ‰äº†å¯¹å­—èŠ‚çœŸæ­£æ˜¯ä»€ä¹ˆçš„åšå®åŸºç¡€ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å®ƒå¦‚ä½•å…¨éƒ¨å‡ºé”™ã€‚
- en: A real demo of why text fails
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸€ä¸ªçœŸå®çš„ä¸ºä»€ä¹ˆæ–‡æœ¬å¤±è´¥çš„æ¼”ç¤º
- en: 'Suppose we have a simple PNG image file in our project directory, say `logo.png`.
    It''s a binary file. Our task is simple: read it into memory and then write it
    back out to a new file, `logo-copy.png`. A simple file copy operation.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬åœ¨é¡¹ç›®ç›®å½•ä¸­æœ‰ä¸€ä¸ªç®€å•çš„PNGå›¾åƒæ–‡ä»¶ï¼Œæ¯”å¦‚ `logo.png`ã€‚å®ƒæ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ã€‚æˆ‘ä»¬çš„ä»»åŠ¡å¾ˆç®€å•ï¼šå°†å…¶è¯»å…¥å†…å­˜ï¼Œç„¶åå°†å…¶å†™å›åˆ°ä¸€ä¸ªæ–°çš„æ–‡ä»¶ä¸­ï¼Œ`logo-copy.png`ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•çš„æ–‡ä»¶å¤åˆ¶æ“ä½œã€‚
- en: Based on our existing knowledge of Node's `fs` module, the naive attempt looks
    perfectly reasonable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ®æˆ‘ä»¬å¯¹Nodeçš„`fs`æ¨¡å—çš„ç°æœ‰çŸ¥è¯†ï¼Œè¿™ç§å¤©çœŸå°è¯•çœ‹èµ·æ¥å®Œå…¨åˆç†ã€‚
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s run this. You''ll need a `logo.png` file in the same directory.
    The output will look something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬è¿è¡Œè¿™ä¸ªç¨‹åºã€‚ä½ éœ€è¦åœ¨åŒä¸€ç›®å½•ä¸‹æœ‰ä¸€ä¸ª `logo.png` æ–‡ä»¶ã€‚è¾“å‡ºå°†ç±»ä¼¼äºä»¥ä¸‹å†…å®¹ï¼š
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first clue that something is deeply wrong is that sample output. It''s
    a mess of weird symbols and, most notably, those diamond-shaped question marks:
    `ï¿½`. That''s not just a random character; it''s a specific Unicode character with
    a very important meaning, which we''ll get to in a moment.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªè¡¨æ˜äº‹æƒ…ä¸¥é‡é”™è¯¯çš„çº¿ç´¢æ˜¯æ ·æœ¬è¾“å‡ºã€‚å®ƒæ˜¯ä¸€å †å¥‡æ€ªçš„ç¬¦å·çš„æ··ä¹±ï¼Œæœ€å€¼å¾—æ³¨æ„çš„æ˜¯é‚£äº›è±å½¢é—®å·ï¼š`ï¿½`ã€‚è¿™ä¸ä»…ä»…æ˜¯ä¸€ä¸ªéšæœºå­—ç¬¦ï¼›å®ƒæ˜¯ä¸€ä¸ªå…·æœ‰éå¸¸é‡è¦æ„ä¹‰çš„ç‰¹å®šUnicodeå­—ç¬¦ï¼Œæˆ‘ä»¬å°†åœ¨ç¨åè§£é‡Šã€‚
- en: But the truly damning evidence comes when you check your file system. You'll
    find a new file, `logo-corrupted.png`. Compare its file size to the original `logo.png`.
    The corrupted version will almost certainly be smaller. And if you try to open
    it with an image viewer, it will fail. It's broken. We haven't copied the data;
    we've actively destroyed it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†çœŸæ­£ä»¤äººä¿¡æœçš„è¯æ®å‡ºç°åœ¨ä½ æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿæ—¶ã€‚ä½ ä¼šå‘ç°ä¸€ä¸ªæ–°çš„æ–‡ä»¶ï¼Œ`logo-corrupted.png`ã€‚å°†å…¶æ–‡ä»¶å¤§å°ä¸åŸå§‹çš„ `logo.png`
    è¿›è¡Œæ¯”è¾ƒã€‚æŸåçš„ç‰ˆæœ¬å‡ ä¹è‚¯å®šä¼šæ›´å°ã€‚å¦‚æœä½ å°è¯•ç”¨å›¾åƒæŸ¥çœ‹å™¨æ‰“å¼€å®ƒï¼Œå®ƒå°†å¤±è´¥ã€‚å®ƒå·²ç»æŸåäº†ã€‚æˆ‘ä»¬æ²¡æœ‰å¤åˆ¶æ•°æ®ï¼›æˆ‘ä»¬å®é™…ä¸Šç ´åäº†å®ƒã€‚
- en: So what just happened? This wasn't a bug in Node.js. It was a fundamental misunderstanding
    of what we were asking it to do.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œåˆšæ‰å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿè¿™ä¸æ˜¯Node.jsçš„bugã€‚è¿™æ˜¯ä¸€ä¸ªå¯¹æˆ‘ä»¬è¦æ±‚å®ƒåšä»€ä¹ˆçš„æ ¹æœ¬æ€§è¯¯è§£ã€‚
- en: 'To unravel this, we need to back up and ask a critical question: what *is*
    a JavaScript string? It''s tempting to think of it as an array of bytes, but as
    we''ve just established, that''s not right. **A JavaScript string is an immutable
    sequence of *characters*.** Internally, the V8 engine represents these characters
    using a format that is usually UTF-16\. The crucial takeaway is that a string
    is an abstraction layer. It''s not the raw bytes; it''s an *interpretation* of
    raw bytes according to a set of linguistic and symbolic rules (Unicode).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†è§£å¼€è¿™ä¸ªè°œå›¢ï¼Œæˆ‘ä»¬éœ€è¦å›é¡¾å¹¶é—®ä¸€ä¸ªå…³é”®é—®é¢˜ï¼šJavaScript å­—ç¬¦ä¸²ç©¶ç«Ÿæ˜¯ä»€ä¹ˆï¼ŸæŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªå­—èŠ‚æ•°ç»„å¾ˆè¯±äººï¼Œä½†æ­£å¦‚æˆ‘ä»¬åˆšæ‰æ‰€ç¡®ç«‹çš„ï¼Œé‚£æ˜¯ä¸æ­£ç¡®çš„ã€‚**JavaScript
    å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªä¸å¯å˜çš„å­—ç¬¦åºåˆ—**ã€‚å†…éƒ¨ï¼ŒV8 å¼•æ“ä½¿ç”¨é€šå¸¸ä¸º UTF-16 çš„æ ¼å¼æ¥è¡¨ç¤ºè¿™äº›å­—ç¬¦ã€‚å…³é”®çš„ä¸€ç‚¹æ˜¯ï¼Œå­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªæŠ½è±¡å±‚ã€‚å®ƒä¸æ˜¯åŸå§‹å­—èŠ‚ï¼›å®ƒæ˜¯æ ¹æ®ä¸€ç»„è¯­è¨€å’Œç¬¦å·è§„åˆ™ï¼ˆUnicodeï¼‰å¯¹åŸå§‹å­—èŠ‚çš„è§£é‡Šã€‚
- en: 'This brings us to the heart of the problem: the `''utf8''` argument we passed
    to `readFileSync`. When we provided that encoding, we weren''t just telling Node
    to read the file. We were issuing a command: "Read the sequence of raw bytes from
    `logo.png`, and I want you to *decode* them, interpreting them as a valid UTF-8
    text sequence."'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æŠŠæˆ‘ä»¬å¸¦åˆ°äº†é—®é¢˜çš„æ ¸å¿ƒï¼šæˆ‘ä»¬ä¼ é€’ç»™ `readFileSync` çš„ `'utf8'` å‚æ•°ã€‚å½“æˆ‘ä»¬æä¾›è¿™ä¸ªç¼–ç æ—¶ï¼Œæˆ‘ä»¬ä¸ä»…ä»…æ˜¯å‘Šè¯‰ Node è¯»å–æ–‡ä»¶ã€‚æˆ‘ä»¬å‘å‡ºäº†ä¸€ä¸ªå‘½ä»¤ï¼šâ€œä»
    `logo.png` è¯»å–ä¸€ç³»åˆ—åŸå§‹å­—èŠ‚ï¼Œå¹¶ä¸”æˆ‘å¸Œæœ›ä½ å°†å®ƒä»¬è§£ç ï¼Œå°†å®ƒä»¬è§£é‡Šä¸ºæœ‰æ•ˆçš„ UTF-8 æ–‡æœ¬åºåˆ—ã€‚â€
- en: This is the UTF-8 trap. A PNG file is a highly structured binary format. Its
    bytes represent pixels, compression metadata, color palettes, and checksums. They
    are *not* structured to represent text. Let's look at the first four bytes of
    virtually any PNG file, known as the "magic number" that identifies it as a PNG.
    In hexadecimal, they are `89 50 4E 47`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ª UTF-8 çš„é™·é˜±ã€‚PNG æ–‡ä»¶æ˜¯ä¸€ä¸ªé«˜åº¦ç»“æ„çš„äºŒè¿›åˆ¶æ ¼å¼ã€‚å®ƒçš„å­—èŠ‚è¡¨ç¤ºåƒç´ ã€å‹ç¼©å…ƒæ•°æ®ã€è°ƒè‰²æ¿å’Œæ ¡éªŒå’Œã€‚å®ƒä»¬ä¸æ˜¯ç”¨æ¥è¡¨ç¤ºæ–‡æœ¬çš„ã€‚è®©æˆ‘ä»¬çœ‹çœ‹å‡ ä¹ä»»ä½•
    PNG æ–‡ä»¶çš„ç¬¬ä¸€ä¸ªå››ä¸ªå­—èŠ‚ï¼Œè¢«ç§°ä¸ºâ€œé­”æ•°â€ï¼Œå®ƒæ ‡è¯†äº†å®ƒæ˜¯ä¸€ä¸ª PNG æ–‡ä»¶ã€‚ç”¨åå…­è¿›åˆ¶è¡¨ç¤ºï¼Œå®ƒä»¬æ˜¯ `89 50 4E 47`ã€‚
- en: When Node's UTF-8 decoder encounters the byte `0x89`, it immediately hits a
    problem. In UTF-8, any byte value greater than `0x7F` (127) signals the start
    of a multi-byte character sequence. The specific value `0x89` is not a valid starting
    byte for any multi-byte sequence in the UTF-8 specification. The decoder is now
    stuck. It has encountered a byte that has no meaning in the language of UTF-8.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ Node çš„ UTF-8 è§£ç å™¨é‡åˆ°å­—èŠ‚ `0x89` æ—¶ï¼Œå®ƒä¼šç«‹å³é‡åˆ°é—®é¢˜ã€‚åœ¨ UTF-8 ä¸­ï¼Œä»»ä½•å¤§äº `0x7F`ï¼ˆ127ï¼‰çš„å­—èŠ‚å€¼éƒ½è¡¨ç¤ºå¤šå­—èŠ‚å­—ç¬¦åºåˆ—çš„å¼€å§‹ã€‚ç‰¹å®šçš„å€¼
    `0x89` åœ¨ UTF-8 è§„èŒƒä¸­ä¸æ˜¯ä»»ä½•å¤šå­—èŠ‚åºåˆ—çš„æœ‰æ•ˆèµ·å§‹å­—èŠ‚ã€‚è§£ç å™¨ç°åœ¨é™·å…¥äº†å›°å¢ƒã€‚å®ƒé‡åˆ°äº†åœ¨ UTF-8 è¯­è¨€ä¸­æ²¡æœ‰æ„ä¹‰çš„å­—èŠ‚ã€‚
- en: What does a well-behaved decoder do when it finds an invalid byte sequence?
    It can't just crash. It has to produce *something*. So, it emits `U+FFFD`, the
    official Unicode "Replacement Character". That's the `ï¿½` you saw in the console.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: å½“è§£ç å™¨å‘ç°æ— æ•ˆçš„å­—èŠ‚åºåˆ—æ—¶ï¼Œå®ƒä¼šåšä»€ä¹ˆï¼Ÿå®ƒä¸èƒ½åªæ˜¯å´©æºƒã€‚å®ƒå¿…é¡»äº§ç”ŸæŸç§ä¸œè¥¿ã€‚æ‰€ä»¥ï¼Œå®ƒå‘å‡º `U+FFFD`ï¼Œè¿™æ˜¯å®˜æ–¹çš„ Unicode â€œæ›¿æ¢å­—ç¬¦â€ã€‚é‚£å°±æ˜¯ä½ åœ¨æ§åˆ¶å°çœ‹åˆ°çš„
    `ï¿½`ã€‚
- en: âš ï¸Warning
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸è­¦å‘Š
- en: The appearance of the replacement character `ï¿½` is a red flag. It signifies
    that an irreversible, lossy conversion has occurred. The original byte sequence
    that the decoder could not understand has been discarded and replaced. Your data
    is now permanently corrupted.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: æ›¿æ¢å­—ç¬¦ `ï¿½` çš„å‡ºç°æ˜¯ä¸€ä¸ªçº¢æ——ã€‚å®ƒè¡¨ç¤ºå‘ç”Ÿäº†ä¸å¯é€†çš„ã€æœ‰æŸçš„è½¬æ¢ã€‚è§£ç å™¨æ— æ³•ç†è§£çš„åŸå§‹å­—èŠ‚åºåˆ—å·²è¢«ä¸¢å¼ƒå¹¶æ›¿æ¢ã€‚æ‚¨çš„æ•°æ®ç°åœ¨æ°¸ä¹…æŸåã€‚
- en: This is an irreversible, lossy conversion. The decoder threw away the original
    `0x89` byte and replaced it with the three bytes that represent `ï¿½` in UTF-8 (`EF
    BF BD`). The original information is gone. Forever. It did this for every single
    byte or sequence of bytes in the file that didn't conform to the strict rules
    of UTF-8\. This is why our `logo-corrupted.png` was a different size and why it
    was full of junk. We didn't store the file's data; we stored the wreckage of a
    failed decoding attempt.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªä¸å¯é€†çš„ã€æœ‰æŸçš„è½¬æ¢ã€‚è§£ç å™¨ä¸¢å¼ƒäº†åŸå§‹çš„ `0x89` å­—èŠ‚ï¼Œå¹¶ç”¨è¡¨ç¤º UTF-8 ä¸­ `ï¿½` çš„ä¸‰ä¸ªå­—èŠ‚ï¼ˆ`EF BF BD`ï¼‰æ›¿æ¢äº†å®ƒã€‚åŸå§‹ä¿¡æ¯å·²ç»æ¶ˆå¤±ã€‚æ°¸è¿œæ¶ˆå¤±ã€‚å®ƒå¯¹æ–‡ä»¶ä¸­æ¯ä¸ªä¸ç¬¦åˆ
    UTF-8 ä¸¥æ ¼è§„åˆ™çš„å•ç‹¬å­—èŠ‚æˆ–å­—èŠ‚åºåˆ—éƒ½è¿™æ ·åšã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬çš„ `logo-corrupted.png` å¤§å°ä¸åŒï¼Œä¸ºä»€ä¹ˆå®ƒå……æ»¡äº†åƒåœ¾ã€‚æˆ‘ä»¬æ²¡æœ‰å­˜å‚¨æ–‡ä»¶çš„æ•°æ®ï¼›æˆ‘ä»¬å­˜å‚¨äº†å¤±è´¥è§£ç å°è¯•çš„æ®‹éª¸ã€‚
- en: Now, a clever developer might ask, "But wait, what about other encodings? What
    if I used `'latin1'` or the old `'binary'` encoding?"
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œä¸€ä¸ªèªæ˜çš„å¼€å‘è€…å¯èƒ½ä¼šé—®ï¼Œâ€œä½†æ˜¯ç­‰ç­‰ï¼Œå…¶ä»–ç¼–ç æ€ä¹ˆåŠï¼Ÿå¦‚æœæˆ‘ä½¿ç”¨äº† `'latin1'` æˆ–æ—§çš„ `'binary'` ç¼–ç å‘¢ï¼Ÿâ€
- en: This is a great question that leads to an even deeper insight. Let's try `'latin1'`.
    The `latin1` (or ISO-8859-1) encoding is special because it defines a one-to-one
    mapping for byte values from 0 to 255 to the first 256 Unicode code points. If
    you try the copy script with `'latin1'`, the round trip might actually *work*.
    The resulting file might be identical to the original.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„é—®é¢˜ï¼Œå®ƒå¼•å‡ºäº†æ›´æ·±å±‚æ¬¡çš„è§è§£ã€‚è®©æˆ‘ä»¬å°è¯•ä½¿ç”¨`'latin1'`ã€‚`latin1`ï¼ˆæˆ–ISO-8859-1ï¼‰ç¼–ç æ˜¯ç‰¹æ®Šçš„ï¼Œå› ä¸ºå®ƒå®šä¹‰äº†ä»0åˆ°255çš„å­—èŠ‚å€¼åˆ°å‰256ä¸ªUnicodeä»£ç ç‚¹çš„ä¸€å¯¹ä¸€æ˜ å°„ã€‚å¦‚æœä½ å°è¯•ä½¿ç”¨`'latin1'`å¤åˆ¶è„šæœ¬ï¼Œå¾€è¿”å¯èƒ½å®é™…ä¸Š*ä¼šå·¥ä½œ*ã€‚ç”Ÿæˆçš„æ–‡ä»¶å¯èƒ½ä¸åŸå§‹æ–‡ä»¶å®Œå…¨ç›¸åŒã€‚
- en: So, problem solved? Absolutely not. This is a dangerous and misleading hack.
    Even though it might appear to preserve the data, you've still forced the JavaScript
    engine to treat your binary data *as text*. It's now a string. This means V8 might
    perform internal optimizations on it that are designed for text, not for arbitrary
    binary data. More importantly, it's semantically incorrect. You're lying to the
    runtime about what your data represents. You're holding a sequence of pixel data
    and telling the engine, "This is a sequence of European linguistic characters."
    This can lead to subtle, horrifying bugs when you pass that "string" to other
    APIs that expect actual text.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œé—®é¢˜è§£å†³äº†å—ï¼Ÿç»å¯¹æ²¡æœ‰ã€‚è¿™æ˜¯ä¸€ä¸ªå±é™©ä¸”è¯¯å¯¼æ€§çš„æŠ€å·§ã€‚å°½ç®¡å®ƒå¯èƒ½çœ‹èµ·æ¥ä¿ç•™äº†æ•°æ®ï¼Œä½†ä½ ä»ç„¶è¿«ä½¿JavaScriptå¼•æ“å°†ä½ çš„äºŒè¿›åˆ¶æ•°æ®*ä½œä¸ºæ–‡æœ¬*å¤„ç†ã€‚ç°åœ¨å®ƒæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¿™æ„å‘³ç€V8å¯èƒ½ä¼šå¯¹å…¶æ‰§è¡Œé’ˆå¯¹æ–‡æœ¬è®¾è®¡çš„å†…éƒ¨ä¼˜åŒ–ï¼Œè€Œä¸æ˜¯ä»»æ„äºŒè¿›åˆ¶æ•°æ®ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œè¿™åœ¨è¯­ä¹‰ä¸Šæ˜¯ä¸æ­£ç¡®çš„ã€‚ä½ å‘è¿è¡Œæ—¶æ’’è°ï¼Œå…³äºä½ çš„æ•°æ®ä»£è¡¨ä»€ä¹ˆã€‚ä½ æ‹¿ç€ä¸€ç³»åˆ—åƒç´ æ•°æ®ï¼Œå‘Šè¯‰å¼•æ“ï¼Œâ€œè¿™æ˜¯ä¸€ç³»åˆ—æ¬§æ´²è¯­è¨€å­—ç¬¦çš„åºåˆ—ã€‚â€å½“ä½ å°†è¿™ä¸ªâ€œå­—ç¬¦ä¸²â€ä¼ é€’ç»™æœŸæœ›å®é™…æ–‡æœ¬çš„å…¶ä»–APIæ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´å¾®å¦™çš„ã€ä»¤äººææƒ§çš„é”™è¯¯ã€‚
- en: ğŸš¨Caution
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸš¨è­¦å‘Š
- en: Using `'latin1'` to "preserve" binary data in a string is a fragile hack that
    should be avoided. It is semantically incorrect and can lead to unexpected behavior
    with other APIs or future JavaScript engine optimizations. The correct solution
    is to not use strings for binary data at all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨`'latin1'`æ¥â€œä¿ç•™â€å­—ç¬¦ä¸²ä¸­çš„äºŒè¿›åˆ¶æ•°æ®æ˜¯ä¸€ç§è„†å¼±çš„æŠ€å·§ï¼Œåº”è¯¥é¿å…ä½¿ç”¨ã€‚è¿™åœ¨è¯­ä¹‰ä¸Šæ˜¯ä¸æ­£ç¡®çš„ï¼Œå¹¶ä¸”å¯èƒ½å¯¼è‡´ä¸å…¶ä»–APIæˆ–æœªæ¥JavaScriptå¼•æ“ä¼˜åŒ–ä¸é¢„æœŸçš„è¡Œä¸ºã€‚æ­£ç¡®çš„è§£å†³æ–¹æ¡ˆæ˜¯å®Œå…¨ä¸ä½¿ç”¨å­—ç¬¦ä¸²æ¥å¤„ç†äºŒè¿›åˆ¶æ•°æ®ã€‚
- en: The problem isn't the *choice* of encoding. The problem is the act of *decoding*
    in the first place. We don't want to interpret the bytes as text. We want to hold
    the bytes, raw and unadulterated. We need a data structure that represents a pure,
    uninterpreted sequence of bytes. And that's something JavaScript, by itself, simply
    did not have.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: é—®é¢˜ä¸åœ¨äºç¼–ç çš„é€‰æ‹©ã€‚é—®é¢˜åœ¨äºè§£ç çš„è¡Œä¸ºæœ¬èº«ã€‚æˆ‘ä»¬ä¸æƒ³å°†å­—èŠ‚è§£é‡Šä¸ºæ–‡æœ¬ã€‚æˆ‘ä»¬æƒ³è¦ä¿ç•™å­—èŠ‚ï¼ŒåŸå§‹ä¸”æœªè¢«æ±¡æŸ“ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªè¡¨ç¤ºçº¯ã€æœªè§£é‡Šçš„å­—èŠ‚åºåˆ—çš„æ•°æ®ç»“æ„ã€‚è€ŒJavaScriptæœ¬èº«å¹¶æ²¡æœ‰è¿™æ ·çš„ç»“æ„ã€‚
- en: Why Node Needed Its Own Memory
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¸ºä»€ä¹ˆNodeéœ€è¦è‡ªå·±çš„å†…å­˜
- en: Okay, so we've established that strings are the wrong tool for the job. We need
    a new tool, a data structure that's essentially just an array of bytes. Before
    we introduce Node's solution, the `Buffer`, we have to understand a critical piece
    of system architecture. The question isn't just *what* a Buffer is, but *where*
    it lives in memory. And the answer is genuinely clever.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å·²ç»ç¡®å®šå­—ç¬¦ä¸²ä¸æ˜¯å®Œæˆè¿™é¡¹å·¥ä½œçš„æ­£ç¡®å·¥å…·ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–°çš„å·¥å…·ï¼Œä¸€ä¸ªæœ¬è´¨ä¸Šåªæ˜¯å­—èŠ‚æ•°ç»„çš„æ•°æ®åº“ç»“æ„ã€‚åœ¨æˆ‘ä»¬ä»‹ç»Nodeçš„è§£å†³æ–¹æ¡ˆï¼Œå³`Buffer`ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»ç†è§£ä¸€ä¸ªå…³é”®çš„ç³»ç»Ÿæ¶æ„é—®é¢˜ã€‚é—®é¢˜ä¸ä»…ä»…æ˜¯`Buffer`æ˜¯ä»€ä¹ˆï¼Œè€Œæ˜¯å®ƒåœ¨å†…å­˜ä¸­çš„ä½ç½®ã€‚ç­”æ¡ˆæ˜¯çœŸæ­£å·§å¦™çš„ã€‚
- en: 'Let''s quickly revisit V8''s world, which we touched on in a previous chapter.
    The V8 engine manages its memory in a region we call the V8 heap. This is a highly
    sophisticated environment, constantly being monitored and cleaned up by a world-class
    garbage collector (GC). The GC is optimized for a very specific workload: managing
    the lifecycle of many small, highly interconnected JavaScript objects. It''s brilliant
    at cleaning up after strings, objects, arrays, and closures that have short-to-medium
    lifetimes.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å¿«é€Ÿå›é¡¾ä¸€ä¸‹V8çš„ä¸–ç•Œï¼Œæˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­æåˆ°äº†å®ƒã€‚V8å¼•æ“åœ¨å…¶ç§°ä¸ºV8å †çš„åŒºåŸŸä¸­ç®¡ç†å…¶å†…å­˜ã€‚è¿™æ˜¯ä¸€ä¸ªé«˜åº¦å¤æ‚çš„ç¯å¢ƒï¼Œç”±ä¸–ç•Œçº§çš„åƒåœ¾æ”¶é›†å™¨ï¼ˆGCï¼‰ä¸æ–­ç›‘æ§å’Œæ¸…ç†ã€‚GCé’ˆå¯¹ä¸€ä¸ªéå¸¸ç‰¹å®šçš„è´Ÿè½½è¿›è¡Œäº†ä¼˜åŒ–ï¼šç®¡ç†è®¸å¤šå°å‹ã€é«˜åº¦äº’è”çš„JavaScriptå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸã€‚å®ƒåœ¨æ¸…ç†å­—ç¬¦ä¸²ã€å¯¹è±¡ã€æ•°ç»„å’Œé—­åŒ…æ–¹é¢éå¸¸å‡ºè‰²ï¼Œè¿™äº›å¯¹è±¡å…·æœ‰çŸ­åˆ°ä¸­ç­‰çš„ç”Ÿå‘½å‘¨æœŸã€‚
- en: Now, let's introduce a nightmare scenario for this garbage collector. Imagine
    our image processing service doesn't just need to read 512 bytes, but instead
    needs to load an entire 500MB video file into memory for analysis.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä»‹ç»ä¸€ä¸ªå¯¹åƒåœ¾æ”¶é›†å™¨æ¥è¯´çš„å™©æ¢¦åœºæ™¯ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬çš„å›¾åƒå¤„ç†æœåŠ¡ä¸ä»…éœ€è¦è¯»å–512å­—èŠ‚ï¼Œè€Œæ˜¯éœ€è¦å°†æ•´ä¸ª500MBçš„è§†é¢‘æ–‡ä»¶åŠ è½½åˆ°å†…å­˜ä¸­è¿›è¡Œåˆ†æã€‚
- en: If we were to design a new "byte array" data type that lived on the V8 heap,
    allocating that 500MB object would be the first problem. But the real catastrophe
    would happen during garbage collection. V8's GC, particularly during major collection
    cycles, needs to walk the entire graph of live objects and, in many cases, move
    them around to compact memory and prevent fragmentation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬è¦è®¾è®¡ä¸€ä¸ªæ–°çš„â€œå­—èŠ‚æ•°ç»„â€æ•°æ®ç±»å‹ï¼Œå®ƒä½äºV8å †ä¸Šï¼Œåˆ†é…é‚£ä¸ª500MBçš„å¯¹è±¡å°†æ˜¯ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚ä½†çœŸæ­£çš„ç¾éš¾å°†åœ¨åƒåœ¾å›æ”¶æœŸé—´å‘ç”Ÿã€‚V8çš„GCï¼Œå°¤å…¶æ˜¯åœ¨ä¸»è¦æ”¶é›†å‘¨æœŸä¸­ï¼Œéœ€è¦éå†æ•´ä¸ªæ´»åŠ¨å¯¹è±¡å›¾ï¼Œå¹¶åœ¨è®¸å¤šæƒ…å†µä¸‹ç§»åŠ¨å®ƒä»¬ä»¥å‹ç¼©å†…å­˜å¹¶é˜²æ­¢ç¢ç‰‡åŒ–ã€‚
- en: Imagine the GC encountering our 500MB video object. It would have to scan it,
    figure out if anything points to it, and then potentially copy that *entire half-gigabyte
    block of memory* from one location to another. This would trigger a massive, application-freezing
    "stop-the-world" pause. Your server would become completely unresponsive for seconds
    at a time. All the cleverness of the event loop would be useless if the main thread
    is locked up doing memory management. V8's heap and its garbage collector are
    simply not designed for handling large, contiguous blocks of static data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: æƒ³è±¡GCé‡åˆ°æˆ‘ä»¬çš„500MBè§†é¢‘å¯¹è±¡ã€‚å®ƒå¿…é¡»æ‰«æå®ƒï¼Œç¡®å®šæ˜¯å¦æœ‰ä»»ä½•ä¸œè¥¿æŒ‡å‘å®ƒï¼Œç„¶åå¯èƒ½å°†é‚£ä¸ª*æ•´ä¸ªåŠGBçš„å†…å­˜å—*ä»ä¸€ä¸ªä½ç½®å¤åˆ¶åˆ°å¦ä¸€ä¸ªä½ç½®ã€‚è¿™å°†è§¦å‘ä¸€æ¬¡å·¨å¤§çš„ã€å†»ç»“åº”ç”¨ç¨‹åºçš„â€œåœæ­¢ä¸–ç•Œâ€æš‚åœã€‚å¦‚æœä¸»çº¿ç¨‹è¢«é”å®šåœ¨å†…å­˜ç®¡ç†ä¸­ï¼Œé‚£ä¹ˆä½ çš„æœåŠ¡å™¨å°†å®Œå…¨æ— å“åº”æ•°ç§’ã€‚å¦‚æœä¸»çº¿ç¨‹è¢«é”å®šåœ¨å†…å­˜ç®¡ç†ä¸­ï¼Œé‚£ä¹ˆäº‹ä»¶å¾ªç¯çš„æ‰€æœ‰å·§å¦™ä¹‹å¤„éƒ½å°†æ— ç”¨ã€‚V8çš„å †åŠå…¶åƒåœ¾å›æ”¶å™¨æ ¹æœ¬ä¸é€‚åˆå¤„ç†å¤§å‹ã€è¿ç»­çš„é™æ€æ•°æ®å—ã€‚
- en: This is where Node.js makes a brilliant architectural decision.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯Node.jsåšå‡ºå“è¶Šæ¶æ„å†³ç­–çš„åœ°æ–¹ã€‚
- en: Node's `Buffer`s are allocated in a completely different memory space. They
    live *outside* the V8 managed heap.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Nodeçš„`Buffer`æ˜¯åœ¨ä¸€ä¸ªå®Œå…¨ä¸åŒçš„å†…å­˜ç©ºé—´ä¸­åˆ†é…çš„ã€‚å®ƒä»¬å­˜åœ¨äºV8ç®¡ç†çš„å †*ä¹‹å¤–*ã€‚
- en: ğŸ“ŒImportant
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ“Œé‡è¦
- en: This is the key architectural decision that makes high-performance binary data
    processing in Node.js possible without crippling the garbage collector.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å…³é”®æ¶æ„å†³ç­–ï¼Œä½¿å¾—åœ¨Node.jsä¸­å®ç°é«˜æ€§èƒ½çš„äºŒè¿›åˆ¶æ•°æ®å¤„ç†æˆä¸ºå¯èƒ½ï¼Œè€Œä¸ä¼šæŸå®³åƒåœ¾å›æ”¶å™¨ã€‚
- en: So how do we interact with it from our JavaScript code?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œæˆ‘ä»¬å¦‚ä½•ä»JavaScriptä»£ç ä¸­ä¸ä¹‹äº¤äº’å‘¢ï¼Ÿ
- en: This is the second part of the clever design. The `Buffer` object that you manipulate
    in your JS code is not the memory slab itself. It's just a small, lightweight
    JavaScript object that acts as a *handle* or a *pointer*. This small handle object
    *does* live on the V8 heap and is managed by the garbage collector. It contains
    metadata about the data, like its length, and most critically, an internal pointer
    to the actual memory address of the raw data slab sitting outside of V8.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯å·§å¦™è®¾è®¡çš„ç¬¬äºŒéƒ¨åˆ†ã€‚ä½ åœ¨JSä»£ç ä¸­æ“ä½œçš„`Buffer`å¯¹è±¡æœ¬èº«å¹¶ä¸æ˜¯å†…å­˜å—ã€‚å®ƒåªæ˜¯ä¸€ä¸ªå°å‹ã€è½»é‡çº§çš„JavaScriptå¯¹è±¡ï¼Œå……å½“ä¸€ä¸ª*å¥æŸ„*æˆ–*æŒ‡é’ˆ*ã€‚è¿™ä¸ªå°çš„å¥æŸ„å¯¹è±¡*ç¡®å®*å­˜åœ¨äºV8å †ä¸Šï¼Œå¹¶ç”±åƒåœ¾å›æ”¶å™¨ç®¡ç†ã€‚å®ƒåŒ…å«æœ‰å…³æ•°æ®çš„å…ƒæ•°æ®ï¼Œå¦‚å…¶é•¿åº¦ï¼Œä»¥åŠæœ€å…³é”®çš„æ˜¯ï¼ŒæŒ‡å‘å®é™…æ•°æ®å—å†…å­˜åœ°å€çš„å†…éƒ¨æŒ‡é’ˆï¼Œè¯¥æ•°æ®å—ä½äºV8ä¹‹å¤–ã€‚
- en: 'Let''s build that mental model:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ„å»ºè¿™ä¸ªå¿ƒç†æ¨¡å‹ï¼š
- en: '**The Raw Slab,** a large, contiguous block of memory somewhere in your computer''s
    RAM, managed by Node''s C++ core, not V8\. This is where the actual bytes of your
    file or network packet reside.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŸå§‹æ•°æ®å—**ï¼Œä½äºä½ ç”µè„‘RAMä¸­çš„æŸä¸ªåœ°æ–¹çš„ä¸€ä¸ªå¤§ã€è¿ç»­çš„å†…å­˜å—ï¼Œç”±Nodeçš„C++æ ¸å¿ƒç®¡ç†ï¼Œè€Œä¸æ˜¯V8ã€‚è¿™æ˜¯ä½ çš„æ–‡ä»¶æˆ–ç½‘ç»œæ•°æ®åŒ…å®é™…å­—èŠ‚æ‰€åœ¨çš„åœ°æ–¹ã€‚'
- en: '**The JS Handle,** a tiny JavaScript object living on the V8 heap. It''s cheap
    to create and for the GC to track. It holds the address of the Raw Slab.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSå¥æŸ„**ï¼Œä¸€ä¸ªä½äºV8å †ä¸Šçš„å°å‹JavaScriptå¯¹è±¡ã€‚å®ƒæ˜“äºåˆ›å»ºï¼Œå¹¶ä¸”å¯¹äºGCæ¥è¯´æ˜“äºè·Ÿè¸ªã€‚å®ƒæŒæœ‰åŸå§‹æ•°æ®å—çš„åœ°å€ã€‚'
- en: When the garbage collector runs, it only sees the small handle object. It can
    track it, move it, and eventually garbage collect it with incredible efficiency.
    It never has to touch the massive 500MB data slab. When the JS handle is eventually
    collected, Node's C++ layer is notified via a special mechanism (weak references),
    and it then knows it's safe to free the associated raw memory slab, returning
    it to the operating system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: å½“åƒåœ¾å›æ”¶å™¨è¿è¡Œæ—¶ï¼Œå®ƒåªèƒ½çœ‹åˆ°å°çš„å¥æŸ„å¯¹è±¡ã€‚å®ƒå¯ä»¥è·Ÿè¸ªå®ƒï¼Œç§»åŠ¨å®ƒï¼Œå¹¶ä»¥æé«˜çš„æ•ˆç‡æœ€ç»ˆå°†å…¶åƒåœ¾å›æ”¶ã€‚å®ƒæ°¸è¿œä¸éœ€è¦è§¦åŠé‚£ä¸ªåºå¤§çš„500MBæ•°æ®å—ã€‚å½“JSå¥æŸ„æœ€ç»ˆè¢«å›æ”¶æ—¶ï¼ŒNodeçš„C++å±‚é€šè¿‡ä¸€ç§ç‰¹æ®Šæœºåˆ¶ï¼ˆå¼±å¼•ç”¨ï¼‰å¾—åˆ°é€šçŸ¥ï¼Œç„¶åå®ƒçŸ¥é“å¯ä»¥å®‰å…¨åœ°é‡Šæ”¾ç›¸å…³çš„åŸå§‹å†…å­˜å—ï¼Œå°†å…¶è¿”å›ç»™æ“ä½œç³»ç»Ÿã€‚
- en: This design is the best of both worlds. We get the safety and convenience of
    working with an object in JavaScript, while the heavy lifting of memory management
    for large binary data is handled by a system better suited for it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§è®¾è®¡æ˜¯ä¸¤è€…çš„æœ€ä½³ç»“åˆã€‚æˆ‘ä»¬å¾—åˆ°äº†åœ¨JavaScriptä¸­å¤„ç†å¯¹è±¡çš„å®‰å…¨æ€§å’Œä¾¿åˆ©æ€§ï¼Œè€Œå¤§å‹äºŒè¿›åˆ¶æ•°æ®çš„å†…å­˜ç®¡ç†åˆ™ç”±æ›´é€‚åˆå®ƒçš„ç³»ç»Ÿæ¥å¤„ç†ã€‚
- en: But this design isn't magic, and it comes with tradeoffs. Allocating memory
    directly from the OS is generally a slower operation than V8's highly optimized
    "bump-pointer" allocation for small objects on its heap. And, more importantly,
    by stepping outside of V8's fully automated memory management, we introduce a
    new class of potential issues. We are now interacting with a memory system that
    behaves differently, and understanding this boundary is key to writing high-performance,
    leak-free Node applications. We'll explore these performance and memory leak implications
    in much greater detail later, but for now, the crucial takeaway is this two-heap
    model. It's the foundation that makes everything else possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†è¿™ç§è®¾è®¡å¹¶éé­”æ³•ï¼Œå®ƒä¹Ÿæœ‰å…¶æƒè¡¡ã€‚ç›´æ¥ä»æ“ä½œç³»ç»Ÿåˆ†é…å†…å­˜é€šå¸¸æ¯”V8ä¸ºå…¶å †ä¸Šçš„å°å¯¹è±¡é«˜åº¦ä¼˜åŒ–çš„â€œè·³è·ƒæŒ‡é’ˆâ€åˆ†é…æ“ä½œæ…¢ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œé€šè¿‡è·³å‡ºV8çš„å®Œå…¨è‡ªåŠ¨åŒ–çš„å†…å­˜ç®¡ç†ï¼Œæˆ‘ä»¬å¼•å…¥äº†ä¸€ä¸ªæ–°çš„æ½œåœ¨é—®é¢˜ç±»åˆ«ã€‚æˆ‘ä»¬ç°åœ¨æ­£åœ¨ä¸ä¸€ä¸ªè¡Œä¸ºä¸åŒçš„å†…å­˜ç³»ç»Ÿäº¤äº’ï¼Œç†è§£è¿™ä¸ªè¾¹ç•Œæ˜¯ç¼–å†™é«˜æ€§èƒ½ã€æ— æ³„æ¼çš„Nodeåº”ç”¨ç¨‹åºçš„å…³é”®ã€‚æˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­æ›´è¯¦ç»†åœ°æ¢è®¨è¿™äº›æ€§èƒ½å’Œå†…å­˜æ³„æ¼çš„å½±å“ï¼Œä½†å°±ç›®å‰è€Œè¨€ï¼Œå…³é”®çš„è®¤è¯†æ˜¯è¿™ä¸ªåŒå †æ¨¡å‹ã€‚å®ƒæ˜¯ä½¿å…¶ä»–ä¸€åˆ‡æˆä¸ºå¯èƒ½çš„åŸºç¡€ã€‚
- en: â„¹ï¸Note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: â„¹ï¸æ³¨æ„
- en: The two-heap model has performance implications. Creating many small Buffers
    can be slower than creating many small JS objects due to the overhead of calling
    into C++ to allocate memory. Node has optimizations (like a memory pool) to mitigate
    this, which we'll cover in a later chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: åŒå †æ¨¡å‹æœ‰æ€§èƒ½å½±å“ã€‚åˆ›å»ºè®¸å¤šå°çš„ç¼“å†²åŒºå¯èƒ½æ¯”åˆ›å»ºè®¸å¤šå°çš„JSå¯¹è±¡æ…¢ï¼Œå› ä¸ºè°ƒç”¨C++åˆ†é…å†…å­˜çš„å¼€é”€ã€‚Nodeæœ‰ä¸€äº›ä¼˜åŒ–ï¼ˆå¦‚å†…å­˜æ± ï¼‰æ¥å‡è½»è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­ä»‹ç»ã€‚
- en: The `Buffer`- Node's Solution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Buffer` - Nodeçš„è§£å†³æ–¹æ¡ˆ'
- en: 'Now that we understand the problem (strings are dangerous) and the architectural
    solution (off-heap memory), we can finally talk about the tool itself: the `Buffer`.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»ç†è§£äº†é—®é¢˜ï¼ˆå­—ç¬¦ä¸²æ˜¯å±é™©çš„ï¼‰å’Œæ¶æ„è§£å†³æ–¹æ¡ˆï¼ˆå †å¤–å†…å­˜ï¼‰ï¼Œæˆ‘ä»¬ç»ˆäºå¯ä»¥è°ˆè®ºè¿™ä¸ªå·¥å…·æœ¬èº«äº†ï¼š`Buffer`ã€‚
- en: A question you might be asking, especially if you have experience with modern
    browser APIs, is "Why didn't Node just use `ArrayBuffer` and TypedArrays like
    `Uint8Array`?" It's an excellent question, and the answer is simple history. When
    Node.js was created by Ryan Dahl in 2009, `ArrayBuffer` and the suite of TypedArrays
    were not a stable, standardized part of the JavaScript language or the V8 engine.
    They were experimental proposals, years away from being reliable enough for production
    use.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½æ­£åœ¨é—®çš„ä¸€ä¸ªé—®é¢˜ï¼Œå°¤å…¶æ˜¯å¦‚æœä½ æœ‰ç°ä»£æµè§ˆå™¨APIçš„ç»éªŒï¼Œæ˜¯â€œä¸ºä»€ä¹ˆNodeæ²¡æœ‰ç›´æ¥ä½¿ç”¨`ArrayBuffer`å’Œåƒ`Uint8Array`è¿™æ ·çš„ç±»å‹æ•°ç»„ï¼Ÿâ€è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„é—®é¢˜ï¼Œç­”æ¡ˆæ˜¯ç®€å•çš„å†å²ã€‚å½“Node.jsåœ¨2009å¹´ç”±Ryan
    Dahlåˆ›å»ºæ—¶ï¼Œ`ArrayBuffer`å’Œç±»å‹æ•°ç»„å¥—ä»¶å¹¶ä¸æ˜¯JavaScriptè¯­è¨€æˆ–V8å¼•æ“çš„ç¨³å®šã€æ ‡å‡†åŒ–çš„éƒ¨åˆ†ã€‚å®ƒä»¬æ˜¯å®éªŒæ€§ææ¡ˆï¼Œç¦»å¯é åˆ°è¶³ä»¥ç”¨äºç”Ÿäº§ä½¿ç”¨è¿˜æœ‰å¥½å‡ å¹´ã€‚
- en: 'But Node had an immediate, pressing need. The entire purpose of Node was to
    enable server-side I/O. How could you build an HTTP server if you couldn''t handle
    raw request bodies? How could you interact with the filesystem if you couldn''t
    hold file data? Node *had* to solve the binary data problem from day one. So,
    Ryan Dahl and the other early contributors did what any pragmatic engineer would
    do: they invented their own solution. The `Buffer` was born out of pure necessity.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æ˜¯Nodeæœ‰ä¸€ä¸ªç´§è¿«çš„éœ€æ±‚ã€‚Nodeçš„æ•´ä¸ªç›®çš„å°±æ˜¯å®ç°æœåŠ¡å™¨ç«¯I/Oã€‚å¦‚æœä½ æ— æ³•å¤„ç†åŸå§‹è¯·æ±‚ä½“ï¼Œä½ æ€ä¹ˆèƒ½æ„å»ºä¸€ä¸ªHTTPæœåŠ¡å™¨å‘¢ï¼Ÿå¦‚æœä½ æ— æ³•æŒæœ‰æ–‡ä»¶æ•°æ®ï¼Œä½ æ€ä¹ˆèƒ½ä¸æ–‡ä»¶ç³»ç»Ÿäº¤äº’å‘¢ï¼ŸNodeä»ç¬¬ä¸€å¤©èµ·å°±å¿…é¡»è§£å†³äºŒè¿›åˆ¶æ•°æ®é—®é¢˜ã€‚å› æ­¤ï¼ŒRyan
    Dahlå’Œå…¶ä»–æ—©æœŸè´¡çŒ®è€…åšäº†ä»»ä½•å®ç”¨å·¥ç¨‹å¸ˆéƒ½ä¼šåšçš„äº‹æƒ…ï¼šä»–ä»¬å‘æ˜äº†è‡ªå·±çš„è§£å†³æ–¹æ¡ˆã€‚`Buffer`å°±æ˜¯åœ¨è¿™ç§çº¯ç²¹çš„éœ€æ±‚ä¸‹è¯ç”Ÿçš„ã€‚
- en: So, what is a `Buffer` fundamentally? It's a fixed-size, mutable sequence of
    bytes. Think of it as a direct, low-level view into a slab of memory. It behaves
    much like an array of bytes, where each element is an integer from 0 to 255 (the
    range of a single byte).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œ`Buffer`æœ¬è´¨ä¸Šæ˜¯ä»€ä¹ˆï¼Ÿå®ƒæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„ã€å¯å˜çš„å­—èŠ‚åºåˆ—ã€‚æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªç›´æ¥çš„ä½çº§è§†å›¾ï¼Œå¯ä»¥çœ‹åˆ°ä¸€å—å†…å­˜ã€‚å®ƒè¡¨ç°å¾—å°±åƒä¸€ä¸ªå­—èŠ‚æ•°ç»„ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªä»0åˆ°255çš„æ•´æ•°ï¼ˆå•ä¸ªå­—èŠ‚çš„èŒƒå›´ï¼‰ã€‚
- en: Let's look at how we create and work with them. The old way of creating buffers
    (`new Buffer()`) has long been deprecated because it was dangerously ambiguous.
    The modern API is much safer and more explicit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•åˆ›å»ºå’Œä½¿ç”¨å®ƒä»¬ã€‚åˆ›å»ºç¼“å†²åŒºï¼ˆ`new Buffer()`ï¼‰çš„æ—§æ–¹æ³•å·²ç»è¢«å¼ƒç”¨ï¼Œå› ä¸ºå®ƒéå¸¸æ¨¡ç³Šï¼Œå…·æœ‰å±é™©æ€§ã€‚ç°ä»£APIæ›´å®‰å…¨ï¼Œä¹Ÿæ›´æ˜ç¡®ã€‚
- en: âš ï¸Warning
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸è­¦å‘Š
- en: You may see `new Buffer()` in older codebases or online examples. This constructor
    is deprecated and should **never** be used in modern code. It has different behaviors
    depending on the type of its arguments, which led to serious security vulnerabilities
    (e.g., accidentally exposing uninitialized memory). Always use `Buffer.alloc()`
    or `Buffer.from()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½ä¼šåœ¨æ—§ä»£ç åº“æˆ–åœ¨çº¿ç¤ºä¾‹ä¸­çœ‹åˆ°`new Buffer()`ã€‚è¿™ä¸ªæ„é€ å‡½æ•°å·²è¢«å¼ƒç”¨ï¼Œä¸åº”åœ¨ç°ä»£ä»£ç ä¸­ä½¿ç”¨ã€‚å®ƒçš„è¡Œä¸ºå–å†³äºå…¶å‚æ•°çš„ç±»å‹ï¼Œè¿™å¯¼è‡´äº†ä¸¥é‡çš„å®‰å…¨æ¼æ´ï¼ˆä¾‹å¦‚ï¼Œæ„å¤–æš´éœ²æœªåˆå§‹åŒ–çš„å†…å­˜ï¼‰ã€‚å§‹ç»ˆä½¿ç”¨`Buffer.alloc()`æˆ–`Buffer.from()`ã€‚
- en: 'There are two primary static methods you''ll use: `Buffer.alloc()` and `Buffer.from()`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å°†ä½¿ç”¨ä¸¤ä¸ªä¸»è¦çš„é™æ€æ–¹æ³•ï¼š`Buffer.alloc()`å’Œ`Buffer.from()`ã€‚
- en: '`Buffer.alloc(size)` is the way to create a new, "clean" buffer. You tell it
    how many bytes you need, and it gives you a buffer of that size, filled with zeros.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer.alloc(size)`æ˜¯åˆ›å»ºä¸€ä¸ªæ–°â€œå¹²å‡€â€ç¼“å†²åŒºçš„æ–¹æ³•ã€‚ä½ å‘Šè¯‰å®ƒä½ éœ€è¦å¤šå°‘å­—èŠ‚ï¼Œå®ƒå°±ä¼šç»™ä½ ä¸€ä¸ªç›¸åº”å¤§å°çš„ç¼“å†²åŒºï¼Œå¹¶ç”¨é›¶å¡«å……ã€‚'
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The fact that it's zero-filled is important. This is called "zeroing" the memory.
    `Buffer.alloc()` does this by default for security reasons. When Node requests
    memory from the operating system, the OS might give it a chunk of memory that
    was previously used by another process. That memory could contain sensitive data
    - passwords, private keys, you name it. By overwriting the entire block with zeros,
    `Buffer.alloc()` ensures that you start with a clean slate and can't accidentally
    leak old data. There is an "unsafe" version, `Buffer.allocUnsafe()`, that skips
    this zero-filling step for performance reasons, but you should only use it if
    you know for sure that you are going to immediately overwrite the entire buffer
    with your own data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒè¢«é›¶å¡«å……çš„äº‹å®å¾ˆé‡è¦ã€‚è¿™è¢«ç§°ä¸ºâ€œé›¶åŒ–â€å†…å­˜ã€‚å‡ºäºå®‰å…¨è€ƒè™‘ï¼Œ`Buffer.alloc()`é»˜è®¤ä¼šè¿™æ ·åšã€‚å½“Nodeä»æ“ä½œç³»ç»Ÿè¯·æ±‚å†…å­˜æ—¶ï¼Œæ“ä½œç³»ç»Ÿå¯èƒ½ä¼šç»™å®ƒä¸€å—ä¹‹å‰ç”±å…¶ä»–è¿›ç¨‹ä½¿ç”¨çš„å†…å­˜ã€‚é‚£å—å†…å­˜å¯èƒ½åŒ…å«æ•æ„Ÿæ•°æ®â€”â€”å¯†ç ã€ç§é’¥ï¼Œç­‰ç­‰ã€‚é€šè¿‡ç”¨é›¶è¦†ç›–æ•´ä¸ªå—ï¼Œ`Buffer.alloc()`ç¡®ä¿ä½ ä»ä¸€ä¸ªå¹²å‡€çš„èµ·ç‚¹å¼€å§‹ï¼Œå¹¶ä¸”ä¸ä¼šæ„å¤–æ³„éœ²æ—§æ•°æ®ã€‚æœ‰ä¸€ä¸ªâ€œä¸å®‰å…¨â€ç‰ˆæœ¬ï¼Œ`Buffer.allocUnsafe()`ï¼Œå‡ºäºæ€§èƒ½åŸå› è·³è¿‡äº†è¿™ä¸ªé›¶å¡«å……æ­¥éª¤ï¼Œä½†åªæœ‰å½“ä½ ç¡®ä¿¡ä½ å°†ç«‹å³ç”¨ä½ è‡ªå·±çš„æ•°æ®è¦†ç›–æ•´ä¸ªç¼“å†²åŒºæ—¶æ‰åº”ä½¿ç”¨å®ƒã€‚
- en: ğŸš¨Caution
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸš¨æ³¨æ„
- en: Use `Buffer.allocUnsafe()` with extreme care. It is faster because it does not
    initialize the allocated memory. This means the new Buffer may contain old, sensitive
    data from other parts of your application or other processes. Only use it if you
    can guarantee that you will completely overwrite the memory space immediately
    after allocation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·åŠ¡å¿…è°¨æ…ä½¿ç”¨`Buffer.allocUnsafe()`ã€‚å®ƒä¹‹æ‰€ä»¥æ›´å¿«ï¼Œæ˜¯å› ä¸ºå®ƒä¸ä¼šåˆå§‹åŒ–åˆ†é…çš„å†…å­˜ã€‚è¿™æ„å‘³ç€æ–°çš„Bufferå¯èƒ½åŒ…å«æ¥è‡ªåº”ç”¨ç¨‹åºå…¶ä»–éƒ¨åˆ†æˆ–å…¶ä»–è¿›ç¨‹çš„æ—§æ•æ„Ÿæ•°æ®ã€‚åªæœ‰åœ¨ä½ èƒ½å¤Ÿä¿è¯åœ¨åˆ†é…åç«‹å³å®Œå…¨è¦†ç›–æ•´ä¸ªå†…å­˜ç©ºé—´æ—¶ï¼Œæ‰åº”ä½¿ç”¨å®ƒã€‚
- en: The other workhorse is `Buffer.from(thing)`. This is a versatile method for
    creating a buffer from existing data. This is how we solve our original string
    problem.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ä¸ªå·¥ä½œé©¬æ˜¯`Buffer.from(thing)`ã€‚è¿™æ˜¯ä¸€ä¸ªçµæ´»çš„æ–¹æ³•ï¼Œå¯ä»¥ä»ç°æœ‰æ•°æ®åˆ›å»ºç¼“å†²åŒºã€‚è¿™å°±æ˜¯æˆ‘ä»¬è§£å†³åŸå§‹å­—ç¬¦ä¸²é—®é¢˜çš„æ–¹æ³•ã€‚
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how `Buffer.from('hello world', 'utf8')` is the inverse of the operation
    that failed us before. Instead of destructively *decoding* binary data into a
    string, we are correctly *encoding* a string into its underlying binary (UTF-8)
    representation. This is the right tool for the job.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„`Buffer.from('hello world', 'utf8')`æ˜¯å¦‚ä½•ä¸æˆ‘ä»¬ä¹‹å‰å¤±è´¥çš„æ“ä½œçš„é€†æ“ä½œã€‚æˆ‘ä»¬ä¸æ˜¯å°†äºŒè¿›åˆ¶æ•°æ®ç ´åæ€§åœ°è§£ç æˆå­—ç¬¦ä¸²ï¼Œè€Œæ˜¯æ­£ç¡®åœ°å°†å­—ç¬¦ä¸²ç¼–ç æˆå…¶åº•å±‚çš„äºŒè¿›åˆ¶ï¼ˆUTF-8ï¼‰è¡¨ç¤ºå½¢å¼ã€‚è¿™æ˜¯å®Œæˆè¿™é¡¹å·¥ä½œçš„æ­£ç¡®å·¥å…·ã€‚
- en: Once you have a buffer, you can interact with it directly. It feels a lot like
    a standard JavaScript array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦ä½ æœ‰äº†ç¼“å†²åŒºï¼Œä½ å°±å¯ä»¥ç›´æ¥ä¸ä¹‹äº¤äº’ã€‚å®ƒæ„Ÿè§‰å°±åƒä¸€ä¸ªæ ‡å‡†çš„JavaScriptæ•°ç»„ã€‚
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This direct, array-like access is simple and powerful. But this is where the
    `Buffer` module really shines and shows its server-side heritage. It provides
    an ergonomic layer of helper methods that aren't available on standard browser
    TypedArrays, designed specifically for the kinds of tasks you do in Node.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç›´æ¥ã€ç±»ä¼¼æ•°ç»„çš„è®¿é—®æ–¹å¼ç®€å•è€Œå¼ºå¤§ã€‚ä½†æ­£æ˜¯åœ¨è¿™é‡Œï¼Œ`Buffer`æ¨¡å—çœŸæ­£å¤§æ”¾å¼‚å½©ï¼Œå¹¶å±•ç°äº†å…¶æœåŠ¡å™¨ç«¯é—äº§ã€‚å®ƒæä¾›äº†ä¸€å±‚ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„è¾…åŠ©æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•åœ¨æ ‡å‡†çš„æµè§ˆå™¨TypedArraysä¸­ä¸å¯ç”¨ï¼Œä¸“ä¸ºåœ¨Nodeä¸­æ‰§è¡Œçš„ä»»åŠ¡è€Œè®¾è®¡ã€‚
- en: One of the most common tasks is converting binary data into a textual representation
    for logging, debugging, or transport. The `buf.toString()` method is your friend
    here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€å¸¸è§çš„ä»»åŠ¡ä¹‹ä¸€æ˜¯å°†äºŒè¿›åˆ¶æ•°æ®è½¬æ¢ä¸ºæ–‡æœ¬è¡¨ç¤ºå½¢å¼ï¼Œç”¨äºè®°å½•ã€è°ƒè¯•æˆ–ä¼ è¾“ã€‚`buf.toString()`æ–¹æ³•æ˜¯ä½ çš„å¥½æœ‹å‹ã€‚
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Crucially, this is a safe, controlled *representation* of the data as text.
    It's not the destructive *decoding* we saw earlier. We're not losing information;
    we're just choosing how to display it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®çš„æ˜¯ï¼Œè¿™æ˜¯ä¸€ä¸ªå®‰å…¨ã€å—æ§çš„æ•°æ®æ–‡æœ¬è¡¨ç¤ºã€‚è¿™ä¸æ˜¯æˆ‘ä»¬ä¹‹å‰çœ‹åˆ°çš„ç ´åæ€§è§£ç ã€‚æˆ‘ä»¬æ²¡æœ‰ä¸¢å¤±ä¿¡æ¯ï¼›æˆ‘ä»¬åªæ˜¯é€‰æ‹©å¦‚ä½•æ˜¾ç¤ºå®ƒã€‚
- en: The flip side is writing data. The `buf.write()` method is a power tool for
    placing string data precisely into a larger binary structure. Imagine you're building
    an HTTP response by hand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢æ˜¯å†™å…¥æ•°æ®ã€‚`buf.write()`æ–¹æ³•æ˜¯å°†å­—ç¬¦ä¸²æ•°æ®ç²¾ç¡®æ”¾ç½®åˆ°æ›´å¤§çš„äºŒè¿›åˆ¶ç»“æ„ä¸­çš„å¼ºå¤§å·¥å…·ã€‚æƒ³è±¡ä¸€ä¸‹ä½ æ­£åœ¨æ‰‹åŠ¨æ„å»ºä¸€ä¸ªHTTPå“åº”ã€‚
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, I want to give you a quick glimpse of something we''ll cover in much
    more depth later. Most binary protocols involve not just bytes, but multi-byte
    numbers: 16-bit integers, 32-bit floats, etc. `Buffer` has a whole family of methods
    for this, like `buf.readInt16BE()` and `buf.writeInt16BE()`. The `BE` stands for
    Big-Endian, which refers to the byte order - a critical concept in binary data.
    These methods allow you to pluck a two-byte number directly out of a buffer without
    manual bit-shifting, which is absolutely essential for parsing any non-trivial
    binary format, from a JPEG header to a database wire protocol.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘æƒ³ç»™ä½ å¿«é€Ÿæµè§ˆä¸€ä¸‹æˆ‘ä»¬å°†åœ¨ä»¥åæ›´æ·±å…¥æ¢è®¨çš„å†…å®¹ã€‚å¤§å¤šæ•°äºŒè¿›åˆ¶åè®®ä¸ä»…æ¶‰åŠå­—èŠ‚ï¼Œè¿˜æ¶‰åŠå¤šå­—èŠ‚æ•°å­—ï¼š16ä½æ•´æ•°ã€32ä½æµ®ç‚¹æ•°ç­‰ã€‚`Buffer`æœ‰ä¸€ç³»åˆ—ç”¨äºæ­¤çš„æ–¹æ³•ï¼Œå¦‚`buf.readInt16BE()`å’Œ`buf.writeInt16BE()`ã€‚`BE`ä»£è¡¨å¤§ç«¯åºï¼Œå®ƒæŒ‡çš„æ˜¯å­—èŠ‚é¡ºåºâ€”â€”äºŒè¿›åˆ¶æ•°æ®ä¸­çš„ä¸€ä¸ªå…³é”®æ¦‚å¿µã€‚è¿™äº›æ–¹æ³•å…è®¸ä½ ç›´æ¥ä»ç¼“å†²åŒºä¸­æå–ä¸€ä¸ªä¸¤å­—èŠ‚çš„æ•°å­—ï¼Œè€Œæ— éœ€æ‰‹åŠ¨ä½ç§»åŠ¨ï¼Œè¿™å¯¹äºè§£æä»»ä½•éå¹³å‡¡çš„äºŒè¿›åˆ¶æ ¼å¼è‡³å…³é‡è¦ï¼Œä»JPEGå¤´åˆ°æ•°æ®åº“çº¿åè®®ã€‚
- en: This rich, ergonomic API is what made `Buffer` so indispensable to Node.js developers
    for years. It was a custom-built, perfectly tailored tool for the server-side
    job. But the JavaScript language standard eventually caught up, which leads us
    to the modern state of affairs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸°å¯Œã€äººæ€§åŒ–çš„APIä½¿å¾—`Buffer`å¤šå¹´æ¥å¯¹Node.jså¼€å‘è€…æ¥è¯´ä¸å¯æˆ–ç¼ºã€‚å®ƒæ˜¯ä¸€ä¸ªä¸ºæœåŠ¡å™¨ç«¯å·¥ä½œé‡èº«å®šåˆ¶çš„å®šåˆ¶å·¥å…·ã€‚ä½†JavaScriptè¯­è¨€æ ‡å‡†æœ€ç»ˆèµ¶ä¸Šäº†ï¼Œè¿™è®©æˆ‘ä»¬æ¥åˆ°äº†ç°åœ¨çš„çŠ¶æ€ã€‚
- en: Buffers and TypedArrays Converge
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç¼“å†²åŒºå’Œç±»å‹åŒ–æ•°ç»„è¶‹åŒ
- en: 'At this point, if you''ve been working with modern JavaScript in the browser,
    a thought has likely been nagging at you: "This `Buffer` thing, with its fixed
    length and byte-level access... it looks and smells an awful lot like a `Uint8Array`."'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå¦‚æœä½ ä¸€ç›´åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨ç°ä»£JavaScriptï¼Œå¯èƒ½æœ‰ä¸€ä¸ªæƒ³æ³•ä¸€ç›´åœ¨å›°æ‰°ç€ä½ ï¼šâ€œè¿™ä¸ª`Buffer`ä¸œè¥¿ï¼Œç”±äºå…¶å›ºå®šé•¿åº¦å’Œå­—èŠ‚çº§è®¿é—®â€¦â€¦å®ƒçœ‹èµ·æ¥å’Œé—»èµ·æ¥éå¸¸åƒ`Uint8Array`ã€‚â€
- en: You are absolutely, 100% correct.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ç»å¯¹æ˜¯ï¼Œ100%æ­£ç¡®çš„ã€‚
- en: 'And here is the most important thing to understand about Buffers in modern
    Node.js: **The `Buffer` class *is* a subclass of the standard JavaScript `Uint8Array`.**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: è€Œå…³äºç°ä»£Node.jsä¸­çš„ç¼“å†²åŒºï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªæœ€é‡è¦çš„ç†è§£ï¼š**`Buffer`ç±»*æ˜¯*æ ‡å‡†JavaScript `Uint8Array`çš„å­ç±»ã€‚**
- en: ğŸ“ŒImportant
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ“Œé‡è¦
- en: 'This is a game-changer for interoperability. A Node.js `Buffer` is a `Uint8Array`.
    This means you can pass a `Buffer` to any modern API (in Node or in a browser-compatible
    library) that expects a `Uint8Array`, and it will work seamlessly. You get the
    best of both worlds: Node''s powerful, ergonomic API and compatibility with the
    web standard.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¯¹äºäº’æ“ä½œæ€§æ¥è¯´æ˜¯ä¸€ä¸ªå˜é©ã€‚Node.jsçš„`Buffer`æ˜¯ä¸€ä¸ª`Uint8Array`ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥å°†ä¸€ä¸ª`Buffer`ä¼ é€’ç»™ä»»ä½•æœŸæœ›`Uint8Array`çš„ç°ä»£APIï¼ˆåœ¨Nodeæˆ–æµè§ˆå™¨å…¼å®¹çš„åº“ä¸­ï¼‰ï¼Œå¹¶ä¸”å®ƒå°†æ— ç¼å·¥ä½œã€‚ä½ å¾—åˆ°äº†ä¸¤è€…çš„æœ€ä½³ä¹‹å¤„ï¼šNodeå¼ºå¤§çš„ã€äººæ€§åŒ–çš„APIå’Œä¸ç½‘ç»œæ ‡å‡†çš„å…¼å®¹æ€§ã€‚
- en: This wasn't always the case. In the early days of Node, `Buffer` was its own
    completely separate, proprietary thing. But as the `TypedArray` specification
    matured and became a core part of V8 and JavaScript, the Node.js core team made
    a brilliant move. Starting around Node.js v3, they refactored `Buffer` to inherit
    from `Uint8Array`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å¹¶ä¸æ˜¯ä¸€ç›´å¦‚æ­¤ã€‚åœ¨Nodeçš„æ—©æœŸï¼Œ`Buffer`æ˜¯å®Œå…¨ç‹¬ç«‹ã€ä¸“æœ‰çš„ä¸œè¥¿ã€‚ä½†éšç€`TypedArray`è§„èŒƒçš„æˆç†Ÿå¹¶æˆä¸ºV8å’ŒJavaScriptçš„æ ¸å¿ƒéƒ¨åˆ†ï¼ŒNode.jsæ ¸å¿ƒå›¢é˜Ÿåšå‡ºäº†ä¸€ä¸ªè‹±æ˜çš„å†³å®šã€‚å¤§çº¦ä»Node.js
    v3å¼€å§‹ï¼Œä»–ä»¬å°†`Buffer`é‡æ„ä¸ºä»`Uint8Array`ç»§æ‰¿ã€‚
- en: Let's prove it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥è¯æ˜å®ƒã€‚
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a crucial piece of the puzzle. It bridges the gap between the Node-specific
    world and the web standard. It means that any API, in any library, that is written
    to accept a `Uint8Array` will also seamlessly accept a Node.js `Buffer`. You don't
    need to convert between them. A Buffer *is* a `Uint8Array`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯æ‹¼å›¾çš„å…³é”®éƒ¨åˆ†ã€‚å®ƒå¼¥åˆäº†Nodeç‰¹å®šä¸–ç•Œå’Œç½‘ç»œæ ‡å‡†ä¹‹é—´çš„å·®è·ã€‚è¿™æ„å‘³ç€ä»»ä½•ç¼–å†™ä¸ºæ¥å—`Uint8Array`çš„APIï¼Œæ— è®ºåœ¨å“ªä¸ªåº“ä¸­ï¼Œéƒ½å°†æ— ç¼æ¥å—Node.jsçš„`Buffer`ã€‚ä½ ä¸éœ€è¦åœ¨å®ƒä»¬ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚ç¼“å†²åŒº*å°±æ˜¯*ä¸€ä¸ª`Uint8Array`ã€‚
- en: So, if it's just a `Uint8Array`, why do we still have the `Buffer` name and
    the special API? Because it's a *subclass*. It's an enhanced, specialized version.
    A `Buffer` instance gets all the standard `Uint8Array` methods you might know
    from the browser (`.slice()`, `.subarray()`, `.map()`, `.filter()`, etc.) for
    free, *plus* the entire ergonomic, server-side-optimized API we just explored
    (`.toString('hex')`, `.write()`, `.readInt16BE()`, etc.).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå¦‚æœå®ƒåªæ˜¯ä¸€ä¸ª `Uint8Array`ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬ä»ç„¶æœ‰ `Buffer` åç§°å’Œç‰¹æ®Š API å‘¢ï¼Ÿå› ä¸ºå®ƒæ˜¯ä¸€ä¸ª *å­ç±»*ã€‚å®ƒæ˜¯ä¸€ä¸ªå¢å¼ºçš„ã€ä¸“é—¨çš„ç‰ˆæœ¬ã€‚ä¸€ä¸ª
    `Buffer` å®ä¾‹å…è´¹è·å¾—ä½ å¯èƒ½ä»æµè§ˆå™¨ä¸­çŸ¥é“çš„æ‰€æœ‰çš„æ ‡å‡† `Uint8Array` æ–¹æ³•ï¼ˆ`.slice()`ã€`.subarray()`ã€`.map()`ã€`.filter()`
    ç­‰ï¼‰ï¼Œ*åŠ ä¸Š* æˆ‘ä»¬åˆšåˆšæ¢ç´¢çš„æ•´ä¸ªç”¨æˆ·å‹å¥½ã€æœåŠ¡å™¨ç«¯ä¼˜åŒ–çš„ APIï¼ˆ`.toString('hex')`ã€`.write()`ã€`.readInt16BE()`
    ç­‰ï¼‰ã€‚
- en: It truly is the best of both worlds. You get compatibility with the web platform
    standard and the power tools needed for hardcore server development.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒç¡®å®æ˜¯ä¸¤è€…çš„æœ€ä½³ç»“åˆã€‚ä½ æ—¢è·å¾—äº†ä¸ç½‘ç»œå¹³å°æ ‡å‡†çš„å…¼å®¹æ€§ï¼Œåˆè·å¾—äº†ç”¨äºæ ¸å¿ƒæœåŠ¡å™¨å¼€å‘çš„å¼ºå¤§å·¥å…·ã€‚
- en: 'But there''s one final layer to this memory model we need to uncover. Both
    `Buffer` and `Uint8Array` are, themselves, abstractions. They are just *views*
    onto a deeper, more fundamental object: the `ArrayBuffer`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†æˆ‘ä»¬è¿˜éœ€è¦æ­ç¤ºè¿™ä¸ªå†…å­˜æ¨¡å‹çš„æœ€åä¸€å±‚ã€‚`Buffer` å’Œ `Uint8Array` æœ¬èº«ä¹Ÿæ˜¯æŠ½è±¡ã€‚å®ƒä»¬åªæ˜¯å¯¹æ›´æ·±å±‚æ¬¡ã€æ›´åŸºæœ¬å¯¹è±¡çš„è§†å›¾ï¼š`ArrayBuffer`ã€‚
- en: Let's visualize the complete hierarchy -
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å¯è§†åŒ–å®Œæ•´çš„å±‚æ¬¡ç»“æ„ -
- en: '**`ArrayBuffer`** is the raw, inaccessible slab of memory itself. You can''t
    directly read or write bytes from an `ArrayBuffer`. It has almost no methods.
    It doesn''t know if it''s supposed to be interpreted as 8-bit integers, 32-bit
    floats, or anything else. It just *is* the bytes. It represents the resource.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ArrayBuffer`** æ˜¯åŸå§‹çš„ã€ä¸å¯è®¿é—®çš„å†…å­˜å—æœ¬èº«ã€‚ä½ ä¸èƒ½ç›´æ¥ä» `ArrayBuffer` ä¸­è¯»å–æˆ–å†™å…¥å­—èŠ‚ã€‚å®ƒå‡ ä¹æ²¡æœ‰æ–¹æ³•ã€‚å®ƒä¸çŸ¥é“å®ƒåº”è¯¥è¢«è§£é‡Šä¸º
    8 ä½æ•´æ•°ã€32 ä½æµ®ç‚¹æ•°è¿˜æ˜¯å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚å®ƒåªæ˜¯ *æ˜¯* å­—èŠ‚ã€‚å®ƒä»£è¡¨äº†èµ„æºã€‚'
- en: '**`TypedArray` Views (`Uint8Array`, `Int16Array`, etc.) and the `Buffer` View(s)**
    are the "lenses" or "windows" that you place over an `ArrayBuffer` to give it
    meaning and provide an API for manipulation. A `Uint8Array` tells the JavaScript
    engine, "Interpret this underlying block of memory as a sequence of 8-bit unsigned
    integers." A `Buffer` does the same, but adds its own special methods on top.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`TypedArray` è§†å›¾ï¼ˆ`Uint8Array`ã€`Int16Array` ç­‰ï¼‰å’Œ `Buffer` è§†å›¾**æ˜¯ä½ åœ¨ `ArrayBuffer`
    ä¸Šæ”¾ç½®çš„â€œé€é•œâ€æˆ–â€œçª—å£â€ï¼Œä»¥èµ‹äºˆå®ƒæ„ä¹‰å¹¶æä¾›æ“ä½œå®ƒçš„ APIã€‚ä¸€ä¸ª `Uint8Array` å‘Šè¯‰ JavaScript å¼•æ“ï¼Œâ€œå°†è¿™ä¸ªåº•å±‚å†…å­˜å—è§£é‡Šä¸ºä¸€ç³»åˆ—
    8 ä½æ— ç¬¦å·æ•´æ•°ã€‚â€ä¸€ä¸ª `Buffer` åšåŒæ ·çš„äº‹æƒ…ï¼Œä½†æ·»åŠ äº†è‡ªå·±çš„ç‰¹æ®Šæ–¹æ³•ã€‚'
- en: When you call `Buffer.alloc(10)`, Node is actually performing two steps under
    the hood. First, it allocates a raw `ArrayBuffer` of 10 bytes (this is the memory
    that lives off the V8 heap). Then it creates a `Buffer` instance (the view) that
    points to that `ArrayBuffer` and returns it to you.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä½ è°ƒç”¨ `Buffer.alloc(10)` æ—¶ï¼ŒNode å®é™…ä¸Šåœ¨åº•å±‚æ‰§è¡Œäº†ä¸¤ä¸ªæ­¥éª¤ã€‚é¦–å…ˆï¼Œå®ƒåˆ†é…äº†ä¸€ä¸ª 10 å­—èŠ‚çš„åŸå§‹ `ArrayBuffer`ï¼ˆè¿™æ˜¯ä½äº
    V8 å †ä¸Šçš„å†…å­˜ï¼‰ã€‚ç„¶åï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªæŒ‡å‘è¯¥ `ArrayBuffer` çš„ `Buffer` å®ä¾‹ï¼ˆè§†å›¾ï¼‰ï¼Œå¹¶å°†å…¶è¿”å›ç»™ä½ ã€‚
- en: We can prove this connection, too. Every `Buffer` instance has a `.buffer` property
    that gives you access to its underlying `ArrayBuffer`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥è¯æ˜è¿™ä¸ªè”ç³»ã€‚æ¯ä¸ª `Buffer` å®ä¾‹éƒ½æœ‰ä¸€ä¸ª `.buffer` å±æ€§ï¼Œå®ƒè®©ä½ å¯ä»¥è®¿é—®å…¶åº•å±‚çš„ `ArrayBuffer`ã€‚
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This concept of separating the memory (`ArrayBuffer`) from the view (`Buffer`
    or `Uint8Array`) has a powerful implication: you can have multiple views over
    the exact same block of memory.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: å°†å†…å­˜ï¼ˆ`ArrayBuffer`ï¼‰ä¸è§†å›¾ï¼ˆ`Buffer` æˆ– `Uint8Array`ï¼‰åˆ†ç¦»çš„æ¦‚å¿µå…·æœ‰å¼ºå¤§çš„å½±å“ï¼šä½ å¯ä»¥å¯¹åŒä¸€å—å†…å­˜æœ‰å¤šä¸ªè§†å›¾ã€‚
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Changing the bytes through one view is immediately reflected in the other, because
    they're both just different interpretations of the same underlying memory. This
    is an advanced technique, but it's a direct consequence of this memory architecture
    and is fundamental to high-performance libraries that need to work with complex
    binary data without creating unnecessary copies.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡ä¸€ä¸ªè§†å›¾æ›´æ”¹å­—èŠ‚ä¼šç«‹å³åæ˜ åœ¨å¦ä¸€ä¸ªè§†å›¾ä¸Šï¼Œå› ä¸ºå®ƒä»¬åªæ˜¯å¯¹åŒä¸€åº•å±‚å†…å­˜çš„ä¸åŒè§£é‡Šã€‚è¿™æ˜¯ä¸€ç§é«˜çº§æŠ€æœ¯ï¼Œä½†å®ƒç›´æ¥æºäºè¿™ç§å†…å­˜æ¶æ„ï¼Œå¹¶ä¸”å¯¹äºéœ€è¦å¤„ç†å¤æ‚äºŒè¿›åˆ¶æ•°æ®è€Œä¸åˆ›å»ºä¸å¿…è¦çš„å‰¯æœ¬çš„é«˜æ€§èƒ½åº“æ¥è¯´æ˜¯åŸºæœ¬çš„ã€‚
- en: ğŸ’¡Tip
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡æç¤º
- en: The ability to create multiple views on a single `ArrayBuffer` is a powerful
    optimization technique. It allows you to interpret the same binary data in different
    ways (e.g., as a struct of mixed integers and floats) without any data copying,
    which can be a significant performance win.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å•ä¸ª `ArrayBuffer` ä¸Šåˆ›å»ºå¤šä¸ªè§†å›¾æ˜¯ä¸€ç§å¼ºå¤§çš„ä¼˜åŒ–æŠ€æœ¯ã€‚å®ƒå…è®¸ä½ ä»¥ä¸åŒçš„æ–¹å¼è§£é‡Šç›¸åŒçš„äºŒè¿›åˆ¶æ•°æ®ï¼ˆä¾‹å¦‚ï¼Œä½œä¸ºæ··åˆæ•´æ•°å’Œæµ®ç‚¹æ•°çš„ç»“æ„ï¼‰ï¼Œè€Œä¸éœ€è¦ä»»ä½•æ•°æ®å¤åˆ¶ï¼Œè¿™å¯ä»¥å¸¦æ¥æ˜¾è‘—çš„æ€§èƒ½æå‡ã€‚
- en: The conclusion
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: Let's take a breath and recap the journey we just took. We started with a simple,
    practical task - handling a binary file - and immediately fell into a chasm between
    JavaScript's comfortable text-based world and the harsh, byte-based reality of
    systems programming.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å–˜å£æ°”ï¼Œå›é¡¾ä¸€ä¸‹æˆ‘ä»¬åˆšåˆšèµ°è¿‡çš„æ—…ç¨‹ã€‚æˆ‘ä»¬ä»ä¸€ä¸ªç®€å•ã€å®ç”¨çš„ä»»åŠ¡å¼€å§‹â€”â€”å¤„ç†äºŒè¿›åˆ¶æ–‡ä»¶â€”â€”å¹¶ç«‹å³é™·å…¥äº†ä¸€ä¸ªJavaScriptèˆ’é€‚çš„åŸºäºæ–‡æœ¬çš„ä¸–ç•Œå’Œç³»ç»Ÿç¼–ç¨‹æ®‹é…·çš„åŸºäºå­—èŠ‚çš„ç°å®ä¹‹é—´çš„é¸¿æ²Ÿã€‚
- en: 'We saw firsthand how the obvious tool, the string, failed spectacularly, not
    just performing poorly but actively corrupting our data by trying to force a linguistic
    interpretation onto it. This pushed us to look for a solution, and we found it
    in Node''s core architecture: a clever two-heap memory model that keeps large,
    static binary data outside the purview of V8''s garbage collector, preventing
    catastrophic performance issues.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬äº²çœ¼ç›®ç¹äº†æ˜¾è€Œæ˜“è§çš„å·¥å…·â€”â€”å­—ç¬¦ä¸²â€”â€”å¦‚ä½•å½»åº•å¤±è´¥ï¼Œä¸ä»…è¡¨ç°ä¸ä½³ï¼Œè¿˜é€šè¿‡è¯•å›¾å°†å…¶å¼ºåŠ äºå…¶ä¸Šçš„è¯­è¨€è§£é‡Šæ¥ä¸»åŠ¨ç ´åæˆ‘ä»¬çš„æ•°æ®ã€‚è¿™ä¿ƒä½¿æˆ‘ä»¬å¯»æ‰¾è§£å†³æ–¹æ¡ˆï¼Œå¹¶åœ¨Nodeçš„æ ¸å¿ƒæ¶æ„ä¸­æ‰¾åˆ°äº†å®ƒï¼šä¸€ä¸ªå·§å¦™çš„åŒå †å†…å­˜æ¨¡å‹ï¼Œå°†å¤§å‹ã€é™æ€çš„äºŒè¿›åˆ¶æ•°æ®ä¿æŒåœ¨V8åƒåœ¾æ”¶é›†å™¨ä¹‹å¤–ï¼Œé˜²æ­¢äº†ç¾éš¾æ€§çš„æ€§èƒ½é—®é¢˜ã€‚
- en: We met the `Buffer` class, Node's original, pragmatic tool for the job, with
    its rich, server-focused API. And finally, we saw how this once-proprietary solution
    has been beautifully integrated into the modern JavaScript ecosystem, becoming
    a specialized subclass of the standard `Uint8Array`, all built upon the fundamental
    `ArrayBuffer`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é‡åˆ°äº†`Buffer`ç±»ï¼Œè¿™æ˜¯Nodeçš„åŸå§‹ã€å®ç”¨çš„å·¥å…·ï¼Œå®ƒæ‹¥æœ‰ä¸°å¯Œçš„ã€é¢å‘æœåŠ¡å™¨çš„APIã€‚æœ€ç»ˆï¼Œæˆ‘ä»¬çœ‹åˆ°äº†è¿™ä¸ªæ›¾ç»ä¸“æœ‰çš„è§£å†³æ–¹æ¡ˆæ˜¯å¦‚ä½•å®Œç¾åœ°é›†æˆåˆ°ç°ä»£JavaScriptç”Ÿæ€ç³»ç»Ÿä¸­çš„ï¼Œæˆä¸ºæ ‡å‡†`Uint8Array`çš„ä¸€ä¸ªä¸“ç”¨å­ç±»ï¼Œæ‰€æœ‰è¿™äº›éƒ½å»ºç«‹åœ¨åŸºæœ¬çš„`ArrayBuffer`ä¹‹ä¸Šã€‚
- en: If there's one sentence to take away from this entire chapter, let it be this
    - **A Node.js `Buffer` is a performance-optimized, server-side-ergonomic subclass
    of `Uint8Array`, representing a view over a raw block of memory allocated outside
    the V8 garbage-collected heap.**
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœè¦ä»æ•´ä¸ªç« èŠ‚ä¸­æç‚¼ä¸€å¥è¯ï¼Œé‚£å°±æ˜¯è¿™å¥è¯â€”â€”**Node.jsçš„`Buffer`æ˜¯ä¸€ä¸ªæ€§èƒ½ä¼˜åŒ–çš„ã€é¢å‘æœåŠ¡å™¨çš„`Uint8Array`å­ç±»ï¼Œå®ƒè¡¨ç¤ºå¯¹åœ¨V8åƒåœ¾å›æ”¶å †å¤–åˆ†é…çš„åŸå§‹å†…å­˜å—çš„è§†å›¾ã€‚**
- en: Every part of that sentence is now something you understand deeply. You know
    *why* it needs to be outside the V8 heap, you know *why* it can't be a string,
    and you know how it relates to the modern standards you might use in the browser.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: å¥å­ä¸­çš„æ¯ä¸€éƒ¨åˆ†ç°åœ¨éƒ½æ˜¯ä½ æ·±åˆ»ç†è§£çš„ã€‚ä½ çŸ¥é“ä¸ºä»€ä¹ˆå®ƒéœ€è¦ä½äºV8å †ä¹‹å¤–ï¼Œä½ çŸ¥é“ä¸ºä»€ä¹ˆå®ƒä¸èƒ½æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä½ ä¹ŸçŸ¥é“å®ƒä¸ä½ åœ¨æµè§ˆå™¨ä¸­å¯èƒ½ä½¿ç”¨çš„ç°ä»£æ ‡å‡†ä¹‹é—´çš„å…³ç³»ã€‚
- en: 'This understanding isn''t just academic. It is the absolute bedrock for nearly
    every high-performance task you will undertake in Node.js. Now that we have a
    solid mental model for how Node represents chunks of binary data at rest, we are
    finally equipped to tackle Node''s most powerful I/O abstraction: Streams.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§ç†è§£ä¸ä»…ä»…æ˜¯å­¦æœ¯æ€§çš„ã€‚å®ƒæ˜¯ä½ åœ¨Node.jsä¸­æ‰§è¡Œå‡ ä¹æ‰€æœ‰é«˜æ€§èƒ½ä»»åŠ¡çš„ç»å¯¹åŸºçŸ³ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å¯¹Nodeå¦‚ä½•è¡¨ç¤ºé™æ€çš„äºŒè¿›åˆ¶æ•°æ®å—æœ‰äº†ç¨³å›ºçš„å¿ƒç†æ¨¡å‹ï¼Œæˆ‘ä»¬ç»ˆäºå¯ä»¥ç€æ‰‹å¤„ç†Nodeæœ€å¼ºå¤§çš„I/OæŠ½è±¡ï¼šæµã€‚
- en: In the next chapter, we're going to see how data flows through a Node application,
    not as one giant blob, but piece by piece, as a sequence of Buffers. Mastering
    this flow of data is the single most important skill for building scalable, memory-efficient
    systems. We've just figured out *what* Buffers are. Now, let's go find out what
    you can build with them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°æ•°æ®æ˜¯å¦‚ä½•åœ¨Nodeåº”ç”¨ç¨‹åºä¸­æµåŠ¨çš„ï¼Œä¸æ˜¯ä½œä¸ºä¸€ä¸ªå·¨å¤§çš„æ•´ä½“ï¼Œè€Œæ˜¯ä½œä¸ºä¸€ç³»åˆ—Bufferçš„ç‰‡æ®µã€‚æŒæ¡è¿™ç§æ•°æ®æµæ˜¯æ„å»ºå¯æ‰©å±•ã€å†…å­˜é«˜æ•ˆçš„ç³»ç»Ÿçš„æœ€é‡è¦çš„æŠ€èƒ½ã€‚æˆ‘ä»¬åˆšåˆšå¼„æ¸…æ¥š**Bufferæ˜¯ä»€ä¹ˆ**ã€‚ç°åœ¨ï¼Œè®©æˆ‘ä»¬å»æ¢ç´¢ä½ å¯ä»¥ç”¨å®ƒä»¬æ„å»ºä»€ä¹ˆã€‚
