- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DATA STRUCTURES: OBJECTS AND ARRAYS'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers, Booleans, and strings are the atoms from which data structures are
    built. Many types of information require more than one atom, though. *Objects*
    allow us to group values—including other objects—to build more complex structures.
  prefs: []
  type: TYPE_NORMAL
- en: The programs we have built so far have been limited by the fact that they were
    operating only on simple data types. After learning the basics of data structures
    in this chapter, you’ll know enough to start writing useful programs.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter will work through a more or less realistic programming example,
    introducing concepts as they apply to the problem at hand. The example code will
    often build on functions and bindings introduced earlier in the book.
  prefs: []
  type: TYPE_NORMAL
- en: The online coding sandbox for the book (*[https://eloquentjavascript.net/code](https://eloquentjavascript.net/code)*)
    provides a way to run code in the context of a particular chapter. If you decide
    to work through the examples in another environment, be sure to first download
    the full code for this chapter from the sandbox page.
  prefs: []
  type: TYPE_NORMAL
- en: The Weresquirrel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every now and then, usually between 8 PM and 10 PM, Jacques finds himself transforming
    into a small furry rodent with a bushy tail.
  prefs: []
  type: TYPE_NORMAL
- en: On one hand, Jacques is quite glad that he doesn’t have classic lycanthropy.
    Turning into a squirrel does cause fewer problems than turning into a wolf. Instead
    of having to worry about accidentally eating the neighbor (*that* would be awkward),
    he worries about being eaten by the neighbor’s cat. After two occasions of waking
    up on a precariously thin branch in the crown of an oak, naked and disoriented,
    he has taken to locking the doors and windows of his room at night and putting
    a few walnuts on the floor to keep himself busy.
  prefs: []
  type: TYPE_NORMAL
- en: But Jacques would prefer to get rid of his condition entirely. The irregular
    occurrences of the transformation make him suspect that they might be triggered
    by something. For a while, he believed that it happened only on days when he had
    been near oak trees. However, avoiding oak trees did not solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Switching to a more scientific approach, Jacques has started keeping a daily
    log of everything he does on a given day and whether he changed form. With this
    data he hopes to narrow down the conditions that trigger the transformations.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing he needs is a data structure to store this information.
  prefs: []
  type: TYPE_NORMAL
- en: Datasets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To work with a chunk of digital data, we first have to find a way to represent
    it in our machine’s memory. Say, for example, that we want to represent a collection
    of the numbers 2, 3, 5, 7, and 11.
  prefs: []
  type: TYPE_NORMAL
- en: We could get creative with strings—after all, strings can have any length, so
    we can put a lot of data into them—and use “2 3 5 7 11” as our representation.
    But this is awkward. We’d have to somehow extract the digits and convert them
    back to numbers to access them.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, JavaScript provides a data type specifically for storing sequences
    of values. It is called an *array* and is written as a list of values between
    square brackets, separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The notation for getting at the elements inside an array also uses square brackets.
    A pair of square brackets immediately after an expression, with another expression
    inside of them, will look up the element in the left-hand expression that corresponds
    to the *index* given by the expression in the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: The first index of an array is zero, not one, so the first element is retrieved
    with listOfNumbers[0]. Zero-based counting has a long tradition in technology
    and in certain ways makes a lot of sense, but it takes some getting used to. Think
    of the index as the number of items to skip, counting from the start of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve seen a few expressions like myString.length (to get the length of a string)
    and Math.max (the maximum function) in past chapters. These expressions access
    a *property* of some value. In the first case, we access the length property of
    the value in myString. In the second, we access the property named max in the
    Math object (which is a collection of mathematics-related constants and functions).
  prefs: []
  type: TYPE_NORMAL
- en: Almost all JavaScript values have properties. The exceptions are null and undefined.
    If you try to access a property on one of these nonvalues, you get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The two main ways to access properties in JavaScript are with a dot and with
    square brackets. Both value.x and value[x] access a property on value— but not
    necessarily the same property. The difference is in how x is interpreted. When
    using a dot, the word after the dot is the literal name of the property. When
    using square brackets, the expression between the brackets is *evaluated* to get
    the property name. Whereas value.x fetches the property of value named “x,” value[x]
    takes the value of the variable named x and uses that, converted to a string,
    as the property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know that the property in which you are interested is called *color*,
    you say value.color. If you want to extract the property named by the value held
    in the binding i, you say value[i]. Property names are strings. They can be any
    string, but the dot notation works only with names that look like valid binding
    names—starting with a letter or underscore, and containing only letters, numbers,
    and underscores. If you want to access a property named *2* or *John Doe*, you
    must use square brackets: value[2] or value[“John Doe”].'
  prefs: []
  type: TYPE_NORMAL
- en: The elements in an array are stored as the array’s properties, using numbers
    as property names. Because you can’t use the dot notation with numbers and usually
    want to use a binding that holds the index anyway, you have to use the bracket
    notation to get at them.
  prefs: []
  type: TYPE_NORMAL
- en: Just like strings, arrays have a length property that tells us how many elements
    the array has.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both string and array values contain, in addition to the length property, a
    number of properties that hold function values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Every string has a toUpperCase property. When called, it will return a copy
    of the string in which all letters have been converted to uppercase. There is
    also toLowerCase, going the other way.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, even though the call to toUpperCase does not pass any arguments,
    the function somehow has access to the string “Doh”, the value whose property
    we called. You’ll find out how this works in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: Properties that contain functions are generally called *methods* of the value
    they belong to, as in “toUpperCase is a method of a string.”
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates two methods you can use to manipulate arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The push method adds values to the end of an array. The pop method does the
    opposite, removing the last value in the array and returning it.
  prefs: []
  type: TYPE_NORMAL
- en: These somewhat silly names are the traditional terms for operations on a *stack*.
    A stack, in programming, is a data structure that allows you to push values into
    it and pop them out again in the opposite order so that the thing that was added
    last is removed first. Stacks are common in programming— you might remember the
    function call stack from the previous chapter, which is an instance of the same
    idea.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back to the weresquirrel. A set of daily log entries can be represented as an
    array, but the entries do not consist of just a number or a string—each entry
    needs to store a list of activities and a Boolean value that indicates whether
    Jacques turned into a squirrel or not. Ideally, we would like to group these together
    into a single value and then put those grouped values into an array of log entries.
  prefs: []
  type: TYPE_NORMAL
- en: Values of the type *object* are arbitrary collections of properties. One way
    to create an object is by using braces as an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inside the braces, you write a list of properties separated by commas. Each
    property has a name followed by a colon and a value. When an object is written
    over multiple lines, indenting it as shown in this example helps with readability.
    Properties whose names aren’t valid binding names or valid numbers must be quoted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that braces have *two* meanings in JavaScript. At the start of a
    statement, they begin a block of statements. In any other position, they describe
    an object. Fortunately, it is rarely useful to start a statement with an object
    in braces, so the ambiguity between these two is not much of a problem. The one
    case where this does come up is when you want to return an object from a shorthand
    arrow function—you can’t write n => {prop: n}, since the braces will be interpreted
    as a function body. Instead, you have to put a set of parentheses around the object
    to make it clear that it is an expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading a property that doesn’t exist will give you the value undefined.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to assign a value to a property expression with the = operator.
    This will replace the property’s value if it already existed or create a new property
    on the object if it didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: To briefly return to our tentacle model of bindings—property bindings are similar.
    They *grasp* values, but other bindings and properties might be holding onto those
    same values. You can think of objects as octopuses with any number of tentacles,
    each of which has a name written on it.
  prefs: []
  type: TYPE_NORMAL
- en: The delete operator cuts off a tentacle from such an octopus. It is a unary
    operator that, when applied to an object property, will remove the named property
    from the object. This is not a common thing to do, but it is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The binary in operator, when applied to a string and an object, tells you whether
    that object has a property with that name. The difference between setting a property
    to undefined and actually deleting it is that in the first case, the object still
    *has* the property (it just doesn’t have a very interesting value), whereas in
    the second case, the property is no longer present and in will return false.
  prefs: []
  type: TYPE_NORMAL
- en: To find out what properties an object has, you can use the Object.keys function.
    Give the function an object and it will return an array of strings— the object’s
    property names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There’s an Object.assign function that copies all properties from one object
    into another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Arrays, then, are just a kind of object specialized for storing sequences of
    things. If you evaluate typeof [], it produces “object”. You can visualize arrays
    as long, flat octopuses with all their tentacles in a neat row, labeled with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Jacques will represent the journal that he keeps as an array of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Mutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will get to actual programming soon, but first, there’s one more piece of
    theory to understand.
  prefs: []
  type: TYPE_NORMAL
- en: We saw that object values can be modified. The types of values discussed in
    earlier chapters, such as numbers, strings, and Booleans, are all *immutable*—
    it is impossible to change values of those types. You can combine them and derive
    new values from them, but when you take a specific string value, that value will
    always remain the same. The text inside it cannot be changed. If you have a string
    that contains “cat”, it is not possible for other code to change a character in
    your string to make it spell “rat”.
  prefs: []
  type: TYPE_NORMAL
- en: Objects work differently. You *can* change their properties, causing a single
    object value to have different content at different times.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we have two numbers, 120 and 120, we can consider them precisely the same
    number, whether or not they refer to the same physical bits. With objects, there
    is a difference between having two references to the same object and having two
    different objects that contain the same properties. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The object1 and object2 bindings grasp the *same* object, which is why changing
    object1 also changes the value of object2. They are said to have the same *identity*.
    The binding object3 points to a different object, which initially contains the
    same properties as object1 but lives a separate life.
  prefs: []
  type: TYPE_NORMAL
- en: Bindings can also be changeable or constant, but this is separate from the way
    their values behave. Even though number values don’t change, you can use a let
    binding to keep track of a changing number by changing the value at which the
    binding points. Similarly, though a const binding to an object can itself not
    be changed and will continue to point at the same object, the *contents* of that
    object might change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you compare objects with JavaScript’s == operator, it compares by identity:
    it will produce true only if both objects are precisely the same value. Comparing
    different objects will return false, even if they have identical properties. There
    is no “deep” comparison operation built into Java-Script that compares objects
    by contents, but it is possible to write it yourself (which is one of the exercises
    at the end of this chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: The Lycanthrope’s Log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jacques starts up his JavaScript interpreter and sets up the environment he
    needs to keep his journal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the object added to the journal looks a little odd. Instead of declaring
    properties like events: events, it just gives a property name: events. This is
    shorthand that means the same thing—if a property name in brace notation isn’t
    followed by a value, its value is taken from the binding with the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: Every evening at 10 PM—or sometimes the next morning, after climbing down from
    the top shelf of his bookcase—Jacques records the day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Once he has enough data points, he intends to use statistics to find out which
    of these events may be related to the squirrelifications.
  prefs: []
  type: TYPE_NORMAL
- en: '*Correlation* is a measure of dependence between statistical variables. A statistical
    variable is not quite the same as a programming variable. In statistics you typically
    have a set of *measurements*, and each variable is measured for every measurement.
    Correlation between variables is usually expressed as a value that ranges from
    –1 to 1\. Zero correlation means the variables are not related. A correlation
    of 1 indicates that the two are perfectly related—if you know one, you also know
    the other. Negative 1 also means that the variables are perfectly related but
    are opposites—when one is true, the other is false.'
  prefs: []
  type: TYPE_NORMAL
- en: To compute the measure of correlation between two Boolean variables, we can
    use the *phi coefficient* (*φ*). This is a formula whose input is a frequency
    table containing the number of times the different combinations of the variables
    were observed. The output of the formula is a number between –1 and 1 that describes
    the correlation.
  prefs: []
  type: TYPE_NORMAL
- en: We could take the event of eating pizza and put that in a frequency table like
    this, where each number indicates the number of times that combination occurred
    in our measurements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0065-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we call that table *n*, we can compute *φ* using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0065-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (If at this point you’re putting the book down to focus on a terrible flash-back
    to 10th grade math class—hold on! I do not intend to torture you with endless
    pages of cryptic notation—it’s just this one formula for now. And even with this
    one, all we do is turn it into JavaScript.)
  prefs: []
  type: TYPE_NORMAL
- en: The notation *n*[01] indicates the number of measurements where the first variable
    (squirrelness) is false (0) and the second variable (pizza) is true (1). In the
    pizza table, *n*[01] is 9.
  prefs: []
  type: TYPE_NORMAL
- en: The value *n*[1*•*] refers to the sum of all measurements where the first variable
    is true, which is 5 in the example table. Likewise, *n*[•0] refers to the sum
    of the measurements where the second variable is false.
  prefs: []
  type: TYPE_NORMAL
- en: So for the pizza table, the part above the division line (the dividend) would
    be 1 *×* 76 − 4 *×* 9 = 40, and the part below it (the divisor) would be the square
    root of 5 *×* 85 *×* 10 *×* 80, or ![Image](../images/f0065-03.jpg). This comes
    out to *φ ≈* 0.069, which is tiny. Eating pizza does not appear to have influence
    on the transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Computing Correlation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can represent a two-by-two table in JavaScript with a four-element array
    ([76, 9, 4, 1]). We could also use other representations, such as an array containing
    two two-element arrays ([[76, 9], [4, 1]]) or an object with property names like
    “11” and “01”, but the flat array is simple and makes the expressions that access
    the table pleasantly short. We’ll interpret the indices to the array as two-bit
    binary numbers, where the leftmost (most significant) digit refers to the squirrel
    variable and the rightmost (least significant) digit refers to the event variable.
    For example, the binary number 10 refers to the case where Jacques did turn into
    a squirrel, but the event (say, “pizza”) didn’t occur. This happened four times.
    And since binary 10 is 2 in decimal notation, we will store this number at index
    2 of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the function that computes the *φ* coefficient from such an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a direct translation of the *φ* formula into JavaScript. Math.sqrt is
    the square root function, as provided by the Math object in a standard Java-Script
    environment. We have to add two fields from the table to get fields like *n*[1*•*]
    because the sums of rows or columns are not stored directly in our data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Jacques keeps his journal for three months. The resulting dataset is available
    in the coding sandbox for this chapter (*[https://eloquentjavascript.net/code#4](https://eloquentjavascript.net/code#4)*),
    where it is stored in the JOURNAL binding, and in a downloadable file.
  prefs: []
  type: TYPE_NORMAL
- en: To extract a two-by-two table for a specific event from the journal, we must
    loop over all the entries and tally how many times the event occurs in relation
    to squirrel transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Arrays have an includes method that checks whether a given value exists in the
    array. The function uses that to determine whether the event name it is interested
    in is part of the event list for a given day.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the loop in tableFor figures out which box in the table each journal
    entry falls into by checking whether the entry contains the specific event it’s
    interested in and whether the event happens alongside a squirrel incident. The
    loop then adds one to the correct box in the table.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the tools we need to compute individual correlations. The only step
    remaining is to find a correlation for every type of event that was recorded and
    see whether anything stands out.
  prefs: []
  type: TYPE_NORMAL
- en: Array Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the tableFor function, there’s a loop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This kind of loop is common in classical JavaScript—going over arrays one element
    at a time is something that comes up a lot, and to do that you’d run a counter
    over the length of the array and pick out each element in turn.
  prefs: []
  type: TYPE_NORMAL
- en: There is a simpler way to write such loops in modern JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When a for loop uses the word of after its variable definition, it will loop
    over the elements of the value given after of. This works not only for arrays
    but also for strings and some other data structures. We’ll discuss *how* it works
    in [Chapter 6](ch06.xhtml#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: The Final Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to compute a correlation for every type of event that occurs in the
    dataset. To do that, we first need to *find* every type of event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By adding any event names that aren’t already in it to the events array, the
    function collects every type of event.
  prefs: []
  type: TYPE_NORMAL
- en: Using that function, we can see all the correlations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Most correlations seem to lie close to zero. Eating carrots, bread, or pudding
    apparently does not trigger squirrel-lycanthropy. The transformations *do* seem
    to occur somewhat more often on weekends. Let’s filter the results to show only
    correlations greater than 0.1 or less than –0.1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Aha! There are two factors with a correlation clearly stronger than the others.
    Eating peanuts has a strong positive effect on the chance of turning into a squirrel,
    whereas brushing teeth has a significant negative effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting. Let’s try something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That’s a strong result. The phenomenon occurs precisely when Jacques eats peanuts
    and fails to brush his teeth. If only he weren’t such a slob about dental hygiene,
    he’d never even have noticed his affliction.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing this, Jacques stops eating peanuts altogether and finds that his transformations
    stop.
  prefs: []
  type: TYPE_NORMAL
- en: But it takes only a few months for him to notice that something is missing from
    this entirely human way of living. Without his feral adventures, Jacques hardly
    feels alive at all. He decides he’d rather be a full-time wild animal. After building
    a beautiful little tree house in the forest and equipping it with a peanut butter
    dispenser and a ten-year supply of peanut butter, he changes form one last time
    and lives the short and energetic life of a squirrel.
  prefs: []
  type: TYPE_NORMAL
- en: Further Arrayology
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before finishing the chapter, I want to introduce you to a few more object-related
    concepts. I’ll start with some generally useful array methods.
  prefs: []
  type: TYPE_NORMAL
- en: We saw push and pop, which add and remove elements at the end of an array, earlier
    in this chapter. The corresponding methods for adding and removing things at the
    start of an array are called unshift and shift.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This program manages a queue of tasks. You add tasks to the end of the queue
    by calling remember(“groceries”), and when you’re ready to do something, you call
    getTask() to get (and remove) the front item from the queue. The rememberUrgently
    function also adds a task but adds it to the front instead of the back of the
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: To search for a specific value, arrays provide an indexOf method. The method
    searches through the array from the start to the end and returns the index at
    which the requested value was found—or –1 if it wasn’t found. To search from the
    end instead of the start, there’s a similar method called lastIndexOf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Both indexOf and lastIndexOf take an optional second argument that indicates
    where to start searching.
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamental array method is slice, which takes start and end indices
    and returns an array that has only the elements between them. The start index
    is inclusive and the end index is exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the end index is not given, slice will take all of the elements after the
    start index. You can also omit the start index to copy the entire array.
  prefs: []
  type: TYPE_NORMAL
- en: The concat method can be used to append arrays together to create a new array,
    similar to what the + operator does for strings.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows both concat and slice in action. It takes an array
    and an index and returns a new array that is a copy of the original array with
    the element at the given index removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If you pass concat an argument that is not an array, that value will be added
    to the new array as if it were a one-element array.
  prefs: []
  type: TYPE_NORMAL
- en: Strings and Their Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can read properties like length and toUpperCase from string values. But if
    we try to add a new property, it doesn’t stick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Values of type string, number, and Boolean are not objects, and though the language
    doesn’t complain if you try to set new properties on them, it doesn’t actually
    store those properties. As mentioned earlier, such values are immutable and cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: But these types do have built-in properties. Every string value has a number
    of methods. Some very useful ones are slice and indexOf, which resemble the array
    methods of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: One difference is that a string’s indexOf can search for a string containing
    more than one character, whereas the corresponding array method looks only for
    a single element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The trim method removes whitespace (spaces, newlines, tabs, and similar characters)
    from the start and end of a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The zeroPad function from the previous chapter also exists as a method. It is
    called padStart and takes the desired length and padding character as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can split a string on every occurrence of another string with split and
    join it again with join.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A string can be repeated with the repeat method, which creates a new string
    containing multiple copies of the original string, glued together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have already seen the string type’s length property. Accessing the individual
    characters in a string looks like accessing array elements (with a complication
    that we’ll discuss in [Chapter 5](ch05.xhtml#ch05)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Rest Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can be useful for a function to accept any number of arguments. For example,
    Math.max computes the maximum of *all* the arguments it is given. To write such
    a function, you put three dots before the function’s last parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When such a function is called, the *rest parameter* is bound to an array containing
    all further arguments. If there are other parameters before it, their values aren’t
    part of that array. When, as in max, it is the only parameter, it will hold all
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a similar three-dot notation to *call* a function with an array
    of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This “spreads” out the array into the function call, passing its elements as
    separate arguments. It is possible to include an array like that along with other
    arguments, as in max(9, ...numbers, 2).
  prefs: []
  type: TYPE_NORMAL
- en: Square bracket array notation similarly allows the triple-dot operator to spread
    another array into the new array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This works even in curly brace objects, where it adds all properties from another
    object. If a property is added multiple times, the last value to be added wins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The Math Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we’ve seen, Math is a grab bag of number-related utility functions such as
    Math.max (maximum), Math.min (minimum), and Math.sqrt (square root).
  prefs: []
  type: TYPE_NORMAL
- en: The Math object is used as a container to group a bunch of related functionality.
    There is only one Math object, and it is almost never useful as a value. Rather,
    it provides a *namespace* so that all these functions and values do not have to
    be global bindings.
  prefs: []
  type: TYPE_NORMAL
- en: Having too many global bindings “pollutes” the namespace. The more names have
    been taken, the more likely you are to accidentally overwrite the value of some
    existing binding. For example, it’s not unlikely you’ll want to name something
    max in one of your programs. Since JavaScript’s built-in max function is tucked
    safely inside the Math object, you don’t have to worry about overwriting it.
  prefs: []
  type: TYPE_NORMAL
- en: Many languages will stop you, or at least warn you, when you are defining a
    binding with a name that is already taken. JavaScript does this for bindings you
    declared with let or const but—perversely—not for standard bindings nor for bindings
    declared with var or function.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Math object. If you need to do trigonometry, Math can help. It contains
    cos (cosine), sin (sine), and tan (tangent), as well as their inverse functions,
    acos, asin, and atan, respectively. The number *π* (pi)—or at least the closest
    approximation that fits in a JavaScript number—is available as Math.PI. There
    is an old programming tradition of writing the names of constant values in all
    caps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you’re not familiar with sines and cosines, don’t worry. I’ll explain them
    when they are used in [Chapter 14](ch14.xhtml#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: The previous example used Math.random. This is a function that returns a new
    pseudorandom number between 0 (inclusive) and 1 (exclusive) every time you call
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Though computers are deterministic machines—they always react the same way if
    given the same input—it is possible to have them produce numbers that appear random.
    To do that, the machine keeps some hidden value, and whenever you ask for a new
    random number, it performs complicated computations on this hidden value to create
    a new value. It stores a new value and returns some number derived from it. That
    way, it can produce ever new, hard-to-predict numbers in a way that *seems* random.
  prefs: []
  type: TYPE_NORMAL
- en: If we want a whole random number instead of a fractional one, we can use Math.floor
    (which rounds down to the nearest whole number) on the result of Math.random.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Multiplying the random number by 10 gives us a number greater than or equal
    to 0 and below 10\. Since Math.floor rounds down, this expression will produce,
    with equal chance, any number from 0 through 9.
  prefs: []
  type: TYPE_NORMAL
- en: There are also the functions Math.ceil (for “ceiling,” which rounds up to a
    whole number), Math.round (to the nearest whole number), and Math.abs, which takes
    the absolute value of a number, meaning it negates negative values but leaves
    positive ones as they are.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s return to the phi function for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: One reason this function is awkward to read is that we have a binding pointing
    at our array, but we’d much prefer to have bindings for the *elements* of the
    array—that is, let n00 = table[0] and so on. Fortunately, there is a succinct
    way to do this in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This also works for bindings created with let, var, or const. If you know that
    the value you are binding is an array, you can use square brackets to “look inside”
    of the value, binding its contents.
  prefs: []
  type: TYPE_NORMAL
- en: A similar trick works for objects, using braces instead of square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you try to destructure null or undefined, you get an error, much
    as you would if you directly try to access a property of those values.
  prefs: []
  type: TYPE_NORMAL
- en: Optional Property Access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you aren’t sure whether a given value produces an object, but still want
    to read a property from it when it does, you can use a variant of the dot notation:
    object?.property.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The expression a?.b means the same as a.b when a isn’t null or undefined. When
    it is, it evaluates to undefined. This can be convenient when, as in the example,
    you aren’t sure that a given property exists or when a variable might hold an
    undefined value.
  prefs: []
  type: TYPE_NORMAL
- en: A similar notation can be used with square bracket access, and even with function
    calls, by putting ?. in front of the parentheses or brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because properties grasp their value rather than contain it, objects and arrays
    are stored in the computer’s memory as sequences of bits holding the *addresses*—the
    place in memory—of their contents. An array with another array inside of it consists
    of (at least) one memory region for the inner array and another for the outer
    array, containing (among other things) a number that represents the address of
    the inner array.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save data in a file for later or send it to another computer
    over the network, you have to somehow convert these tangles of memory addresses
    to a description that can be stored or sent. You *could* send over your entire
    computer memory along with the address of the value you’re interested in, I suppose,
    but that doesn’t seem like the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: What we can do is *serialize* the data. That means it is converted into a flat
    description. A popular serialization format is called *JSON* (pronounced “Jason”),
    which stands for JavaScript Object Notation. It is widely used as a data storage
    and communication format on the web, even with languages other than JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JSON looks similar to JavaScript’s way of writing arrays and objects, with a
    few restrictions. All property names have to be surrounded by double quotes, and
    only simple data expressions are allowed—no function calls, bindings, or anything
    that involves actual computation. Comments are not allowed in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'A journal entry might look like this when represented as JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript gives us the functions JSON.stringify and JSON.parse to convert data
    to and from this format. The first takes a JavaScript value and returns a JSON-encoded
    string. The second takes such a string and converts it to the value it encodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects and arrays provide ways to group several values into a single value.
    This allows us to put a bunch of related things in a bag and run around with the
    bag instead of wrapping our arms around all of the individual things and trying
    to hold on to them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Most values in JavaScript have properties, with the exceptions being null and
    undefined. Properties are accessed using value.prop or value[“prop”]. Objects
    tend to use names for their properties and store more or less a fixed set of them.
    Arrays, on the other hand, usually contain varying amounts of conceptually identical
    values and use numbers (starting from 0) as the names of their properties.
  prefs: []
  type: TYPE_NORMAL
- en: There *are* some named properties in arrays, such as length and a number of
    methods. Methods are functions that live in properties and (usually) act on the
    value of which they are a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can iterate over arrays using a special kind of for loop: for (let *element*
    of *array*).'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Sum of a Range*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The introduction of this book alluded to the following as a nice way to compute
    the sum of a range of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Write a range function that takes two arguments, start and end, and returns
    an array containing all the numbers from start up to and including end.
  prefs: []
  type: TYPE_NORMAL
- en: Next, write a sum function that takes an array of numbers and returns the sum
    of these numbers. Run the example program and see whether it does indeed return
    55.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus assignment, modify your range function to take an optional third
    argument that indicates the “step” value used when building the array. If no step
    is given, the elements should go up by increments of one, corresponding to the
    old behavior. The function call range(1, 10, 2) should return [1, 3, 5, 7, 9].
    Make sure this also works with negative step values so that range(5, 2, -1) produces
    [5, 4, 3, 2].
  prefs: []
  type: TYPE_NORMAL
- en: '*Reversing an Array*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Arrays have a reverse method that changes the array by inverting the order
    in which its elements appear. For this exercise, write two functions, reverseArray
    and reverseArrayInPlace. The first, reverseArray, should take an array as its
    argument and produce a *new* array that has the same elements in the inverse order.
    The second, reverseArrayInPlace, should do what the reverse method does: *modify*
    the array given as its argument by reversing its elements. Neither may use the
    standard reverse method.'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking back to the notes about side effects and pure functions in the previous
    chapter, which variant do you expect to be useful in more situations? Which one
    runs faster?
  prefs: []
  type: TYPE_NORMAL
- en: '*A List*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As generic blobs of values, objects can be used to build all sorts of data structures.
    A common data structure is the *list* (not to be confused with arrays). A list
    is a nested set of objects with the first object holding a reference to the second,
    the second to the third, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting objects form a chain, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0078-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A nice thing about lists is that they can share parts of their structure. For
    example, if I create two new values {value: 0, rest: list} and {value: -1, rest:
    list} (with list referring to the binding defined earlier), they are both independent
    lists, but they share the structure that makes up their last three elements. The
    original list is also still a valid three-element list.'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function arrayToList that builds up a list structure like the one shown
    when given [1, 2, 3] as its argument. Also write a listToArray function that produces
    an array from a list. Add the helper functions prepend, which takes an element
    and a list and creates a new list that adds the element to the front of the input
    list, and nth, which takes a list and a number and returns the element at the
    given position in the list (with zero referring to the first element) or undefined
    when there is no such element.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already, also write a recursive version of nth.
  prefs: []
  type: TYPE_NORMAL
- en: '*Deep Comparison*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The == operator compares objects by identity, but sometimes you’d prefer to
    compare the values of their actual properties.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function deepEqual that takes two values and returns true only if they
    are the same value or are objects with the same properties, where the values of
    the properties are equal when compared with a recursive call to deepEqual.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out whether values should be compared directly (using the === operator)
    or have their properties compared, you can use the typeof operator. If it produces
    “object” for both values, you should do a deep comparison. But you have to take
    one silly exception into account: because of a historical accident, typeof null
    also produces “object”.'
  prefs: []
  type: TYPE_NORMAL
- en: The Object.keys function will be useful when you need to go over the properties
    of objects to compare them.
  prefs: []
  type: TYPE_NORMAL
- en: '*There are two ways of constructing a software design: One way is to make it
    so simple that there are obviously no deficiencies, and the other way is to make
    it so complicated that there are no obvious deficiencies.*'
  prefs: []
  type: TYPE_NORMAL
- en: —C.A.R. Hoare, *1980 ACM Turing Award Lecture*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0080-01.jpg)'
  prefs: []
  type: TYPE_IMG
