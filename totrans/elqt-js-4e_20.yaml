- en: '18'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP AND FORMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HyperText Transfer Protocol, introduced in [Chapter 13](ch13.xhtml#ch13),
    is the mechanism through which data is requested and provided on the World Wide
    Web. This chapter describes the protocol in more detail and explains the way browser
    JavaScript has access to it.
  prefs: []
  type: TYPE_NORMAL
- en: The Protocol
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you type *[eloquentjavascript.net/18_http.xhtml](http://eloquentjavascript.net/18_http.xhtml)*
    in your browser’s address bar, the browser first looks up the address of the server
    associated with *eloquent [javascript.net](http://javascript.net)* and tries to
    open a TCP connection to it on port 80, the default port for HTTP traffic. If
    the server exists and accepts the connection, the browser might send something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then the server responds, through that same connection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The browser takes the part of the response after the blank line, its *body*
    (not to be confused with the HTML <body> tag), and displays it as an HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information sent by the client is called the *request*. It starts with
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first word is the *method* of the request. GET means that we want to *get*
    the specified resource. Other common methods are DELETE to delete a resource,
    PUT to create or replace it, and POST to send information to it. Note that the
    server is not obliged to carry out every request it gets. If you walk up to a
    random website and tell it to DELETE its main page, it’ll probably refuse.
  prefs: []
  type: TYPE_NORMAL
- en: The part after the method name is the path of the *resource* the request applies
    to. In the simplest case, a resource is simply a file on the server, but the protocol
    doesn’t require it to be. A resource may be anything that can be transferred *as
    if* it is a file. Many servers generate the responses they produce on the fly.
    For example, if you open *[https://github.com/marijnh](https://github.com/marijnh)*,
    the server looks in its database for a user named *marijnh*, and if it finds one,
    it will generate a profile page for that user.
  prefs: []
  type: TYPE_NORMAL
- en: After the resource path, the first line of the request mentions HTTP/1.1 to
    indicate the version of the HTTP protocol it is using.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, many sites use HTTP version 2, which supports the same concepts
    as version 1.1 but is a lot more complicated so that it can be faster. Browsers
    will automatically switch to the appropriate protocol version when talking to
    a given server, and the outcome of a request is the same regardless of which version
    is used. Because version 1.1 is more straightforward and easier to play around
    with, we’ll use that to illustrate the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The server’s response will start with a version as well, followed by the status
    of the response, first as a three-digit status code and then as a human-readable
    string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Status codes starting with a 2 indicate that the request succeeded. Codes starting
    with 4 mean there was something wrong with the request. The most famous HTTP status
    code is probably 404, which means that the resource could not be found. Codes
    that start with 5 mean an error happened on the server and the request is not
    to blame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line of a request or response may be followed by any number of *headers*.
    These are lines in the form name: value that specify extra information about the
    request or response. These headers were part of the example response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This tells us the size and type of the response document. In this case, it is
    an HTML document of 87,320 bytes. It also tells us when that document was last
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: The client and server are free to decide what headers to include in their requests
    or responses. But some of them are necessary for things to work. For example,
    without a Content-Type header in the response, the browser won’t know how to display
    the document.
  prefs: []
  type: TYPE_NORMAL
- en: After the headers, both requests and responses may include a blank line followed
    by a body, which contains the actual document being sent. GET and DELETE requests
    don’t send along any data, but PUT and POST requests do. Some response types,
    such as error responses, also don’t require a body.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers and HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw, a browser will make a request when we enter a URL in its address
    bar. When the resulting HTML page references other files, such as images and JavaScript
    files, it will retrieve those as well.
  prefs: []
  type: TYPE_NORMAL
- en: A moderately complicated website can easily include anywhere from 10 to 200
    resources. To be able to fetch those quickly, browsers will make several GET requests
    simultaneously, rather than waiting for the responses one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML pages may include *forms*, which allow the user to fill out information
    and send it to the server. This is an example of a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code describes a form with two fields: a small one asking for a name and
    a larger one to write a message in. When you click the Send button, the form is
    *submitted*, meaning that the content of its field is packed into an HTTP request
    and the browser navigates to the result of that request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the <form> element’s method attribute is GET (or is omitted), the information
    in the form is added to the end of the action URL as a *query string*. The browser
    might make a request to this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The question mark indicates the end of the path part of the URL and the start
    of the query. It is followed by pairs of names and values, corresponding to the
    name attribute on the form field elements and the content of those elements, respectively.
    An ampersand character (&) is used to separate the pairs.
  prefs: []
  type: TYPE_NORMAL
- en: The actual message encoded in the URL is “Yes?” but the question mark is replaced
    by a strange code. Some characters in query strings must be escaped. The question
    mark, represented as %3F, is one of those. There seems to be an unwritten rule
    that every format needs its own way of escaping characters. This one, called *URL
    encoding*, uses a percent sign followed by two hexadecimal (base 16) digits that
    encode the character code. In this case, 3F, which is 63 in decimal notation,
    is the code of a question mark character. JavaScript provides the encodeURIComponent
    and decodeURIComponent functions to encode and decode this format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we change the method attribute of the HTML form in the example we saw earlier
    to POST, the HTTP request made to submit the form will use the POST method and
    put the query string in the body of the request rather than adding it to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: GET requests should be used for requests that do not have side effects but simply
    ask for information. Requests that change something on the server, for example
    creating a new account or posting a message, should be expressed with other methods,
    such as POST. Client-side software such as a browser knows that it shouldn’t blindly
    make POST requests but will often implicitly make GET requests—to prefetch a resource
    it believes the user will soon need, for example.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to forms and how to interact with them from JavaScript later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface through which browser JavaScript can make HTTP requests is called
    fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling fetch returns a promise that resolves to a Response object holding information
    about the server’s response, such as its status code and its headers. The headers
    are wrapped in a Map-like object that treats its keys (the header names) as case
    insensitive because header names are not supposed to be case sensitive. This means
    headers.get(“Content-Type”) and headers.get (“content-TYPE”) will return the same
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the promise returned by fetch resolves successfully even if the server
    responded with an error code. It can also be rejected if there is a network error
    or if the server to which the request is addressed can’t be found.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to fetch is the URL that should be requested. When that URL
    doesn’t start with a protocol name (such as *http:*), it is treated as *relative*,
    which means it is interpreted relative to the current document. When it starts
    with a slash (/), it replaces the current path, which is the part after the server
    name. When it does not, the part of the current path up to and including its last
    slash character is put in front of the relative URL.
  prefs: []
  type: TYPE_NORMAL
- en: To get at the actual content of a response, you can use its text method. Because
    the initial promise is resolved as soon as the response’s headers have been received
    and because reading the response body might take a while longer, this again returns
    a promise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A similar method, called json, returns a promise that resolves to the value
    you get when parsing the body as JSON or rejects if it’s not valid JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, fetch uses the GET method to make its request and does not include
    a request body. You can configure it differently by passing an object with extra
    options as a second argument. For example, this request tries to delete *example/data.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The 405 status code means “method not allowed,” an HTTP server’s way of saying
    “I’m afraid I can’t do that.”
  prefs: []
  type: TYPE_NORMAL
- en: To add a request body for a PUT or POST request, you can include a body option.
    To set headers, there’s the headers option. For example, this request includes
    a Range header, which instructs the server to return only part of a document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The browser will automatically add some request headers, such as “Host” and
    those needed for the server to figure out the size of the body. But adding your
    own headers is often useful to include things such as authentication information
    or to tell the server which file format you’d like to receive.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Sandboxing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making HTTP requests in web page scripts once again raises concerns about security.
    The person who controls the script might not have the same interests as the person
    on whose computer it is running. More specifically, if I visit *themafia.org*,
    I do not want its scripts to be able to make a request to *mybank.com*, using
    identifying information from my browser, with instructions to transfer away all
    my money.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, browsers protect us by disallowing scripts to make HTTP requests
    to other domains (names such as *themafia.org* and *mybank.com*).
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be an annoying problem when building systems that want to access several
    domains for legitimate reasons. Fortunately, servers can include a header like
    this in their response to explicitly indicate to the browser that it is OK for
    the request to come from another domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Appreciating HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building a system that requires communication between a JavaScript program
    running in the browser (client-side) and a program on a server (server-side),
    there are several different ways to model this communication.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly used model is that of *remote procedure calls*. In this model, communication
    follows the patterns of normal function calls, except that the function is actually
    running on another machine. Calling it involves making a request to the server
    that includes the function’s name and arguments. The response to that request
    contains the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: When thinking in terms of remote procedure calls, HTTP is just a vehicle for
    communication, and you will most likely write an abstraction layer that hides
    it entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach is to build your communication around the concept of resources
    and HTTP methods. Instead of a remote procedure called addUser, you use a PUT
    request to */users/larry*. Instead of encoding that user’s properties in function
    arguments, you define a JSON document format (or use an existing format) that
    represents a user. The body of the PUT request to create a new resource is then
    such a document. A resource is fetched by making a GET request to the resource’s
    URL (for example, */users/larry*), which again returns the document representing
    the resource.
  prefs: []
  type: TYPE_NORMAL
- en: This second approach makes it easier to use some of the features that HTTP provides,
    such as support for caching resources (keeping a copy of a resource on the client
    for fast access). The concepts used in HTTP, which are well designed, can provide
    a helpful set of principles to design your server interface around.
  prefs: []
  type: TYPE_NORMAL
- en: Security and HTTPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Data traveling over the internet tends to follow a long, dangerous road. To
    get to its destination, it must hop through anything from coffee shop Wi-Fi hotspots
    to networks controlled by various companies and states. At any point along its
    route, it may be inspected or even modified.
  prefs: []
  type: TYPE_NORMAL
- en: If it is important that something remain secret, such as the password to your
    email account, or that it arrive at its destination unmodified, such as the account
    number you transfer money to via your bank’s website, plain HTTP is not good enough.
  prefs: []
  type: TYPE_NORMAL
- en: The secure HTTP protocol, used for URLs starting with *https://*, wraps HTTP
    traffic in a way that makes it harder to read and tamper with. Before exchanging
    data, the client verifies that the server is who it claims to be by asking it
    to prove that it has a cryptographic certificate issued by a certificate authority
    that the browser recognizes. Next, all data going over the connection is encrypted
    in a way that should prevent eavesdropping and tampering.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when it works right, HTTPS prevents other people from impersonating the
    website you are trying to talk to *and* from snooping on your communication. It’s
    not perfect, and there have been various incidents where HTTPS failed because
    of forged or stolen certificates and broken software, but it is a *lot* safer
    than plain HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Form Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forms were originally designed for the pre-JavaScript web to allow websites
    to send user-submitted information in an HTTP request. This design assumes that
    interaction with the server always happens by navigating to a new page.
  prefs: []
  type: TYPE_NORMAL
- en: However, the form elements are part of the DOM, like the rest of the page, and
    the DOM elements that represent form fields support a number of properties and
    events that are not present on other elements. These make it possible to inspect
    and control such input fields with JavaScript programs and do things such as adding
    new functionality to a form or using forms and fields as building blocks in a
    JavaScript application.
  prefs: []
  type: TYPE_NORMAL
- en: A web form consists of any number of input fields grouped in a <form> tag. HTML
    allows several different styles of fields, ranging from simple on/off checkboxes
    to drop-down menus and fields for text input. This book won’t try to comprehensively
    discuss all field types, but we’ll start with a rough overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of field types use the <input> tag. This tag’s type attribute is used
    to select the field’s style. These are some commonly used <input> types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| text | A single-line text field |'
  prefs: []
  type: TYPE_TB
- en: '| password | Same as text but hides the text that is typed |'
  prefs: []
  type: TYPE_TB
- en: '| checkbox | An on/off switch |'
  prefs: []
  type: TYPE_TB
- en: '| color | A color |'
  prefs: []
  type: TYPE_TB
- en: '| date | A calendar date |'
  prefs: []
  type: TYPE_TB
- en: '| radio | (Part of) a multiple-choice field |'
  prefs: []
  type: TYPE_TB
- en: '| file | Allows the user to choose a file from their computer |'
  prefs: []
  type: TYPE_TB
- en: Form fields do not necessarily have to appear in a <form> tag. You can put them
    anywhere in a page. Such form-less fields cannot be submitted (only a form as
    a whole can), but when responding to input with JavaScript, we often don’t want
    to submit our fields normally anyway.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields created with this HTML code look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0304-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaScript interface for such elements differs with the type of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline text fields have their own tag, <textarea>, mostly because using an
    attribute to specify a multiline starting value would be awkward. The <textarea>
    tag requires a matching </textarea> closing tag and uses the text between those
    two, instead of the value attribute, as starting text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the <select> tag is used to create a field that allows the user to
    select from a number of predefined options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a field looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0305-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever the value of a form field changes, it will fire a “change” event.
  prefs: []
  type: TYPE_NORMAL
- en: Focus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike most elements in HTML documents, form fields can get *keyboard focus*.
    When clicked, moved to with TAB, or activated in some other way, they become the
    currently active element and the recipient of keyboard input.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you can type into a text field only when it is focused. Other fields respond
    differently to keyboard events. For example, a <select> menu tries to move to
    the option that contains the text the user typed and responds to the arrow keys
    by moving its selection up and down.
  prefs: []
  type: TYPE_NORMAL
- en: We can control focus from JavaScript with the focus and blur methods. The first
    moves focus to the DOM element it is called on, and the second removes focus.
    The value in document.activeElement corresponds to the currently focused element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For some pages, the user is expected to want to interact with a form field immediately.
    JavaScript can be used to focus this field when the document is loaded, but HTML
    also provides the autofocus attribute, which produces the same effect while letting
    the browser know what we are trying to achieve. This gives the browser the option
    to disable the behavior when it is not appropriate, such as when the user has
    put the focus on something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browsers allow the user to move the focus through the document by pressing
    TAB to move to the next focusable element, and SHIFT-TAB to move back to the previous
    element. By default, elements are visited in the order in which they appear in
    the document. It is possible to use the tabindex attribute to change this order.
    The following example document will let the focus jump from the text input to
    the OK button, rather than going through the help link first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By default, most types of HTML elements cannot be focused. You can add a tabindex
    attribute to any element to make it focusable. A tabindex of 0 makes an element
    focusable without affecting the focus order.
  prefs: []
  type: TYPE_NORMAL
- en: Disabled Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All form fields can be *disabled* through their disabled attribute. It is an
    attribute that can be specified without value—the fact that it is present at all
    disables the element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Disabled fields cannot be focused or changed, and browsers make them look gray
    and faded.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0306-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a program is in the process of handling an action caused by some button
    or other control that might require communication with the server and thus take
    a while, it can be a good idea to disable the control until the action finishes.
    That way, when the user gets impatient and clicks it again, they don’t accidentally
    repeat their action.
  prefs: []
  type: TYPE_NORMAL
- en: The Form as a Whole
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a field is contained in a <form> element, its DOM element will have a form
    property linking back to the form’s DOM element. The <form> element, in turn,
    has a property called elements that contains an array-like collection of the fields
    inside it.
  prefs: []
  type: TYPE_NORMAL
- en: The name attribute of a form field determines the way its value will be identified
    when the form is submitted. It can also be used as a property name when accessing
    the form’s elements property, which acts both as an array-like object (accessible
    by number) and a map (accessible by name).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A button with a type attribute of submit will, when pressed, cause the form
    to be submitted. Pressing ENTER when a form field is focused has the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting a form normally means that the browser navigates to the page indicated
    by the form’s action attribute, using either a GET or a POST request. But before
    that happens, a “submit” event is fired. You can handle this event with JavaScript
    and prevent this default behavior by calling preventDefault on the event object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Intercepting “submit” events in JavaScript has various uses. We can write code
    to verify that the values the user entered make sense and immediately show an
    error message instead of submitting the form. Or we can disable the regular way
    of submitting the form entirely, as in the example, and have our program handle
    the input, possibly using fetch to send it to a server without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: Text Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fields created by <textarea> tags, or <input> tags with a type of text or password,
    share a common interface. Their DOM elements have a value property that holds
    their current content as a string value. Setting this property to another string
    changes the field’s content.
  prefs: []
  type: TYPE_NORMAL
- en: The selectionStart and selectionEnd properties of text fields give us information
    about the cursor and selection in the text. When nothing is selected, these two
    properties hold the same number, indicating the position of the cursor. For example,
    0 indicates the start of the text, and 10 indicates the cursor is after the 10th
    character. When part of the field is selected, the two properties will differ,
    giving us the start and end of the selected text. Like value, these properties
    may also be written to.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are writing an article about Khasekhemwy, last pharaoh of the Second
    Dynasty, but have some trouble spelling his name. The following code wires up
    a <textarea> tag with an event handler that, when you press F2, inserts the string
    “Khasekhemwy” for you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The replaceSelection function replaces the currently selected part of a text
    field’s content with the given word and then moves the cursor after that word
    so that the user can continue typing.
  prefs: []
  type: TYPE_NORMAL
- en: The “change” event for a text field does not fire every time something is typed.
    Rather, it fires when the field loses focus after its content was changed. To
    respond immediately to changes in a text field, you should register a handler
    for the “input” event instead, which fires every time the user types a character,
    deletes text, or otherwise manipulates the field’s content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a text field and a counter displaying the current
    length of the text in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Checkboxes and Radio Buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A checkbox field is a binary toggle. Its value can be extracted or changed through
    its checked property, which holds a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The <label> tag associates a piece of document with an input field. Clicking
    anywhere on the label will activate the field, which focuses it and toggles its
    value when it is a checkbox or radio button.
  prefs: []
  type: TYPE_NORMAL
- en: A radio button is similar to a checkbox, but it’s implicitly linked to other
    radio buttons with the same name attribute so that only one of them can be active
    at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The square brackets in the CSS query given to querySelectorAll are used to match
    attributes. It selects elements whose name attribute is “color”.
  prefs: []
  type: TYPE_NORMAL
- en: Select Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Select fields are conceptually similar to radio buttons—they also allow the
    user to choose from a set of options. But where a radio button puts the layout
    of the options under our control, the appearance of a <select> tag is determined
    by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Select fields also have a variant more akin to a list of checkboxes rather than
    radio boxes. When given the multiple attribute, a <select> tag will allow the
    user to select any number of options, rather than just a single option. Whereas
    a regular select field is drawn as a *drop-down* control, which shows the inactive
    options only when you open it, a field with multiple enabled shows multiple options
    at the same time, allowing the user to enable or disable them individually.
  prefs: []
  type: TYPE_NORMAL
- en: Each <option> tag has a value. This value can be defined with a value attribute.
    When that is not given, the text inside the option will count as its value. The
    value property of a <select> element reflects the currently selected option. For
    a multiple field, though, this property doesn’t mean much, since it will give
    the value of only *one* of the currently selected options.
  prefs: []
  type: TYPE_NORMAL
- en: The <option> tags for a <select> field can be accessed as an array-like object
    through the field’s options property. Each option has a property called selected,
    which indicates whether that option is currently selected. The property can also
    be written to select or deselect an option.
  prefs: []
  type: TYPE_NORMAL
- en: This example extracts the selected values from a multiple select field and uses
    them to compose a binary number from individual bits. Hold CTRL (or COMMAND on
    a Mac) to select multiple options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: File Fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: File fields were originally designed as a way to upload files from the user’s
    machine through a form. In modern browsers, they also provide a way to read such
    files from JavaScript programs. The field acts as a kind of gate-keeper. The script
    cannot simply start reading private files from the user’s computer, but if the
    user selects a file in such a field, the browser interprets that action to mean
    that the script may read the file.
  prefs: []
  type: TYPE_NORMAL
- en: A file field usually looks like a button labeled with something like “choose
    file” or “browse,” with information about the chosen file next to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The files property of a file field element is an array-like object (once again,
    not a real array) containing the files chosen in the field. It is initially empty.
    The reason there isn’t simply a file property is that file fields also support
    a multiple attribute, which makes it possible to select multiple files at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: The objects in files have properties such as name (the filename), size (the
    file’s size in bytes, which are chunks of 8 bits), and type (the media type of
    the file, such as text/plain or image/jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: What it does not have is a property that contains the content of the file. Getting
    at that is a little more involved. Since reading a file from disk can take time,
    the interface is asynchronous to avoid freezing the window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Reading a file is done by creating a FileReader object, registering a “load”
    event handler for it, and calling its readAsText method, giving it the file we
    want to read. Once loading finishes, the reader’s result property contains the
    file’s content.
  prefs: []
  type: TYPE_NORMAL
- en: 'FileReaders also fire an “error” event when reading the file fails for any
    reason. The error object itself will end up in the reader’s error property. This
    interface was designed before promises became part of the language. You could
    wrap it in a promise like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Storing Data Client-Side
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simple HTML pages with a bit of JavaScript can be a great format for “mini applications”—small
    helper programs that automate basic tasks. By connecting a few form fields with
    event handlers, you can do anything from converting between centimeters and inches
    to computing passwords from a master password and a website name.
  prefs: []
  type: TYPE_NORMAL
- en: When such an application needs to remember something between sessions, you cannot
    use JavaScript bindings—those are thrown away every time the page is closed. You
    could set up a server, connect it to the internet, and have your application store
    something there (we’ll see how to do that in [Chapter 20](ch20.xhtml#ch20)). But
    that’s a lot of extra work and complexity. Sometimes it’s enough to just keep
    the data in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The localStorage object can be used to store data in a way that survives page
    reloads. This object allows you to file string values under names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A value in localStorage sticks around until it is overwritten or is removed
    with removeItem, or the user clears their local data.
  prefs: []
  type: TYPE_NORMAL
- en: Sites from different domains get different storage compartments. That means
    data stored in localStorage by a given website can, in principle, be read (and
    overwritten) only by scripts on that same site.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers do enforce a limit on the size of the data a site can store in localStorage.
    That restriction, along with the fact that filling up people’s hard drives with
    junk is not really profitable, prevents the feature from eating up too much space.
  prefs: []
  type: TYPE_NORMAL
- en: The following code implements a crude note-taking application. It keeps a set
    of named notes and allows the user to edit notes and create new ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The script gets its starting state from the “Notes” value stored in local Storage
    or, if that’s missing, creates an example state that has only a shopping list
    in it. Reading a field that does not exist from localStorage will yield null.
    Passing null to JSON.parse will make it parse the string “null” and return null.
    Thus, the ?? operator can be used to provide a default value in a situation like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: The setState method makes sure the DOM is showing a given state and stores the
    new state to localStorage. Event handlers call this function to move to a new
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The ... syntax in the example is used to create a new object that is a clone
    of the old state.notes, but with one property added or overwritten. It uses spread
    syntax to first add the properties from the old object and then set a new property.
    The square brackets notation in the object literal is used to create a property
    whose name is based on some dynamic value.
  prefs: []
  type: TYPE_NORMAL
- en: There is another object, similar to localStorage, called sessionStorage. The
    difference between the two is that the content of sessionStorage is forgotten
    at the end of each *session*, which for most browsers means whenever the browser
    is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we discussed how the HTTP protocol works. A *client* sends
    a request, which contains a method (usually GET) and a path that identifies a
    resource. The *server* then decides what to do with the request and responds with
    a status code and a response body. Both requests and responses may contain headers
    that provide additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface through which browser JavaScript can make HTTP requests is called
    fetch. Making a request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Browsers make GET requests to fetch the resources needed to display a web page.
    A page may also contain forms, which allow information entered by the user to
    be sent as a request for a new page when the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: HTML can represent various types of form fields, such as text fields, checkboxes,
    multiple-choice fields, and file pickers. Such fields can be inspected and manipulated
    with JavaScript. They fire the “change” event when changed, fire the “input” event
    when text is typed, and receive keyboard events when they have keyboard focus.
    Properties like value (for text and select fields) or checked (for checkboxes
    and radio buttons) are used to read or set the field’s content.
  prefs: []
  type: TYPE_NORMAL
- en: When a form is submitted, a “submit” event is fired on it. A JavaScript handler
    can call preventDefault on that event to disable the browser’s default behavior.
    Form field elements may also occur outside of a form tag.
  prefs: []
  type: TYPE_NORMAL
- en: When the user has selected a file from their local filesystem in a file picker
    field, the FileReader interface can be used to access the content of this file
    from a JavaScript program.
  prefs: []
  type: TYPE_NORMAL
- en: The localStorage and sessionStorage objects can be used to save information
    in a way that survives page reloads. The first object saves the data forever (or
    until the user decides to clear it), and the second saves it until the browser
    is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Content Negotiation*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the things HTTP can do is called *content negotiation*. The Accept request
    header is used to tell the server what type of document the client would like
    to get. Many servers ignore this header, but when a server knows of various ways
    to encode a resource, it can look at this header and send the one that the client
    prefers.
  prefs: []
  type: TYPE_NORMAL
- en: The URL *[https://eloquentjavascript.net/author](https://eloquentjavascript.net/author)*
    is configured to respond with either plaintext, HTML, or JSON, depending on what
    the client asks for. These formats are identified by the standardized *media types*
    text/plain, text/html, and application/json.
  prefs: []
  type: TYPE_NORMAL
- en: Send requests to fetch all three formats of this resource. Use the headers property
    in the options object passed to fetch to set the header named Accept to the desired
    media type.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, try asking for the media type application/rainbows+unicorns and see
    which status code that produces.
  prefs: []
  type: TYPE_NORMAL
- en: '*A JavaScript Workbench*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Build an interface that allows users to type and run pieces of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Put a button next to a <textarea> field that, when pressed, uses the Function
    constructor we saw in [Chapter 10](ch10.xhtml#ch10) to wrap the text in a function
    and call it. Convert the return value of the function, or any error it raises,
    to a string and display it below the text field.
  prefs: []
  type: TYPE_NORMAL
- en: '*Conway’s Game of Life*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Conway’s Game of Life is a simple simulation that creates artificial “life”
    on a grid, each cell of which is either alive or not. In each generation (turn),
    the following rules are applied:'
  prefs: []
  type: TYPE_NORMAL
- en: Any live cell with fewer than two or more than three live neighbors dies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any live cell with two or three live neighbors lives on to the next generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any dead cell with exactly three live neighbors becomes a live cell.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *neighbor* is defined as any adjacent cell, including diagonally adjacent
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Note that these rules are applied to the whole grid at once, not one square
    at a time. That means the counting of neighbors is based on the situation at the
    start of the generation, and changes happening to neighbor cells during this generation
    should not influence the new state of a given cell.
  prefs: []
  type: TYPE_NORMAL
- en: Implement this game using whichever data structure you find appropriate. Use
    Math.random to populate the grid with a random pattern initially. Display it as
    a grid of checkbox fields, with a button next to it to advance to the next generation.
    When the user checks or unchecks the checkboxes, their changes should be included
    when computing the next generation.
  prefs: []
  type: TYPE_NORMAL
- en: '*I look at the many colors before me. I look at my blank canvas. Then, I try
    to apply colors like words that shape poems, like notes that shape music.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Joan Miró
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0318-01.jpg)'
  prefs: []
  type: TYPE_IMG
