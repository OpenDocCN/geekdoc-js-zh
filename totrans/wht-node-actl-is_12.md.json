["```js\nimport { Writable } from \"stream\";\n const writable = new Writable({\n highWaterMark: 8192, // 8KB buffer threshold\n});\n```", "```js\nconst objectWritable = new Writable({\n objectMode: true,\n highWaterMark: 50, // buffer up to 50 objects\n});\n```", "```js\nconst stringWritable = new Writable({\n decodeStrings: false, // keep strings as strings\n});\n```", "```js\nfunction writeData(writable, data) {\n if (!writable.write(data)) {\n writable.once(\"drain\", () => {\n // Buffer drained, safe to write more\n continueWriting();\n });\n }\n}\n```", "```js\nwritable.on(\"finish\", () => {\n console.log(\"All data written\");\n});\n writable.write(\"some data\");\nwritable.end(); // signals end of writes\n```", "```js\nwritable.on(\"close\", () => {\n console.log(\"Stream closed\");\n});\n```", "```js\nwritable.on(\"error\", (err) => {\n console.error(\"Write error:\", err);\n});\n```", "```js\nwritable.on(\"pipe\", (src) => {\n console.log(\"Something is piping into me\");\n});\n```", "```js\nimport { createReadStream, createWriteStream } from \"fs\";\n const readable = createReadStream(\"input.dat\");\nconst writable = createWriteStream(\"output.dat\");\n readable.on(\"data\", (chunk) => {\n writable.write(chunk);\n});\n```", "```js\nreadable.on(\"data\", (chunk) => {\n const canContinue = writable.write(chunk);\n if (!canContinue) {\n readable.pause();\n writable.once(\"drain\", () => {\n readable.resume();\n });\n }\n});\n```", "```js\nclass SimplifiedWritable {\n constructor(options) {\n this.highWaterMark = options.highWaterMark || 16384;\n this.buffer = [];\n this.bufferSize = 0;\n this.writing = false;\n }\n write(chunk) {\n this.buffer.push(chunk);\n this.bufferSize += chunk.length;\n if (!this.writing) {\n this._processBuffer();\n }\n return this.bufferSize < this.highWaterMark;\n }\n _processBuffer() {\n // writes chunks to destination\n }\n}\n```", "```js\nclass DetailedWritable {\n constructor(options) {\n this.highWaterMark = options.highWaterMark || 16384;\n this.buffer = [];\n this.length = 0;\n this.writing = false;\n this.needDrain = false;\n }\n write(chunk) {\n this.buffer.push(chunk);\n this.length += chunk.length;\n const ret = this.length < this.highWaterMark;\n if (!ret) {\n this.needDrain = true;\n }\n if (!this.writing) {\n this._doWrite();\n }\n return ret;\n }\n _doWrite() {\n if (this.buffer.length === 0) {\n if (this.needDrain) {\n this.needDrain = false;\n this.emit(\"drain\");\n }\n return;\n }\n const chunk = this.buffer.shift();\n this.length -= chunk.length;\n this.writing = true;\n this._write(chunk, (err) => {\n this.writing = false;\n if (err) {\n this.emit(\"error\", err);\n } else {\n this._doWrite();\n }\n });\n }\n}\n```", "```js\nwritable.cork();\nwritable.write(\"line 1\\n\");\nwritable.write(\"line 2\\n\");\nwritable.write(\"line 3\\n\");\nwritable.uncork();\n```", "```js\nimport { Writable } from \"stream\";\n class NullWritable extends Writable {\n _write(chunk, encoding, callback) {\n callback(); // write completes immediately\n }\n}\n```", "```js\nclass ArrayWritable extends Writable {\n constructor(options) {\n super(options);\n this.data = [];\n }\n _write(chunk, encoding, callback) {\n this.data.push(chunk);\n callback();\n }\n}\n```", "```js\nclass AsyncWritable extends Writable {\n _write(chunk, encoding, callback) {\n setTimeout(() => {\n console.log(\"Wrote:\", chunk.toString());\n callback();\n }, 100);\n }\n}\n```", "```js\nclass ErrorWritable extends Writable {\n _write(chunk, encoding, callback) {\n if (chunk.toString().includes(\"bad\")) {\n callback(new Error(\"Invalid data\"));\n } else {\n callback();\n }\n }\n}\n```", "```js\nclass BatchWritable extends Writable {\n _writev(chunks, callback) {\n const allData = Buffer.concat(\n chunks.map((c) => c.chunk)\n );\n console.log(\"Batch write:\", allData.length, \"bytes\");\n callback();\n }\n}\n```", "```js\nclass CleanupWritable extends Writable {\n _write(chunk, encoding, callback) {\n // write data\n callback();\n }\n _final(callback) {\n console.log(\"Finalizing...\");\n // perform cleanup\n callback();\n }\n}\n```", "```js\nimport { Writable } from \"stream\";\nimport { open, write as fsWrite } from \"fs\";\n class LogWritable extends Writable {\n constructor(filename, options) {\n super(options);\n this.filename = filename;\n this.fd = null;\n this._open();\n }\n _open() {\n open(this.filename, \"a\", (err, fd) => {\n if (err) {\n this.destroy(err);\n } else {\n this.fd = fd;\n this.emit(\"open\", fd);\n }\n });\n }\n _write(chunk, encoding, callback) {\n if (!this.fd) {\n this.once(\"open\", () => {\n this._write(chunk, encoding, callback);\n });\n return;\n }\n const line = `[${new Date().toISOString()}] ${chunk}\\n`;\n fsWrite(this.fd, line, callback);\n }\n _final(callback) {\n if (this.fd) {\n require(\"fs\").close(this.fd, callback);\n } else {\n callback();\n }\n }\n}\n```", "```js\nimport { createReadStream, createWriteStream } from \"fs\";\n const reader = createReadStream(\"input.txt\");\nconst writer = createWriteStream(\"output.txt\");\n reader.on(\"data\", (chunk) => {\n const ok = writer.write(chunk);\n if (!ok) {\n reader.pause();\n }\n});\n writer.on(\"drain\", () => {\n reader.resume();\n});\n reader.on(\"end\", () => {\n writer.end();\n});\n```", "```js\nwriter.end(\"final chunk\");\n```", "```js\nwriter.write(\"final chunk\");\nwriter.end();\n```", "```js\nwriter.end();\nwriter.write(\"more data\"); // throws ERR_STREAM_WRITE_AFTER_END\n```", "```js\nwriter.cork();\nfor (let i = 0; i < 1000; i++) {\n writer.write(`line ${i}\\n`);\n}\nwriter.uncork();\n```", "```js\nasync function writeArray(writable, array) {\n for (const item of array) {\n const ok = writable.write(item);\n if (!ok) {\n await new Promise((resolve) => {\n writable.once(\"drain\", resolve);\n });\n }\n }\n writable.end();\n}\n```", "```js\nimport { createReadStream } from \"fs\";\nimport { Writable } from \"stream\";\nimport { pipeline } from \"stream/promises\";\n class DatabaseWriter extends Writable {\n constructor(db) {\n super({ objectMode: true });\n this.db = db;\n }\n async _write(row, encoding, callback) {\n try {\n await this.db.insert(row);\n callback();\n } catch (err) {\n callback(err);\n }\n }\n}\n async function importCSV(filename, db) {\n const reader = createReadStream(filename);\n const parser = parseCSV(); // hypothetical CSV parser\n const writer = new DatabaseWriter(db);\n await pipeline(reader, parser, writer);\n console.log(\"Import complete\");\n}\n```", "```js\nreadable.on(\"data\", (chunk) => {\n writable.write(chunk); // ignoring return value\n});\n```", "```js\nreadable.on(\"data\", (chunk) => {\n const ok = writable.write(chunk);\n if (!ok) {\n readable.pause();\n }\n});\n writable.on(\"drain\", () => {\n readable.resume();\n});\n```", "```js\nclass FailingWritable extends Writable {\n _write(chunk, encoding, callback) {\n callback(new Error(\"Write failed\"));\n }\n}\n const writable = new FailingWritable();\n writable.on(\"error\", (err) => {\n console.error(\"Stream error:\", err.message);\n});\n writable.write(\"test\"); // triggers error event\nwritable.write(\"more\"); // throws ERR_STREAM_DESTROYED\n```", "```js\nasync function buggyWrite(writable) {\n setTimeout(() => {\n writable.write(\"async write\");\n }, 100);\n writable.end(); // called before async write\n}\n```", "```js\nasync function correctWrite(writable) {\n await new Promise((resolve) => {\n setTimeout(() => {\n writable.write(\"async write\", resolve);\n }, 100);\n });\n writable.end();\n}\n```", "```js\nwritable.destroy(new Error(\"Aborted\"));\n```", "```js\nif (!writable.destroyed) {\n writable.write(\"data\");\n}\n```", "```js\nconsole.log(writable.writableLength);\n```", "```js\nconsole.log(writable.writableHighWaterMark);\n```", "```js\nif (writable.writable) {\n writable.write(\"data\");\n}\n```", "```js\nconsole.log(writable.writableEnded);\n```", "```js\nconsole.log(writable.writableFinished);\n```", "```js\nwritable.cork();\nwritable.cork();\nconsole.log(writable.writableCorked); // 2\n```", "```js\nconsole.log(writable.writableObjectMode);\n```", "```js\nwritable.cork();\nwritable.write(\"a\"); // creates request, queues it\nwritable.write(\"b\"); // creates request, queues it\nwritable.write(\"c\"); // creates request, queues it\nwritable.uncork(); // calls _writev([\"a\", \"b\", \"c\"])\n```", "```js\nwritable.write(\"a\"); // creates request, calls _write(\"a\")\nwritable.write(\"b\"); // creates request, queues it\nwritable.write(\"c\"); // creates request, queues it\n// as each _write completes, the next is called\n```", "```js\nclass RowWriter extends Writable {\n constructor(db, options) {\n super({ ...options, objectMode: true });\n this.db = db;\n }\n async _write(row, encoding, callback) {\n try {\n await this.db.insert(row);\n callback();\n } catch (err) {\n callback(err);\n }\n }\n}\n```", "```js\nimport { Transform } from \"stream\";\n class JSONLineParser extends Transform {\n constructor(options) {\n super({ ...options, objectMode: true });\n this.buffer = \"\";\n }\n _transform(chunk, encoding, callback) {\n this.buffer += chunk.toString();\n const lines = this.buffer.split(\"\\n\");\n this.buffer = lines.pop(); // incomplete line\n for (const line of lines) {\n if (line.trim()) {\n try {\n this.push(JSON.parse(line));\n } catch (err) {\n return callback(err);\n }\n }\n }\n callback();\n }\n}\n```", "```js\nclass BatchingWritable extends Writable {\n constructor(batchSize, options) {\n super(options);\n this.batchSize = batchSize;\n this.batch = [];\n }\n _write(chunk, encoding, callback) {\n this.batch.push(chunk);\n if (this.batch.length >= this.batchSize) {\n this._flush(callback);\n } else {\n callback();\n }\n }\n _final(callback) {\n if (this.batch.length > 0) {\n this._flush(callback);\n } else {\n callback();\n }\n }\n _flush(callback) {\n const data = Buffer.concat(this.batch);\n this.batch = [];\n // write data to destination\n callback();\n }\n}\n```", "```js\nasync _final(callback) {\n try {\n await this.flushAsync();\n callback();\n } catch (err) {\n callback(err);\n }\n}\n```", "```js\nasync _final() {\n await this.flushAsync();\n}\n```", "```js\nimport { Writable } from \"stream\";\n class RateLimitedWritable extends Writable {\n constructor(dest, bytesPerSecond, options) {\n super(options);\n this.dest = dest;\n this.bytesPerSecond = bytesPerSecond;\n this.tokens = bytesPerSecond;\n this.lastRefill = Date.now();\n }\n _write(chunk, encoding, callback) {\n this._refillTokens();\n if (this.tokens >= chunk.length) {\n this.tokens -= chunk.length;\n this.dest.write(chunk, encoding, callback);\n } else {\n const wait = ((chunk.length - this.tokens) / this.bytesPerSecond) * 1000;\n setTimeout(() => {\n this.tokens = 0;\n this.dest.write(chunk, encoding, callback);\n }, wait);\n }\n }\n _refillTokens() {\n const now = Date.now();\n const elapsed = (now - this.lastRefill) / 1000;\n this.tokens = Math.min(\n this.bytesPerSecond,\n this.tokens + elapsed * this.bytesPerSecond\n );\n this.lastRefill = now;\n }\n}\n```", "```js\nconst ok = writable.write(chunk);\nif (!ok) {\n console.log(\"Backpressure! Buffer size:\", writable.writableLength);\n}\n```", "```js\nsetInterval(() => {\n console.log(\"Buffer size:\", writable.writableLength);\n}, 1000);\n```", "```js\nconst v8 = require(\"v8\");\nconst fs = require(\"fs\");\n const snapshot = v8.writeHeapSnapshot();\nconsole.log(\"Heap snapshot written to\", snapshot);\n```", "```js\nnode --trace-gc app.js\n```", "```js\nfunction writeToAll(writables, chunk) {\n const results = writables.map((w) => w.write(chunk));\n return results.every((r) => r === true);\n}\n const ok = writeToAll([writable1, writable2], chunk);\nif (!ok) {\n // at least one stream signaled backpressure\n}\n```", "```js\nclass FanOutWritable extends Writable {\n constructor(destinations, options) {\n super(options);\n this.destinations = destinations;\n }\n _write(chunk, encoding, callback) {\n let pending = this.destinations.length;\n let error = null;\n const done = (err) => {\n if (err) error = err;\n if (--pending === 0) {\n callback(error);\n }\n };\n this.destinations.forEach((dest) => {\n dest.write(chunk, encoding, done);\n });\n }\n}\n```"]