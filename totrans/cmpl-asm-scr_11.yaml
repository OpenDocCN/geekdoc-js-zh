- en: Chapter 9 Introduction to Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2](https://keleshev.com/compiling-to-assembly-from-scratch/09-introduction-to-part-2)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Compiling to Assembly from Scratch](./#table-of-contents)'
  prefs: []
  type: TYPE_NORMAL
- en: by [Vladimir Keleshev](/)
  prefs: []
  type: TYPE_NORMAL
- en: Before extending the compiler, let’s discuss the language we have implemented
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Is our language memory-safe? What is memory safety, anyway? Simply speaking,
    a language is memory-safe if it does not allow you to write a program that causes
    a segmentation fault. The baseline language is memory-safe if we limit ourselves
    to calling functions that we have defined ourselves. However, our calling convention
    allows us to call arbitrary `libc` functions. You can find creative ways to call
    these functions that will lead to a segmentation fault (try `free(42)`). So, unless
    we do something about that, the baseline language is not memory-safe.
  prefs: []
  type: TYPE_NORMAL
- en: A way to fix that is to introduce a prefix for function labels. For example,
    a function `factorial` can be compiled with a label `ts$factorial:`, and a call
    to `factorial` can be compiled to a jump to `ts$factorial`. This way, you can
    only call functions that are defined in the source language, or that had explicit
    wrappers written in assembly. These wrappers can be auto-generated by the compiler
    and also handle type conversion, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Is our language dynamically-typed? Or is it statically-typed? Both and neither!
    The baseline language supports only integer numbers. So, it could be thought of
    as a dynamically-typed language with only one data type, or as a statically-typed
    language with one static type. But we are soon to change this.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we explore static and dynamic typing, we need to have more than
    one data type in our language. We will start by introducing booleans, undefined,
    and then arrays. First, we will introduce them in an unsafe/untyped manner, and
    then we will apply static/dynamic treatment to them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Next: Chapter 10\. Primitive Scalar Data Types](./10-primitive-scalar-data-types)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
