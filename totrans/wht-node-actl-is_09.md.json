["```js\n// BAD\n// This code allocates two new buffers for every single data chunk,\n// creating massive memory churn and risking fragmentation over time.\nsocket.on(\"data\", (chunk) => {\n // Allocation #1: New header buffer\n const header = Buffer.alloc(4);\n header.writeUInt32BE(chunk.length, 0);\n // Allocation #2: Buffer.concat creates a new buffer and copies data\n const framedPacket = Buffer.concat([header, chunk]);\n sendToNextService(framedPacket);\n});\n```", "```js\n// BETTER (but see \"shared memorey hazard\" section below!)\n// A single, larger buffer is allocated once and reused.\nconst MAX_PACKET_SIZE = 65536; // 64KB\nconst reusableBuffer = Buffer.alloc(MAX_PACKET_SIZE);\n socket.on(\"data\", (chunk) => {\n const framedPacketLength = chunk.length + 4;\n if (framedPacketLength > MAX_PACKET_SIZE) {\n console.error(\"Packet too large for reusable buffer!\");\n return;\n }\n // No new backing buffer allocation. Write header into our existing buffer.\n reusableBuffer.writeUInt32BE(chunk.length, 0);\n // No new backing buffer allocation. Copy packet data after the header.\n chunk.copy(reusableBuffer, 4);\n // Create a view over the valid data. This creates a small Buffer wrapper\n // object but shares the underlying memory (zero-copy of bytes).\n const framedPacketView = reusableBuffer.subarray(0, framedPacketLength);\n sendToNextService(framedPacketView);\n});\n```", "```js\n// SAFER: Ring buffer pool\nconst POOL_SIZE = 32; // Must be >= max in-flight packets\nconst MAX_PACKET_SIZE = 65536;\nconst pool = Array.from({ length: POOL_SIZE }, () => Buffer.alloc(MAX_PACKET_SIZE));\nlet poolIndex = 0;\n socket.on(\"data\", (chunk) => {\n const framedPacketLength = chunk.length + 4;\n if (framedPacketLength > MAX_PACKET_SIZE) {\n console.error(\"Packet too large!\");\n return;\n }\n // Get next buffer from pool (rotates through POOL_SIZE distinct buffers)\n const buf = pool[poolIndex];\n poolIndex = (poolIndex + 1) % POOL_SIZE;\n buf.writeUInt32BE(chunk.length, 0);\n chunk.copy(buf, 4);\n // Safe because we won't reuse this specific buffer until\n // we've cycled through all POOL_SIZE buffers\n const framedPacketView = buf.subarray(0, framedPacketLength);\n sendToNextService(framedPacketView);\n});\n```", "```js\nconst samplePacket = Buffer.from([\n 0x00,\n 0x00,\n 0x01,\n 0xa4, // Sensor ID: 420\n 0x41,\n 0xd9,\n 0x5c,\n 0x38,\n 0x2d,\n 0x5b,\n 0x81,\n 0x24, // Timestamp: 1672531200000\n 0x00,\n 0x01, // Sensor Type: 1 (Thermometer)\n 0x05, // Status Flags: 00000101 (Bit 0 and Bit 2 are set)\n 0x19, // Temperature: 25Â°C\n 0x42,\n 0x48,\n 0x00,\n 0x00, // Humidity: 50.0\n 0x42,\n 0xc8,\n 0x66,\n 0x66, // Pressure: 100.2\n]);\n```", "```js\n{\n \"sensorId\": 420,\n \"timestamp\": 1672531200000,\n \"sensorType\": 1,\n \"statusFlags\": 5,\n \"temperature\": 25,\n \"humidity\": 50,\n \"pressure\": 100.19999694824219\n}\n```", "```js\n// A full message - Type 1, Length 5, Value \"hello\"\nconst message1 = Buffer.from([0x01, 0x00, 0x05, 0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n // A second message - Type 2, Length 8, Value \"goodbye!\"\nconst message2 = Buffer.from([0x02, 0x00, 0x08, 0x67, 0x6f, 0x6f, 0x64, 0x62, 0x79, 0x65, 0x21]);\n // Let's simulate a messy TCP stream by chunking the data weirdly.\nconst chunk1 = message1.subarray(0, 4); // Contains header and one byte of value\nconst chunk2 = Buffer.concat([message1.subarray(4), message2.subarray(0, 6)]); // Contains rest of msg1 and start of msg2\nconst chunk3 = message2.subarray(6); // Contains the rest of msg2\n```", "```js\nconst legacyPacket = Buffer.from([\n 0xca,\n 0xfe, // Magic Number (BE)\n 0xad,\n 0xde,\n 0x00,\n 0x00, // Device ID: 57005 (LE)\n 0x40,\n 0xa0,\n 0x00,\n 0x00, // Voltage: 5.0 (BE)\n 0x01, // Status: 1 (OK)\n 0xb5, // Checksum\n 0x80,\n 0x51,\n 0x01,\n 0x00, // Uptime: 86400 (LE)\n]);\n```", "```js\n{\n \"magic\": 60158,\n \"deviceId\": 57005,\n \"voltage\": 5,\n \"status\": 1,\n \"checksum\": 181,\n \"uptime\": 86400\n}\n```"]