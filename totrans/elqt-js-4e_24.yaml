- en: '21'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PROJECT: SKILL-SHARING WEBSITE'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *skill-sharing* meeting is an event where people with a shared interest come
    together and give small, informal presentations about things they know. At a gardening
    skill-sharing meeting, someone might explain how to cultivate celery. Or in a
    programming skill-sharing group, you could drop by and tell people about Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: In this final project chapter, our goal is to set up a website for managing
    talks given at a skill-sharing meeting. Imagine a small group of people meeting
    up regularly in the office of one of the members to talk about unicycling. The
    previous organizer of the meetings moved to another town, and nobody stepped forward
    to take over this task. We want a system that will let the participants propose
    and discuss talks among themselves without an active organizer.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for the project can be downloaded from *[https://eloquentjavascript.net/code/skillsharing.zip](https://eloquentjavascript.net/code/skillsharing.zip).*
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a *server* part to this project, written for Node.js, and a *client*
    part, written for the browser. The server stores the system’s data and provides
    it to the client. It also serves the files that implement the client-side system.
  prefs: []
  type: TYPE_NORMAL
- en: The server keeps the list of talks proposed for the next meeting, and the client
    shows this list. Each talk has a presenter name, a title, a summary, and an array
    of comments associated with it. The client allows users to propose new talks (adding
    them to the list), delete talks, and comment on existing talks. Whenever the user
    makes such a change, the client makes an HTTP request to tell the server about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0356-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The application will be set up to show a *live* view of the current proposed
    talks and their comments. Whenever someone, somewhere, submits a new talk or adds
    a comment, all people who have the page open in their browsers should immediately
    see the change. This poses a bit of a challenge—there is no way for a web server
    to open a connection to a client, nor is there a good way to know which clients
    are currently looking at a given website.
  prefs: []
  type: TYPE_NORMAL
- en: A common solution to this problem is called *long polling*, which happens to
    be one of the motivations for Node’s design.
  prefs: []
  type: TYPE_NORMAL
- en: Long Polling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To be able to immediately notify a client that something changed, we need a
    connection to that client. Since web browsers do not traditionally accept connections
    and clients are often behind routers that would block such connections anyway,
    having the server initiate this connection is not practical.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can arrange for the client to open the connection and keep it around so
    that the server can use it to send information when it needs to do so. But an
    HTTP request allows only a simple flow of information: the client sends a request,
    the server comes back with a single response, and that’s it. A technology called
    *WebSockets* makes it possible to open connections for arbitrary data exchange,
    but using such sockets properly is somewhat tricky.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we use a simpler technique, *long polling*, where clients continuously
    ask the server for new information using regular HTTP requests and the server
    stalls its answer when it has nothing new to report.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the client makes sure it constantly has a polling request open, it
    will receive information from the server quickly after it becomes available. For
    example, if Fatma has our skill-sharing application open in her browser, that
    browser will have made a request for updates and will be waiting for a response
    to that request. When Iman submits a talk on Extreme Downhill Unicycling, the
    server will notice that Fatma is waiting for updates and send a response containing
    the new talk to her pending request. Fatma’s browser will receive the data and
    update the screen to show the talk.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent connections from timing out (being aborted because of a lack of activity),
    long polling techniques usually set a maximum time for each request, after which
    the server will respond anyway, even though it has nothing to report. The client
    can then start a new request. Periodically restarting the request also makes the
    technique more robust, allowing clients to recover from temporary connection failures
    or server problems.
  prefs: []
  type: TYPE_NORMAL
- en: A busy server that is using long polling may have thousands of waiting requests,
    and thus TCP connections, open. Node, which makes it easy to manage many connections
    without creating a separate thread of control for each one, is a good fit for
    such a system.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we start designing either the server or the client, let’s think about
    the point where they touch: the HTTP interface over which they communicate.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use JSON as the format of our request and response body. Like in the
    file server from [Chapter 20](ch20.xhtml#ch20), we’ll try to make good use of
    HTTP methods and headers. The interface is centered around the */talks* path.
    Paths that do not start with */talks* will be used for serving static files—the
    HTML and JavaScript code for the client-side system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A GET request to */talks* returns a JSON document like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new talk is done by making a PUT request to a URL like */talks/ Unituning*,
    where the part after the second slash is the title of the talk. The PUT request’s
    body should contain a JSON object that has presenter and summary properties.
  prefs: []
  type: TYPE_NORMAL
- en: Since talk titles may contain spaces and other characters that may not appear
    normally in a URL, title strings must be encoded with the encodeURI Component
    function when building up such a URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A request to create a talk about idling might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Such URLs also support GET requests to retrieve the JSON representation of a
    talk and DELETE requests to delete a talk.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a comment to a talk is done with a POST request to a URL like */talks/Unituning/comments*,
    with a JSON body that has author and message properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To support long polling, GET requests to */talks* may include extra headers
    that inform the server to delay the response if no new information is available.
    We’ll use a pair of headers normally intended to manage caching: ETag and If-None-Match.'
  prefs: []
  type: TYPE_NORMAL
- en: Servers may include an ETag (“entity tag”) header in a response. Its value is
    a string that identifies the current version of the resource. Clients, when they
    later request that resource again, may make a *conditional request* by including
    an If-None-Match header whose value holds that same string. If the resource hasn’t
    changed, the server will respond with status code 304, which means “not modified,”
    telling the client that its cached version is still current. When the tag does
    not match, the server responds as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need something like this, where the client can tell the server which version
    of the list of talks it has, and the server responds only when that list has changed.
    But instead of immediately returning a 304 response, the server should stall the
    response and return only when something new is available or a given amount of
    time has elapsed. To distinguish long polling requests from normal conditional
    requests, we give them another header, Prefer: wait=90, which tells the server
    that the client is willing to wait up to 90 seconds for the response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The server will keep a version number that it updates every time the talks
    change and will use that as the ETag value. Clients can make requests like this
    to be notified when the talks change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The protocol described here doesn’t do any access control. Everybody can comment,
    modify talks, and even delete them. (Since the internet is full of hooligans,
    putting such a system online without further protection probably wouldn’t end
    well.)
  prefs: []
  type: TYPE_NORMAL
- en: The Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by building the server-side part of the program. The code in this
    section runs on Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: '*Routing*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our server will use Node’s createServer to start an HTTP server. In the function
    that handles a new request, we must distinguish between the various kinds of requests
    (as determined by the method and the path) that we support. This can be done with
    a long chain of if statements, but there’s a nicer way.
  prefs: []
  type: TYPE_NORMAL
- en: A *router* is a component that helps dispatch a request to the function that
    can handle it. You can tell the router, for example, that PUT requests with a
    path that matches the regular expression /^\/talks\/([^\/]+)$/ (*/talks/* followed
    by a talk title) can be handled by a given function. In addition, it can help
    extract the meaningful parts of the path (in this case the talk title), wrapped
    in parentheses in the regular expression, and pass them to the handler function.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of good router packages on NPM, but here we’ll write one
    ourselves to illustrate the principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is *router.mjs*, which we will later import from our server module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The module exports the Router class. A router object allows you to register
    handlers for specific methods and URL patterns with its add method. When a request
    is resolved with the resolve method, the router calls the handler whose method
    and URL match the request and return its result.
  prefs: []
  type: TYPE_NORMAL
- en: Handler functions are called with the context value given to resolve. We will
    use this to give them access to our server state. Additionally, they receive the
    match strings for any groups they defined in their regular expression, and the
    request object. The strings have to be URL-decoded, since the raw URL may contain
    %20-style codes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Serving Files*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a request matches none of the request types defined in our router, the
    server must interpret it as a request for a file in the *public* directory. It
    would be possible to use the file server defined in [Chapter 20](ch20.xhtml#ch20)
    to serve such files, but we neither need nor want to support PUT and DELETE requests
    on files, and we would like to have advanced features such as support for caching.
    Let’s use a solid, well-tested static file server from NPM instead.
  prefs: []
  type: TYPE_NORMAL
- en: I opted for serve-static. This isn’t the only such server on NPM, but it works
    well and fits our purposes. The serve-static package exports a function that can
    be called with a root directory to produce a request handler function. The handler
    function accepts the request and response arguments provided by the server from
    “node:http”, and a third argument, a function that it will call if no file matches
    the request. We want our server to first check for requests we should handle specially,
    as defined in the router, so we wrap it in another function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The serveFromRouter function has the same interface as fileServer, taking (request,
    response, next) arguments. We can use this to “chain” several request handlers,
    allowing each to either handle the request or pass responsibility for that on
    to the next handler. The final handler, notFound, simply responds with a “not
    found” error.
  prefs: []
  type: TYPE_NORMAL
- en: Our serveFromRouter function uses a similar convention to the file server from
    the previous chapter for responses—handlers in the router return promises that
    resolve to objects describing the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Talks as Resources*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The talks that have been proposed are stored in the talks property of the server,
    an object whose property names are the talk titles. We’ll add some handlers to
    our router that expose these as HTTP resources under */talks/<title>*.
  prefs: []
  type: TYPE_NORMAL
- en: The handler for requests that GET a single talk must look up the talk and respond
    either with the talk’s JSON data or with a 404 error response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a talk is done by removing it from the talks object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The updated method, which we will define later, notifies waiting long polling
    requests about the change.
  prefs: []
  type: TYPE_NORMAL
- en: One handler that needs to read request bodies is the PUT handler, which is used
    to create new talks. It has to check whether the data it was given has presenter
    and summary properties, which are strings. Any data coming from outside the system
    might be nonsense, and we don’t want to corrupt our internal data model or crash
    when bad requests come in.
  prefs: []
  type: TYPE_NORMAL
- en: If the data looks valid, the handler stores an object that represents the new
    talk in the talks object, possibly overwriting an existing talk with this title,
    and again calls updated.
  prefs: []
  type: TYPE_NORMAL
- en: To read the body from the request stream, we will use the json function from
    “node:stream/consumers”, which collects the data in the stream and then parses
    it as JSON. There are similar exports called text (to read the content as a string)
    and buffer (to read it as binary data) in this package. Since json is a very generic
    name, the import renames it to readJSON to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Adding a comment to a talk works similarly. We use readJSON to get the content
    of the request, validate the resulting data, and store it as a comment when it
    looks valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Trying to add a comment to a nonexistent talk returns a 404 error.
  prefs: []
  type: TYPE_NORMAL
- en: '*Long Polling Support*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most interesting aspect of the server is the part that handles long polling.
    When a GET request comes in for */talks*, it may be either a regular request or
    a long polling request.
  prefs: []
  type: TYPE_NORMAL
- en: There will be multiple places in which we have to send an array of talks to
    the client, so we first define a helper method that builds up such an array and
    includes an ETag header in the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The handler itself needs to look at the request headers to see whether If-None-Match
    and Prefer headers are present. Node stores headers, whose names are specified
    to be case insensitive, under their lowercase names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If no tag was given or a tag was given that doesn’t match the server’s current
    version, the handler responds with the list of talks. If the request is conditional
    and the talks did not change, we consult the Prefer header to see whether we should
    delay the response or respond right away.
  prefs: []
  type: TYPE_NORMAL
- en: Callback functions for delayed requests are stored in the server’s waiting array
    so that they can be notified when something happens. The waitFor Changes method
    also immediately sets a timer to respond with a 304 status when the request has
    waited long enough.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Registering a change with updated increases the version property and wakes up
    all waiting requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the server code. If we create an instance of SkillShare Server
    and start it on port 8000, the resulting HTTP server serves files from the *public*
    subdirectory alongside a talk-managing interface under the */talks* URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The client-side part of the skill-sharing website consists of three files:
    a tiny HTML page, a style sheet, and a JavaScript file.'
  prefs: []
  type: TYPE_NORMAL
- en: '*HTML*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is a widely used convention for web servers to try to serve a file named
    *index.xhtml* when a request is made directly to a path that corresponds to a
    directory. The file server module we use, serve-static, supports this convention.
    When a request is made to the path */*, the server looks for the file *./public/index.xhtml*
    (*./public* being the root we gave it) and returns that file if found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, if we want a page to show up when a browser is pointed at our server,
    we should put it in *public/index.xhtml*. This is our index file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It defines the document title and includes a style sheet, which defines a few
    styles to, among other things, make sure there is some space between talks. It
    then adds a heading at the top of the page and loads the script that contains
    the client-side application.
  prefs: []
  type: TYPE_NORMAL
- en: '*Actions*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The application state consists of the list of talks and the name of the user,
    and we’ll store it in a {*talks*, *user*} object. We don’t allow the user interface
    to directly manipulate the state or send off HTTP requests. Rather, it may emit
    *actions* that describe what the user is trying to do.
  prefs: []
  type: TYPE_NORMAL
- en: The handleAction function takes such an action and makes it happen. Because
    our state updates are so simple, state changes are handled in the same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We’ll store the user’s name in localStorage so that it can be restored when
    the page is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The actions that need to involve the server make network requests, using fetch,
    to the HTTP interface described earlier. We use a wrapper function, fetchOK, which
    makes sure the returned promise is rejected when the server returns an error code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This helper function is used to build up a URL for a talk with a given title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When the request fails, we don’t want our page to just sit there doing nothing
    without explanation. The function called reportError, which we used as the catch
    handler, shows the user a crude dialog to tell them something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Rendering Components*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll use an approach similar to the one we saw in [Chapter 19](ch19.xhtml#ch19),
    splitting the application into components. However, since some of the components
    either never need to update or are always fully redrawn when updated, we’ll define
    those not as classes but as functions that directly return a DOM node. For example,
    here is a component that shows the field where the user can enter their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The elt function used to construct DOM elements is the one we used in [Chapter
    19](ch19.xhtml#ch19).
  prefs: []
  type: TYPE_NORMAL
- en: A similar function is used to render talks, which include a list of comments
    and a form for adding a new comment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The “submit” event handler calls form.reset to clear the form’s content after
    creating a “newComment” action.
  prefs: []
  type: TYPE_NORMAL
- en: When creating moderately complex pieces of DOM, this style of programming starts
    to look rather messy. To avoid this, people often use a *templating language*,
    which allows you to write your interface as an HTML file with some special markers
    to indicate where dynamic elements go. Or they use *JSX*, a nonstandard JavaScript
    dialect that allows you to write something very close to HTML tags in your program
    as if they are JavaScript expressions. Both of these approaches use additional
    tools to preprocess the code before it can be run, which we will avoid in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are simple to render.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the form that the user can use to create a new talk is rendered like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Polling*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To start the app, we need the current list of talks. Since the initial load
    is closely related to the long polling process—the ETag from the load must be
    used when polling—we’ll write a function that keeps polling the server for */talks*
    and calls a callback function when a new set of talks is available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is an async function so that looping and waiting for the request is easier.
    It runs an infinite loop that, on each iteration, retrieves the list of talks—either
    normally or, if this isn’t the first request, with the headers included that make
    it a long polling request.
  prefs: []
  type: TYPE_NORMAL
- en: When a request fails, the function waits a moment and then tries again. This
    way, if your network connection goes away for a while and then comes back, the
    application can recover and continue updating. The promise resolved via setTimeout
    is a way to force the async function to wait.
  prefs: []
  type: TYPE_NORMAL
- en: When the server gives back a 304 response, that means a long polling request
    timed out, so the function should just immediately start the next request. If
    the response is a normal 200 response, its body is read as JSON and passed to
    the callback, and its ETag header value is stored for the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '*The Application*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following component ties the whole user interface together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the talks change, this component redraws all of them. This is simple but
    also wasteful. We’ll get back to that in the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start the application like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you run the server and open two browser windows for *http://localhost:8000*
    next to each other, you can see that the actions you perform in one window are
    immediately visible in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following exercises will involve modifying the system defined in this chapter.
    To work on them, make sure you’ve downloaded the code (*[https://eloquentjavascript.net/code/skillsharing.zip](https://eloquentjavascript.net/code/skillsharing.zip)*),
    installed Node (*[https://nodejs.org](https://nodejs.org)*), and installed the
    project’s dependency with npm install.
  prefs: []
  type: TYPE_NORMAL
- en: '*Disk Persistence*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The skill-sharing server keeps its data purely in memory. This means that when
    it crashes or is restarted for any reason, all talks and comments are lost.
  prefs: []
  type: TYPE_NORMAL
- en: Extend the server so that it stores the talk data to disk and automatically
    reloads the data when it is restarted. Don’t worry about efficiency—do the simplest
    thing that works.
  prefs: []
  type: TYPE_NORMAL
- en: '*Comment Field Resets*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The wholesale redrawing of talks works pretty well because you usually can’t
    tell the difference between a DOM node and its identical replacement. But there
    are exceptions. If you start typing something in the comment field for a talk
    in one browser window and then, in another, add a comment to that talk, the field
    in the first window will be redrawn, removing both its content and its focus.
  prefs: []
  type: TYPE_NORMAL
- en: When multiple people are adding comments at the same time, this would be annoying.
    Can you come up with a way to solve it?
  prefs: []
  type: TYPE_NORMAL
- en: '*The big optimizations come from refining the high-level design, not the individual
    routines.*'
  prefs: []
  type: TYPE_NORMAL
- en: —Steve McConnell, *Code Complete*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0372-01.jpg)'
  prefs: []
  type: TYPE_IMG
