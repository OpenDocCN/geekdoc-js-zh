- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: PROGRAM STRUCTURE
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序结构
- en: In this chapter, we will start to do things that can actually be called *programming*.
    We will expand our command of the JavaScript language beyond the nouns and sentence
    fragments we’ve seen so far to the point where we can express meaningful prose.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始做一些真正可以称之为*编程*的事情。我们将把对 JavaScript 语言的掌握扩展到名词和我们迄今为止看到的句子片段的范围，达到能够表达有意义的散文的程度。
- en: Expressions and Statements
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式与语句
- en: In [Chapter 1](ch01.xhtml#ch01), we made values and applied operators to them
    to get new values. Creating values like this is the main substance of any JavaScript
    program. But that substance has to be framed in a larger structure to be useful.
    That’s what we’ll cover in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#ch01)中，我们创建了值并将运算符应用于这些值以获得新值。像这样创建值是任何 JavaScript 程序的主要内容。但这些内容必须框架在一个更大的结构中才能有用。这就是我们在本章中要讨论的内容。
- en: A fragment of code that produces a value is called an *expression*. Every value
    that is written literally (such as 22 or “psychoanalysis”) is an expression. An
    expression between parentheses is also an expression, as is a binary operator
    applied to two expressions or a unary operator applied to one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 产生一个值的代码片段称为*表达式*。每个字面写出的值（如 22 或 “精神分析”）都是一个表达式。括号中的表达式也是表达式，二元运算符应用于两个表达式或一元运算符应用于一个表达式也是如此。
- en: This shows part of the beauty of a language-based interface. Expressions can
    contain other expressions in a way similar to how subsentences in human languages
    are nested—a subsentence can contain its own subsentences, and so on. This allows
    us to build expressions that describe arbitrarily complex computations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了基于语言的接口的部分美妙之处。表达式可以包含其他表达式，这与人类语言中子句嵌套的方式类似——一个子句可以包含它自己的子句，依此类推。这使我们能够构建描述任意复杂计算的表达式。
- en: If an expression corresponds to a sentence fragment, a JavaScript *statement*
    corresponds to a full sentence. A program is a list of statements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式对应于一个句子片段，那么 JavaScript 的*语句*对应于一个完整的句子。一个程序是一系列语句。
- en: 'The simplest kind of statement is an expression with a semicolon after it.
    This is a program:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的语句是一个表达式，后面跟着一个分号。这是一个程序：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is a useless program, though. An expression can be content to just produce
    a value, which can then be used by the enclosing code. However, a statement stands
    on its own, so if it doesn’t affect the world, it’s useless. It may display something
    on the screen, as with console.log, or change the state of the machine in a way
    that will affect the statements that come after it. These changes are called *side
    effects*. The statements in the previous example just produce the values 1 and
    true and then immediately throw them away. This leaves no impression on the world
    at all. When you run this program, nothing observable happens.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这仍然是一个无用的程序。一个表达式可以满足于仅仅生成一个值，然后该值可以被外部代码使用。然而，一个语句是独立存在的，因此如果它不影响世界，那就是无用的。它可以在屏幕上显示某些内容，比如通过
    console.log，或者以某种方式改变机器的状态，从而影响之后的语句。这些变化被称为*副作用*。前一个示例中的语句仅仅生成值 1 和 true，然后立即将它们丢弃。这对世界没有任何影响。当你运行这个程序时，没有任何可观察的事情发生。
- en: In some cases, JavaScript allows you to omit the semicolon at the end of a statement.
    In other cases, it has to be there, or the next line will be treated as part of
    the same statement. The rules for when it can be safely omitted are somewhat complex
    and error prone. So in this book, every statement that needs a semicolon will
    always get one. I recommend you do the same, at least until you’ve learned more
    about the subtleties of missing semicolons.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，JavaScript 允许你省略语句末尾的分号。在其他情况下，它必须存在，否则下一行将被视为同一语句的一部分。关于何时可以安全省略分号的规则有些复杂且容易出错。因此在本书中，所有需要分号的语句都会包含一个。我建议你也这样做，至少在你学会了更多关于省略分号的细微之处之前。
- en: Bindings
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定
- en: How does a program keep an internal state? How does it remember things? We have
    seen how to produce new values from old values, but this does not change the old
    values, and the new value must be used immediately or it will dissipate again.
    To catch and hold values, JavaScript provides a thing called a *binding*, or *variable*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 程序如何保持内部状态？它是如何记住事物的？我们已经看到如何从旧值生成新值，但这并不会改变旧值，而且新值必须立即使用，否则会再次消散。为了捕捉和保持值，JavaScript
    提供了一种叫做*绑定*或*变量*的东西。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That gives us a second kind of statement. The special word (*keyword*) let indicates
    that this sentence is going to define a binding. It is followed by the name of
    the binding and, if we want to immediately give it a value, by an = operator and
    an expression.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们第二种语句。特殊词（*关键字*）let表示此句将定义一个绑定。它后面跟着绑定的名称，如果我们想立即赋值，则跟着一个=运算符和一个表达式。
- en: The example creates a binding called caught and uses it to grab hold of the
    number that is produced by multiplying 5 by 5.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个名为caught的绑定，并用它来获取通过将5与5相乘产生的数字。
- en: 'After a binding has been defined, its name can be used as an expression. The
    value of such an expression is the value the binding currently holds. Here’s an
    example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个绑定后，可以将其名称用作表达式。此类表达式的值是绑定当前持有的值。这里有一个例子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When a binding points at a value, that does not mean it is tied to that value
    forever. The = operator can be used at any time on existing bindings to disconnect
    them from their current value and have them point to a new one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个绑定指向一个值时，并不意味着它永远与该值绑定。=运算符可以随时在现有绑定上使用，以将它们从当前值中断开，并指向一个新值。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should imagine bindings as tentacles rather than boxes. They do not *contain*
    values; they *grasp* them—two bindings can refer to the same value. A program
    can access only the values to which it still has a reference. When you need to
    remember something, you either grow a tentacle to hold on to it or reattach one
    of your existing tentacles to it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该把绑定想象成触手，而不是盒子。它们不*包含*值；它们*抓住*值——两个绑定可以引用同一个值。程序只能访问它仍有引用的值。当你需要记住某些东西时，你要么生长一个触手来保持它，要么将你现有的一个触手重新连接到它。
- en: Let’s look at another example. To remember the number of dollars that Luigi
    still owes you, you create a binding. When he pays back $35, you give this binding
    a new value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子。为了记住路易吉还欠你的美元金额，你创建了一个绑定。当他还款$35时，你给这个绑定一个新值。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you define a binding without giving it a value, the tentacle has nothing
    to grasp, so it ends in thin air. If you ask for the value of an empty binding,
    you’ll get the value undefined.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个绑定而不给它赋值时，触手没有任何东西可抓，因此它就空悬了。如果你询问一个空绑定的值，你会得到值undefined。
- en: A single let statement may define multiple bindings. The definitions must be
    separated by commas.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单个let语句可以定义多个绑定。定义必须用逗号分隔。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The words var and const can also be used to create bindings, in a similar fashion
    to let.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 单词var和const也可以以类似于let的方式创建绑定。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first of these, var (short for “variable”), is the way bindings were declared
    in pre-2015 JavaScript, when let didn’t exist yet. I’ll get back to the precise
    way it differs from let in the next chapter. For now, remember that it mostly
    does the same thing, but we’ll rarely use it in this book because it behaves oddly
    in some situations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个，var（“变量”的缩写），是在2015年前的JavaScript中声明绑定的方式，当时let还不存在。我将在下一章中详细说明它与let的具体区别。现在，请记住，它主要执行相同的操作，但我们在本书中很少使用它，因为它在某些情况下的行为奇怪。
- en: The word const stands for “constant.” It defines a constant binding, which points
    at the same value for as long as it lives. This is useful for bindings that just
    give a name to a value so that you can easily refer to it later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单词const代表“常量”。它定义了一个常量绑定，该绑定在其存在期间始终指向相同的值。这对于仅将名称赋给某个值的绑定很有用，以便你可以在以后轻松引用它。
- en: Binding Names
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定名称
- en: Binding names can be any sequence of one or more letters. Digits can be part
    of binding names—catch22 is a valid name, for example—but the name must not start
    with a digit. A binding name may include dollar signs ($) or underscores (_) but
    no other punctuation or special characters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定名称可以是一个或多个字母的任何序列。数字可以是绑定名称的一部分——例如，catch22是一个有效名称——但名称不能以数字开头。绑定名称可以包含美元符号（$）或下划线（_），但不能有其他标点符号或特殊字符。
- en: Words with a special meaning, such as let, are *keywords*, and may not be used
    as binding names. There are also a number of words that are “reserved for use”
    in future versions of JavaScript, which also can’t be used as binding names. The
    full list of keywords and reserved words is rather long.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特殊含义的词，如let，是*关键字*，不能用作绑定名称。还有一些词是“保留以供未来版本使用”的，这些也不能用作绑定名称。关键字和保留字的完整列表相当长。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Don’t worry about memorizing this list. When creating a binding produces an
    unexpected syntax error, check whether you’re trying to define a reserved word.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心记住这个列表。当创建绑定产生意外的语法错误时，请检查你是否尝试定义一个保留字。
- en: The Environment
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境
- en: The collection of bindings and their values that exist at a given time is called
    the *environment*. When a program starts up, this environment is not empty. It
    always contains bindings that are part of the language standard, and most of the
    time, it also has bindings that provide ways to interact with the surrounding
    system. For example, in a browser, there are functions to interact with the currently
    loaded website and to read mouse and keyboard input.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在特定时间存在的绑定及其值的集合称为*环境*。当程序启动时，这个环境并不是空的。它总是包含作为语言标准一部分的绑定，并且大多数时候，它也包含提供与周围系统交互方式的绑定。例如，在浏览器中，有一些函数用于与当前加载的网站进行交互，以及读取鼠标和键盘输入。
- en: Functions
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'A lot of the values provided in the default environment have the type *function*.
    A function is a piece of program wrapped in a value. Such values can be *applied*
    in order to run the wrapped program. For example, in a browser environment, the
    binding prompt holds a function that shows a little dialog asking for user input.
    It is used like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认环境中提供的许多值的类型为*函数*。函数是包裹在值中的一段程序。这种值可以被*应用*以运行包裹的程序。例如，在浏览器环境中，绑定`prompt`持有一个函数，该函数显示一个小对话框以请求用户输入。使用方法如下：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Image](../images/f0027-01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0027-01.jpg)'
- en: Executing a function is called *invoking*, *calling*, or *applying* it. You
    can call a function by putting parentheses after an expression that produces a
    function value. Usually you’ll directly use the name of the binding that holds
    the function. The values between the parentheses are given to the program inside
    the function. In the example, the prompt function uses the string that we give
    it as the text to show in the dialog. Values given to functions are called *arguments*.
    Different functions might need a different number or different types of arguments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 执行一个函数称为*调用*、*调用*或*应用*它。你可以通过在产生函数值的表达式后加上括号来调用一个函数。通常你会直接使用持有函数的绑定的名称。括号之间的值被传递给函数内部的程序。在示例中，`prompt`函数使用我们提供的字符串作为在对话框中显示的文本。传递给函数的值称为*参数*。不同的函数可能需要不同数量或不同类型的参数。
- en: The prompt function isn’t used much in modern web programming, mostly because
    you have no control over the way the resulting dialog looks, but it can be helpful
    in toy programs and experiments.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`prompt`函数在现代网络编程中使用得不多，主要是因为你无法控制生成的对话框的外观，但它在玩具程序和实验中可能会很有帮助。'
- en: The console.log Function
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`console.log`函数'
- en: In the examples, I used console.log to output values. Most JavaScript systems
    (including all modern web browsers and Node.js) provide a console.log function
    that writes out its arguments to *some* text output device. In browsers, the output
    lands in the JavaScript console. This part of the browser interface is hidden
    by default, but most browsers open it when you press F12 or, on a Mac, COMMAND-OPTION-I.
    If that does not work, search through the menus for an item named Developer Tools
    or similar.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我使用`console.log`输出值。大多数JavaScript系统（包括所有现代网页浏览器和Node.js）提供一个`console.log`函数，将其参数写入*某个*文本输出设备。在浏览器中，输出会出现在JavaScript控制台。这部分浏览器界面默认是隐藏的，但大多数浏览器在你按下F12或在Mac上按下COMMAND-OPTION-I时会打开它。如果这样不行，可以在菜单中查找名为开发者工具或类似的选项。
- en: Though binding names cannot contain period characters, console.log does have
    one. This is because console.log isn’t a simple binding, but an expression that
    retrieves the log property from the value held by the console binding. We’ll find
    out exactly what this means in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管绑定名称不能包含句点字符，但`console.log`确实有一个。这是因为`console.log`不是一个简单的绑定，而是一个从`console`绑定持有的值中检索`log`属性的表达式。我们将在[第4章](ch04.xhtml#ch04)中确切了解这意味着什么。
- en: Return Values
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: Showing a dialog or writing text to the screen is a *side effect*. Many functions
    are useful because of the side effects they produce. Functions may also produce
    values, in which case they don’t need to have a side effect to be useful. For
    example, the function Math.max takes any amount of number arguments and gives
    back the greatest.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显示对话框或在屏幕上写入文本是一个*副作用*。许多函数因其产生的副作用而变得有用。函数也可以产生值，在这种情况下，它们不需要有副作用才能有用。例如，函数`Math.max`接受任意数量的数字参数并返回最大值。
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When a function produces a value, it is said to *return* that value. Anything
    that produces a value is an expression in JavaScript, which means that function
    calls can be used within larger expressions. In the following code, a call to
    Math.min, which is the opposite of Math.max, is used as part of a plus expression:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数生成一个值时，称其为*返回*该值。在JavaScript中，任何生成值的东西都是一个表达式，这意味着函数调用可以在更大的表达式中使用。在以下代码中，调用`Math.min`（与`Math.max`相反）作为加法表达式的一部分：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Chapter 3](ch03.xhtml#ch03) will explain how to write your own functions.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.xhtml#ch03)将解释如何编写自己的函数。'
- en: Control Flow
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流
- en: When your program contains more than one statement, the statements are executed
    as though they were a story, from top to bottom. For example, the following program
    has two statements. The first asks the user for a number, and the second, which
    is executed after the first, shows the square of that number.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序包含多个语句时，这些语句的执行就像一个故事，从上到下。例如，以下程序有两个语句。第一个请求用户输入一个数字，第二个在第一个之后执行，显示该数字的平方。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function Number converts a value to a number. We need that conversion because
    the result of prompt is a string value, and we want a number. There are similar
    functions called String and Boolean that convert values to those types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`函数将一个值转换为数字。我们需要这个转换，因为`prompt`的结果是一个字符串值，而我们想要的是一个数字。还有类似的函数叫做`String`和`Boolean`，它们将值转换为相应的类型。'
- en: 'Here is the rather trivial schematic representation of straight-line control
    flow:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是简单的直线控制流的示意图：
- en: '![Image](../images/f0028-01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0028-01.jpg)'
- en: Conditional Execution
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件执行
- en: Not all programs are straight roads. We may, for example, want to create a branching
    road where the program takes the proper branch based on the situation at hand.
    This is called *conditional execution*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有程序都是直线道路。例如，我们可能希望创建一条分支道路，在这种情况下，程序根据当前情况选择适当的分支。这被称为*条件执行*。
- en: '![Image](../images/f0028-02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0028-02.jpg)'
- en: Conditional execution is created with the if keyword in JavaScript. In the simple
    case, we want some code to be executed if, and only if, a certain condition holds.
    We might, for example, want to show the square of the input only if the input
    is actually a number.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 条件执行是在JavaScript中通过`if`关键字创建的。在简单的情况下，我们希望某段代码仅在某个条件成立时执行。例如，我们可能希望仅在输入实际是数字时显示输入的平方。
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this modification, if you enter **parrot**, no output is shown.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修改，如果你输入**鹦鹉**，将不会显示任何输出。
- en: The if keyword executes or skips a statement depending on the value of a Boolean
    expression. The deciding expression is written after the keyword, between parentheses,
    followed by the statement to execute.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`关键字根据布尔表达式的值执行或跳过语句。决定性的表达式写在关键字后面，用括号括起来，后面跟着要执行的语句。'
- en: The Number.isNaN function is a standard JavaScript function that returns true
    only if the argument it is given is NaN. The Number function happens to return
    NaN when you give it a string that doesn’t represent a valid number. Thus, the
    condition translates to “unless theNumber is not-a-number, do this.”
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.isNaN`函数是一个标准的JavaScript函数，仅当给定的参数是NaN时返回true。`Number`函数在你给它一个不表示有效数字的字符串时，恰好返回NaN。因此，这个条件可以理解为“除非theNumber不是一个数字，否则执行这个操作。”'
- en: The statement after the if is wrapped in braces ({ and }) in this example. The
    braces can be used to group any number of statements into a single statement,
    called a *block*. You could also have omitted them in this case, since they hold
    only a single statement, but to avoid having to think about whether they are needed,
    most JavaScript programmers use them in every wrapped statement like this. We’ll
    mostly follow that convention in this book, except for the occasional one-liner.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`if`后面的语句用大括号（{ 和 }）包裹起来。大括号可以用来将任意数量的语句组合成一个单一的语句，称为*块*。在这种情况下，你也可以省略它们，因为它们只包含一条语句，但为了避免考虑它们是否需要，大多数JavaScript程序员在每个包裹的语句中都使用它们。在本书中，我们大多数情况下将遵循这个约定，偶尔会有一行代码的情况。
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You often won’t just have code that executes when a condition holds true, but
    also code that handles the other case. This alternate path is represented by the
    second arrow in the diagram. You can use the else keyword, together with if, to
    create two separate, alternative execution paths.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不仅会有在条件为真时执行的代码，还有处理其他情况的代码。这个替代路径在图中用第二个箭头表示。你可以使用`else`关键字，与`if`一起创建两个独立的替代执行路径。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you have more than two paths to choose from, you can “chain” multiple if/else
    pairs together. Here’s an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有超过两个路径可以选择，你可以将多个 `if/else` 对组合在一起。这里有一个例子：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The program will first check whether num is less than 10\. If it is, it chooses
    that branch, shows “Small”, and is done. If it isn’t, it takes the else branch,
    which itself contains a second if. If the second condition (< 100) holds, that
    means the number is at least 10 but below 100, and “Medium” is shown. If it doesn’t,
    the second and last else branch is chosen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将首先检查 `num` 是否小于 10。如果是，它选择那个分支，显示“Small”，并结束。如果不是，它选择 `else` 分支，该分支本身包含一个第二个
    `if`。如果第二个条件（< 100）成立，这意味着这个数字至少是 10，但低于 100，显示“Medium”。如果不成立，就选择第二个也是最后的 `else`
    分支。
- en: 'The schema for this program looks something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的框架大致如下：
- en: '![Image](../images/f0030-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0030-01.jpg)'
- en: while and do Loops
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while` 和 `do` 循环'
- en: 'Consider a program that outputs all even numbers from 0 to 12\. One way to
    write this is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个输出 0 到 12 之间所有偶数的程序。可以这样编写：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That works, but the idea of writing a program is to make something *less* work,
    not more. If we needed all even numbers less than 1,000, this approach would be
    unworkable. What we need is a way to run a piece of code multiple times. This
    form of control flow is called a *loop*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然可行，但编写程序的想法是为了减少工作量，而不是增加。如果我们需要所有小于 1,000 的偶数，这种方法将行不通。我们需要的是一种能多次运行代码的方法。这种控制流的形式称为
    *循环*。
- en: '![Image](../images/f0030-02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/f0030-02.jpg)'
- en: 'Looping control flow allows us to go back to some point in the program where
    we were before and repeat it with our current program state. If we combine this
    with a binding that counts, we can do something like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 循环控制流允许我们返回到程序中的某个点，并用当前的程序状态重复执行。如果我们将其与一个计数绑定结合起来，我们可以做到类似于：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A statement starting with the keyword while creates a loop. The word while is
    followed by an expression in parentheses and then a statement, much like if. The
    loop keeps entering that statement as long as the expression produces a value
    that gives true when converted to Boolean.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以关键字 `while` 开头的语句会创建一个循环。`while` 后面跟着一个括号中的表达式，然后是一个语句，和 `if` 类似。只要表达式产生一个转换为布尔值时为真值的值，循环就会不断进入该语句。
- en: The number binding demonstrates the way a binding can track the progress of
    a program. Every time the loop repeats, number gets a value that is 2 more than
    its previous value. At the beginning of every repetition, it is compared with
    the number 12 to decide whether the program’s work is finished.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数字绑定演示了绑定如何跟踪程序的进展。每次循环重复时，`number` 会获取比其先前值多 2 的值。在每次重复的开始，它会与数字 12 进行比较，以决定程序的工作是否完成。
- en: 'As an example that actually does something useful, we can now write a program
    that calculates and shows the value of 2^(10) (2 to the 10th power). We use two
    bindings: one to keep track of our result and one to count how often we have multiplied
    this result by 2\. The loop tests whether the second binding has reached 10 yet
    and, if not, updates both bindings.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际上能做有用事情的例子，我们现在可以编写一个程序来计算并显示 2^(10)（2 的 10 次方）的值。我们使用两个绑定：一个用于跟踪结果，另一个用于计数我们将这个结果乘以
    2 的次数。循环测试第二个绑定是否已达到 10，如果没有，就更新这两个绑定。
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The counter could also have started at 1 and checked for <= 10, but for reasons
    that will become apparent in [Chapter 4](ch04.xhtml#ch04), it is a good idea to
    get used to counting from 0.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器也可以从 1 开始，并检查是否 <= 10，但出于在 [第 4 章](ch04.xhtml#ch04) 中显而易见的原因，习惯从 0 开始计数是个好主意。
- en: Note that JavaScript also has an operator for exponentiation (2 ** 10), which
    you would use to compute this in real code—but that would have ruined the example.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JavaScript 还有一个用于指数运算的运算符（2 ** 10），你可以在实际代码中使用它来计算这一点——但这会破坏示例。
- en: 'A do loop is a control structure similar to a while loop. It differs only on
    one point: a do loop always executes its body at least once, and it starts testing
    whether it should stop only after that first execution. To reflect this, the test
    appears after the body of the loop.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` 循环是一种控制结构，类似于 `while` 循环。它的不同之处在于：`do` 循环至少会执行其主体一次，只有在第一次执行之后才开始测试是否应该停止。为了反映这一点，测试出现在循环主体之后。'
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This program will force you to enter a name. It will ask again and again until
    it gets something that is not an empty string. Applying the ! operator will convert
    a value to Boolean type before negating it, and all strings except "" convert
    to true. This means the loop continues going round until you provide a non-empty
    name.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将强制你输入一个名称。它会不断询问，直到获得一个非空字符串。使用 ! 运算符将值转换为布尔类型后再取反，除了 "" 之外的所有字符串都会转换为 true。这意味着循环将继续，直到你提供一个非空名称。
- en: Indenting Code
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进代码
- en: In the examples, I’ve been adding spaces in front of statements that are part
    of some larger statement. These spaces are not required—the computer will accept
    the program just fine without them. In fact, even the line breaks in programs
    are optional. You could write a program as a single long line if you felt like
    it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我在某些较大语句的一部分前添加了空格。这些空格不是必需的——计算机没有它们也能正常接受程序。实际上，程序中的换行也是可选的。如果你愿意，可以将程序写成一长行。
- en: The role of this indentation inside blocks is to make the structure of the code
    stand out to human readers. In code where new blocks are opened inside other blocks,
    it can become hard to see where one block ends and another begins. With proper
    indentation, the visual shape of a program corresponds to the shape of the blocks
    inside it. I like to use two spaces for every open block, but tastes differ—some
    people use four spaces, and some people use tab characters. The important thing
    is that each new block adds the same amount of space.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码块内部的缩进作用是让代码结构对人类读者更明显。在其他块内打开新块的代码中，可能很难看出一个块结束了另一个块开始了。通过适当的缩进，程序的视觉形状与其中的块的形状相对应。我喜欢每个打开的块使用两个空格，但口味各异——有些人使用四个空格，有些人使用制表符。重要的是每个新块添加相同数量的空格。
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most code editor programs will help by automatically indenting new lines the
    proper amount.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码编辑器程序会自动将新行缩进到适当的位置。
- en: for Loops
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: Many loops follow the pattern shown in the while examples. First a “counter”
    binding is created to track the progress of the loop. Then comes a while loop,
    usually with a test expression that checks whether the counter has reached its
    end value. At the end of the loop body, the counter is updated to track progress.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 许多循环遵循 while 示例中展示的模式。首先创建一个“计数器”绑定，以跟踪循环的进度。然后是一个 while 循环，通常带有一个测试表达式，以检查计数器是否已达到其结束值。在循环体结束时，计数器会更新以跟踪进度。
- en: Because this pattern is so common, JavaScript and similar languages provide
    a slightly shorter and more comprehensive form, the for loop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种模式非常常见，JavaScript 和类似语言提供了一种稍短且更全面的形式，即 for 循环。
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This program is exactly equivalent to the earlier even-number-printing example
    (on [page 30](ch02.xhtml#page_30)). The only change is that all the statements
    that are related to the “state” of the loop are grouped together after for.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序与之前的偶数打印示例完全相同（见 [第 30 页](ch02.xhtml#page_30)）。唯一的变化是与循环的“状态”相关的所有语句都在 for
    之后分组在一起。
- en: The parentheses after a for keyword must contain two semicolons. The part before
    the first semicolon *initializes* the loop, usually by defining a binding. The
    second part is the expression that *checks* whether the loop must continue. The
    final part *updates* the state of the loop after every iteration. In most cases,
    this is shorter and clearer than a while construct.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: for 关键字后的括号必须包含两个分号。第一个分号之前的部分*初始化*循环，通常通过定义一个绑定来实现。第二部分是*检查*循环是否应该继续的表达式。最后一部分在每次迭代后*更新*循环的状态。在大多数情况下，这比
    while 结构更简洁明了。
- en: 'This is the code that computes 2^(10) using for instead of while:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 for 循环而非 while 循环计算 2^(10) 的代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Breaking Out of a Loop
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳出循环
- en: Having the looping condition produce false is not the only way a loop can finish.
    The break statement has the effect of immediately jumping out of the enclosing
    loop. Its use is demonstrated in the following program, which finds the first
    number that is both greater than or equal to 20 and divisible by 7.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使循环条件产生 false 不是循环结束的唯一方式。break 语句的作用是立即跳出所包围的循环。其用法在以下程序中演示，该程序找出第一个大于或等于 20
    且能被 7 整除的数字。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using the remainder (%) operator is an easy way to test whether a number is
    divisible by another number. If it is, the remainder of their division is zero.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用余数 (%) 运算符是测试一个数字是否能被另一个数字整除的简单方法。如果能，二者相除的余数就是零。
- en: The for construct in the example does not have a part that checks for the end
    of the loop. This means that the loop will never stop unless the break statement
    inside is executed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的for构造没有检查循环结束的部分。这意味着循环永远不会停止，除非执行内部的break语句。
- en: If you were to remove that break statement or you accidentally write an end
    condition that always produces true, your program would get stuck in an *infinite
    loop*. A program stuck in an infinite loop will never finish running, which is
    usually a bad thing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除那个break语句，或者不小心写了一个始终为真的结束条件，你的程序将陷入*无限循环*。被困在无限循环中的程序永远不会完成运行，这通常是个坏事。
- en: The continue keyword is similar to break in that it influences the progress
    of a loop. When continue is encountered in a loop body, control jumps out of the
    body and continues with the loop’s next iteration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: continue关键字与break类似，它会影响循环的进度。当在循环体内遇到continue时，控制权会跳出该体，并继续进行循环的下一次迭代。
- en: Updating Bindings Succinctly
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简洁地更新绑定
- en: Especially when looping, a program often needs to “update” a binding to hold
    a value based on that binding’s previous value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在循环中，程序通常需要“更新”绑定，以基于该绑定的先前值保持一个值。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: JavaScript provides a shortcut for this.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript为此提供了一个快捷方式。
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Similar shortcuts work for many other operators, such as result *= 2 to double
    result or counter -= 1 to count downward.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多其他运算符，类似的快捷方式也有效，例如result *= 2用于将result加倍，或counter -= 1用于向下计数。
- en: This allows us to further shorten our counting example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够进一步缩短计数示例。
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For counter += 1 and counter -= 1, there are even shorter equivalents: counter++
    and counter--.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于counter += 1和counter -= 1，还有更短的等效形式：counter++和counter--。
- en: Dispatching on a Value with switch
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用switch根据值调度
- en: 'It is not uncommon for code to look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像这样并不少见：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is a construct called switch that is intended to express such a “dispatch”
    in a more direct way. Unfortunately, the syntax JavaScript uses for this (which
    it inherited from the C/Java line of programming languages) is somewhat awkward—a
    chain of if statements may look better. Here is an example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种构造叫做switch，旨在以更直接的方式表达这样的“调度”。不幸的是，JavaScript使用的语法（它从C/Java编程语言继承而来）有些笨拙——一系列if语句可能看起来更好。以下是一个示例：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You may put any number of case labels inside the block opened by switch. The
    program will start executing at the label that corresponds to the value that switch
    was given, or at default if no matching value is found. It will continue executing,
    even across other labels, until it reaches a break statement. In some cases, such
    as the “sunny” case in the example, this can be used to share some code between
    cases (it recommends going outside for both sunny and cloudy weather). Be careful,
    though—it is easy to forget such a break, which will cause the program to execute
    code you do not want executed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在switch打开的块内放置任意数量的case标签。程序将从与给定switch值相对应的标签开始执行，如果没有匹配值，则从default开始。它将继续执行，甚至跨越其他标签，直到达到break语句。在某些情况下，例如示例中的“晴天”情况，可以用来在不同的情况之间共享一些代码（它建议在晴天和阴天都出去）。但要小心——很容易忘记这样的break，这将导致程序执行你不希望执行的代码。
- en: Capitalization
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大写
- en: 'Binding names may not contain spaces, yet it is often helpful to use multiple
    words to clearly describe what the binding represents. These are pretty much your
    choices for writing a binding name with several words in it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定名称不能包含空格，但使用多个词清晰描述绑定所代表的内容通常是有帮助的。以下是编写包含多个单词的绑定名称的选择：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first style can be hard to read. I rather like the look of the underscores,
    though that style is a little painful to type. The standard JavaScript functions,
    and most JavaScript programmers, follow the final style—they capitalize every
    word except the first. It is not hard to get used to little things like that,
    and code with mixed naming styles can be jarring to read, so we follow this convention.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种风格可能难以阅读。我比较喜欢下划线的样子，尽管这种风格有点难打。标准的JavaScript函数和大多数JavaScript程序员遵循最后一种风格——它们将每个单词的首字母大写，除了第一个。适应这样的细节并不难，而混合命名风格的代码可能会让人阅读不畅，所以我们遵循这一惯例。
- en: In a few cases, such as the Number function, the first letter of a binding is
    also capitalized. This was done to mark this function as a constructor. It will
    become clear what a constructor is in [Chapter 6](ch06.xhtml#ch06). For now, the
    important thing is to not be bothered by this apparent lack of consistency.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在少数情况下，例如数字函数，绑定的首字母也会大写。这是为了将该函数标记为构造函数。在[第6章](ch06.xhtml#ch06)中会明确说明构造函数是什么。现在，重要的是不要被这种明显的不一致所困扰。
- en: Comments
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Often, raw code does not convey all the information you want a program to convey
    to human readers, or it conveys it in such a cryptic way that people might not
    understand it. At other times, you might just want to include some related thoughts
    as part of your program. This is what *comments* are for.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，原始代码无法传达程序希望传达给人类读者的所有信息，或者以一种人们可能无法理解的方式传达。有时，你可能只是想在程序中包含一些相关的想法。这就是*注释*的作用。
- en: A comment is a piece of text that is part of a program but is completely ignored
    by the computer. JavaScript has two ways of writing comments. To write a single-line
    comment, you can use two slash characters (//) and then the comment text after
    it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是一段程序的一部分，但计算机完全忽略它。JavaScript有两种写注释的方法。要编写单行注释，可以使用两个斜杠字符（//），然后在后面写上注释文本。
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A // comment goes only to the end of the line. A section of text between /*
    and */ will be ignored in its entirety, regardless of whether it contains line
    breaks. This is useful for adding blocks of information about a file or a chunk
    of program.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: // 注释只到行尾。位于/*和*/之间的文本段落将完全被忽略，无论是否包含换行。这对于添加关于文件或程序块的信息块是很有用的。
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You now know that a program is built out of statements, which themselves sometimes
    contain more statements. Statements tend to contain expressions, which themselves
    can be built out of smaller expressions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道程序是由语句构成的，而这些语句有时又包含更多的语句。语句往往包含表达式，而这些表达式可以由更小的表达式构建而成。
- en: Putting statements after one another gives you a program that is executed from
    top to bottom. You can introduce disturbances in the flow of control by using
    conditional (if, else, and switch) and looping (while, do, and for) statements.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将语句一个接一个放置，构成一个从上到下执行的程序。你可以通过使用条件语句（if、else和switch）和循环语句（while、do和for）引入控制流中的干扰。
- en: Bindings can be used to file pieces of data under a name, and they are useful
    for tracking state in your program. The environment is the set of bindings that
    are defined. JavaScript systems always put a number of useful standard bindings
    into your environment.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定可以用来将数据片段归档到一个名称下，它们对于跟踪程序状态是有用的。环境是定义的绑定集合。JavaScript系统总是将一些有用的标准绑定放入你的环境中。
- en: Functions are special values that encapsulate a piece of program. You can invoke
    them by writing functionName(argument1, argument2). Such a function call is an
    expression and may produce a value.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是封装了一段程序的特殊值。你可以通过编写functionName(argument1, argument2)来调用它们。这样的函数调用是一个表达式，可能会产生一个值。
- en: Exercises
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: If you are unsure how to test your solutions to the exercises, refer to the
    introduction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定如何测试练习的解决方案，请参考引言。
- en: Each exercise starts with a problem description. Read this description and try
    to solve the exercise. If you run into problems, consider reading the hints at
    the end of the book. You can find full solutions to the exercises online at *[https://eloquentjavascript.net/code#2](https://eloquentjavascript.net/code#2)*.
    If you want to learn something from the exercises, I recommend looking at the
    solutions only after you’ve solved the exercise, or at least after you’ve attacked
    it long and hard enough to have a slight headache.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个练习以问题描述开始。阅读这个描述并尝试解决练习。如果遇到问题，可以考虑阅读书末的提示。你可以在*[https://eloquentjavascript.net/code#2](https://eloquentjavascript.net/code#2)*找到练习的完整解决方案。如果你想从练习中学到东西，我建议在你解决了练习之后，或者至少在你努力攻克它到头痛的程度后，再查看解决方案。
- en: '*Looping a Triangle*'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*循环三角形*'
- en: 'Write a loop that makes seven calls to console.log to output the following
    triangle:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个循环，使其调用console.log七次，以输出以下三角形：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It may be useful to know that you can find the length of a string by writing
    .length after it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何通过在字符串后写.length来获取字符串的长度可能会很有用。
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*FizzBuzz*'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*FizzBuzz*'
- en: Write a program that uses console.log to print all the numbers from 1 to 100,
    with two exceptions. For numbers divisible by 3, print “Fizz” instead of the number,
    and for numbers divisible by 5 (and not 3), print “Buzz” instead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，使用 console.log 打印从 1 到 100 的所有数字，有两个例外。对于能被 3 整除的数字，打印“Fizz”代替数字，而对于能被
    5 整除（且不能被 3 整除）的数字，打印“Buzz”代替。
- en: When you have that working, modify your program to print “FizzBuzz” for numbers
    that are divisible by both 3 and 5 (and still print “Fizz” or “Buzz” for numbers
    divisible by only one of those).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现这个功能后，修改你的程序以打印“FizzBuzz”，用于那些同时能被 3 和 5 整除的数字（同时仍然打印“Fizz”或“Buzz”用于仅能被其中一个整除的数字）。
- en: (This is actually an interview question that has been claimed to weed out a
    significant percentage of programmer candidates. So if you solved it, your labor
    market value just went up.)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: （这实际上是一个面试问题，据说可以筛选出相当一部分程序员候选人。所以如果你解决了这个问题，你的劳动力市场价值就上升了。）
- en: '*Chessboard*'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*棋盘*'
- en: Write a program that creates a string that represents an 8*×*8 grid, using new-line
    characters to separate lines. At each position of the grid there is either a space
    or a “#” character. The characters should form a chessboard.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个程序，创建一个表示 8*×*8 网格的字符串，使用换行符分隔行。在网格的每个位置上都有一个空格或一个“#”字符。这些字符应该形成一个棋盘。
- en: 'Passing this string to console.log should show something like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个字符串传递给 console.log 应该显示类似这样的内容：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you have a program that generates this pattern, define a binding size =
    8 and change the program so that it works for any size, outputting a grid of the
    given width and height.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个生成这个图案的程序时，定义一个绑定 size = 8，并修改程序使其适用于任意大小，输出给定宽度和高度的网格。
- en: '*People think that computer science is the art of geniuses but the actual reality
    is the opposite, just many people doing things that build on each other, like
    a wall of mini stones.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*人们认为计算机科学是天才的艺术，但实际上情况正好相反，只是许多人在做相互积累的事情，就像一堵迷你石头墙。*'
- en: —Donald Knuth
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: —唐纳德·克努斯
- en: '![Image](../images/f0038-01.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0038-01.jpg)'
