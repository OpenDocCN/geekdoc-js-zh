- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: BUGS AND ERRORS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞和错误
- en: Flaws in computer programs are usually called *bugs*. It makes programmers feel
    good to imagine them as little things that just happen to crawl into our work.
    In reality, of course, we put them there ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序中的缺陷通常被称为*漏洞*。程序员常常觉得将它们想象成一些偶然爬入我们工作的“小东西”会让人感觉良好。但实际上，当然是我们自己把它们放进去的。
- en: If a program is crystallized thought, we can roughly categorize bugs into those
    caused by the thoughts being confused and those caused by mistakes introduced
    while converting a thought to code. The former type is generally harder to diagnose
    and fix than the latter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序是凝结的思维，我们可以大致将漏洞分为由于思维混乱引起的漏洞和在将思维转换为代码时引入的错误。前者通常比后者更难以诊断和修复。
- en: Language
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语言
- en: Many mistakes could be pointed out to us automatically by the computer if it
    knew enough about what we’re trying to do. But here, JavaScript’s looseness is
    a hindrance. Its concept of bindings and properties is vague enough that it will
    rarely catch typos before actually running the program. Even then, it allows you
    to do some clearly nonsensical things without complaint, such as computing true
    * “monkey”.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机对我们正在尝试做的事情了解得足够多，许多错误可以被自动指出。但在这里，JavaScript的宽松性反而成了障碍。它对绑定和属性的概念模糊到几乎无法在程序运行之前捕捉到拼写错误。即便如此，它仍然允许你在没有抱怨的情况下做一些显然无意义的事情，比如计算true
    * “monkey”。
- en: There are some things that JavaScript does complain about. Writing a program
    that does not follow the language’s grammar will immediately make the computer
    complain. Other things, such as calling something that’s not a function or looking
    up a property on an undefined value, will cause an error to be reported when the
    program tries to perform the action.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript会对一些事情进行抱怨。编写一个不符合语言语法的程序会立即导致计算机发出警告。其他事情，例如调用非函数的东西或在未定义值上查找属性，都会在程序尝试执行该操作时引发错误。
- en: Often, however, your nonsense computation will merely produce NaN (not a number)
    or an undefined value, while the program happily continues, convinced that it’s
    doing something meaningful. The mistake will manifest itself only later, after
    the bogus value has traveled through several functions. It might not trigger an
    error at all, but silently cause the program’s output to be wrong. Finding the
    source of such problems can be difficult.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下，你的无意义计算会仅仅产生NaN（不是一个数字）或未定义值，而程序则会愉快地继续运行，确信自己在做一些有意义的事情。这个错误只有在虚假值经过多个函数后才会显现出来。它可能根本不会触发错误，但会默默导致程序的输出错误。找到此类问题的源头可能会很困难。
- en: The process of finding mistakes—bugs—in programs is called *debugging*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查找程序中错误（漏洞）的过程称为*调试*。
- en: Strict Mode
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式
- en: 'JavaScript can be made a *little* stricter by enabling *strict mode*. This
    can be done by putting the string “use strict” at the top of a file or a function
    body. Here’s an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript可以通过启用*严格模式*变得*稍微*严格。这可以通过在文件或函数体的顶部放置字符串“use strict”来实现。以下是一个示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code inside classes and modules (which we will discuss in [Chapter 10](ch10.xhtml#ch10))
    is automatically strict. The old nonstrict behavior still exists only because
    some old code might depend on it, and the language designers work hard to avoid
    breaking any existing programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类和模块中的代码（我们将在[第10章](ch10.xhtml#ch10)中讨论）是自动严格的。旧的非严格行为仍然存在，只是因为某些旧代码可能依赖于此，语言设计者努力避免破坏任何现有程序。
- en: Normally, when you forget to put let in front of your binding, as with counter
    in the example, JavaScript quietly creates a global binding and uses that. In
    strict mode, an error is reported instead. This is very helpful. It should be
    noted, though, that this doesn’t work when the binding in question already exists
    somewhere in scope. In that case, the loop will still quietly overwrite the value
    of the binding.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你忘记在绑定前加let时，比如示例中的counter，JavaScript会静默地创建一个全局绑定并使用它。在严格模式下，则会报告错误。这是非常有帮助的。但需要注意的是，当相关的绑定已经在作用域中存在时，这种方法将不起作用。在这种情况下，循环仍然会静默地覆盖绑定的值。
- en: Another change in strict mode is that the this binding holds the value undefined
    in functions that are not called as methods. When making such a call outside of
    strict mode, this refers to the global scope object, which is an object whose
    properties are the global bindings. So if you accidentally call a method or constructor
    incorrectly in strict mode, JavaScript will produce an error as soon as it tries
    to read something from this, rather than happily writing to the global scope.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式的另一个变化是，this 绑定在未作为方法调用的函数中保持未定义值。当在非严格模式下进行这样的调用时，this 引用全局作用域对象，该对象的属性是全局绑定。因此，如果你在严格模式下错误地调用了一个方法或构造函数，JavaScript
    会在尝试从 this 读取内容时产生错误，而不是高兴地写入全局作用域。
- en: 'For example, consider the following code, which calls a constructor function
    without the new keyword so that its this will *not* refer to a newly constructed
    object:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码，它在没有 new 关键字的情况下调用构造函数，因此它的 this 将*不*引用新构造的对象：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bogus call to Person succeeded, but returned an undefined value and created
    the global binding name. In strict mode, the result is different.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Person 的虚假调用成功了，但返回了未定义的值，并创建了全局绑定名称。在严格模式下，结果是不同的。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We are immediately told that something is wrong. This is helpful. Fortunately,
    constructors created with the class notation will always complain if they are
    called without new, making this less of a problem even in nonstrict mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会立即被告知某些地方出了问题。这很有帮助。幸运的是，使用 class 语法创建的构造函数如果没有 new 被调用时总会抱怨，即使在非严格模式下，这也减少了问题的发生。
- en: Strict mode does a few more things. It disallows giving a function multiple
    parameters with the same name and removes certain problematic language features
    entirely (such as the with statement, which is so wrong it is not further discussed
    in this book).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式还做了一些其他事情。它不允许给函数多个相同名称的参数，并完全移除某些有问题的语言特性（例如 with 语句，由于错误严重而未在本书中进一步讨论）。
- en: In short, putting “use strict” at the top of your program rarely hurts and might
    help you spot a problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在程序顶部放置“use strict”通常不会造成伤害，反而可能帮助你发现问题。
- en: Types
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: Some languages want to know the types of all your bindings and expressions before
    even running a program. They will tell you right away when a type is used in an
    inconsistent way. JavaScript considers types only when actually running the program,
    and even there often tries to implicitly convert values to the type it expects,
    so it’s not much help.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言希望在运行程序之前知道所有绑定和表达式的类型。当类型以不一致的方式使用时，它们会立即告诉你。JavaScript 只在实际运行程序时考虑类型，即使在那时也常常尝试隐式地将值转换为它所期望的类型，因此并没有太大帮助。
- en: Still, types provide a useful framework for talking about programs. A lot of
    mistakes come from being confused about the kind of value that goes into or comes
    out of a function. If you have that information written down, you’re less likely
    to get confused.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，类型提供了一个有用的框架来讨论程序。许多错误源于对输入或输出的值类型的混淆。如果你把这些信息写下来，你就不容易混淆。
- en: 'You could add a comment like the following before the findRoute function from
    the previous chapter to describe its type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上一章的 findRoute 函数之前添加如下注释，以描述它的类型：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are a number of different conventions for annotating JavaScript programs
    with types.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种不同的约定用于用类型注解 JavaScript 程序。
- en: A thing about types is that they need to introduce their own complexity to be
    able to describe enough code to be useful. What do you think would be the type
    of the randomPick function that returns a random element from an array? You’d
    need to introduce a *type variable*, *T*, which can stand in for any type, so
    that you can give randomPick a type like (T[]) *→* T (function from an array of
    *T*s to a *T*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类型的一点是，它们需要引入自己的复杂性，以能够描述足够的代码以便有用。你认为返回数组中随机元素的 randomPick 函数的类型会是什么？你需要引入一个*类型变量*，*T*，它可以代表任何类型，以便你可以为
    randomPick 赋予类似 (T[]) *→* T 的类型（从一个*T*数组到一个*T*的函数）。
- en: When the types of a program are known, it is possible for the computer to *check*
    them for you, pointing out mistakes before the program is run. There are several
    JavaScript dialects that add types to the language and check them. The most popular
    one is called TypeScript. If you are interested in adding more rigor to your programs,
    I recommend you give it a try.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序的类型已知时，计算机可以为你*检查*这些类型，指出在程序运行前的错误。有几种 JavaScript 方言为语言添加了类型并进行检查。其中最流行的是
    TypeScript。如果你有兴趣为你的程序增加更多严谨性，我建议你试一试。
- en: In this book, we will continue using raw, dangerous, untyped Java-Script code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将继续使用原始的、危险的、无类型的 JavaScript 代码。
- en: Testing
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试
- en: 'If the language is not going to do much to help us find mistakes, we’ll have
    to find them the hard way: by running the program and seeing whether it does the
    right thing.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果语言不会在很大程度上帮助我们找到错误，我们就必须通过运行程序并查看它是否做正确的事情来艰难地找到它们。
- en: Doing this by hand, again and again, is a really bad idea. Not only is it annoying
    but it also tends to be ineffective, since it takes too much time to exhaustively
    test everything every time you make a change.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 手动一次又一次地这样做是个很糟糕的主意。这不仅令人烦恼，而且往往效率低下，因为每次修改时要全面测试所有内容需要花费太多时间。
- en: 'Computers are good at repetitive tasks, and testing is the ideal repetitive
    task. Automated testing is the process of writing a program that tests another
    program. Writing tests is a bit more work than testing manually, but once you’ve
    done it, you gain a kind of superpower: it takes you only a few seconds to verify
    that your program still behaves properly in all the situations you wrote tests
    for. When you break something, you’ll immediately notice rather than randomly
    running into it at some later time.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机擅长重复性任务，而测试就是理想的重复性任务。自动化测试是编写一个测试另一个程序的程序的过程。编写测试比手动测试需要多一点工作，但一旦你完成它，你就获得了一种超能力：你只需几秒钟就能验证你的程序在你编写测试的所有情况下仍然表现正常。当你破坏了某些东西时，你会立即注意到，而不是在之后的某个时刻偶然发现。
- en: 'Tests usually take the form of little labeled programs that verify some aspect
    of your code. For example, a set of tests for the (standard, probably already
    tested by someone else) toUpperCase method might look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常以小型标记程序的形式出现，用于验证代码的某些方面。例如，针对（标准的，可能已经被其他人测试过的）toUpperCase 方法的一组测试可能如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Writing tests like this tends to produce rather repetitive, awkward code. Fortunately,
    there exist pieces of software that help you build and run collections of tests
    (*test suites*) by providing a language (in the form of functions and methods)
    suited to expressing tests and by outputting informative information when a test
    fails. These are usually called *test runners*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样编写测试往往会产生相当重复和笨拙的代码。幸运的是，有一些软件可以帮助你构建和运行测试集合（*测试套件*），通过提供一种适合表达测试的语言（以函数和方法的形式）以及在测试失败时输出有用信息。这些通常被称为*测试运行器*。
- en: Some code is easier to test than other code. Generally, the more external objects
    that the code interacts with, the harder it is to set up the context in which
    to test it. The style of programming shown in the previous chapter, which uses
    self-contained persistent values rather than changing objects, tends to be easy
    to test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码比其他代码更容易测试。一般来说，代码与外部对象的交互越多，设置测试上下文就越困难。前一章中展示的编程风格，使用自包含的持久值而不是可变对象，往往更容易测试。
- en: Debugging
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试
- en: Once you notice there is something wrong with your program because it misbehaves
    or produces errors, the next step is to figure out *what* the problem is.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你注意到程序出现了问题，因为它表现不当或产生错误，下一步就是找出*是什么*问题。
- en: Sometimes it is obvious. The error message will point at a specific line of
    your program, and if you look at the error description and that line of code,
    you can often see the problem.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这很明显。错误信息会指向程序的特定行，如果你查看错误描述和那行代码，通常能看到问题所在。
- en: But not always. Sometimes the line that triggered the problem is simply the
    first place where a flaky value produced elsewhere gets used in an invalid way.
    If you have been solving the exercises in earlier chapters, you will probably
    have already experienced such situations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但并不总是如此。有时触发问题的行仅仅是一个地方，在那里一个不稳定的值以无效的方式被使用。如果你在前面的章节中解决过练习，你可能已经经历过这样的情况。
- en: The following example program tries to convert a whole number to a string in
    a given base (decimal, binary, and so on) by repeatedly picking out the last digit
    and then dividing the number to get rid of this digit. But the strange output
    that it currently produces suggests that it has a bug.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例程序试图将一个整数转换为给定基数（十进制、二进制等）的字符串，通过反复提取最后一位数字，然后除以该数字以去掉这位数字。但它目前产生的奇怪输出表明它存在缺陷。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even if you see the problem already, pretend for a moment that you don’t. We
    know that our program is malfunctioning, and we want to find out why.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经看到问题，暂时假装你没有。我们知道我们的程序出现了故障，我们想找出原因。
- en: This is where you must resist the urge to start making random changes to the
    code to see whether that makes it better. Instead, *think*. Analyze what is happening
    and come up with a theory of why it might be happening. Then make additional observations
    to test this theory—or, if you don’t yet have a theory, make additional observations
    to help you come up with one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你必须抵制随机更改代码的冲动，以看看这样是否会改善程序。相反，*思考*。分析发生了什么，并提出一个可能的理论来解释它。然后进行额外的观察以测试这个理论——或者，如果你还没有理论，进行额外的观察来帮助你形成一个。
- en: Putting a few strategic console.log calls into the program is a good way to
    get additional information about what the program is doing. In this case, we want
    n to take the values 13, 1, and then 0. Let’s write out its value at the start
    of the loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中放置一些战略性的 console.log 调用是获取程序正在做的事情的额外信息的好方法。在这种情况下，我们希望 n 依次取值 13、1，然后 0。让我们在循环开始时写出它的值。
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Right*. Dividing 13 by 10 does not produce a whole number. Instead of n /=
    base, what we actually want is n = Math.floor(n / base) so that the number is
    properly “shifted” to the right.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*对的*。将13除以10不会产生一个整数。我们实际上想要的是 n = Math.floor(n / base)，而不是 n /= base，这样数字才能正确“向右移动”。'
- en: An alternative to using console.log to peek into the program’s behavior is to
    use the *debugger* capabilities of your browser. Browsers come with the ability
    to set a *breakpoint* on a specific line of your code. When the execution of the
    program reaches a line with a breakpoint, it is paused, and you can inspect the
    values of bindings at that point. I won’t go into details, as debuggers differ
    from browser to browser, but look in your browser’s developer tools or search
    the web for instructions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 console.log 来窥探程序行为的替代方法是使用浏览器的 *调试器* 功能。浏览器具有在代码的特定行上设置 *断点* 的能力。当程序执行到包含断点的行时，它会暂停，你可以检查此时绑定的值。我不会详细说明，因为不同浏览器的调试器各不相同，但可以查看浏览器的开发者工具或在网上搜索说明。
- en: Another way to set a breakpoint is to include a debugger statement (consisting
    simply of that keyword) in your program. If the developer tools of your browser
    are active, the program will pause whenever it reaches such a statement.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设置断点的方法是在你的程序中包含一个调试器语句（仅由该关键字组成）。如果浏览器的开发者工具处于活动状态，程序将在遇到此类语句时暂停。
- en: Error Propagation
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误传播
- en: Not all problems can be prevented by the programmer, unfortunately. If your
    program communicates with the outside world in any way, it is possible to get
    malformed input, to become overloaded with work, or to have the network fail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不是所有问题都能由程序员预防。如果你的程序以任何方式与外部世界通信，就有可能收到格式不正确的输入、过载工作量，或者网络失败。
- en: If you’re programming only for yourself, you can afford to just ignore such
    problems until they occur. But if you build something that is going to be used
    by anybody else, you usually want the program to do better than just crash. Sometimes
    the right thing to do is take the bad input in stride and continue running. In
    other cases, it is better to report to the user what went wrong and then give
    up. In either situation the program has to actively do something in response to
    the problem.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是为自己编程，你可以选择忽略这些问题直到它们发生。但如果你构建的东西将被其他人使用，通常希望程序比单纯崩溃做得更好。有时正确的做法是坦然接受错误输入并继续运行。在其他情况下，最好是向用户报告发生了什么错误，然后放弃。在这两种情况下，程序必须积极响应问题。
- en: Say you have a function promptNumber that asks the user for a number and returns
    it. What should it return if the user inputs “orange”?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数 promptNumber，它询问用户一个数字并返回它。如果用户输入“橙子”，它应该返回什么？
- en: One option is to make it return a special value. Common choices for such values
    are null, undefined, or -1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是让它返回一个特殊值。常见的选择包括 null、undefined 或 -1。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now any code that calls promptNumber must check whether an actual number was
    read and, failing that, must somehow recover—maybe by asking again or by filling
    in a default value. Or it could again return a special value to *its* caller to
    indicate that it failed to do what it was asked.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何调用 promptNumber 的代码都必须检查是否读取到了实际的数字，如果没有，则必须以某种方式进行恢复——也许是再次询问，或者填入一个默认值。或者它可以再次返回一个特殊值给
    *它* 的调用者，以指示它未能完成请求的操作。
- en: In many situations, mostly when errors are common and the caller should be explicitly
    taking them into account, returning a special value is a good way to indicate
    an error. It does, however, have its downsides. First, what if the function can
    already return every possible kind of value? In such a function, you’ll have to
    do something like wrap the result in an object to be able to distinguish success
    from failure, the way the next method on the iterator interface does.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，尤其是在错误常见且调用者应明确考虑这些错误时，返回一个特殊值是指示错误的好方法。然而，这也有其缺点。首先，如果函数已经可以返回每种可能的值怎么办？在这样的函数中，你需要做一些像将结果包装在对象中，以便能够区分成功和失败的事情，正如迭代器接口的下一个方法所做的那样。
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second issue with returning special values is that it can lead to awkward
    code. If a piece of code calls promptNumber 10 times, it has to check 10 times
    whether null was returned. If its response to finding null is to simply return
    null itself, callers of the function will in turn have to check for it, and so
    on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 返回特殊值的第二个问题是，它可能导致尴尬的代码。如果一段代码调用 promptNumber 10 次，它必须检查 10 次是否返回了 null。如果它发现
    null 的反应只是简单地返回 null 本身，那么调用这个函数的代码也将必须进行检查，依此类推。
- en: Exceptions
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常
- en: When a function cannot proceed normally, what we would often *like* to do is
    just stop what we are doing and immediately jump to a place that knows how to
    handle the problem. This is what *exception handling* does.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数无法正常进行时，我们通常*希望*做的就是停止我们正在做的事情，并立即跳转到一个知道如何处理该问题的地方。这就是*异常处理*所做的。
- en: 'Exceptions are a mechanism that makes it possible for code that runs into a
    problem to *raise* (or *throw*) an exception. An exception can be any value. Raising
    one somewhat resembles a supercharged return from a function: it jumps out of
    not just the current function but also its callers, all the way down to the first
    call that started the current execution. This is called *unwinding the stack*.
    You may remember the stack of function calls mentioned in [Chapter 3](ch03.xhtml#ch03).
    An exception zooms down this stack, throwing away all the call contexts it encounters.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一种机制，使得在代码遇到问题时可以*引发*（或*抛出*）异常。异常可以是任何值。引发异常有点类似于函数的超级返回：它不仅跳出当前函数，还跳出所有调用它的函数，一直返回到开始当前执行的第一个调用。这被称为*展开栈*。你可能还记得在[第3章](ch03.xhtml#ch03)提到的函数调用栈。异常在这个栈中快速向下移动，抛弃它遇到的所有调用上下文。
- en: If exceptions always zoomed right down to the bottom of the stack, they would
    not be of much use. They’d just provide a novel way to blow up your program. Their
    power lies in the fact that you can set “obstacles” along the stack to *catch*
    the exception as it is zooming down. Once you’ve caught an exception, you can
    do something with it to address the problem and then continue to run the program.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异常总是直接向下快速传递到栈底，它们就没有太大用处。它们只会提供一种新颖的方式来使你的程序崩溃。它们的强大在于你可以在栈上设置“障碍”，以*捕获*在下落过程中发生的异常。一旦你捕获了异常，就可以处理它以解决问题，然后继续运行程序。
- en: 'Here’s an example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The throw keyword is used to raise an exception. Catching one is done by wrapping
    a piece of code in a try block, followed by the keyword catch. When the code in
    the try block causes an exception to be raised, the catch block is evaluated,
    with the name in parentheses bound to the exception value. After the catch block
    finishes—or if the try block finishes without problems—the program proceeds beneath
    the entire try/catch statement.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: throw 关键字用于引发异常。捕获异常是通过将一段代码包装在 try 块中，然后跟上关键字 catch 来实现的。当 try 块中的代码引发异常时，catch
    块将被评估，括号中的名称绑定到异常值上。在 catch 块完成后——或者如果 try 块没有问题地完成——程序将在整个 try/catch 语句下继续执行。
- en: 'In this case, we used the Error constructor to create our exception value.
    This is a standard JavaScript constructor that creates an object with a message
    property. Instances of Error also gather information about the call stack that
    existed when the exception was created, a so-called *stack trace*. This information
    is stored in the stack property and can be helpful when trying to debug a problem:
    it tells us the function where the problem occurred and which functions made the
    failing call.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用 Error 构造函数创建我们的异常值。这是一个标准的 JavaScript 构造函数，用于创建一个具有消息属性的对象。Error
    的实例还收集了在创建异常时存在的调用栈的信息，所谓的*栈追踪*。这些信息存储在 stack 属性中，在尝试调试问题时非常有用：它告诉我们问题发生的函数以及哪些函数进行了失败的调用。
- en: 'Note that the look function completely ignores the possibility that prompt
    Direction might go wrong. This is the big advantage of exceptions: error-handling
    code is necessary only at the point where the error occurs and at the point where
    it is handled. The functions in between can forget all about it.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，look函数完全忽略了prompt Direction可能出现错误的情况。这就是异常的重大优势：错误处理代码仅在错误发生的点和处理的点才是必要的。而中间的函数可以完全不再考虑这个问题。
- en: Well, almost . . .
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，几乎是这样……
- en: Cleaning Up After Exceptions
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常后的清理
- en: The effect of an exception is another kind of control flow. Every action that
    might cause an exception, which is pretty much every function call and property
    access, might cause control to suddenly leave your code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的效果是一种控制流。每个可能引发异常的动作，几乎每个函数调用和属性访问，都可能导致控制突然离开你的代码。
- en: This means when code has several side effects, even if its “regular” control
    flow looks like they’ll always all happen, an exception might prevent some of
    them from taking place.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当代码有多个副作用时，即使其“常规”控制流看起来总会发生这些副作用，异常可能会阻止其中某些副作用的发生。
- en: 'Here is some really bad banking code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些非常糟糕的银行代码：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The transfer function transfers a sum of money from a given account to another,
    asking for the name of the other account in the process. If given an invalid account
    name, getAccount throws an exception.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 转账函数将一笔资金从一个指定账户转移到另一个账户，并在此过程中询问另一个账户的名称。如果给出无效的账户名称，getAccount将抛出异常。
- en: But transfer *first* removes the money from the account and *then* calls getAccount
    before it adds it to another account. If it is broken off by an exception at that
    point, it’ll just make the money disappear.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是转账*首先*从账户中移走资金，然后*再*调用getAccount，才将其添加到另一个账户。如果在这一点上被异常中断，资金就会消失。
- en: That code could have been written a little more intelligently, for example by
    calling getAccount before it starts moving money around. But often problems like
    this occur in more subtle ways. Even functions that don’t look like they will
    throw an exception might do so in exceptional circumstances or when they contain
    a programmer mistake.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本可以写得更聪明一些，例如在开始转移资金之前先调用getAccount。但这样的错误往往以更微妙的方式出现。即使是看似不会抛出异常的函数，在特殊情况下或因程序员的失误也可能会抛出异常。
- en: One way to address this is to use fewer side effects. Again, a programming style
    that computes new values instead of changing existing data helps. If a piece of
    code stops running in the middle of creating a new value, no existing data structures
    were damaged, making it easier to recover.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这一问题的一种方法是减少副作用。同样，计算新值而不是更改现有数据的编程风格有助于减少问题。如果一段代码在创建新值的过程中中途停止运行，就不会破坏任何现有的数据结构，从而使恢复变得更容易。
- en: 'Since that isn’t always practical, try statements have another feature: they
    may be followed by a finally block either instead of or in addition to a catch
    block. A finally block says “no matter *what* happens, run this code after trying
    to run the code in the try block.”'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这并不总是实际可行，try语句还有另一个特性：它们可以被finally块跟随，作为catch块的替代或补充。finally块表示“无论发生*什么*，在尝试运行try块中的代码后运行这段代码。”
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This version of the function tracks its progress, and if, when leaving, it notices
    that it was aborted at a point where it had created an inconsistent program state,
    it repairs the damage it did.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的函数跟踪其进度，如果在离开时发现它在创建不一致的程序状态时被中止，它会修复所造成的损害。
- en: Note that even though the finally code is run when an exception is thrown in
    the try block, it does not interfere with the exception. After the finally block
    runs, the stack continues unwinding.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使在try块中抛出异常时，finally代码仍会运行，但这并不会干扰异常。在finally块运行后，堆栈继续展开。
- en: Writing programs that operate reliably even when exceptions pop up in unexpected
    places is hard. Many people simply don’t bother, and because exceptions are typically
    reserved for exceptional circumstances, the problem may occur so rarely that it
    is never even noticed. Whether that is a good thing or a really bad thing depends
    on how much damage the software will do when it fails.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 编写即使在意外情况下也能可靠运行的程序是很困难的。许多人根本不在意，因为异常通常是为特殊情况保留的，所以问题可能发生得非常少，以至于根本不会被注意到。这是好事还是坏事，取决于软件失败时造成的损害程度。
- en: Selective Catching
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择性捕获
- en: When an exception makes it all the way to the bottom of the stack without being
    caught, it gets handled by the environment. What this means differs between environments.
    In browsers, a description of the error typically gets written to the JavaScript
    console (reachable through the browser’s Tools or Developer menu). Node.js, the
    browserless JavaScript environment we will discuss in [Chapter 20](ch20.xhtml#ch20),
    is more careful about data corruption. It aborts the whole process when an unhandled
    exception occurs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当异常一路传递到底部而未被捕获时，它会被环境处理。这在不同环境中意味着不同的事情。在浏览器中，错误描述通常会写入JavaScript控制台（可以通过浏览器的工具或开发者菜单访问）。Node.js（我们将在[第20章](ch20.xhtml#ch20)中讨论的无浏览器JavaScript环境）对数据损坏更加谨慎。当发生未处理异常时，它会中止整个进程。
- en: For programmer mistakes, just letting the error go through is often the best
    you can do. An unhandled exception is a reasonable way to signal a broken program,
    and the JavaScript console will, on modern browsers, provide you with some information
    about which function calls were on the stack when the problem occurred.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序员的错误，通常允许错误通过是你能做的最好的选择。未处理异常是指示程序出现故障的一种合理方式，现代浏览器的JavaScript控制台会为你提供一些关于问题发生时调用栈上哪些函数的信息。
- en: For problems that are *expected* to happen during routine use, crashing with
    an unhandled exception is a terrible strategy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在日常使用中*预期*会发生的问题，崩溃并伴随未处理异常是一种糟糕的策略。
- en: Invalid uses of the language, such as referencing a nonexistent binding, looking
    up a property on null, or calling something that’s not a function, will also result
    in exceptions being raised. Such exceptions can also be caught.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对语言的无效使用，例如引用一个不存在的绑定、在null上查找属性或调用非函数的东西，也会导致异常被抛出。这些异常也可以被捕获。
- en: When a catch body is entered, all we know is that *something* in our try body
    caused an exception. But we don’t know *what* did or *which* exception it caused.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入`catch`体时，我们所知道的只是我们的`try`体中的*某些东西*导致了异常。但我们并不知道*是什么*造成了异常，或者*是哪一个*异常。
- en: 'JavaScript (in a rather glaring omission) doesn’t provide direct support for
    selectively catching exceptions: either you catch them all or you don’t catch
    any. This makes it tempting to *assume* that the exception you get is the one
    you were thinking about when you wrote the catch block.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript（在一个相当明显的遗漏中）并未提供选择性捕获异常的直接支持：要么捕获所有异常，要么一个都不捕获。这使得*假设*你获得的异常正是你在编写`catch`块时所考虑的异常变得很诱人。
- en: 'But it might not be. Some other assumption might be violated, or you might
    have introduced a bug that is causing an exception. Here is an example that *attempts*
    to keep on calling promptDirection until it gets a valid answer:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但这可能并非如此。某些其他假设可能被违反，或者你可能引入了导致异常的错误。以下是一个*尝试*持续调用`promptDirection`直到得到有效答案的示例：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The for (;;) construct is a way to intentionally create a loop that doesn’t
    terminate on its own. We break out of the loop only when a valid direction is
    given. Unfortunately, we misspelled promptDirection, which will result in an “undefined
    variable” error. Because the catch block completely ignores its exception value
    (e), assuming it knows what the problem is, it wrongly treats the binding error
    as indicating bad input. Not only does this cause an infinite loop but it also
    “buries” the useful error message about the misspelled binding.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`for (;;)`结构是一种故意创建不会自行终止的循环的方法。我们仅在给出有效方向时才会跳出循环。不幸的是，我们拼写错误了`promptDirection`，这将导致“未定义变量”错误。由于`catch`块完全忽略了其异常值（e），假设它知道问题出在哪里，因此错误地将绑定错误视为输入不正确。这不仅导致了无限循环，还“埋没”了关于拼写错误绑定的有用错误信息。'
- en: As a general rule, don’t blanket-catch exceptions unless it is for the purpose
    of “routing” them somewhere—for example, over the network to tell another system
    that our program crashed. And even then, think carefully about how you might be
    hiding information.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除非是为了“路由”异常到某处（例如，通过网络告知另一个系统我们的程序崩溃了），否则不要随意捕获异常。即便如此，也要仔细考虑你可能隐藏的信息。
- en: We want to catch a *specific* kind of exception. We can do this by checking
    in the catch block whether the exception we got is the one we are interested in,
    and if not, rethrow it. But how do we recognize an exception?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望捕获*特定*类型的异常。我们可以通过在`catch`块中检查捕获的异常是否是我们感兴趣的类型，如果不是，就重新抛出它。但我们如何识别异常呢？
- en: We could compare its message property against the error message we happen to
    expect. But that’s a shaky way to write code—we’d be using information that’s
    intended for human consumption (the message) to make a programmatic decision.
    As soon as someone changes (or translates) the message, the code will stop working.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其消息属性与我们预期的错误消息进行比较。但这是一种不可靠的写代码方式——我们将使用旨在供人类理解的信息（消息）来做出程序决策。一旦有人更改（或翻译）消息，代码将停止工作。
- en: Rather, let’s define a new type of error and use instanceof to identify it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们定义一个新的错误类型，并使用 instanceof 来识别它。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The new error class extends Error. It doesn’t define its own constructor, which
    means that it inherits the Error constructor, which expects a string message as
    its argument. In fact, it doesn’t define anything at all—the class is empty. InputError
    objects behave like Error objects, except that they have a different class by
    which we can recognize them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 新的错误类扩展了 Error。它没有定义自己的构造函数，这意味着它继承了 Error 的构造函数，该构造函数期望一个字符串消息作为参数。实际上，它什么都没有定义——这个类是空的。InputError
    对象的行为类似于 Error 对象，除了它们有一个不同的类，我们可以通过这个类来识别它们。
- en: Now the loop can catch these more carefully.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在循环可以更仔细地捕捉这些错误。
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will catch only instances of InputError and let unrelated exceptions through.
    If you reintroduce the typo, the undefined binding error will be properly reported.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅捕获 InputError 的实例，并让不相关的异常通过。如果你重新引入拼写错误，将正确报告未定义绑定错误。
- en: Assertions
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: '*Assertions* are checks inside a program that verify that something is the
    way it is supposed to be. They are used not to handle situations that can come
    up in normal operation but to find programmer mistakes.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*断言*是在程序内部进行的检查，用于验证某件事情是否如预期那样。它们的使用不是为了处理在正常操作中可能出现的情况，而是为了发现程序员的错误。'
- en: 'If, for example, firstElement is described as a function that should never
    be called on empty arrays, we might write it like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 firstElement 被描述为一个不应在空数组上调用的函数，我们可能会这样写：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, instead of silently returning undefined (which you get when reading an
    array property that does not exist), this will loudly blow up your program as
    soon as you misuse it. This makes it less likely for such mistakes to go unnoticed
    and easier to find their cause when they occur.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你错误使用它时，这将使你的程序立刻崩溃，而不是静默地返回 undefined（当读取一个不存在的数组属性时得到的结果）。这降低了此类错误被忽视的可能性，并使得发生时更容易找到它们的原因。
- en: I do not recommend trying to write assertions for every possible kind of bad
    input. That’d be a lot of work and would lead to very noisy code. You’ll want
    to reserve them for mistakes that are easy to make (or that you find yourself
    making).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议尝试为每种可能的错误输入编写断言。那会是一项巨大的工作，并且会导致代码非常嘈杂。你应该将断言保留给那些容易犯的错误（或者是你发现自己经常犯的错误）。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: An important part of programming is finding, diagnosing, and fixing bugs. Problems
    can become easier to notice if you have an automated test suite or add assertions
    to your programs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的重要部分是发现、诊断和修复错误。如果你有一个自动化测试套件或在程序中添加断言，问题可能会变得更容易被注意到。
- en: Problems caused by factors outside the program’s control should usually be actively
    planned for. Sometimes, when the problem can be handled locally, special return
    values are a good way to track them. Otherwise, exceptions may be preferable.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由程序控制之外的因素引起的问题通常应该积极规划。有时，当问题可以在本地处理时，特殊返回值是跟踪它们的好方法。否则，异常可能更为合适。
- en: Throwing an exception causes the call stack to be unwound until the next enclosing
    try/catch block or until the bottom of the stack. The exception value will be
    given to the catch block that catches it, which should verify that it is actually
    the expected kind of exception and then do something with it. To help address
    the unpredictable control flow caused by exceptions, finally blocks can be used
    to ensure that a piece of code *always* runs when a block finishes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常会导致调用栈被展开，直到下一个封闭的 try/catch 块或者栈底。异常值将被传递给捕获它的 catch 块，该块应该验证它实际上是预期的异常类型，然后对其进行处理。为了帮助解决异常引起的不可预测的控制流，可以使用
    finally 块以确保在块结束时某段代码*总是*执行。
- en: Exercises
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '*Retry*'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*重试*'
- en: Say you have a function primitiveMultiply that in 20 percent of cases multiplies
    two numbers and in the other 80 percent of cases raises an exception of type MultiplicatorUnitFailure.
    Write a function that wraps this clunky function and just keeps trying until a
    call succeeds, after which it returns the result.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数 `primitiveMultiply`，在20%的情况下会乘以两个数字，而在其他80%的情况下会抛出类型为 `MultiplicatorUnitFailure`
    的异常。编写一个函数来封装这个笨拙的函数，持续尝试直到调用成功，之后返回结果。
- en: Make sure you handle only the exceptions you are trying to handle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你只处理你试图处理的异常。
- en: '*The Locked Box*'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*锁定的盒子*'
- en: 'Consider the following (rather contrived) object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下（相当人为的）对象：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is a box with a lock. There is an array in the box, but you can get at it
    only when the box is unlocked.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带锁的盒子。盒子里有一个数组，但只有在盒子解锁时才能访问。
- en: Write a function called withBoxUnlocked that takes a function value as its argument,
    unlocks the box, runs the function, and then ensures that the box is locked again
    before returning, regardless of whether the argument function returned normally
    or threw an exception.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为 `withBoxUnlocked` 的函数，接受一个函数值作为参数，解锁盒子，运行该函数，然后确保在返回之前盒子再次上锁，无论参数函数是正常返回还是抛出异常。
- en: For extra points, make sure that if you call withBoxUnlocked when the box is
    already unlocked, the box stays unlocked.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了额外加分，确保当调用 `withBoxUnlocked` 时，如果盒子已经解锁，盒子保持解锁状态。
- en: '*Some people, when confronted with a problem, think “I know, I’ll use regular
    expressions.” Now they have two problems.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些人在面对问题时，会想“我知道，我会使用正则表达式。”现在他们有两个问题。*'
- en: —Jamie Zawinski
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: —杰米·扎温斯基
- en: '![Image](../images/f0140-01.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0140-01.jpg)'
